

<!DOCTYPE html>
<html lang="zh-Hans" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ariel">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一章：React Fiber 的诞生背景1.1 React15 及之前版本的渲染瓶颈递归不可中断的协调过程（stack reconciler栈协调器）stack reconciler 是什么？ stack reconciler 是 React15 及之前版本中使用的虚拟 dom 协调算法，负责计算组件树的变化并更新真实 dom。其核心特点是基于递归遍历、不可中断的同步更新流程。 递归遍历虚拟 d">
<meta property="og:type" content="article">
<meta property="og:title" content="React Fiber 专题学习">
<meta property="og:url" content="https://tianfei92.github.io/2025/06/18/React%20Fiber/index.html">
<meta property="og:site_name" content="Ariel&#39;s Blog">
<meta property="og:description" content="第一章：React Fiber 的诞生背景1.1 React15 及之前版本的渲染瓶颈递归不可中断的协调过程（stack reconciler栈协调器）stack reconciler 是什么？ stack reconciler 是 React15 及之前版本中使用的虚拟 dom 协调算法，负责计算组件树的变化并更新真实 dom。其核心特点是基于递归遍历、不可中断的同步更新流程。 递归遍历虚拟 d">
<meta property="og:locale">
<meta property="article:published_time" content="2025-06-18T06:07:11.000Z">
<meta property="article:modified_time" content="2025-06-18T09:30:57.777Z">
<meta property="article:author" content="Ariel">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>React Fiber 专题学习 - Ariel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tianfei92.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Startseite</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archiv</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Kategorien</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Schlagwörter</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>Über</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="React Fiber 专题学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-18 14:07" pubdate>
          June 18, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k wörter
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          104 minuten
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">React Fiber 专题学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章：React-Fiber-的诞生背景"><a href="#第一章：React-Fiber-的诞生背景" class="headerlink" title="第一章：React Fiber 的诞生背景"></a>第一章：React Fiber 的诞生背景</h1><h2 id="1-1-React15-及之前版本的渲染瓶颈"><a href="#1-1-React15-及之前版本的渲染瓶颈" class="headerlink" title="1.1 React15 及之前版本的渲染瓶颈"></a>1.1 React15 及之前版本的渲染瓶颈</h2><h3 id="递归不可中断的协调过程（stack-reconciler栈协调器）"><a href="#递归不可中断的协调过程（stack-reconciler栈协调器）" class="headerlink" title="递归不可中断的协调过程（stack reconciler栈协调器）"></a>递归不可中断的协调过程（stack reconciler栈协调器）</h3><p><strong>stack reconciler 是什么？</strong></p>
<p>stack reconciler 是 React15 及之前版本中使用的虚拟 dom 协调算法，负责计算组件树的变化并更新真实 dom。其核心特点是基于递归遍历、不可中断的同步更新流程。</p>
<p><strong>递归遍历虚拟 dom</strong></p>
<p>采用深度优先遍历策略（FDS），从组件树根节点开始，递归调用组件的 render 方法，生成完整的虚拟 dom 树。递归遍历依赖于 JavaScript 调用栈（call stack），一旦开始就必须执行到底，无法中途暂停。</p>
<p><strong>同步更新机制</strong></p>
<p>所有更新（比如 setState）都会立即触发完整的 diff 计算，无法合并和延迟。当一个应用的组件树过于庞大时，一次递归 diff 计算是十分耗时的。stack reconciler 的工作流程分为两个阶段：</p>
<ul>
<li>协调（reconciliation）：该阶段中采用递归 diff 算法，对比新旧虚拟 dom 树的差异，找到需要进行更新的树节点，标记需要更新的节点的增删改</li>
<li>提交（commit）：根据 diff 计算的结果，一次性同步执行所有的 dom 操作，并触发生命周期钩子（componentDidMount、componentDidUpdate等）</li>
</ul>
<p><strong>局限性</strong></p>
<p>在了解上述知识后，我们可以很清晰的感知到 stack reconciler 的局限性：</p>
<ul>
<li>无法中断长任务：递归遍历一旦开始就无法中断，这会占用 js 主线程，导致无法响应其他高优先级任务</li>
<li>缺乏任务优先级调度：所有的更新任务同步执行，享有同等优先级</li>
<li>内存泄漏风险：当组件树十分庞大时，深度递归可能会引起栈内存泄漏</li>
</ul>
<span id="more"></span>

<h3 id="大型应用中的掉帧问题和用户体验缺陷"><a href="#大型应用中的掉帧问题和用户体验缺陷" class="headerlink" title="大型应用中的掉帧问题和用户体验缺陷"></a>大型应用中的掉帧问题和用户体验缺陷</h3><p><strong>“帧”是什么？</strong></p>
<p>在计算机图形学与交互式应用中，帧是指屏幕画面的一次完整更新，它是衡量画面流畅度的核心单位，帧率（FPS）即是指每秒内渲染的帧数，人眼视觉对 60FPS 以上的变化感知有限，但低于 60FPS 时则会感知到延迟、卡顿。主流浏览器的帧率大多为 60FPS ，即每帧 16.67ms。</p>
<p><strong>什么是掉帧，掉帧是怎么引起的？</strong></p>
<p>掉帧即是指帧率未达预期，导致动画或交互卡顿。以浏览器举例，预期帧率 60FPS，则每一帧（16.67ms）的生命周期内，浏览器需要完成 js 执行、样式计算（style）、布局（layout）、绘制（paint）、合成（composite）等步骤，否则就会导致掉帧。</p>
<h2 id="1-2-浏览器渲染机制与主线程阻塞"><a href="#1-2-浏览器渲染机制与主线程阻塞" class="headerlink" title="1.2 浏览器渲染机制与主线程阻塞"></a>1.2 浏览器渲染机制与主线程阻塞</h2><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><p>浏览器渲染过程是指浏览器将 HTML、CSS、JavaScript 等代码转换为用户可视界面的过程。浏览器通过多线程协作提高渲染效率，其中关键线程的分工如下：</p>
<table>
<thead>
<tr>
<th align="left">线程</th>
<th align="left">职责</th>
<th align="left">示例场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主线程（Main Thread）</td>
<td align="left">运行 JavaScript、DOM&#x2F;CSS 解析、样式计算、布局、绘制、生成绘制指令</td>
<td align="left">setTimeout、React 渲染、事件处理</td>
</tr>
<tr>
<td align="left">合成器线程（Compositor Thread）</td>
<td align="left">接收绘制指令、图层分块光栅化、加速图层合成、提交 GPU 显示</td>
<td align="left">滚动、动画（如 transform 动画）</td>
</tr>
<tr>
<td align="left">光栅化线程（Raster Thread）</td>
<td align="left">将绘制指令转换为位图</td>
<td align="left">处理图片解码、图层分块光栅化</td>
</tr>
</tbody></table>
<p>正如上一章节所讲，浏览器渲染过程涉及多个阶段，且与主线程（Main Thread）紧密相关：</p>
<ol>
<li>解析阶段：解析 HTML （遇到<code>&lt;script&gt;</code>标签时会阻塞解析）和 CSS，生成 DOM 和 CSSOM</li>
<li>样式计算阶段：将 DOM 和 CSSOM 合并，生成渲染树，树仅包含可见节点，并计算节点的最终样式</li>
<li>布局阶段：根据渲染树计算每个节点的精确位置和大小</li>
<li>绘制阶段：生成绘制指令，将布局结果转换为屏幕上的像素，输出绘制列表，记录绘制顺序</li>
<li>合成阶段：将页面分为多个图层并启用 GPU 加速合成</li>
<li>显示阶段：将合成后的位图通过显卡驱动传递给屏幕显示</li>
</ol>
<p>浏览器的一次渲染过程即对应一帧的生成，单次渲染过程耗时过长即会导致帧率下降，即所谓的<code>掉帧</code>。结合浏览器关键线程分工职责和渲染过程的知识，可以知道，导致单次渲染耗时过长的原因有很多，与前端开发者息息相关的就是<code>主线程阻塞</code>。为了分析引起主线程阻塞的原因，我们还需要额外学习部分知识。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>JavaScript 的事件循环是什么？</strong></p>
<p>JavaScript 的事件循环是其异步编程的核心机制，它决定了代码的执行顺序，使得单线程的 JavaScript 可以处理非阻塞任务</p>
<p><strong>核心组成</strong></p>
<p>事件循环的核心组成是<code>调用栈</code>和<code>任务队列</code>：</p>
<ul>
<li>调用栈：按顺序执行同步代码，后进先出（LIFO），执行一个函数时，将其压入栈顶，函数返回后弹出。如果栈溢出（比如深度递归）会抛出异常。</li>
<li>任务队列：存储待执行的异步回调，分为宏任务队列、微任务队列、其他队列（比如requestAnimationFrame、web workers）。</li>
</ul>
<p>调用栈与任务队列的协作模型的核心规则：</p>
<ul>
<li>同步代码属于当前宏任务，直接由调用栈执行</li>
<li>异步任务分为宏任务、微任务两类，每次事件循环只执行一个宏任务，微任务必须在当前宏任务结束后立即执行，且必须清空队列</li>
</ul>
<p><strong>工作流程&#x2F;执行顺序</strong></p>
<ol>
<li>执行当前调用栈中的同步代码（属于当前宏任务）</li>
<li>执行所有微任务，直到微任务队列为空</li>
<li>必要时渲染页面（浏览器决定）</li>
<li>从宏任务队列中取出一个任务执行（回到步骤 1）</li>
</ol>
<p><strong>核心规则</strong></p>
<p>同步代码 &gt; 微任务 &gt; 渲染 &gt; 宏任务</p>
<h3 id="布局抖动（Layout-Thrashing）"><a href="#布局抖动（Layout-Thrashing）" class="headerlink" title="布局抖动（Layout Thrashing）"></a>布局抖动（Layout Thrashing）</h3><p><strong>什么是布局抖动？</strong></p>
<p>布局是指浏览器计算渲染树中每个节点的几何信息（精确位置、大小）的过程，发生在样式计算之后、绘制之前。修改影响几何属性的 CSS（如 width、margin）或读取布局属性（如 offsetWidth）都会触发布局重排。</p>
<p>布局抖动是指浏览器因频繁的强制同步布局造成的性能问题，表现为多次不必要的布局计算（<code>重排/Reflow</code>），影响页面渲染速度。其本质是代码中混合连续读写布局属性，迫使浏览器多次重新计算布局</p>
<p><strong>常见触发场景</strong></p>
<ul>
<li>循环中读写布局属性</li>
<li>频繁访问布局 API：offsetTop、offsetLeft、scrollTop、getComputedStyle() 等</li>
<li>动画中混合读写</li>
</ul>
<h3 id="长任务（Long-Task）"><a href="#长任务（Long-Task）" class="headerlink" title="长任务（Long Task）"></a>长任务（Long Task）</h3><p><strong>什么是长任务？</strong></p>
<p>长任务是指主线程上连续执行时间超过 50ms 的 JavaScript 代码或渲染操作，它会阻塞用户交互和页面渲染，导致明显的卡顿</p>
<p><strong>长任务的标准</strong></p>
<ul>
<li>时间阈值：50ms，是由 Google 根据人类感知延迟提出的临界值</li>
<li>检测工具：Chrome DevTools 的 Performance 面板中，长任务会被标记为红色区块并显示 Long Task 警告</li>
</ul>
<p><strong>常见的长任务场景</strong></p>
<ul>
<li>复杂的 JavaScript 计算</li>
<li>未优化的 dom 操作</li>
<li>同步网络请求</li>
<li>加载未优化的三方脚本</li>
</ul>
<p><strong>长任务优化手段</strong></p>
<ul>
<li>任务拆分</li>
<li>web workers 多线程：将计算密集型任务转到worker</li>
<li>异步编程优化：通过 promise、async&#x2F;await 等手段避免阻塞</li>
<li>虚拟列表优化渲染：仅渲染可视区域内容</li>
<li>惰性加载：按需加载非关键脚本</li>
</ul>
<h3 id="主线程阻塞原因分析"><a href="#主线程阻塞原因分析" class="headerlink" title="主线程阻塞原因分析"></a>主线程阻塞原因分析</h3><p>现在，我们可以知道，引起主线程阻塞的主要原因有以下几点：</p>
<ul>
<li>布局抖动</li>
<li>长任务</li>
<li>过多的微任务</li>
</ul>
<h2 id="1-3-现代前端应用的需求演进"><a href="#1-3-现代前端应用的需求演进" class="headerlink" title="1.3 现代前端应用的需求演进"></a>1.3 现代前端应用的需求演进</h2><h3 id="动画-手势的高优先级更新"><a href="#动画-手势的高优先级更新" class="headerlink" title="动画&#x2F;手势的高优先级更新"></a>动画&#x2F;手势的高优先级更新</h3><p>在现代前端应用中，动画&#x2F;手势的高优先级更新是提升用户体验（UX）和界面流畅性的关键设计，其意义有以下几个方面：</p>
<ul>
<li>确保交互即时响应</li>
<li>避免掉帧现象的发生</li>
<li>提升手势操作的跟手性</li>
<li>支持复杂的 UI 设计：拖拽、捏合缩放、页面过渡动画等复杂交互依赖高优先级更新</li>
<li>与浏览器渲染管线的协同优化：高优先级动画（如 transform）可由合成器线程直接处理，无需主线程参与，从而避免布局&#x2F;重绘</li>
</ul>
<p>通过优先级调度策略，可以提升用户留存率和满意度。</p>
<h3 id="异步数据加载与Suspense的诉求"><a href="#异步数据加载与Suspense的诉求" class="headerlink" title="异步数据加载与Suspense的诉求"></a>异步数据加载与Suspense的诉求</h3><p>传统前端应用中，通常会遇到以下几大问题：</p>
<ul>
<li>“白屏”等待：传统应用在数据加载完全前，页面通常显示空白或 loading 图标，用户无法感知进度。</li>
<li>不必要的加载状态：传统模式下，各个组件独立维护 loading 状态，会导致多次闪烁的 loading 提示</li>
<li>竞态条件问题：典型场景是快速切换标签页时，前一次请求可能覆盖后一次请求的结果，比如从详情 A 跳到详情 B</li>
</ul>
<p>而现代前端应用中，这些问题是严重影响用户体验的，针对以上问题，衍生出了以下现代需求：</p>
<ul>
<li>骨架屏：在数据加载时显示占位 UI，提升感知速度</li>
<li>流式渲染：逐步发送 HTML 片段，让用户尽早看到内容</li>
<li>状态统一：统一管理数据状态，仅在所有数据就绪后一次性渲染</li>
<li>AbortController：可中断正在进行的异步操作，避免资源浪费和竞态条件</li>
</ul>
<p>这就要求应用在数据管理方案上能支持异步数据管理，因此 React 团队提出了Suspense 声明式异步数据管理方案。</p>
<p>为了解决 React15 及之前版本的渲染问题，应对日益激增的现代前端应用需求，React Fiber 架构于 16.x 版本诞生，并于后续版本中逐步优化完善。</p>
<h1 id="第二章：Fiber架构的核心设计思想"><a href="#第二章：Fiber架构的核心设计思想" class="headerlink" title="第二章：Fiber架构的核心设计思想"></a>第二章：Fiber架构的核心设计思想</h1><h2 id="2-1-Fiber-的三大角色定义"><a href="#2-1-Fiber-的三大角色定义" class="headerlink" title="2.1 Fiber 的三大角色定义"></a>2.1 Fiber 的三大角色定义</h2><h3 id="作为数据结构的Fiber节点（链表节点）"><a href="#作为数据结构的Fiber节点（链表节点）" class="headerlink" title="作为数据结构的Fiber节点（链表节点）"></a>作为数据结构的Fiber节点（链表节点）</h3><p>每个 Fiber 节点是一个 JavaScript 对象，React <a href="https://github.com/facebook/react/blob/1f5ce59dd7b6869b1a17ede65aa301002ef31d4b/packages/react-reconciler/src/ReactFiber.js#L134">源码</a>中对 Fiber 节点的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: $FlowFixMe,</span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | string,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">refCleanup</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">flags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subtreeFlags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deletions</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    <span class="comment">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initializing the fields below to smis and later updating them with</span></span><br><span class="line">    <span class="comment">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class="line">    <span class="comment">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class="line">    <span class="comment">// Fortunately this only impacts DEV builds.</span></span><br><span class="line">    <span class="comment">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class="line">    <span class="comment">// To work around this, initialize the fields below with doubles.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Learn more about this here:</span></span><br><span class="line">    <span class="comment">// https://github.com/facebook/react/issues/14365</span></span><br><span class="line">    <span class="comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">actualDuration</span> = <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">actualStartTime</span> = <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">selfBaseDuration</span> = <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">treeBaseDuration</span> = <span class="title class_">Number</span>.<span class="property">NaN</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It&#x27;s okay to replace the initial doubles with smis after initialization.</span></span><br><span class="line">    <span class="comment">// This won&#x27;t trigger the performance cliff mentioned above,</span></span><br><span class="line">    <span class="comment">// and it simplifies other profiler code (including DevTools).</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">actualDuration</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">actualStartTime</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">selfBaseDuration</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">treeBaseDuration</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// This isn&#x27;t directly used but is handy for debugging internals:</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugSource</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugOwner</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugNeedsRemount</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_debugHookTypes</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">preventExtensions</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作为执行单元的任务分片（Unit-of-Work）"><a href="#作为执行单元的任务分片（Unit-of-Work）" class="headerlink" title="作为执行单元的任务分片（Unit of Work）"></a>作为执行单元的任务分片（Unit of Work）</h3><p>在第一章节中，我们了解了长任务的相关知识，知道长任务会阻塞主线程，引起掉帧问题。为了解决这个问题，我们需要将长任务进行拆分，并在浏览器的每一帧中限制主线程执行任务的时间（React 默认初始时间是 <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119">5ms</a>），这种将长任务拆成多段微小任务的技术被称为<code>任务分片</code>，分配到每一帧中去执行的操作被称为<code>时间切片</code>，二者协同实现 React 的高效渲染。</p>
<p>实现任务分片的关键是将同步更新变为可中断的异步更新：</p>
<ol>
<li>构建链表树：通过 Fiber 节点的链表结构构建链表树，替代递归调用栈</li>
<li>分片执行：React 通过循环逐个处理 Fiber 节点，每处理完一个节点后检查剩余时间，决定继续还是暂停</li>
<li>中断和恢复：当有高优先级任务（如用户点击）或当前分片时间用尽时暂停任务，通过保存当前处理的 Fiber 节点指针，下次从断点继续</li>
</ol>
<h3 id="作为调度单位的优先级载体（Lane模型）"><a href="#作为调度单位的优先级载体（Lane模型）" class="headerlink" title="作为调度单位的优先级载体（Lane模型）"></a>作为调度单位的优先级载体（Lane模型）</h3><p>React Fiber 架构中实现任务优先级调度的核心思想是：将优先级信息分散在 Fiber 树的各个节点和更新信息中，通过动态计算（lanes）和调度器（scheduler）的协作实现优先级调度。</p>
<p><strong>Lane（车道）的定义</strong></p>
<ul>
<li>每个 Lane 是一个32位的二进制位</li>
<li>每个二进制位代表一种优先级类型</li>
<li>数字越小（位越低）优先级越高</li>
<li>Lane 互斥</li>
</ul>
<p><strong>Lane 的类型</strong></p>
<p>React 18 版本中定义的类型有以下几种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级从高到低</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SyncLane</span>: <span class="title class_">Lane</span> = <span class="number">0b0000000000000000000000000000001</span>; <span class="comment">// 同步任务（最高）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">InputContinuousLane</span>: <span class="title class_">Lane</span> = <span class="number">0b0000000000000000000000000000100</span>; <span class="comment">// 用户输入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultLane</span>: <span class="title class_">Lane</span> = <span class="number">0b0000000000000000000000000100000</span>; <span class="comment">// 默认更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">TransitionLane</span>: <span class="title class_">Lane</span> = <span class="number">0b0000000000000000001000000000000</span>; <span class="comment">// 过渡更新，比如useTransition</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IdleLane</span>: <span class="title class_">Lane</span> = <span class="number">0b0100000000000000000000000000000</span>; <span class="comment">// 空闲任务（最低）</span></span><br></pre></td></tr></table></figure>

<p><strong>Lane 集合（Lanes）</strong></p>
<p>多个 Lane 可以组合：<code>lanes = InputLane | DefaultLane</code>，表示一组需要处理的优先级集合</p>
<p><strong>Lane 模型的工作原理</strong></p>
<ol>
<li>优先级分配：更新阶段根据交互类型分配 Lane</li>
<li>优先级收集：每个 Fiber 节点对象都有 <code>lanes</code> 属性和 <code>childLanes</code> 属性，lanes 属性保存该节点需要处理的优先级合集，childLanes 属性保存子节点中所有未处理的优先级合集</li>
<li>优先级调度：Fiber 树根节点合并所有子节点的 lanes 和 childLanes -&gt; 从合并后的优先级合集中选取最高优先级的 Lane 进行处理 -&gt; 只处理与选定 Lane 匹配的更新</li>
</ol>
<p>这里先只做简单的概念了解，详细知识将在 4.1 章节中进行讲解。</p>
<h2 id="2-2-关键设计目标"><a href="#2-2-关键设计目标" class="headerlink" title="2.2 关键设计目标"></a>2.2 关键设计目标</h2><p>我们已经知道在 React15 及之前版本中，渲染一旦开始便无法中断，并且所有任务同步进行，享有同等优先级，会导致交互延迟。Fiber 架构为了解决这些问题的核心设计目标有三个</p>
<h3 id="可中断、可恢复的渲染流程"><a href="#可中断、可恢复的渲染流程" class="headerlink" title="可中断、可恢复的渲染流程"></a>可中断、可恢复的渲染流程</h3><p><strong>关键设计</strong></p>
<p>要实现可中断、可恢复的渲染流程，关键设计有三点：</p>
<ul>
<li>链表结构替代递归结构：Fiber 通过 <code>child、sibling、return</code>构成树形链表</li>
<li>全局指针跟踪进度：<code>nextUnitOfWork</code>记录当前处理节点</li>
<li>双缓存机制：<code>current tree</code> 和 <code>work-in-progress tree</code> 两棵树交替更新</li>
</ul>
<p><strong>完整流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[触发更新] --&gt; B&#123;有高优先级任务&#125;</span><br><span class="line">    B --&gt;|是| C[中断当前任务]</span><br><span class="line">    B --&gt;|否| D[开始Render阶段]</span><br><span class="line">    D --&gt; E[处理Fiber节点]</span><br><span class="line">    E --&gt; F&#123;时间用完&#125;</span><br><span class="line">    F --&gt;|是| C</span><br><span class="line">    F --&gt;|否| G&#123;还有子节点&#125;</span><br><span class="line">    G --&gt;|是| H[移动到子节点]</span><br><span class="line">    G --&gt;|否| I&#123;还有兄弟节点&#125;</span><br><span class="line">    I --&gt;|是| J[移动到兄弟节点]</span><br><span class="line">    I --&gt;|否| K[回溯到父节点]</span><br><span class="line">    K --&gt; L&#123;根节点&#125;</span><br><span class="line">    L --&gt;|否| E</span><br><span class="line">    L --&gt;|是| M[完成Render阶段]</span><br><span class="line">    M --&gt; N[Commit阶段]</span><br><span class="line">    N --&gt; O[更新DOM]</span><br><span class="line">    C --&gt; P[保存进度]</span><br><span class="line">    P --&gt; Q[执行高优先级任务]</span><br><span class="line">    Q --&gt; R[恢复低优先级任务]</span><br></pre></td></tr></table></figure>

<p><strong>实现原理</strong></p>
<ol>
<li>渲染阶段可中断，核心代码如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>; <span class="comment">// 全局工作指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主工作循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@noinline</span> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrentByScheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span></span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否需要中断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shouldYield</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span> || </span><br><span class="line">         <span class="title function_">hasHigherPriorityWork</span>(); <span class="comment">// 高优先级任务到达</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进度保存和恢复：中断时保留 <code>nextUnitOfWork</code> 指针指向未完成的 Fiber 节点，恢复时从上次中断的节点继续遍历，采用深度优先遍历策略，优先处理子节点（<code>child</code>），无子节点时处理兄弟节点（<code>sibling</code>），无兄弟节点时回溯父节点（<code>return</code>）</li>
<li>双缓存保证一致性：current tree 展示当前界面，中断时保持不变，work-in-progress tree 构建新的 Fiber 树，构建完成后一次性替换 current tree 变成新的 current tree</li>
</ol>
<p>React Fiber 架构通过可中断、可恢复的渲染流程拥有类似于操作系统的“多任务处理”能力，最终实现渲染不阻塞交互的用户体验</p>
<h3 id="时间切片（Time-Slicing）与增量渲染"><a href="#时间切片（Time-Slicing）与增量渲染" class="headerlink" title="时间切片（Time Slicing）与增量渲染"></a>时间切片（Time Slicing）与增量渲染</h3><p>在 React Fiber 中，时间切片和增量渲染是两个紧密相关的核心概念，共同解决了渲染过程中主线程阻塞的问题，但他们的关注点不同</p>
<p><strong>时间切片 - 时间维度的解决方案</strong></p>
<p>时间切片是将连续长任务切割成多个微小任务，并分散在浏览器的多个渲染帧中去执行的技术</p>
<p>它的核心目标有 2 个：</p>
<ul>
<li>防止 JavaScript 代码执行时间超过 50ms</li>
<li>保证浏览器的每一帧中有足够的时间去执行渲染、动画和交互</li>
</ul>
<p>其核心实现原理是通过 <code>requestIdleCallback</code>（React17及以下） 或 <code>MessageChannel</code>（React18） 来检测剩余时间，当时间用尽时中断任务并保存状态，下次空余时间到来时从中断点恢复</p>
<p><strong>增量渲染 - 任务维度的解决方案</strong></p>
<p>增量渲染是将整个渲染过程分解为多个可独立执行的子任务，并按优先级逐步完成的技术</p>
<p>它的核心目标是：</p>
<ul>
<li>将大型渲染任务分解为可独立执行的小任务</li>
<li>允许先呈现部分内容，再逐步补充剩余内容</li>
</ul>
<p>其实现原理是通过任务分片将组件树拆分为 Fiber 节点链表，通过 Lane 模型区分任务优先级，完成的部分先提交呈现，并结合双缓存机制保证渲染过程不影响当前显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[开始渲染] --&gt; B[处理根节点]</span><br><span class="line">B --&gt; C[处理子节点1]</span><br><span class="line">C --&gt; D[处理子节点1.1]</span><br><span class="line">D --&gt; E[提交已完成部分]</span><br><span class="line">E --&gt; F[处理兄弟节点1.2]</span><br><span class="line">F --&gt; G&#123;时间用尽&#125;</span><br><span class="line">G --&gt;|是| H[保存状态并暂停]</span><br><span class="line">G --&gt;|否| I[继续处理]</span><br></pre></td></tr></table></figure>

<p>时间切片和增量渲染协同工作流程如下：</p>
<ol>
<li>增量渲染拆解任务：将整个渲染任务拆分为 Fiber 节点任务队列</li>
<li>时间切片分配时间：将浏览器每个渲染帧的空闲时间分配给任务队列</li>
<li>优先级调度介入：允许高优先级任务抢占当前执行</li>
<li>渐进式提交：完成的部分内容可先提交显示</li>
</ol>
<h3 id="基于优先级的任务调度"><a href="#基于优先级的任务调度" class="headerlink" title="基于优先级的任务调度"></a>基于优先级的任务调度</h3><p>React 使用 Lane 模型定义优先级，每个优先级对应一个二进制位</p>
<p><strong>调度流程</strong></p>
<p>任务标记阶段：当触发更新时，React 根据场景分配优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">requestUpdateLane</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isTransition) <span class="keyword">return</span> <span class="title class_">TransitionLane</span>;       <span class="comment">// useTransition 更新</span></span><br><span class="line">  <span class="keyword">if</span> (isUserBlockingEvent) <span class="keyword">return</span> <span class="title class_">InputLane</span>;    <span class="comment">// 用户交互事件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">DefaultLane</span>;                          <span class="comment">// 默认更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：点击事件触发的更新</span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> updateLane = <span class="title function_">getEventPriority</span>(event);   <span class="comment">// 返回 InputContinuousLane</span></span><br><span class="line">  <span class="title function_">scheduleUpdate</span>(fiber, updateLane);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>任务调度阶段：根据优先级和剩余时间控制执行顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Browser as 浏览器</span><br><span class="line">    participant Scheduler as React调度器</span><br><span class="line">    participant Renderer as 渲染器</span><br><span class="line">    </span><br><span class="line">    Browser-&gt;&gt;Scheduler: 新帧开始（16.6ms）</span><br><span class="line">    Scheduler-&gt;&gt;Renderer: 获取待处理任务</span><br><span class="line">    Renderer-&gt;&gt;Renderer: 按优先级排序任务</span><br><span class="line">    loop 时间切片执行</span><br><span class="line">        Renderer-&gt;&gt;Renderer: 执行最高优先级任务</span><br><span class="line">        Renderer--&gt;&gt;Scheduler: 检查剩余时间</span><br><span class="line">        Scheduler-&gt;&gt;Browser: 时间用尽则归还控制</span><br><span class="line">    end</span><br><span class="line">    Browser-&gt;&gt;Browser: 执行绘制/用户输入</span><br><span class="line">    Browser-&gt;&gt;Scheduler: 下一帧继续</span><br></pre></td></tr></table></figure>

<p>中断与抢占机制：</p>
<ul>
<li>高优先级任务可直接中断正在执行的低优先级任务</li>
<li>被中断的任务可保存进度到 nextUnitOfWork 指针中，后续恢复</li>
</ul>
<p>饥饿问题处理：长时间未执行的低优先级任务会被逐步提升优先级</p>
<p><strong>关键调度策略</strong></p>
<ol>
<li>批量更新合并：比如相同优先级的多个 setState 会被合并</li>
<li>优先级反转预防：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRootIsScheduled</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextLanes = <span class="title function_">getNextLanes</span>(root, root.<span class="property">pendingLanes</span>);</span><br><span class="line">  <span class="keyword">const</span> highestPriorityLane = <span class="title function_">getHighestPriorityLane</span>(nextLanes);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前执行中的低优先级任务被高优先级打断</span></span><br><span class="line">  <span class="keyword">if</span> (existingCallbackPriority !== highestPriorityLane) &#123;</span><br><span class="line">    <span class="title function_">cancelCallback</span>(existingCallbackNode); <span class="comment">// 取消旧任务</span></span><br><span class="line">    <span class="title function_">scheduleNewCallback</span>(highestPriorityLane); <span class="comment">// 调度新任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>时间切片分配：不同优先级的任务获得的时间片不同</li>
</ol>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">单次分配时间</th>
<th align="left">是否可中断</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SyncLane</td>
<td align="left">不限</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">InputContinuousLane</td>
<td align="left">5ms</td>
<td align="left">是（仅限更高优先级）</td>
</tr>
<tr>
<td align="left">DefaultLane</td>
<td align="left">2ms</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">TransitionLane</td>
<td align="left">1ms</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h1 id="第三章：Fiber的数据结构与算法实现"><a href="#第三章：Fiber的数据结构与算法实现" class="headerlink" title="第三章：Fiber的数据结构与算法实现"></a>第三章：Fiber的数据结构与算法实现</h1><h2 id="3-1-Fiber节点的详细结构解析"><a href="#3-1-Fiber节点的详细结构解析" class="headerlink" title="3.1 Fiber节点的详细结构解析"></a>3.1 Fiber节点的详细结构解析</h2><h3 id="child、sibling、return指针的链表关系"><a href="#child、sibling、return指针的链表关系" class="headerlink" title="child、sibling、return指针的链表关系"></a>child、sibling、return指针的链表关系</h3><p>Fiber 架构的设计哲学在于将树形结构转化为单向链表+树形回溯的混合结构，在保持父子关系的同时获得链表的高效遍历能力。实现该混合结构的关键点就是 child、sibling、return 这三个指针。</p>
<p><strong>三个指针的作用与关系</strong></p>
<table>
<thead>
<tr>
<th align="left">指针名</th>
<th align="left">指向</th>
<th align="left">功能描述</th>
<th align="left">类比传统树结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">child</td>
<td align="left">第一个子节点</td>
<td align="left">向下遍历的入口</td>
<td align="left">node.firstChild</td>
</tr>
<tr>
<td align="left">sibling</td>
<td align="left">下一个兄弟节点</td>
<td align="left">横向遍历同级节点</td>
<td align="left">node.nextSibling</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">父节点</td>
<td align="left">完成当前分支后向上回溯</td>
<td align="left">node.parentNode</td>
</tr>
</tbody></table>
<p><strong>链表结构图解</strong></p>
<p>假设有如下组件树：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Sidebar</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Main</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那该组件树对应的 Fiber 链表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[App] --&gt;|child| B[Header]</span><br><span class="line">    B --&gt;|sibling| C[Content]</span><br><span class="line">    C --&gt;|child| D[Sidebar]</span><br><span class="line">    D --&gt;|sibling| E[Main]</span><br><span class="line">    E --&gt;|return| C</span><br><span class="line">    D --&gt;|return| C</span><br><span class="line">    C --&gt;|return| A</span><br><span class="line">    B --&gt;|return| A</span><br></pre></td></tr></table></figure>

<p>指针关系表如下：</p>
<table>
<thead>
<tr>
<th align="left">Fiber 节点</th>
<th align="left">child</th>
<th align="left">sibling</th>
<th align="left">return</th>
</tr>
</thead>
<tbody><tr>
<td align="left">App</td>
<td align="left">Header</td>
<td align="left">null</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">Header</td>
<td align="left">null</td>
<td align="left">Content</td>
<td align="left">App</td>
</tr>
<tr>
<td align="left">Content</td>
<td align="left">Sidebar</td>
<td align="left">null</td>
<td align="left">App</td>
</tr>
<tr>
<td align="left">Sidebar</td>
<td align="left">null</td>
<td align="left">Main</td>
<td align="left">Content</td>
</tr>
<tr>
<td align="left">Main</td>
<td align="left">null</td>
<td align="left">null</td>
<td align="left">Content</td>
</tr>
</tbody></table>
<h3 id="alternate与双缓存树（Current-WorkInProgress）"><a href="#alternate与双缓存树（Current-WorkInProgress）" class="headerlink" title="alternate与双缓存树（Current&#x2F;WorkInProgress）"></a>alternate与双缓存树（Current&#x2F;WorkInProgress）</h3><p>alternate 指针和双缓存树是实现并发渲染和状态一致性的核心机制</p>
<p><strong>双缓存树的本质</strong></p>
<p>基本概念</p>
<table>
<thead>
<tr>
<th align="left">树类型</th>
<th align="left">作用</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">current</td>
<td align="left">当前界面正在显示内容对应的 Fiber 树</td>
<td align="left">用户正在交互的稳定版本</td>
</tr>
<tr>
<td align="left">workInProgress</td>
<td align="left">正在内存中构建的 Fiber 树（即将成为下一针显示内容）</td>
<td align="left">可中断、可丢弃的中间状态</td>
</tr>
</tbody></table>
<p>alternate 指针的作用：每个 Fiber 节点都有一个 alternate 字段，指向另一棵树上的对应节点（current fiberNodeA.alternate &lt;-&gt; workInProgress fiberNodeA.alternate）</p>
<p><strong>双缓存树的工作流程</strong></p>
<p>初始渲染阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant R as React</span><br><span class="line">    participant D as DOM</span><br><span class="line">    </span><br><span class="line">    R-&gt;&gt;R: 创建 WorkInProgress 树（初始为空）</span><br><span class="line">    R-&gt;&gt;R: 从 Root 开始构建 Fiber 节点</span><br><span class="line">    R-&gt;&gt;R: 每个新节点设置 alternate=null</span><br><span class="line">    R-&gt;&gt;D: 首次渲染完成后，WorkInProgress 树变为 Current 树</span><br></pre></td></tr></table></figure>

<p>更新阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as Current 树</span><br><span class="line">    participant W as WorkInProgress 树</span><br><span class="line">    participant R as React 调度器</span><br><span class="line">    </span><br><span class="line">    R-&gt;&gt;W: 从 Current 树的 Root 克隆节点</span><br><span class="line">    C-&gt;&gt;W: 通过 alternate 互相指向</span><br><span class="line">    loop 渲染阶段</span><br><span class="line">        R-&gt;&gt;W: 增量构建/更新节点</span><br><span class="line">        W-&gt;&gt;C: 通过 alternate 对比差异</span><br><span class="line">    end</span><br><span class="line">    R-&gt;&gt;C: 提交完成后交换两棵树</span><br></pre></td></tr></table></figure>

<h3 id="effectTag与副作用链表（Effect-List）"><a href="#effectTag与副作用链表（Effect-List）" class="headerlink" title="effectTag与副作用链表（Effect List）"></a>effectTag与副作用链表（Effect List）</h3><p>在了解 effectTag 之前，我们先了解下什么是 side effects（副作用）。</p>
<p>在 React 中，副作用是指那些在组件渲染过程中与外部世界交互或影响外部状态的操作（不能在 render 阶段完成）。它们超出了纯函数式渲染的范畴，是 React 组件中需要特殊处理的行为。</p>
<p><strong>副作用的本质特征</strong></p>
<table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">非纯操作</td>
<td align="left">违反纯函数原则（相同输入 ≠ 相同输出）</td>
<td align="left">数据获取、DOM 手动操作</td>
</tr>
<tr>
<td align="left">外部依赖</td>
<td align="left">与 React 渲染流程外的系统交互</td>
<td align="left">访问浏览器 API、网络请求</td>
</tr>
<tr>
<td align="left">时序敏感性</td>
<td align="left">执行时机影响结果</td>
<td align="left">事件监听、定时器</td>
</tr>
<tr>
<td align="left">资源管理</td>
<td align="left">需要显式清理</td>
<td align="left">取消订阅、移除事件监听</td>
</tr>
</tbody></table>
<p><strong>副作用分类机制</strong></p>
<table>
<thead>
<tr>
<th align="left">副作用类型</th>
<th align="left">处理方式</th>
<th align="left">对应 Hook</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步 DOM 副作用</td>
<td align="left">布局阶段同步执行</td>
<td align="left">useLayoutEffect</td>
</tr>
<tr>
<td align="left">异步副作用</td>
<td align="left">浏览器绘制后执行</td>
<td align="left">useEffect</td>
</tr>
<tr>
<td align="left">状态更新副作用</td>
<td align="left">随渲染流程处理</td>
<td align="left">useState&#x2F;useReducer setter</td>
</tr>
<tr>
<td align="left">回调副作用</td>
<td align="left">事件处理中执行</td>
<td align="left">事件处理函数</td>
</tr>
</tbody></table>
<p><strong>正确处理副作用的规则</strong></p>
<ol>
<li>副作用隔离原则：避免渲染中执行（不要在 render 函数中或函数式组件主题中直接操作副作用），使用 Hook 封装（比如 useEffect）</li>
<li>明确声明依赖项（useEffect dependencies）</li>
<li>副作用清理机制（useEffect return）</li>
</ol>
<p>effectTag则是<code>副作用标记系统</code>。</p>
<p><strong>effectTag 的本质与作用</strong></p>
<ul>
<li>二进制位掩码：每个 effectTag 是一个二进制数，表示需要执行的副作用类型</li>
<li>高效内存管理：通过位运算组合多个标记（如 Placement | Update）</li>
<li>精确追踪：标记哪些 Fiber 节点需要进行 DOM 操作或其他副作用</li>
</ul>
<p><strong>常见的 effectTag 值</strong></p>
<table>
<thead>
<tr>
<th align="left">标记</th>
<th align="left">值（二进制）</th>
<th align="left">对应操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NoEffect</td>
<td align="left">0b00000000</td>
<td align="left">无副作用</td>
</tr>
<tr>
<td align="left">Placement</td>
<td align="left">0b00000010</td>
<td align="left">插入新节点</td>
</tr>
<tr>
<td align="left">Update</td>
<td align="left">0b00000100</td>
<td align="left">更新属性&#x2F;样式</td>
</tr>
<tr>
<td align="left">Deletion</td>
<td align="left">0b00001000</td>
<td align="left">删除节点</td>
</tr>
<tr>
<td align="left">Snapshot</td>
<td align="left">0b00010000</td>
<td align="left">生命周期 getSnapshotBeforeUpdate</td>
</tr>
<tr>
<td align="left">Passive</td>
<td align="left">0b00100000</td>
<td align="left">useEffect 的副作用</td>
</tr>
<tr>
<td align="left">Callback</td>
<td align="left">0b01000000</td>
<td align="left">setState 的回调</td>
</tr>
</tbody></table>
<p>副作用链表（effect list）是只包含<code>有副作用的 Fiber 节点</code>的链表结构，它的构建时机是在 <code>completeWork</code> 阶段串联有 effectTag 的节点。它的关键指针如下：</p>
<ul>
<li>firstEffect：链表头节点</li>
<li>nextEffect：下一个待处理节点</li>
<li>lastEffect：链表尾节点</li>
</ul>
<p><strong>副作用链表的构建过程</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理当前节点工作...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构建 Effect List</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> &gt; <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.<span class="property">return</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前节点添加到父节点的 Effect List</span></span><br><span class="line">      <span class="keyword">if</span> (fiber.<span class="property">return</span>.<span class="property">firstEffect</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        fiber.<span class="property">return</span>.<span class="property">firstEffect</span> = fiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fiber.<span class="property">return</span>.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = fiber;</span><br><span class="line">      &#125;</span><br><span class="line">      fiber.<span class="property">return</span>.<span class="property">lastEffect</span> = fiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>effectTag&#x2F;副作用链表的工作原理</strong></p>
<ol>
<li>标记阶段：在 beginWork 中标记需要执行的 DOM 操作</li>
<li>链表构建：在 completeWork 阶段串联具有 effectTag 的节点</li>
<li>提交阶段：按链表顺序执行 DOM 操作</li>
</ol>
<h2 id="3-2-深度优先遍历的迭代实现"><a href="#3-2-深度优先遍历的迭代实现" class="headerlink" title="3.2 深度优先遍历的迭代实现"></a>3.2 深度优先遍历的迭代实现</h2><h3 id="递归遍历的问题与链表遍历的优势"><a href="#递归遍历的问题与链表遍历的优势" class="headerlink" title="递归遍历的问题与链表遍历的优势"></a>递归遍历的问题与链表遍历的优势</h3><p>在 React15 及之前版本的 stack reconciler 协调器采用的遍历策略是递归遍历</p>
<p><strong>递归遍历的问题</strong></p>
<ol>
<li>无条件全量遍历：从根节点开始递归处理每一个节点，无论节点状态是否变化</li>
<li>不可中断：依赖于 JavaScript 栈调用，一旦开始就必须执行到底，中途无法中断或跳过子节点</li>
<li>性能缺陷：阻塞主线程、无优先级调度</li>
</ol>
<p><strong>链表遍历的优势</strong></p>
<ol>
<li>可中断&#x2F;恢复：通过全局变量（nextUnitOfWork）保存进度，结合 requestIdleCallback 或 messageChannel 时间切片实现中断和恢复。</li>
<li>按需遍历：通过 lanes 和 childLanes 标记 Fiber 节点优先级，跳过无需更新的子树，时间复杂度从递归的 O(n) 优化到 O(m)</li>
<li>优先级调度：结合 Lane 模型动态调整遍历顺序，实现高优先级任务中断低优先级任务</li>
<li>内存安全：链表遍历在堆内存中进行，不受调用栈限制，没有递归栈帧累积，因此支持任意深度的组件树</li>
</ol>
<h3 id="performUnitOfWork源码解析（含配图）"><a href="#performUnitOfWork源码解析（含配图）" class="headerlink" title="performUnitOfWork源码解析（含配图）"></a>performUnitOfWork源码解析（含配图）</h3><p>我们首先了解下 Fiber 架构中的工作循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@noinline</span> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrentByScheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span></span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performUnitOfWork 是 Fiber 架构中工作循环（<code>workLoop</code>）的最小执行单元，源码位置见<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2779">这里</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">  <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.<span class="property">alternate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="property">mode</span> &amp; <span class="title class_">ProfileMode</span>) !== <span class="title class_">NoMode</span>) &#123;</span><br><span class="line">    <span class="title function_">startProfilerTimer</span>(unitOfWork);</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      next = <span class="title function_">runWithFiberInDEV</span>(</span><br><span class="line">        unitOfWork,</span><br><span class="line">        beginWork,</span><br><span class="line">        current,</span><br><span class="line">        unitOfWork,</span><br><span class="line">        entangledRenderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = <span class="title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">stopProfilerTimerIfRunningAndRecordDuration</span>(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      next = <span class="title function_">runWithFiberInDEV</span>(</span><br><span class="line">        unitOfWork,</span><br><span class="line">        beginWork,</span><br><span class="line">        current,</span><br><span class="line">        unitOfWork,</span><br><span class="line">        entangledRenderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = <span class="title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unitOfWork.<span class="property">memoizedProps</span> = unitOfWork.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this doesn&#x27;t spawn new work, complete the current work.</span></span><br><span class="line">    <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心代码如下，主要流程分为两个阶段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 开始工作阶段（递）</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  next = <span class="title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 完成工作阶段（归）</span></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beginWork - 递阶段：处理组件更新（props&#x2F;state 计算、diff 等）</strong></p>
<p>核心代码逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// 检查是否需要跳过更新（优化手段）</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldProps === newProps &amp;&amp; !<span class="title function_">hasLegacyContextChanged</span>()) &#123;</span><br><span class="line">      <span class="keyword">const</span> hasScheduledUpdateOrContext = <span class="title function_">checkScheduledUpdateOrContext</span>(</span><br><span class="line">        current,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !hasScheduledUpdateOrContext &amp;&amp;</span><br><span class="line">        <span class="comment">// If this is the second pass of an error or suspense boundary, there</span></span><br><span class="line">        <span class="comment">// may not be work scheduled on `current`, so we check for this flag.</span></span><br><span class="line">        (workInProgress.<span class="property">flags</span> &amp; <span class="title class_">DidCapture</span>) === <span class="title class_">NoFlags</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No pending updates or context. Bail out now.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据组件类型执行不同处理</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(current, workInProgress, ...);</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateClassComponent</span>(current, workInProgress, ...);</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: <span class="comment">// DOM 节点</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateHostComponent</span>(current, workInProgress, ...);</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ScopeComponent</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableScopeAPI) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">updateScopeComponent</span>(current, workInProgress, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...其他类型处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心操作：</p>
<ul>
<li>优先级过滤：通过 renderLanes 跳过低优先级任务</li>
<li>diff 算法：在<code>reconcileChildren</code>中生成子 Fiber</li>
<li>副作用标记：设置 effectTag</li>
</ul>
<p><strong>completeUnitOfWork - 归阶段：完成 DOM 准备、收集副作用</strong></p>
<p>核心代码逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// Attempt to complete the current unit of work, then move to the next</span></span><br><span class="line">  <span class="comment">// sibling. If there are no more siblings, return to the parent fiber.</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">completedWork</span>: <span class="title class_">Fiber</span> = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((completedWork.<span class="property">flags</span> &amp; <span class="title class_">Incomplete</span>) !== <span class="title class_">NoFlags</span>) &#123;</span><br><span class="line">      <span class="comment">// This fiber did not complete, because one of its children did not</span></span><br><span class="line">      <span class="comment">// complete. Switch to unwinding the stack instead of completing it.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The reason &quot;unwind&quot; and &quot;complete&quot; is interleaved is because when</span></span><br><span class="line">      <span class="comment">// something suspends, we continue rendering the siblings even though</span></span><br><span class="line">      <span class="comment">// they will be replaced by a fallback.</span></span><br><span class="line">      <span class="keyword">const</span> skipSiblings = workInProgressRootDidSkipSuspendedSiblings;</span><br><span class="line">      <span class="title function_">unwindUnitOfWork</span>(completedWork, skipSiblings);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">    <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">    <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">    <span class="keyword">const</span> current = completedWork.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.<span class="property">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="title function_">startProfilerTimer</span>(completedWork);</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      next = <span class="title function_">runWithFiberInDEV</span>(</span><br><span class="line">        completedWork,</span><br><span class="line">        completeWork,</span><br><span class="line">        current,</span><br><span class="line">        completedWork,</span><br><span class="line">        entangledRenderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next = <span class="title function_">completeWork</span>(current, completedWork, entangledRenderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.<span class="property">mode</span> &amp; <span class="title class_">ProfileMode</span>) !== <span class="title class_">NoMode</span>) &#123;</span><br><span class="line">      <span class="comment">// Update render duration assuming we didn&#x27;t error.</span></span><br><span class="line">      <span class="title function_">stopProfilerTimerIfRunningAndRecordIncompleteDuration</span>(completedWork);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">      workInProgress = next;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.<span class="property">sibling</span>;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise, return to the parent</span></span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-type] we bail out when we get a null</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    <span class="comment">// Update the next thing we&#x27;re working on in case something throws.</span></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === <span class="title class_">RootInProgress</span>) &#123;</span><br><span class="line">    workInProgressRootExitStatus = <span class="title class_">RootCompleted</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心操作：</p>
<ul>
<li>DOM 准备：在 completeWork 中创建&#x2F;更新 DOM</li>
<li>副作用收集：通过 firstEffect&#x2F;lastEffect构建线性副作用链表，供提交阶段批量处理</li>
<li>回溯机制：通过 return 指针实现非递归遍历</li>
</ul>
<p><strong>遍历过程图解</strong></p>
<p>还是以之前的组件树为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Sidebar</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Main</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其链表遍历顺序图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[App] --&gt; B[Header]</span><br><span class="line">    B --&gt; C[Content]</span><br><span class="line">    C --&gt; D[Sidebar]</span><br><span class="line">    D --&gt; E[Main]</span><br><span class="line">    E --&gt; F[回溯Content]</span><br><span class="line">    F --&gt; G[回溯App]</span><br></pre></td></tr></table></figure>

<p>具体步骤：</p>
<ol>
<li>performUnitOfWork(App) -&gt; beginWork(App) -&gt; 返回子节点 Header -&gt; workInProgress &#x3D; Header</li>
<li>workLoopSync -&gt; performUnitOfWork(Header) -&gt; beginWork(Header) -&gt; 无子节点，返回null</li>
<li>completeUnitOfWork(Header) -&gt; workInProgress &#x3D; Header.siblingFiber(即Content)</li>
<li>performUnitOfWork(Content) -&gt; beginWork(Content) -&gt; 返回子节点 Sidebar -&gt; workInProgress &#x3D; Sidebar</li>
<li>workLoopSync -&gt; performUnitOfWork(Sidebar) -&gt; beginWork(Sidebar) -&gt; 无子节点，返回null</li>
<li>completeUnitOfWork(Sidebar) -&gt; workInProgress &#x3D; Sidebar.siblingFiber(即Main)</li>
<li>performUnitOfWork(Main) -&gt; beginWork(Main) -&gt; 无子节点无兄弟节点，返回 null</li>
<li>completeUnitOfWork(Main) -&gt; 无子节点，无兄弟节点 -&gt; return 回溯到 Content -&gt; 无兄弟节点 -&gt; completeUnitOfWork(Content) -&gt; return 回溯到 App -&gt; 遍历结束</li>
</ol>
<p><strong>performUnitOfWork 的完整工作流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Scheduler</span><br><span class="line">    participant performUnitOfWork</span><br><span class="line">    participant beginWork</span><br><span class="line">    participant completeUnitOfWork</span><br><span class="line"></span><br><span class="line">    Scheduler-&gt;&gt;performUnitOfWork: 分配任务（Fiber节点）</span><br><span class="line">    performUnitOfWork-&gt;&gt;beginWork: 处理当前节点</span><br><span class="line">    alt 有子节点</span><br><span class="line">        beginWork--&gt;&gt;performUnitOfWork: 返回子节点</span><br><span class="line">    else 无子节点</span><br><span class="line">        beginWork--&gt;&gt;performUnitOfWork: null</span><br><span class="line">        performUnitOfWork-&gt;&gt;completeUnitOfWork: 进入完成阶段</span><br><span class="line">        completeUnitOfWork--&gt;&gt;performUnitOfWork: 返回兄弟/父节点</span><br><span class="line">    end</span><br><span class="line">    performUnitOfWork--&gt;&gt;Scheduler: 返回下一个节点</span><br></pre></td></tr></table></figure>

<h2 id="3-3-Diff算法的Fiber化改造"><a href="#3-3-Diff算法的Fiber化改造" class="headerlink" title="3.3 Diff算法的Fiber化改造"></a>3.3 Diff算法的Fiber化改造</h2><h3 id="同级比较（Key优化）在Fiber中的实现"><a href="#同级比较（Key优化）在Fiber中的实现" class="headerlink" title="同级比较（Key优化）在Fiber中的实现"></a>同级比较（Key优化）在Fiber中的实现</h3><p>React 列表元素为什么要加上 key 属性？</p>
<p>无论是传统 Diff 还是 Fiber Diff，key 的核心作用都是<code>唯一标识同级元素</code>。传统虚拟 DOM Diff 在 key 的利用上有两个瓶颈：</p>
<p><strong>双指针遍历算法（O(n²) 复杂度）</strong></p>
<p>传统 Diff 通过两层循环匹配新旧节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>; i &lt; newChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j =<span class="number">0</span>; j &lt; oldChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newChild[i].<span class="property">key</span> === oldChild[j].<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 匹配成功，复用节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这带来的问题是：</p>
<ul>
<li>长度为 n 的列表最坏情况下需要 n² 次比较，性能随列表长度增大急剧下降</li>
<li>仅能通过位置索引猜测节点移动，容易产生冗余 DOM 操作</li>
</ul>
<p><strong>复用粒度有限</strong></p>
<ul>
<li>仅能复用虚拟 DOM 节点对象，仍需执行组件的生命周期和 DOM 属性对比</li>
<li>无法跳过状态未发生改变的组件渲染（比如 shouldComponentUpdate 需手动优化）</li>
</ul>
<p>Fiber 架构对比传统虚拟 DOM Diff 在 key 的利用上实现了质的飞跃。</p>
<p>在 Fiber 架构中，同级比较的核心逻辑集中在 <code>reconcileChildren</code> 函数中，它负责对比新旧子节点并生成新的 Fiber 树。beginWork 函数根据组件类型执行对应处理时触发该函数。</p>
<p><strong>入口函数：reconcileChildren</strong></p>
<p>根据当前是首次渲染还是更新调用 mountChildFibers 或 reconcileChildFibers</p>
<ul>
<li>mountChildFibers：</li>
<li>reconcileChildFibers：处理子节点协调的核心逻辑，根据子节点类型做不同处理，比如子节点为数组时调用 <code>reconcileChildrenArray</code> 函数处理。</li>
</ul>
<p><strong>核心优化逻辑</strong></p>
<p>reconcileChildrenArray 采用多阶段遍历 + key 映射表的策略，将时间复杂度优化至O(n)，主要优化包括:</p>
<ul>
<li>两轮遍历：先尝试从左到右顺序匹配，再处理移动&#x2F;新增&#x2F;删除</li>
<li>key 映射：剩余未匹配的旧节点存入map，实现O(1)查找</li>
<li>节点复用：通过 key 和 type 精确匹配可复用的 Fiber 节点</li>
<li>最小化 DOM 操作：仅标记需要移动和删除的节点</li>
</ul>
<p><strong>源码解析：以 reconcileChildrenArray 为例</strong></p>
<p>阶段一：顺序遍历匹配（从左到右）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldFiber = currentFirstChild; <span class="comment">// 旧 Fiber 链表头节点</span></span><br><span class="line"><span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>; <span class="comment">// 记录最后一个无需移动的节点索引</span></span><br><span class="line"><span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一轮遍历：顺序匹配 key 相同的节点</span></span><br><span class="line"><span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;</span><br><span class="line">    nextOldFiber = oldFiber;</span><br><span class="line">    oldFiber = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试复用旧 Fiber（key &amp; type 匹配）</span></span><br><span class="line">  <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx], lanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// key 不匹配，跳出循环</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记是否需要移动</span></span><br><span class="line">  lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化点：</p>
<ul>
<li>updateSlot：检查 key 和 type，匹配则复用旧 Fiber，否则返回null</li>
<li>placeChild：比较旧 Fiber 的 index 和 newIdx，决定是否标记 placement（移动）</li>
</ul>
<p>阶段二：处理剩余节点<br>情况一：新节点已遍历完</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="comment">// 删除剩余旧节点</span></span><br><span class="line">  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化点：直接删除未匹配的旧节点，无需进一步比较</p>
<p>情况二：旧节点已遍历完</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建剩余新节点</span></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">    <span class="comment">// 链接到链表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化点：剩余新节点直接创建，无需匹配</p>
<p>情况三：新旧节点均未遍历完</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建旧节点 Map&lt;key|index, Fiber&gt;</span></span><br><span class="line"><span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(oldFiber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历剩余新节点，尝试从 Map 中匹配</span></span><br><span class="line"><span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">  <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(</span><br><span class="line">    existingChildren,</span><br><span class="line">    returnFiber,</span><br><span class="line">    newIdx,</span><br><span class="line">    newChildren[newIdx],</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 标记移动或复用</span></span><br><span class="line">    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除未匹配的旧节点</span></span><br><span class="line">existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br></pre></td></tr></table></figure>
<p>优化点：</p>
<ul>
<li>mapRemainingChildren：将剩余旧节点存入 map，key 优先，无 key 时使用 index</li>
<li>updateFromMap：从 map 中查找可复用节点，减少遍历次数</li>
<li>placeChild：仅对需要移动的节点标记 placement，减少不必要的 DOM 操作</li>
</ul>
<p><strong>key的核心作用</strong></p>
<ol>
<li>精确匹配：key 是 React 中节点的唯一标识，应避免复用</li>
<li>高效复用：通过 key 直接定位旧节点，而非递归比较</li>
<li>移动优化：key 相同的节点即使位置发生改变，也能被正确标记移动，而非删除重建</li>
</ol>
<p><strong>性能对比（传统虚拟 DOM Diff 对比 Fiber Diff）</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">传统 Diff</th>
<th align="left">Fiber Diff</th>
</tr>
</thead>
<tbody><tr>
<td align="left">时间复杂度</td>
<td align="left">O(n²)(双指针循环)</td>
<td align="left">O(n) (map查找)</td>
</tr>
<tr>
<td align="left">DOM 操作</td>
<td align="left">可能多次移动&#x2F;重建</td>
<td align="left">仅进行必要更新（placement&#x2F;deletion）</td>
</tr>
<tr>
<td align="left">状态保留</td>
<td align="left">仅复用 DOM</td>
<td align="left">组件状态、hooks、ref全保留</td>
</tr>
<tr>
<td align="left">列表渲染</td>
<td align="left">性能随列表长度下降明显</td>
<td align="left">万级列表仍然流畅</td>
</tr>
</tbody></table>
<h3 id="节点复用策略与bailout机制"><a href="#节点复用策略与bailout机制" class="headerlink" title="节点复用策略与bailout机制"></a>节点复用策略与bailout机制</h3><p><strong>复用条件：key 和 type 双匹配</strong></p>
<p>源码入口：reconcileChildFibers -&gt; reconcileChildrenArray &#x2F; updateSlot<br>核心代码逻辑（简化自ReactFiberChild.js）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateSlot</span>(<span class="params">returnFiber: Fiber, oldFiber: Fiber | <span class="literal">null</span>, newChild: any, lanes: Lanes</span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// Update the fiber if the keys match, otherwise return null.</span></span><br><span class="line">  <span class="keyword">const</span> key = oldFiber !== <span class="literal">null</span> ? oldFiber.<span class="property">key</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newChild.<span class="property">key</span> === key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newChild.<span class="property">type</span> === oldFiber?.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="comment">// 复用旧 Fiber（保留 state/DOM/hooks）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">useFiber</span>(oldFiber, newChild.<span class="property">props</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// key 匹配但 type 不匹配，销毁旧节点</span></span><br><span class="line">      <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 不匹配则创建新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复用规则</strong></p>
<ul>
<li>key 和 type 都相同：调用 useFiber 克隆旧节点，保留：<ul>
<li>组件实例（class组件）和 hooks 链表（函数式组件）</li>
<li>DOM 引用（避免重建）</li>
<li>状态和refs</li>
</ul>
</li>
<li>key 相同，type 不同：销毁旧节点（标记deletion），创建新节点</li>
<li>key 不同：直接创建新节点</li>
</ul>
<p><strong>useFiber实现（状态保留核心）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFiber</span>(<span class="params">fiber: Fiber, pendingProps: mixed</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="comment">// We currently set sibling to null and index to 0 here because it is easy</span></span><br><span class="line">  <span class="comment">// to forget to do before returning it. E.g. for the single child case.</span></span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title function_">createWorkInProgress</span>(fiber, pendingProps);</span><br><span class="line">  clone.<span class="property">index</span> = <span class="number">0</span>; <span class="comment">// 重置索引</span></span><br><span class="line">  clone.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 断开兄弟链接</span></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createWorkInProgress</span>(<span class="params">current: Fiber, pendingProps: any</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> workInProgress = current.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We use a double buffering pooling technique because we know that we&#x27;ll</span></span><br><span class="line">    <span class="comment">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span></span><br><span class="line">    <span class="comment">// node that we&#x27;re free to reuse. This is lazily created to avoid allocating</span></span><br><span class="line">    <span class="comment">// extra objects for things that are never updated. It also allow us to</span></span><br><span class="line">    <span class="comment">// reclaim the extra memory if needed.</span></span><br><span class="line">    workInProgress = <span class="title function_">createFiber</span>(</span><br><span class="line">      current.<span class="property">tag</span>,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.<span class="property">key</span>,</span><br><span class="line">      current.<span class="property">mode</span>,</span><br><span class="line">    );</span><br><span class="line">    workInProgress.<span class="property">elementType</span> = current.<span class="property">elementType</span>;</span><br><span class="line">    workInProgress.<span class="property">type</span> = current.<span class="property">type</span>;</span><br><span class="line">    workInProgress.<span class="property">stateNode</span> = current.<span class="property">stateNode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    workInProgress.<span class="property">alternate</span> = current;</span><br><span class="line">    current.<span class="property">alternate</span> = workInProgress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">    <span class="comment">// Needed because Blocks store data on type.</span></span><br><span class="line">    workInProgress.<span class="property">type</span> = current.<span class="property">type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We already have an alternate.</span></span><br><span class="line">    <span class="comment">// Reset the effect tag.</span></span><br><span class="line">    workInProgress.<span class="property">flags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The effects are no longer valid.</span></span><br><span class="line">    workInProgress.<span class="property">subtreeFlags</span> = <span class="title class_">NoFlags</span>;</span><br><span class="line">    workInProgress.<span class="property">deletions</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">      <span class="comment">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span></span><br><span class="line">      <span class="comment">// This prevents time from endlessly accumulating in new commits.</span></span><br><span class="line">      <span class="comment">// This has the downside of resetting values for different priority renders,</span></span><br><span class="line">      <span class="comment">// But works for yielding (the common case) and should support resuming.</span></span><br><span class="line">      workInProgress.<span class="property">actualDuration</span> = -<span class="number">0</span>;</span><br><span class="line">      workInProgress.<span class="property">actualStartTime</span> = -<span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset all effects except static ones.</span></span><br><span class="line">  <span class="comment">// Static effects are not specific to a render.</span></span><br><span class="line">  workInProgress.<span class="property">flags</span> = current.<span class="property">flags</span> &amp; <span class="title class_">StaticMask</span>;</span><br><span class="line">  workInProgress.<span class="property">childLanes</span> = current.<span class="property">childLanes</span>;</span><br><span class="line">  workInProgress.<span class="property">lanes</span> = current.<span class="property">lanes</span>;</span><br><span class="line"></span><br><span class="line">  workInProgress.<span class="property">child</span> = current.<span class="property">child</span>;</span><br><span class="line">  workInProgress.<span class="property">memoizedProps</span> = current.<span class="property">memoizedProps</span>;</span><br><span class="line">  workInProgress.<span class="property">memoizedState</span> = current.<span class="property">memoizedState</span>;</span><br><span class="line">  workInProgress.<span class="property">updateQueue</span> = current.<span class="property">updateQueue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clone the dependencies object. This is mutated during the render phase, so</span></span><br><span class="line">  <span class="comment">// it cannot be shared with the current fiber.</span></span><br><span class="line">  <span class="keyword">const</span> currentDependencies = current.<span class="property">dependencies</span>;</span><br><span class="line">  workInProgress.<span class="property">dependencies</span> =</span><br><span class="line">    currentDependencies === <span class="literal">null</span></span><br><span class="line">      ? <span class="literal">null</span></span><br><span class="line">      : __DEV__</span><br><span class="line">        ? &#123;</span><br><span class="line">            <span class="attr">lanes</span>: currentDependencies.<span class="property">lanes</span>,</span><br><span class="line">            <span class="attr">firstContext</span>: currentDependencies.<span class="property">firstContext</span>,</span><br><span class="line">            <span class="attr">_debugThenableState</span>: currentDependencies.<span class="property">_debugThenableState</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        : &#123;</span><br><span class="line">            <span class="attr">lanes</span>: currentDependencies.<span class="property">lanes</span>,</span><br><span class="line">            <span class="attr">firstContext</span>: currentDependencies.<span class="property">firstContext</span>,</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These will be overridden during the parent&#x27;s reconciliation</span></span><br><span class="line">  workInProgress.<span class="property">sibling</span> = current.<span class="property">sibling</span>;</span><br><span class="line">  workInProgress.<span class="property">index</span> = current.<span class="property">index</span>;</span><br><span class="line">  workInProgress.<span class="property">ref</span> = current.<span class="property">ref</span>;</span><br><span class="line">  workInProgress.<span class="property">refCleanup</span> = current.<span class="property">refCleanup</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">    workInProgress.<span class="property">selfBaseDuration</span> = current.<span class="property">selfBaseDuration</span>;</span><br><span class="line">    workInProgress.<span class="property">treeBaseDuration</span> = current.<span class="property">treeBaseDuration</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点：</p>
<ul>
<li>通过 alternate 指针复用旧 Fiber 对象（双缓冲技术）</li>
<li>保留 stateNode（DOM&#x2F;实例）和 memoizedState（状态）</li>
</ul>
<p><strong>bailout 机制（跳过子树协调）核心逻辑</strong></p>
<p>源码入口：beginWork -&gt; updateFunctionComponent &#x2F; updateClassComponent</p>
<p>核心代码逻辑（精简自ReactFiberBeginWork.js）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: <span class="literal">null</span> | Fiber,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  Component: any,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    oldProps === newProps &amp;&amp; <span class="comment">// Props 浅比较</span></span><br><span class="line">    !<span class="title function_">hasLegacyContextChanged</span>() &amp;&amp; <span class="comment">// 旧 Context 未变</span></span><br><span class="line">    workInProgress.<span class="property">type</span> === current.<span class="property">type</span> &amp;&amp; <span class="comment">// 组件类型相同</span></span><br><span class="line">    !<span class="title function_">includesSomeLane</span>(renderLanes, current.<span class="property">lanes</span>) <span class="comment">// 无高优先级更新</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    <span class="title function_">bailoutHooks</span>(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>() &amp;&amp; hasId) &#123;</span><br><span class="line">    <span class="title function_">pushMaterializedTreeId</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">  workInProgress.<span class="property">flags</span> |= <span class="title class_">PerformedWork</span>;</span><br><span class="line">  <span class="title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bailout 条件</strong></p>
<ul>
<li>props 浅层相等（Object.is比较）</li>
<li>context 值未变化（新旧 Provider 值浅比较）。</li>
<li>组件类型相同（无 type 变化）。</li>
<li>无更高优先级更新（通过 lanes 模型判断）</li>
</ul>
<p><strong>bailoutOnAlreadyFinishedWork 实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(<span class="params">current: Fiber, workInProgress: Fiber, renderLanes: Lanes</span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="title function_">cloneChildFibers</span>(current, workInProgress); <span class="comment">// 克隆子树</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键操作：</p>
<ul>
<li>子树克隆：直接拷贝 current 树的子链表到 workInProgress 树。</li>
<li>副作用继承：保留旧 Fiber 的 subtreeFlags（标记子树是否需要更新）。</li>
</ul>
<p><strong>性能优化对比</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">传统 Diff</th>
<th align="left">Fiber Diff</th>
</tr>
</thead>
<tbody><tr>
<td align="left">节点复用</td>
<td align="left">仅复用 DOM</td>
<td align="left">状态+DOM+hooks</td>
</tr>
<tr>
<td align="left">条件判断</td>
<td align="left">无系统化 bailout</td>
<td align="left">多维度检测（props&#x2F;context&#x2F;优先级）</td>
</tr>
<tr>
<td align="left">子树跳过</td>
<td align="left">不可能</td>
<td align="left">直接克隆整棵子树（O(1) 操作）</td>
</tr>
<tr>
<td align="left">时间复杂度</td>
<td align="left">O(n²)（递归）</td>
<td align="left">O(n)（map查找+链表遍历）</td>
</tr>
</tbody></table>
<h1 id="第四章：Fiber的调度系统与并发模式"><a href="#第四章：Fiber的调度系统与并发模式" class="headerlink" title="第四章：Fiber的调度系统与并发模式"></a>第四章：Fiber的调度系统与并发模式</h1><h2 id="4-1-调度器（Scheduler）的实现原理"><a href="#4-1-调度器（Scheduler）的实现原理" class="headerlink" title="4.1 调度器（Scheduler）的实现原理"></a>4.1 调度器（Scheduler）的实现原理</h2><p>调度器（scheduler）是 Fiber 架构中并发模式的核心实现。调度器的核心目标有三点：</p>
<ul>
<li>任务可中断与恢复</li>
<li>优先级调度</li>
<li>时间切片</li>
</ul>
<p>React17 及之前版本中任务中断与时间切片的核心逻辑在于浏览器 requestIdleCallback API 的利用，但该 API 有几个问题：</p>
<ul>
<li>不可靠的执行时机：requestIdleCallback 的执行依赖于浏览器的空闲时间，但不同浏览器的实现差异较大，且可能被扩展插件、防病毒软件等干扰</li>
<li>无法保证任务顺序：requestIdleCallback 的回调执行顺序可能被打乱（尤其是设置了 timeout 时），而 React 需要精确控制任务优先级</li>
<li>兼容性问题：部分浏览器（如旧版 Safari）不支持 requestIdleCallback，或实现不一致</li>
<li>时间切片需求：React 需要将任务拆分为 5ms 左右的小块，而 requestIdleCallback 无法提供这种精细控制</li>
</ul>
<p>React 18 改用 <code>MessageChannel</code> 模拟 requestIdleCallback 的行为，并在此基础上实现更高级的调度策略</p>
<h3 id="MessageChannel与时间切片"><a href="#MessageChannel与时间切片" class="headerlink" title="MessageChannel与时间切片"></a>MessageChannel与时间切片</h3><p>MessageChannel 是浏览器提供的用于跨文档通信（跨窗口&#x2F;iframe）的 API，也被广泛用于主线程的任务调度</p>
<p><strong>基本用法</strong></p>
<p>MessageChannel 创建一个双向通信通道，包含两个MessagePort：</p>
<ul>
<li>port1：发送消息</li>
<li>port2：接收消息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; port1, port2 &#125; = channel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// port2 监听消息</span></span><br><span class="line">port2.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Received:&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// port1 发送消息</span></span><br><span class="line">port1.<span class="title function_">postMessage</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>异步执行：postMessage 是宏任务，类似于 setTimeout(fn, 0)，但比setTimeout更高效</li>
<li>零延迟：浏览器会尽快执行回调，不受事件循环延迟影响</li>
<li>跨线程通信：可用于 Web Worker、Service Worker 等场景（但 React 调度器仅用于主线程）</li>
</ul>
<p><strong>React scheduler 如何使用 MessageChannel</strong></p>
<p>关键代码（Scheduler.js）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">performWorkUntilDeadline</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableRequestPaint) &#123;</span><br><span class="line">    needsPaint = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">    <span class="comment">// Keep track of the start time so we can measure how long the main thread</span></span><br><span class="line">    <span class="comment">// has been blocked.</span></span><br><span class="line">    startTime = currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a scheduler task throws, exit the current browser task so the</span></span><br><span class="line">    <span class="comment">// error can be observed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Intentionally not using a try-catch, since that makes some debugging</span></span><br><span class="line">    <span class="comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span></span><br><span class="line">    <span class="comment">// remain true, and we&#x27;ll continue the work loop.</span></span><br><span class="line">    <span class="keyword">let</span> hasMoreWork = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// workLoop 循环执行任务直到时间片用尽</span></span><br><span class="line">      hasMoreWork = <span class="title function_">flushWork</span>(currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s more work, schedule the next message event at the end</span></span><br><span class="line">        <span class="comment">// of the preceding one.</span></span><br><span class="line">        <span class="title function_">schedulePerformWorkUntilDeadline</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params">initialTime: number</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略非关键代码</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">workLoop</span>(initialTime);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 省略非关键代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No catch in prod code path.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">workLoop</span>(initialTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 省略非关键代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">initialTime: number</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableAlwaysYieldScheduler) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentTask.<span class="property">expirationTime</span> &gt; currentTime &amp;&amp; <span class="title function_">shouldYieldToHost</span>()) &#123;</span><br><span class="line">        <span class="comment">// This currentTask hasn&#x27;t expired, and we&#x27;ve reached the deadline.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">pop</span>(taskQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略任务队列循环处理逻辑代码</span></span><br><span class="line">    currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Return whether there&#x27;s additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstTimer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="property">startTime</span> - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleTimeout</span>(<span class="params">currentTime: number</span>) &#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">requestHostCallback</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstTimer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="property">startTime</span> - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestHostCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">schedulePerformWorkUntilDeadline</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM and Worker environments.</span></span><br><span class="line"><span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="keyword">const</span> port = channel.<span class="property">port2</span>;</span><br><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = performWorkUntilDeadline; <span class="comment">// 接收消息后执行任务</span></span><br><span class="line">schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  port.<span class="title function_">postMessage</span>(<span class="literal">null</span>); <span class="comment">// 触发异步执行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调度流程如下：</p>
<ol>
<li>任务入队：unstable_scheduleCallback 将任务加入最小堆</li>
<li>触发调度：requestHostCallback 通过 port.postMessage(null) 请求调度</li>
<li>执行任务：浏览器在下一事件循环中调用 port1.onmessage，执行 flushWork</li>
<li>时间切片：flushWork 每次执行最多 5ms，超时则暂停（shouldYieldToHost）</li>
</ol>
<h3 id="优先级标记（Lane模型）与任务队列"><a href="#优先级标记（Lane模型）与任务队列" class="headerlink" title="优先级标记（Lane模型）与任务队列"></a>优先级标记（Lane模型）与任务队列</h3><p>之前章节我们已经学习过优先级载体 Lane 模型的概念，其对应代码定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SchedulerPriorities.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">PriorityLevel</span> = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Use symbols?</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoPriority</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ImmediatePriority</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserBlockingPriority</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NormalPriority</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LowPriority</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IdlePriority</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>优先级与超时时间映射</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeout;</span><br><span class="line"><span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">  <span class="comment">// Times out immediately</span></span><br><span class="line">  timeout = -<span class="number">1</span>; <span class="comment">// 同步执行</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">  <span class="comment">// Eventually times out</span></span><br><span class="line">  timeout = userBlockingPriorityTimeout; <span class="comment">// 250ms 超时</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">  <span class="comment">// Never times out</span></span><br><span class="line">  timeout = maxSigned31BitInt; <span class="comment">// 最大超时，var maxSigned31BitInt = 1073741823; 约12天</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">  <span class="comment">// Eventually times out</span></span><br><span class="line">  timeout = lowPriorityTimeout; <span class="comment">// 10s 超时</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">  <span class="comment">// Eventually times out</span></span><br><span class="line">  timeout = normalPriorityTimeout; <span class="comment">// 5s 超时</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任务队列（最小堆）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SchedulerMinHeap.js</span></span><br><span class="line">type <span class="title class_">Heap</span>&lt;<span class="attr">T</span>: <span class="title class_">Node</span>&gt; = <span class="title class_">Array</span>&lt;T&gt;;</span><br><span class="line">type <span class="title class_">Node</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: number,</span><br><span class="line">  <span class="attr">sortIndex</span>: number,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> push&lt;<span class="attr">T</span>: <span class="title class_">Node</span>&gt;(<span class="attr">heap</span>: <span class="title class_">Heap</span>&lt;T&gt;, <span class="attr">node</span>: T): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> index = heap.<span class="property">length</span>;</span><br><span class="line">  heap.<span class="title function_">push</span>(node);</span><br><span class="line">  <span class="title function_">siftUp</span>(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> peek&lt;<span class="attr">T</span>: <span class="title class_">Node</span>&gt;(<span class="attr">heap</span>: <span class="title class_">Heap</span>&lt;T&gt;): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> heap.<span class="property">length</span> === <span class="number">0</span> ? <span class="literal">null</span> : heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> pop&lt;<span class="attr">T</span>: <span class="title class_">Node</span>&gt;(<span class="attr">heap</span>: <span class="title class_">Heap</span>&lt;T&gt;): T | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (heap.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> last = heap.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-type]</span></span><br><span class="line">    heap[<span class="number">0</span>] = last;</span><br><span class="line">    <span class="comment">// $FlowFixMe[incompatible-call]</span></span><br><span class="line">    <span class="title function_">siftDown</span>(heap, last, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任务调度入口：unstable_scheduleCallback</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_scheduleCallback</span>(<span class="params"></span></span><br><span class="line"><span class="params">  priorityLevel: PriorityLevel,</span></span><br><span class="line"><span class="params">  callback: Callback,</span></span><br><span class="line"><span class="params">  options?: &#123;delay: number&#125;,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Task</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.<span class="property">delay</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">      <span class="comment">// Times out immediately</span></span><br><span class="line">      timeout = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">      <span class="comment">// Eventually times out</span></span><br><span class="line">      timeout = userBlockingPriorityTimeout;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">      <span class="comment">// Never times out</span></span><br><span class="line">      timeout = maxSigned31BitInt;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">      <span class="comment">// Eventually times out</span></span><br><span class="line">      timeout = lowPriorityTimeout;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// Eventually times out</span></span><br><span class="line">      timeout = normalPriorityTimeout;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算任务过期时间</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新任务对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="attr">newTask</span>: <span class="title class_">Task</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: taskIdCounter++,</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,</span><br><span class="line">    expirationTime,</span><br><span class="line">    <span class="attr">sortIndex</span>: -<span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    newTask.<span class="property">isQueued</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// This is a delayed task.</span></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = startTime;</span><br><span class="line">    <span class="comment">// 将任务插入最小堆（按expirationTime排序）</span></span><br><span class="line">    <span class="title function_">push</span>(timerQueue, newTask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === <span class="title function_">peek</span>(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">        <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule a timeout.</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTask.<span class="property">sortIndex</span> = expirationTime;</span><br><span class="line">    <span class="title function_">push</span>(taskQueue, newTask);</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="title function_">markTaskStart</span>(newTask, currentTime);</span><br><span class="line">      newTask.<span class="property">isQueued</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Schedule a host callback, if needed. If we&#x27;re already performing work,</span></span><br><span class="line">    <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">requestHostCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unstable_scheduleCallback被调用路径</strong></p>
<p>unstable_scheduleCallback 主要通过以下路径被调用：</p>
<ol>
<li>状态更新：setState、useState、useReducer。</li>
<li>副作用调度：useEffect、useLayoutEffect。</li>
<li>并发模式 API：startTransition、useDeferredValue。</li>
<li>根节点渲染：ReactDOM.createRoot().render()。</li>
</ol>
<p><strong>核心调用链路</strong></p>
<p>以 setState 为例，调用链如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setState -&gt; enqueueSetState -&gt; scheduleUpdateOnFiber -&gt; ensureRootIsScheduled -&gt; ensureScheduleIsScheduled -&gt; scheduleImmediateRootScheduleTask -&gt; unstable_scheduleCallback -&gt; requestHostCallback -&gt; schedulePerformWorkUntilDeadline -&gt; port2.<span class="property">postMessage</span> -&gt; port1.<span class="property">onmessage</span> -&gt; performWorkUntilDeadline -&gt; flushWork</span><br><span class="line"></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>class 组件在继承 React.Component 时通过 constructor 指定 <code>instance.updater = classComponentUpdater</code>，enqueueSetState 就是 classComponentUpdater 对象的属性方法</p>
<p>任务调度（unstable_scheduleCallback）到任务执行（performUnitOfWork）的关键在于 flushWork 中 <code>currentTask.callback</code> 的执行。currentTask.callback 是调用 unstable_scheduleCallback 时传入的第二个参数（<code>unstable_scheduleCallback(ImmediateSchedulerPriority, processRootScheduleInImmediateTask)</code>）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processRootScheduleInImmediateTask -&gt; performWorkOnRoot -&gt; renderRootConcurrent -&gt; workLoopConcurrentByScheduler -&gt; performUnitOfWork</span><br></pre></td></tr></table></figure>

<p>此外，performWorkOnRoot 函数内在执行完 renderRootConcurrent 后会返回 exitStatus 值，用于判断完成状态，调用 finishConcurrentRender 后提交 commitRoot</p>
<h2 id="4-2-并发模式（Concurrent-Mode）的底层支持"><a href="#4-2-并发模式（Concurrent-Mode）的底层支持" class="headerlink" title="4.2 并发模式（Concurrent Mode）的底层支持"></a>4.2 并发模式（Concurrent Mode）的底层支持</h2><h3 id="高优先级更新的插队机制（如用户输入）"><a href="#高优先级更新的插队机制（如用户输入）" class="headerlink" title="高优先级更新的插队机制（如用户输入）"></a>高优先级更新的插队机制（如用户输入）</h3><p>Fiber 高优先级任务的插队机制 是并发模式（Concurrent Mode）的核心特性之一，它允许高优先级任务（如用户交互）中断正在执行的低优先级任务（如数据加载）</p>
<p>以 setState 举例说明高优先级更新的插队机制</p>
<p><strong>任务调度</strong></p>
<p>当触发 setState 更新时：</p>
<ol>
<li>创建 update 对象并标记 lane</li>
<li>调用 scheduleUpdateOnFiber 向上收集优先级到 root.pendingLanes</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueSetState</span>(<span class="params">inst: any, payload: any, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">  <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(lane);</span><br><span class="line">  update.<span class="property">payload</span> = payload;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">warnOnInvalidCallback</span>(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    update.<span class="property">callback</span> = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title function_">enqueueUpdate</span>(fiber, update, lane);</span><br><span class="line">  <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">startUpdateTimerByLane</span>(lane, <span class="string">&#x27;this.setState()&#x27;</span>);</span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);</span><br><span class="line">    <span class="title function_">entangleTransitions</span>(root, fiber, lane);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    <span class="title function_">markStateUpdateScheduled</span>(fiber, lane);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react-reconciler/src/ReactFiberWorkLoop.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleUpdateOnFiber</span>(<span class="params">root, fiber, lane</span>) &#123;</span><br><span class="line">  <span class="comment">// Mark that the root has a pending update.</span></span><br><span class="line">  <span class="title function_">markRootUpdated</span>(root, lane); <span class="comment">// 更新 root.pendingLanes</span></span><br><span class="line">  <span class="title function_">ensureRootIsScheduled</span>(root); <span class="comment">// 触发调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">ensureScheduleIsScheduled</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureScheduleIsScheduled</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 在当前事件结束时，遍历每个根，并确保以正确的优先级为每个根安排了一个任务</span></span><br><span class="line">  <span class="comment">// didScheduleMicrotask 用于防止调度冗余的 mircotask</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title class_">ReactSharedInternals</span>.<span class="property">actQueue</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re inside an `act` scope.</span></span><br><span class="line">    <span class="keyword">if</span> (!didScheduleMicrotask_act) &#123;</span><br><span class="line">      didScheduleMicrotask_act = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">scheduleImmediateRootScheduleTask</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!didScheduleMicrotask) &#123;</span><br><span class="line">      didScheduleMicrotask = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">scheduleImmediateRootScheduleTask</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleImmediateRootScheduleTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsMicrotasks) &#123;</span><br><span class="line">    <span class="title function_">scheduleMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">processRootScheduleInMicrotask</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If microtasks are not supported, use Scheduler.</span></span><br><span class="line">    <span class="title class_">Scheduler</span>_scheduleCallback(</span><br><span class="line">      <span class="title class_">ImmediateSchedulerPriority</span>,</span><br><span class="line">      processRootScheduleInImmediateTask,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中断低优先级任务（scheduleTaskForRootDuringMicrotask）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processRootScheduleInMicrotask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 1. 遍历全局调度链表（firstScheduledRoot → lastScheduledRoot）</span></span><br><span class="line">  <span class="keyword">let</span> root = firstScheduledRoot;</span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = root.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">const</span> nextLanes = <span class="title function_">scheduleTaskForRootDuringMicrotask</span>(root, currentTime);</span><br><span class="line">    <span class="keyword">if</span> (nextLanes === <span class="title class_">NoLane</span>) &#123;</span><br><span class="line">      root.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (prev === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the new head of the list</span></span><br><span class="line">        firstScheduledRoot = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.<span class="property">next</span> = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the new tail of the list</span></span><br><span class="line">        lastScheduledRoot = prev;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This root still has work. Keep it in the list.</span></span><br><span class="line">      prev = root;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        syncTransitionLanes !== <span class="title class_">NoLanes</span> ||</span><br><span class="line">        <span class="title function_">includesSyncLane</span>(nextLanes) ||</span><br><span class="line">        (enableGestureTransition &amp;&amp; <span class="title function_">isGestureRender</span>(nextLanes))</span><br><span class="line">      ) &#123;</span><br><span class="line">        mightHavePendingSyncWork = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleTaskForRootDuringMicrotask</span>(<span class="params"></span></span><br><span class="line"><span class="params">  root: FiberRoot,</span></span><br><span class="line"><span class="params">  currentTime: number,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Lane</span> &#123;</span><br><span class="line">  <span class="title function_">markStarvedLanesAsExpired</span>(root, currentTime);</span><br><span class="line">  <span class="keyword">const</span> nextLanes = <span class="title function_">getNextLanes</span>(</span><br><span class="line">    root,</span><br><span class="line">    root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="title class_">NoLanes</span>,</span><br><span class="line">    rootHasPendingCommit);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.<span class="property">callbackNode</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    nextLanes === <span class="title class_">NoLanes</span> ||</span><br><span class="line">    (root === workInProgressRoot &amp;&amp; <span class="title function_">isWorkLoopSuspendedOnData</span>()) ||</span><br><span class="line">    root.<span class="property">cancelPendingCommit</span> !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fast path: There&#x27;s nothing to work on.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">cancelCallback</span>(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line">    root.<span class="property">callbackPriority</span> = <span class="title class_">NoLane</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NoLane</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="title function_">includesSyncLane</span>(nextLanes) &amp;&amp;</span><br><span class="line">    <span class="comment">// If we&#x27;re prerendering, then we should use the concurrent work loop</span></span><br><span class="line">    <span class="comment">// even if the lanes are synchronous, so that prerendering never blocks</span></span><br><span class="line">    <span class="comment">// the main thread.</span></span><br><span class="line">    !<span class="title function_">checkIfRootIsPrerendering</span>(root, nextLanes)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Synchronous work is always flushed at the end of the microtask, so we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need to schedule an additional task.</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">cancelCallback</span>(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">callbackPriority</span> = <span class="title class_">SyncLane</span>;</span><br><span class="line">    root.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SyncLane</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We use the highest priority lane to represent the priority of the callback.</span></span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.<span class="property">callbackPriority</span>;</span><br><span class="line">    <span class="keyword">const</span> newCallbackPriority = <span class="title function_">getHighestPriorityLane</span>(nextLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      newCallbackPriority === existingCallbackPriority &amp;&amp;</span><br><span class="line">      <span class="comment">// Special case related to `act`. If the currently scheduled task is a</span></span><br><span class="line">      <span class="comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span></span><br><span class="line">      <span class="comment">// on the `act` queue.</span></span><br><span class="line">      !(</span><br><span class="line">        __DEV__ &amp;&amp;</span><br><span class="line">        <span class="title class_">ReactSharedInternals</span>.<span class="property">actQueue</span> !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        existingCallbackNode !== fakeActCallbackNode</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// The priority hasn&#x27;t changed. We can reuse the existing task.</span></span><br><span class="line">      <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Cancel the existing callback. We&#x27;ll schedule a new one below.</span></span><br><span class="line">      <span class="title function_">cancelCallback</span>(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performWorkOnRootViaSchedulerTask.<span class="title function_">bind</span>(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.<span class="property">callbackPriority</span> = newCallbackPriority;</span><br><span class="line">    root.<span class="property">callbackNode</span> = newCallbackNode;</span><br><span class="line">    <span class="keyword">return</span> newCallbackPriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插队机制关键解析</strong></p>
<p>（1）标记过期任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">markStarvedLanesAsExpired</span>(root, currentTime);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：检查 root.pendingLanes 中是否有低优先级任务因长期未执行而“饿死”（超过 timeout 未处理）</li>
<li>插队机制：将过期的低优先级任务标记为 expiredLanes 使其升级为同步优先级（SyncLane）从而获得立即执行的机会</li>
</ul>
<p>（2）计算下一个要处理的 lanes（getNextLanes）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextLanes = <span class="title function_">getNextLanes</span>(</span><br><span class="line">  root,</span><br><span class="line">  root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="title class_">NoLanes</span>,</span><br><span class="line">  rootHasPendingCommit</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>优先级比较：从 pendingLanes 中选择最高优先级的 lanes，规则包括：<ul>
<li>优先选择已过期的 expiredLanes（相当于强制插队）</li>
<li>然后选择用户交互相关的 InputContinuousLane 或 DefaultLane</li>
<li>避免与正在进行的渲染任务冲突</li>
</ul>
</li>
</ul>
<p>（3）中断低优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="title function_">cancelCallback</span>(existingCallbackNode); <span class="comment">// 取消当前正在执行的低优先级任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当检测到更高优先级的 newCallbackPriority 时，立即取消当前任务的回调执行。</li>
</ul>
<p>（4）调度新任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">  schedulerPriorityLevel,</span><br><span class="line">  performWorkOnRootViaSchedulerTask.<span class="title function_">bind</span>(<span class="literal">null</span>, root)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Suspense的异步渲染流程"><a href="#Suspense的异步渲染流程" class="headerlink" title="Suspense的异步渲染流程"></a>Suspense的异步渲染流程</h3><p>Suspense 的异步渲染流程主要围绕 <code>异步数据加载</code> 和 <code>懒加载组件（Code Splitting）</code> 两大场景展开。Suspense 的工作原理是捕获子组件抛出的 Promise，并在 Promise 未完成时显示 fallback UI。</p>
<p>其异步状态管理的逻辑如下：</p>
<ul>
<li>当子组件（如 lazy 组件或使用 use Hook 的组件）需要等待异步操作（如数据加载或代码加载）时，它会 抛出一个 Promise。</li>
<li>Suspense 会捕获这个 Promise，并进入 挂起（Suspended）状态，显示 fallback UI。</li>
<li>当 Promise 完成（resolve 或 reject），React 会重新尝试渲染子组件。</li>
</ul>
<p><strong>渲染流程详解</strong></p>
<p>（1）Code Splitting（懒加载组件）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Component&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>lazy 返回一个特殊对象（LazyComponent），包含 <code>_status</code>（<code>Pending/Resolved/Rejected</code>）和 <code>_result</code>（加载的模块）。</li>
<li>首次渲染时，readLazyComponentType 检查状态：<ul>
<li>若 Pending，抛出 thenable（Promise），触发 Suspense 显示 fallback。</li>
<li>若 Resolved，返回模块并渲染</li>
</ul>
</li>
</ul>
<p>（2）数据获取（Async Data Fetching）<br>实验性 API <code>unstable_createResource</code> 允许在组件内同步读取异步数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resource = <span class="title function_">unstable_createResource</span>(fetchData);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = resource.<span class="title function_">read</span>(id); <span class="comment">// 可能抛出 Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>resource.read 检查缓存：<ul>
<li>若数据未加载，抛出 Promise，Suspense 捕获并显示 fallback。</li>
<li>若数据已加载，直接返回6。</li>
</ul>
</li>
<li>React 在微任务阶段重新尝试渲染完成加载的组件</li>
</ul>
<h2 id="4-3-实际案例：startTransition的工作原理"><a href="#4-3-实际案例：startTransition的工作原理" class="headerlink" title="4.3 实际案例：startTransition的工作原理"></a>4.3 实际案例：startTransition的工作原理</h2><h1 id="第五章：Fiber的渲染流程剖析"><a href="#第五章：Fiber的渲染流程剖析" class="headerlink" title="第五章：Fiber的渲染流程剖析"></a>第五章：Fiber的渲染流程剖析</h1><h2 id="5-1-两阶段提交模型详解"><a href="#5-1-两阶段提交模型详解" class="headerlink" title="5.1 两阶段提交模型详解"></a>5.1 两阶段提交模型详解</h2><h3 id="Render阶段（可中断）：Reconciliation与Effect收集"><a href="#Render阶段（可中断）：Reconciliation与Effect收集" class="headerlink" title="Render阶段（可中断）：Reconciliation与Effect收集"></a>Render阶段（可中断）：Reconciliation与Effect收集</h3><h3 id="Commit阶段（不可中断）：DOM更新与生命周期执行"><a href="#Commit阶段（不可中断）：DOM更新与生命周期执行" class="headerlink" title="Commit阶段（不可中断）：DOM更新与生命周期执行"></a>Commit阶段（不可中断）：DOM更新与生命周期执行</h3><h2 id="5-2-双缓存树切换的完整流程"><a href="#5-2-双缓存树切换的完整流程" class="headerlink" title="5.2 双缓存树切换的完整流程"></a>5.2 双缓存树切换的完整流程</h2><h3 id="从WorkInProgress树到Current树的切换时机"><a href="#从WorkInProgress树到Current树的切换时机" class="headerlink" title="从WorkInProgress树到Current树的切换时机"></a>从WorkInProgress树到Current树的切换时机</h3><h3 id="错误边界与渲染恢复机制"><a href="#错误边界与渲染恢复机制" class="headerlink" title="错误边界与渲染恢复机制"></a>错误边界与渲染恢复机制</h3><h1 id="第六章：Fiber的性能优化实践"><a href="#第六章：Fiber的性能优化实践" class="headerlink" title="第六章：Fiber的性能优化实践"></a>第六章：Fiber的性能优化实践</h1><h2 id="6-1-减少协调开销的优化策略"><a href="#6-1-减少协调开销的优化策略" class="headerlink" title="6.1 减少协调开销的优化策略"></a>6.1 减少协调开销的优化策略</h2><h3 id="React-memo、useMemo、useCallback的原理与误用"><a href="#React-memo、useMemo、useCallback的原理与误用" class="headerlink" title="React.memo、useMemo、useCallback的原理与误用"></a>React.memo、useMemo、useCallback的原理与误用</h3><h3 id="不可变数据与SCU（shouldComponentUpdate）优化"><a href="#不可变数据与SCU（shouldComponentUpdate）优化" class="headerlink" title="不可变数据与SCU（shouldComponentUpdate）优化"></a>不可变数据与SCU（shouldComponentUpdate）优化</h3><h2 id="6-2-调试工具与性能分析"><a href="#6-2-调试工具与性能分析" class="headerlink" title="6.2 调试工具与性能分析"></a>6.2 调试工具与性能分析</h2><h3 id="React-DevTools的Fiber树-inspection"><a href="#React-DevTools的Fiber树-inspection" class="headerlink" title="React DevTools的Fiber树 inspection"></a>React DevTools的Fiber树 inspection</h3><h3 id="使用Profiler-API定位渲染瓶颈"><a href="#使用Profiler-API定位渲染瓶颈" class="headerlink" title="使用Profiler API定位渲染瓶颈"></a>使用Profiler API定位渲染瓶颈</h3><h1 id="第七章：Fiber的延伸与生态系统影响"><a href="#第七章：Fiber的延伸与生态系统影响" class="headerlink" title="第七章：Fiber的延伸与生态系统影响"></a>第七章：Fiber的延伸与生态系统影响</h1><h2 id="7-1-Fiber架构的通用性设计"><a href="#7-1-Fiber架构的通用性设计" class="headerlink" title="7.1 Fiber架构的通用性设计"></a>7.1 Fiber架构的通用性设计</h2><h3 id="自定义渲染器（如React-Three-Fiber）的实现原理"><a href="#自定义渲染器（如React-Three-Fiber）的实现原理" class="headerlink" title="自定义渲染器（如React Three Fiber）的实现原理"></a>自定义渲染器（如React Three Fiber）的实现原理</h3><h3 id="非DOM环境（React-Native）的Fiber适配"><a href="#非DOM环境（React-Native）的Fiber适配" class="headerlink" title="非DOM环境（React Native）的Fiber适配"></a>非DOM环境（React Native）的Fiber适配</h3><h2 id="7-2-其他框架的借鉴与对比"><a href="#7-2-其他框架的借鉴与对比" class="headerlink" title="7.2 其他框架的借鉴与对比"></a>7.2 其他框架的借鉴与对比</h2><h3 id="Vue-3的调度器设计-vs-React-Fiber"><a href="#Vue-3的调度器设计-vs-React-Fiber" class="headerlink" title="Vue 3的调度器设计 vs React Fiber"></a>Vue 3的调度器设计 vs React Fiber</h3><h3 id="Svelte的编译时优化与运行时调度的取舍"><a href="#Svelte的编译时优化与运行时调度的取舍" class="headerlink" title="Svelte的编译时优化与运行时调度的取舍"></a>Svelte的编译时优化与运行时调度的取舍</h3><h1 id="第八章：从源码角度理解Fiber"><a href="#第八章：从源码角度理解Fiber" class="headerlink" title="第八章：从源码角度理解Fiber"></a>第八章：从源码角度理解Fiber</h1><h2 id="8-1-关键源码文件导读"><a href="#8-1-关键源码文件导读" class="headerlink" title="8.1 关键源码文件导读"></a>8.1 关键源码文件导读</h2><h3 id="react-reconciler包的核心逻辑"><a href="#react-reconciler包的核心逻辑" class="headerlink" title="react-reconciler包的核心逻辑"></a>react-reconciler包的核心逻辑</h3><h3 id="beginWork、completeWork函数解析"><a href="#beginWork、completeWork函数解析" class="headerlink" title="beginWork、completeWork函数解析"></a>beginWork、completeWork函数解析</h3><h2 id="8-2-手写迷你Fiber引擎"><a href="#8-2-手写迷你Fiber引擎" class="headerlink" title="8.2 手写迷你Fiber引擎"></a>8.2 手写迷你Fiber引擎</h2><h3 id="实现一个简化版Fiber调度器（300行代码Demo）"><a href="#实现一个简化版Fiber调度器（300行代码Demo）" class="headerlink" title="实现一个简化版Fiber调度器（300行代码Demo）"></a>实现一个简化版Fiber调度器（300行代码Demo）</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/React/" class="category-chain-item">React</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/React/" class="print-no-link">#React</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>React Fiber 专题学习</div>
      <div>https://tianfei92.github.io/2025/06/18/React Fiber/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Beitragsautor</div>
          <div>Ariel</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Veröffentlicht am</div>
          <div>June 18, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Urheberrechtshinweis</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/19/JavaScript/" title="JavaScript 专题学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaScript 专题学习</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Inhaltsverzeichnis</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog funktioniert am besten mit aktiviertem JavaScript</div>
  </noscript>
</body>
</html>
