

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ariel">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一章：React 基础与核心概念1.1 React 简介与设计哲学（组件化、声明式 UI）基础概念概述React 是什么？ Facebook 推出的用于构建用户界面的 JavaScript 库，核心解决 UI 组件化开发问题。 两大设计哲学  组件化 (Component-Based)：将 UI 拆分为独立、可复用的代码单元（组件），每个组件管理自身状态与逻辑。示例：&lt;Button &#x2F;&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="React 知识体系专题学习">
<meta property="og:url" content="https://tianfei92.github.io/2025/06/23/React%20Study%20Notes/index.html">
<meta property="og:site_name" content="Ariel&#39;s Blog">
<meta property="og:description" content="第一章：React 基础与核心概念1.1 React 简介与设计哲学（组件化、声明式 UI）基础概念概述React 是什么？ Facebook 推出的用于构建用户界面的 JavaScript 库，核心解决 UI 组件化开发问题。 两大设计哲学  组件化 (Component-Based)：将 UI 拆分为独立、可复用的代码单元（组件），每个组件管理自身状态与逻辑。示例：&lt;Button &#x2F;&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-23T09:00:36.000Z">
<meta property="article:modified_time" content="2025-07-01T09:22:51.628Z">
<meta property="article:author" content="Ariel">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>React 知识体系专题学习 - Ariel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tianfei92.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ariel</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="React 知识体系专题学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-23 17:00" pubdate>
          2025年6月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          164 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">React 知识体系专题学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章：React-基础与核心概念"><a href="#第一章：React-基础与核心概念" class="headerlink" title="第一章：React 基础与核心概念"></a>第一章：React 基础与核心概念</h1><h2 id="1-1-React-简介与设计哲学（组件化、声明式-UI）"><a href="#1-1-React-简介与设计哲学（组件化、声明式-UI）" class="headerlink" title="1.1 React 简介与设计哲学（组件化、声明式 UI）"></a>1.1 React 简介与设计哲学（组件化、声明式 UI）</h2><h3 id="基础概念概述"><a href="#基础概念概述" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p><strong>React 是什么？</strong></p>
<p>Facebook 推出的用于构建用户界面的 JavaScript 库，核心解决 UI 组件化开发问题。</p>
<p><strong>两大设计哲学</strong></p>
<ul>
<li>组件化 (Component-Based)：将 UI 拆分为独立、可复用的代码单元（组件），每个组件管理自身状态与逻辑。<em>示例：<code>&lt;Button /&gt;</code>, <code>&lt;Card /&gt;</code> 等</em></li>
<li>声明式 UI (Declarative)：开发者只需描述“UI 应该是什么样子”（What），而非“如何更新到该状态”（How）。<em>对比命令式：直接操作 DOM vs. 返回 JSX 描述结构</em></li>
</ul>
<span id="more"></span>

<h3 id="深入原理与面试考点"><a href="#深入原理与面试考点" class="headerlink" title="深入原理与面试考点"></a>深入原理与面试考点</h3><p><strong>组件化背后的核心思想</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">说明</th>
<th align="left">面试举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">封装性</td>
<td align="left">组件内部状态&#x2F;逻辑对外隐藏，仅通过 Props 通信</td>
<td align="left">“为何 React 推荐单向数据流？”</td>
</tr>
<tr>
<td align="left">组合性</td>
<td align="left">通过嵌套组件构建复杂 UI（如 <code>&lt;Form&gt;&lt;Input/&gt;&lt;Button/&gt;&lt;/Form&gt;</code>）</td>
<td align="left">“如何设计可复用的高阶组件？”</td>
</tr>
<tr>
<td align="left">复用性</td>
<td align="left">同一组件在不同场景重复使用</td>
<td align="left">“受控组件与非受控组件适用场景差异？”</td>
</tr>
</tbody></table>
<p><strong>声明式 UI 的底层实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 声明式写法（What）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 对应的命令式逻辑（How）</span><br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  count++;<br>  button.<span class="hljs-property">textContent</span> = count; <span class="hljs-comment">// 需手动更新 DOM</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>关键优势：</p>
<ul>
<li>避免直接操作 DOM → 减少代码复杂度与潜在 Bug</li>
<li>与状态绑定 → UI 自动随状态更新（通过 Virtual DOM 协调）</li>
</ul>
<p><strong>虚拟 DOM (Virtual DOM) 的角色</strong></p>
<pre class="mermaid">graph LR
A[组件状态变化] --> B{生成新 Virtual DOM}
B --> C[对比新旧 Virtual DOM]
C --> D[计算最小 DOM 变更]
D --> E[批量更新真实 DOM]</pre>

<p>设计哲学关联：声明式 UI 依赖 Virtual DOM 实现高效的 “状态到 UI 的映射”，开发者无需关注更新过程。</p>
<h3 id="面试话术技巧"><a href="#面试话术技巧" class="headerlink" title="面试话术技巧"></a>面试话术技巧</h3><p><strong>Q：为什么 React 采用声明式而非命令式？</strong></p>
<p>声明式让代码更专注于业务逻辑的描述（What），将底层 DOM 操作交给 React 的 Virtual DOM 协调机制处理。这带来三方面优势：</p>
<ol>
<li>可维护性：状态变化自动触发 UI 更新，避免手动 DOM 操作导致的逻辑分散</li>
<li>性能优化：React 通过 Diff 算法批量 DOM 更新，减少重绘开销</li>
<li>开发体验：更接近自然思维模式的 UI 构建方式，提升开发效率”</li>
</ol>
<h3 id="延伸考点"><a href="#延伸考点" class="headerlink" title="延伸考点"></a>延伸考点</h3><ul>
<li>JSX 的本质：声明式 UI 的语法糖（编译为 React.createElement()）</li>
<li>组件化与设计模式：复合组件 (Compound Components)、容器&#x2F;展示组件等</li>
</ul>
<h2 id="1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）"><a href="#1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）" class="headerlink" title="1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）"></a>1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）</h2><h3 id="基础概念简述"><a href="#基础概念简述" class="headerlink" title="基础概念简述"></a>基础概念简述</h3><p><strong>JSX 是什么？</strong></p>
<p>JavaScript 语法扩展，允许在 JavaScript 中编写类似 HTML 的结构（语法糖）</p>
<p><strong>三大核心功能</strong></p>
<ul>
<li>表达式嵌入：{ } 包裹任意 JavaScript 表达式</li>
<li>条件渲染：三元运算符 ? : 或 &amp;&amp; 短路运算</li>
<li>列表渲染：map() + key 属性生成元素列表</li>
</ul>
<h3 id="核心机制与深度原理"><a href="#核心机制与深度原理" class="headerlink" title="核心机制与深度原理"></a>核心机制与深度原理</h3><p><strong>JSX 编译原理（Babel 转换过程）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始 JSX</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>Hello &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><br><span class="hljs-comment">// Babel 编译后（React 17+ 无需显式引入 React）</span><br><span class="hljs-keyword">import</span> &#123; jsx <span class="hljs-keyword">as</span> _jsx &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react/jsx-runtime&quot;</span>;<br><span class="hljs-keyword">const</span> element = <span class="hljs-title function_">_jsx</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>  <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;container&quot;</span>,<br>  <span class="hljs-attr">children</span>: [<span class="hljs-string">&quot;Hello &quot;</span>, name]<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>关键点：</p>
<ul>
<li>JSX 本质是 React.createElement(type, props, children) 的语法糖</li>
<li>每个 JSX 元素会被编译为 虚拟 DOM 对象（包含 type, props, key 等属性）</li>
</ul>
<p><strong>表达式嵌入的运行时机制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 表达式执行发生在组件 render 阶段</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>当前用户: &#123;props.user ?? &#x27;游客&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>表达式内不能使用语句（如 if&#x2F;for）</li>
<li>表达式结果类型自动转换：<ul>
<li>undefined&#x2F;null&#x2F;true&#x2F;false → 不渲染</li>
<li>数组 → 展开渲染（需包含有效元素）</li>
<li>对象 → 抛出错误（除特殊对象如 ReactElement）</li>
</ul>
</li>
</ul>
<p><strong>条件渲染的底层实现策略</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：三元表达式（适合简单分支）</span><br>&#123; isLoggedIn ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> /&gt;</span></span> &#125;<br><br><span class="hljs-comment">// 方案2：&amp;&amp; 短路（适合单分支）</span><br>&#123; hasUnread &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Badge</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;unreadCount&#125;</span> /&gt;</span></span> &#125;<br><br><span class="hljs-comment">// 方案3：立即执行函数（复杂逻辑 - 不推荐）</span><br>&#123; (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (conditionA) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span>;<br>    <span class="hljs-keyword">if</span> (conditionB) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fallback</span> /&gt;</span></span>;<br>  &#125;)() <br>&#125;<br></code></pre></td></tr></table></figure>

<p>性能优化：条件变化时，React 通过 Diff 算法 复用相同子组件（按组件位置比对）</p>
<p><strong>列表渲染的 key 机制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> todoItems = todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span>  // ⭐ 关键点：key 必须是稳定唯一标识</span><br><span class="language-xml">    &#123;todo.text&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure>

<p>无 key 的隐患：</p>
<ul>
<li>列表顺序变化时引发组件状态错乱（如输入框内容错位）</li>
<li>性能下降：全量比对子元素（时间复杂度 O(n²)）</li>
</ul>
<h3 id="高频面试题与破解技巧"><a href="#高频面试题与破解技巧" class="headerlink" title="高频面试题与破解技巧"></a>高频面试题与破解技巧</h3><p><strong>Q：为什么 JSX 中 <code>&#123;boolean &amp;&amp; &lt;Component/&gt;&#125;</code> 可能渲染 0？</strong></p>
<p>true &amp;&amp; jsx 返回 jsx，但 false &amp;&amp; jsx 返回 false → React 将 false 渲染为空白占位符（类似 null），导致 DOM 中出现空文本节点。</p>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换为 null 避免空节点</span><br>&#123; shouldRender &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span> || <span class="hljs-literal">null</span> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>Q：列表渲染为什么不能用 index 作为 key？</strong></p>
<p>当列表发生增删或排序时：</p>
<ul>
<li>index 变化导致组件被意外销毁重建（状态丢失）</li>
<li>Diff 算法无法准确定位节点变化</li>
<li>正确做法：使用数据唯一 ID（如 todo.id）</li>
</ul>
<p><strong>Q：JSX 如何防止 XSS 攻击？</strong></p>
<p>JSX 在执行表达式插入时自动进行转义处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> title = <span class="hljs-string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> <br><span class="hljs-comment">// 渲染为：&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</span><br></code></pre></td></tr></table></figure>

<p>例外：dangerouslySetInnerHTML 需手动防范</p>
<h2 id="1-3-组件基础（函数组件-vs-类组件）"><a href="#1-3-组件基础（函数组件-vs-类组件）" class="headerlink" title="1.3 组件基础（函数组件 vs. 类组件）"></a>1.3 组件基础（函数组件 vs. 类组件）</h2><h3 id="基础概念概述-1"><a href="#基础概念概述-1" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">函数组件</th>
<th align="left">类组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义方式</td>
<td align="left">JavaScript 函数</td>
<td align="left">ES6 class 继承 React.Component</td>
</tr>
<tr>
<td align="left">状态管理</td>
<td align="left">useState Hook (React 16.8+)</td>
<td align="left">this.state + setState</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td align="left">useEffect Hook</td>
<td align="left">生命周期方法（componentDidMount等）</td>
</tr>
<tr>
<td align="left">代码量</td>
<td align="left">更简洁</td>
<td align="left">相对冗长</td>
</tr>
<tr>
<td align="left">推荐场景</td>
<td align="left">现代 React 开发首选</td>
<td align="left">遗留项目或需要 Error Boundaries 时</td>
</tr>
</tbody></table>
<h3 id="核心机制与差异深度解析"><a href="#核心机制与差异深度解析" class="headerlink" title="核心机制与差异深度解析"></a>核心机制与差异深度解析</h3><p><strong>渲染逻辑本质区别</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 函数组件：纯函数执行</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 类组件：实例化后调用 render 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键差异：</p>
<ul>
<li>函数组件：直接返回 JSX，每次渲染都是独立函数调用</li>
<li>类组件：通过 实例化 → 调用 render() 返回 JSX，实例在更新间保持</li>
</ul>
<p><strong>状态管理的底层实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 函数组件：闭包存储状态（Hook 链表结构）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <br>  <span class="hljs-comment">// React 内部通过顺序索引关联状态</span><br>&#125;<br><br><span class="hljs-comment">// 类组件：实例属性存储状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>状态更新差异：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">函数组件</th>
<th align="left">类组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">更新机制</td>
<td align="left">闭包捕获当次渲染状态</td>
<td align="left">始终读取最新 this.state</td>
</tr>
<tr>
<td align="left">批处理</td>
<td align="left">自动批处理（React 18+）</td>
<td align="left">需 unstable_batchedUpdates</td>
</tr>
<tr>
<td align="left">异步性</td>
<td align="left">状态更新队列</td>
<td align="left">setState 合并更新</td>
</tr>
</tbody></table>
<p><strong>生命周期映射关系</strong></p>
<pre class="mermaid">graph TD
  A[类组件生命周期] --> B[componentDidMount]
  A --> C[componentDidUpdate]
  A --> D[componentWillUnmount]
  
  E[函数组件等效实现] --> F["useEffect(() => {}, [])"]
  E --> G["useEffect(() => {}, [deps])"]
  E --> H["useEffect(() => { return () => {} }, [])"]
  
  B -->|挂载后执行| F
  C -->|依赖更新后执行| G
  D -->|卸载前清理| H</pre>

<p>关键差异点：</p>
<ul>
<li>类组件：生命周期方法分散定义，逻辑易割裂，componentDidMount&#x2F;Update 在 浏览器绘制后 执行</li>
<li>函数组件：useEffect 集中处理副作用，通过依赖数组控制执行时机，useEffect 在 浏览器绘制前 异步执行（使用 useLayoutEffect 可模拟同步行为）</li>
</ul>
<h3 id="高频面试题与破解技巧-1"><a href="#高频面试题与破解技巧-1" class="headerlink" title="高频面试题与破解技巧"></a>高频面试题与破解技巧</h3><p><strong>Q：为什么函数组件取代了类组件成为主流？</strong></p>
<ul>
<li>代码简洁性：减少约 30% 代码量（无 class&#x2F;this&#x2F;constructor）</li>
<li>逻辑复用优势：自定义 Hook 比 HOC&#x2F;Render Props 更直观</li>
<li>性能优化：避免类组件实例化开销，Hook 依赖数组精准控制更新</li>
<li>未来兼容：React 新特性（Concurrent Features）优先支持函数组件</li>
</ul>
<p><strong>Q：函数组件如何实现类似 forceUpdate 的功能？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [_, forceUpdate] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 调用 forceUpdate() 触发重渲染</span><br></code></pre></td></tr></table></figure>

<p>原理：通过修改无关状态强制触发更新</p>
<p><strong>Q：类组件中 setState 是同步还是异步？</strong></p>
<ul>
<li>React 17 及之前：合成事件&#x2F;生命周期中异步，setTimeout 中同步</li>
<li>React 18+：默认全部异步（自动批处理）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 获取更新后状态的正确方式</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">42</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新后：&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// 回调函数保证</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="1-4-Props-与-State（数据流、单向数据绑定）"><a href="#1-4-Props-与-State（数据流、单向数据绑定）" class="headerlink" title="1.4 Props 与 State（数据流、单向数据绑定）"></a>1.4 Props 与 State（数据流、单向数据绑定）</h2><h3 id="基础概念对比表"><a href="#基础概念对比表" class="headerlink" title="基础概念对比表"></a>基础概念对比表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Props</th>
<th align="left">State</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td align="left">组件外部传入的数据</td>
<td align="left">组件内部管理的状态</td>
</tr>
<tr>
<td align="left">可变性</td>
<td align="left">只读（Immutable）</td>
<td align="left">可修改（通过 setState&#x2F;useState）</td>
</tr>
<tr>
<td align="left">数据源</td>
<td align="left">父组件传递</td>
<td align="left">组件自身创建</td>
</tr>
<tr>
<td align="left">更新触发</td>
<td align="left">父组件重渲染</td>
<td align="left">调用状态更新函数</td>
</tr>
<tr>
<td align="left">通信方向</td>
<td align="left">父 → 子</td>
<td align="left">组件内部</td>
</tr>
</tbody></table>
<h3 id="核心机制深度解析"><a href="#核心机制深度解析" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>单向数据流（Unidirectional Data Flow）</strong></p>
<pre class="mermaid">graph LR
A[父组件] -- Props --> B[子组件1]
A -- Props --> C[子组件2]
B -- Props --> D[孙子组件]
C -- Props --> E[孙子组件]</pre>

<p>核心规则：</p>
<ul>
<li>数据只能从父组件流向子组件，禁止反向流动</li>
<li>子组件修改父组件数据需通过回调函数实现：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setValue&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; value, onChange &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> onChange(e.target.value)&#125; /&gt;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Props 的不可变性（Immutability）</strong></p>
<p>底层原理：</p>
<ul>
<li>React 使用 Object.is 算法进行 props 浅比较（shallow compare）</li>
<li>若检测到 props 引用变化，则触发子组件重渲染</li>
</ul>
<p>开发约束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 禁止直接修改 props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserCard</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Hacked&quot;</span>;  <span class="hljs-comment">// 违反不可变性原则</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 正确做法：使用派生数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserCard</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> displayName = user.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();  <span class="hljs-comment">// 创建新值</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;displayName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>State 更新机制</strong></p>
<p>(1) 类组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 批量更新：多次 setState 合并为一次更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>    <span class="hljs-comment">// 结果：count 只 +1（使用对象形式）</span><br>    <br>    <span class="hljs-comment">// 函数形式解决连续更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br>    <span class="hljs-comment">// 结果：count +2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 函数组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 闭包捕获当前 count 值</span><br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 仍基于初始值计算</span><br>    <br>    <span class="hljs-comment">// 函数形式获取最新值</span><br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 正确 +2</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案"><a href="#高频面试题与破解方案" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么React强调Props不可变？</strong></p>
<ul>
<li>可预测性：确保组件行为只取决于输入的props，便于调试</li>
<li>性能优化：浅比较依赖引用不变性（若直接修改，浅比较无法检测变化）</li>
<li>并发安全：避免数据在渲染过程中被意外修改</li>
</ul>
<p><strong>Q：如何实现子组件向父组件通信？</strong></p>
<p>设计模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-comment">// 回调函数作为prop传递</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildSubmit</span> = (<span class="hljs-params">childData</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setData</span>(childData);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleChildSubmit&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; onSubmit &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [input, setInput] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;input&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setInput(e.target.value)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onSubmit(input)&#125;&gt;提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Q：什么时候该用Props vs State？</strong></p>
<p>决策过程：</p>
<pre class="mermaid">graph TD
A[数据来源] -->|父组件传递| B[用Props]
A -->|组件自身管理| C[用State]
D[是否随时间/交互变化] -->|否| E[用Props]
D -->|是| F[用State]</pre>

<h3 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h3><p><strong>状态提升（Lifting State Up）</strong></p>
<p>场景：多个组件需要共享同一状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 状态提升到共同父组件</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> <span class="hljs-attr">onThemeChange</span>=<span class="hljs-string">&#123;setTheme&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ContentArea</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 子组件通过props获取/更新状态</span><br></code></pre></td></tr></table></figure>

<h3 id="性能优化陷阱"><a href="#性能优化陷阱" class="headerlink" title="性能优化陷阱"></a>性能优化陷阱</h3><p><strong>Props 穿透问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 不必要重渲染：直接传递对象</span><br>&lt;<span class="hljs-title class_">Child</span> user=&#123;user&#125; /&gt;<br><br><span class="hljs-comment">// ✅ 解决方案：扁平化props或React.memo</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;user.name&#125;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;user.age&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><strong>状态位置错误导致的渲染风暴</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 状态放在过高层级</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 任何更新触发全应用重渲染</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// ✅ 状态下沉到最小范围</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 影响范围局部化</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c+1)&#125;&gt;&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-5-事件处理（合成事件、this-绑定问题）"><a href="#1-5-事件处理（合成事件、this-绑定问题）" class="headerlink" title="1.5 事件处理（合成事件、this 绑定问题）"></a>1.5 事件处理（合成事件、this 绑定问题）</h2><h3 id="基础概念概述-2"><a href="#基础概念概述-2" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>React 事件处理特点：</p>
<ul>
<li>驼峰命名：onClick 而非 onclick</li>
<li>JSX 中传入函数引用而非字符串</li>
<li>默认阻止默认行为需显式调用 e.preventDefault()</li>
</ul>
<p>两大核心问题：</p>
<ul>
<li>合成事件（SyntheticEvent）机制</li>
<li>类组件中的 this 绑定问题</li>
</ul>
<h3 id="合成事件（SyntheticEvent）深度解析"><a href="#合成事件（SyntheticEvent）深度解析" class="headerlink" title="合成事件（SyntheticEvent）深度解析"></a>合成事件（SyntheticEvent）深度解析</h3><p><strong>设计目的与原理</strong></p>
<pre class="mermaid">graph LR
A[浏览器原生事件] --> B(React事件系统)
B --> C[创建合成事件对象]
C --> D[事件委托到根容器]
D --> E[触发对应组件处理函数]
E --> F[事件池回收]</pre>

<p>核心特性：</p>
<ul>
<li>跨浏览器兼容：统一不同浏览器事件接口</li>
<li>性能优化：事件委托 + 事件池复用（React 17 前）</li>
<li>冒泡机制：基于虚拟DOM树而非实际DOM树</li>
</ul>
<p><strong>事件池机制（React 17 前）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// 正常访问</span><br>  <br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// ❌ React 17前：null（事件对象已被回收）</span><br>  &#125;, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 解决方案：e.persist() 保留事件对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>React 17+ 改进：移除了事件池，无需 e.persist()</p>
<p><strong>合成事件与原生事件差异</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">合成事件</th>
<th align="left">原生事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事件注册</td>
<td align="left">onClick</td>
<td align="left">addEventListener</td>
</tr>
<tr>
<td align="left">事件对象</td>
<td align="left">SyntheticEvent</td>
<td align="left">原生 Event 对象</td>
</tr>
<tr>
<td align="left">事件传播</td>
<td align="left">虚拟DOM树冒泡</td>
<td align="left">实际DOM树冒泡</td>
</tr>
<tr>
<td align="left">阻止冒泡</td>
<td align="left">e.stopPropagation()</td>
<td align="left">同名API</td>
</tr>
<tr>
<td align="left">事件委托</td>
<td align="left">自动委托到根容器</td>
<td align="left">需手动委托</td>
</tr>
</tbody></table>
<h3 id="this-绑定问题详解（类组件）"><a href="#this-绑定问题详解（类组件）" class="headerlink" title="this 绑定问题详解（类组件）"></a>this 绑定问题详解（类组件）</h3><p><strong>问题根源</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ❌ 此时 this 为 undefined（严格模式）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>); <br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因：JavaScript 函数中的 this 由调用方式决定，非类实例本身</p>
<p><strong>四种解决方案对比</strong></p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">代码示例</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">构造函数绑定</td>
<td align="left">this.handleClick &#x3D; this.handleClick.bind(this)</td>
<td align="left">标准做法</td>
<td align="left">代码冗余</td>
</tr>
<tr>
<td align="left">箭头函数（类属性）</td>
<td align="left">handleClick &#x3D; () &#x3D;&gt; {…}</td>
<td align="left">简洁，推荐方案</td>
<td align="left">实验性语法（需Babel）</td>
</tr>
<tr>
<td align="left">内联箭头函数</td>
<td align="left">onClick&#x3D;{() &#x3D;&gt; this.handleClick()}</td>
<td align="left">简单直接</td>
<td align="left">每次渲染创建新函数</td>
</tr>
<tr>
<td align="left">bind 内联</td>
<td align="left">onClick&#x3D;{this.handleClick.bind(this)}</td>
<td align="left">无额外代码</td>
<td align="left">同内联箭头函数</td>
</tr>
</tbody></table>
<p><strong>性能优化关键点</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 避免内联绑定（每次渲染创建新函数）</span><br>&lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(id)&#125;&gt;点击&lt;/button&gt;<br><br><span class="hljs-comment">// ✅ 推荐：构造函数预绑定</span><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// ✅ 或使用类属性箭头函数</span><br>handleClick = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与解决方案"><a href="#高频面试题与解决方案" class="headerlink" title="高频面试题与解决方案"></a>高频面试题与解决方案</h3><p><strong>Q：为什么React不直接使用原生事件？</strong></p>
<ul>
<li>跨浏览器兼容：统一事件处理逻辑</li>
<li>性能优化：事件委托减少内存占用</li>
<li>事件池机制：复用事件对象（React 17前）</li>
<li>框架扩展性：为异步渲染等特性铺平道路</li>
</ul>
<p><strong>Q：如何阻止合成事件的默认行为？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// ✅ 显式阻止表单提交</span><br>    <span class="hljs-comment">// 处理逻辑...</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Q：合成事件和原生事件混用时要注意什么？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleDocumentClick</span>);<br>&#125;<br><br>handleDocumentClick = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 原生事件</span><br>&#125;;<br><br>handleButtonClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 合成事件</span><br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// ❌ 无法阻止原生事件冒泡</span><br>&#125;;<br><br><span class="hljs-comment">// ✅ 正确方案：在原生事件中使用 nativeEvent</span><br>handleButtonClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopImmediatePropagation</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="React-17-事件系统升级"><a href="#React-17-事件系统升级" class="headerlink" title="React 17+ 事件系统升级"></a>React 17+ 事件系统升级</h3><ul>
<li>委托目标变更：从 document 到 ReactDOM.render 的根容器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 16：委托到 document</span><br><span class="hljs-comment">// React 17+：委托到 root DOM 容器</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>移除事件池：无需 e.persist() 可异步访问事件对象</li>
<li>更接近原生：e.stopPropagation() 真正阻止原生事件传播</li>
</ul>
<h1 id="第二章：React-核心机制"><a href="#第二章：React-核心机制" class="headerlink" title="第二章：React 核心机制"></a>第二章：React 核心机制</h1><h2 id="2-1-虚拟-DOM-与-Diff-算法（Reconciliation）"><a href="#2-1-虚拟-DOM-与-Diff-算法（Reconciliation）" class="headerlink" title="2.1 虚拟 DOM 与 Diff 算法（Reconciliation）"></a>2.1 虚拟 DOM 与 Diff 算法（Reconciliation）</h2><h3 id="基础概念概述-3"><a href="#基础概念概述-3" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><ul>
<li>虚拟 DOM (Virtual DOM)：<ul>
<li>JavaScript 对象表示的 DOM 副本</li>
<li>轻量化的内存数据结构</li>
<li>与实际 DOM 结构一一对应</li>
</ul>
</li>
<li>Diff 算法 (Reconciliation)：<ul>
<li>React 比较新旧虚拟 DOM 差异的算法</li>
<li>时间复杂度优化到 O(n)</li>
<li>生成最小化 DOM 操作指令</li>
</ul>
</li>
</ul>
<h3 id="虚拟-DOM-核心原理"><a href="#虚拟-DOM-核心原理" class="headerlink" title="虚拟 DOM 核心原理"></a>虚拟 DOM 核心原理</h3><p><strong>虚拟 DOM 结构示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 实际 JSX</span><br>&lt;div className=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Hello React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-comment">// 对应的虚拟 DOM 对象</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;container&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,<br>      <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello React&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">List</span>,  <span class="hljs-comment">// 组件类型</span><br>      <span class="hljs-attr">props</span>: &#123; items &#125;,<br>      <span class="hljs-comment">// ... 内部有独立虚拟 DOM 树</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>虚拟 DOM 工作流程</strong></p>
<pre class="mermaid">graph LR
A[组件状态变化] --> B[创建新虚拟 DOM 树]
B --> C[Diff 算法比较新旧树]
C --> D[生成 DOM 补丁包]
D --> E[批量更新真实 DOM]</pre>

<p><strong>虚拟 DOM 性能优势</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">直接操作 DOM</th>
<th align="left">虚拟 DOM 方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">更新 10 节点</td>
<td align="left">10 次 DOM 操作</td>
<td align="left">1 次 Diff + 1 次更新</td>
</tr>
<tr>
<td align="left">跨平台能力</td>
<td align="left">依赖浏览器 API</td>
<td align="left">抽象渲染层</td>
</tr>
<tr>
<td align="left">复杂更新</td>
<td align="left">手动优化难度大</td>
<td align="left">自动批量处理</td>
</tr>
</tbody></table>
<h3 id="Diff-算法深度解析（O-n-优化策略）"><a href="#Diff-算法深度解析（O-n-优化策略）" class="headerlink" title="Diff 算法深度解析（O(n) 优化策略）"></a>Diff 算法深度解析（O(n) 优化策略）</h3><p><strong>算法三大设计原则</strong></p>
<p>(1) 同级比较：只比较同一层级的节点，不跨级比较</p>
<pre class="mermaid">graph TD
A[旧树] --> B[节点A]
A --> C[节点B]
D[新树] --> E[节点A']
D --> F[节点B']
B -->|比较| E
C -->|比较| F</pre>

<p>(2) 类型差异直接替换：节点类型不同时直接卸载整棵子树</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 旧：&lt;div&gt;&lt;ComponentA /&gt;&lt;/div&gt;</span><br><span class="hljs-comment">// 新：&lt;span&gt;&lt;ComponentB /&gt;&lt;/span&gt;</span><br><span class="hljs-comment">// React 操作：卸载整个 div 及子组件，创建 span 和 ComponentB</span><br></code></pre></td></tr></table></figure>

<p>(3) Key 属性优化列表：列表项使用 key 标识身份，减少节点移动开销</p>
<p><strong>列表 Diff 的 key 机制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 旧列表</span><br>&lt;ul&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><br><span class="hljs-comment">// 新列表（删除B，新增D）</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>Diff 过程：</p>
<ul>
<li>通过 key 匹配新旧节点：a→a, c→c</li>
<li>删除 key&#x3D;”b” 的节点</li>
<li>新增 key&#x3D;”d” 的节点</li>
<li>复用 key&#x3D;”a” 和 “c” 的节点</li>
</ul>
<p><strong>节点复用策略</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">操作</th>
<th align="left">性能影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">相同类型 DOM 元素</td>
<td align="left">更新属性</td>
<td align="left">高效</td>
</tr>
<tr>
<td align="left">相同类型组件元素</td>
<td align="left">触发更新（不卸载）</td>
<td align="left">保留组件状态</td>
</tr>
<tr>
<td align="left">不同类型元素</td>
<td align="left">卸载整棵子树</td>
<td align="left">成本较高</td>
</tr>
</tbody></table>
<h3 id="React-Fiber-架构与可中断渲染"><a href="#React-Fiber-架构与可中断渲染" class="headerlink" title="React Fiber 架构与可中断渲染"></a>React Fiber 架构与可中断渲染</h3><p><strong>传统 Diff 算法局限</strong></p>
<ul>
<li>递归遍历：无法中断长时间任务</li>
<li>阻塞主线程：导致动画卡顿</li>
</ul>
<p><strong>Fiber 架构核心改进</strong></p>
<pre class="mermaid">graph LR
A[同步递归] --> B[可中断异步任务]
C[虚拟DOM树] --> D[Fiber链表结构]</pre>

<p>Fiber 节点结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,          <span class="hljs-comment">// 节点类型</span><br>  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>,            <span class="hljs-comment">// 唯一标识</span><br>  <span class="hljs-attr">return</span>: parentFiber,  <span class="hljs-comment">// 父节点</span><br>  <span class="hljs-attr">child</span>: firstChild,    <span class="hljs-comment">// 第一个子节点</span><br>  <span class="hljs-attr">sibling</span>: nextSibling, <span class="hljs-comment">// 兄弟节点</span><br>  <span class="hljs-attr">alternate</span>: oldFiber,  <span class="hljs-comment">// 指向旧树对应节点</span><br>  <span class="hljs-attr">effectTag</span>: <span class="hljs-string">&#x27;UPDATE&#x27;</span>,  <span class="hljs-comment">// 需要执行的副作用</span><br>  <span class="hljs-comment">// ... 其他元数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>双缓存机制（Current 树与 WorkInProgress 树）</strong></p>
<pre class="mermaid">graph LR
A[当前显示] -->|Current 树| B[用户界面]
C[正在构建] -->|WorkInProgress 树| D[内存中]
B -->|渲染完成| C</pre>

<ul>
<li>无闪烁更新：直接切换树引用</li>
<li>安全回滚：中断时丢弃未完成树</li>
</ul>
<h3 id="高频面试题与破解方案-1"><a href="#高频面试题与破解方案-1" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么列表渲染需要 key？key 可以随机数吗？</strong></p>
<ul>
<li>key 帮助 React 识别元素身份，减少不必要的销毁&#x2F;重建</li>
<li>禁止使用随机数：每次渲染 key 变化导致全量重建</li>
<li>推荐方案：稳定 ID（如数据 id）或索引（仅静态列表）</li>
</ul>
<p><strong>Q：虚拟 DOM 一定比直接操作 DOM 快吗？</strong></p>
<p>辩证回答：</p>
<ul>
<li>初始渲染：虚拟 DOM 需要额外创建对象，稍慢</li>
<li>复杂更新：虚拟 DOM 通过 Diff 减少操作次数，更快</li>
<li>综合优势：<ul>
<li>跨平台能力（React Native）</li>
<li>声明式编程体验</li>
<li>自动批处理优化</li>
</ul>
</li>
</ul>
<p><strong>Q：React 如何实现 O(n) 复杂度的 Diff？</strong></p>
<p>算法原理：</p>
<ul>
<li>仅同层比较（深度优先遍历）</li>
<li>类型不同时跳过子树比较</li>
<li>列表使用 key 匹配减少移动开销</li>
</ul>
<h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><p><strong>避免不必要节点变动</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 每次渲染创建新对象（导致子组件重渲染）</span><br>&lt;<span class="hljs-title class_">Child</span> style=&#123;&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;&#125; /&gt;<br><br><span class="hljs-comment">// ✅ 提取静态对象</span><br><span class="hljs-keyword">const</span> staticStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;staticStyle&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><strong>列表渲染优化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 索引作为 key（列表变化时状态错乱）</span><br>&#123;todos.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span><br>)&#125;<br><br><span class="hljs-comment">// ✅ 稳定 ID 作为 key</span><br>&#123;todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span><br>)&#125;<br></code></pre></td></tr></table></figure>

<p><strong>组件树结构优化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 深层嵌套导致 Diff 范围大</span><br>&lt;<span class="hljs-title class_">App</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span>&gt;</span>  // 状态变化影响整个 Header</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPanel</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">App</span>&gt;<br><br><span class="hljs-comment">// ✅ 状态下沉 + 组件提权</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span>&gt;</span>   // 独立更新</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserPanel</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="React-18-并发渲染优化"><a href="#React-18-并发渲染优化" class="headerlink" title="React 18 并发渲染优化"></a>React 18 并发渲染优化</h3><p><strong>可中断渲染</strong></p>
<pre class="mermaid">graph LR
A[高优先级更新] --> B[中断当前渲染]
B --> C[执行紧急任务]
C --> D[恢复渲染]</pre>

<p><strong>自动批处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 17：仅事件处理函数内批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 两次独立更新</span><br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// React 18：所有更新自动批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 合并为一次更新</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>);<br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<h2 id="2-2-生命周期（类组件生命周期、useEffect-替代方案）"><a href="#2-2-生命周期（类组件生命周期、useEffect-替代方案）" class="headerlink" title="2.2 生命周期（类组件生命周期、useEffect 替代方案）"></a>2.2 生命周期（类组件生命周期、useEffect 替代方案）</h2><h3 id="类组件生命周期全景图"><a href="#类组件生命周期全景图" class="headerlink" title="类组件生命周期全景图"></a>类组件生命周期全景图</h3><pre class="mermaid">graph TD
  A[挂载阶段] --> B[constructor]
  B --> C[static getDerivedStateFromProps]
  C --> D[render]
  D --> E[componentDidMount]
  
  F[更新阶段] --> G[static getDerivedStateFromProps]
  G --> H[shouldComponentUpdate]
  H --> I[render]
  I --> J[getSnapshotBeforeUpdate]
  J --> K[componentDidUpdate]
  
  L[卸载阶段] --> M[componentWillUnmount]
  
  N[错误处理] --> O[static getDerivedStateFromError]
  O --> P[componentDidCatch]</pre>

<p>各阶段核心方法：</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">方法</th>
<th align="left">执行时机</th>
<th align="left">常见用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">挂载</td>
<td align="left">constructor</td>
<td align="left">组件初始化</td>
<td align="left">初始化 state，绑定 this</td>
</tr>
<tr>
<td align="left">挂载</td>
<td align="left">render</td>
<td align="left">创建虚拟 DOM</td>
<td align="left">返回 JSX 内容</td>
</tr>
<tr>
<td align="left">挂载</td>
<td align="left">componentDidMount</td>
<td align="left">DOM 挂载完成</td>
<td align="left">网络请求、订阅事件</td>
</tr>
<tr>
<td align="left">更新</td>
<td align="left">shouldComponentUpdate</td>
<td align="left">渲染前拦截</td>
<td align="left">性能优化（返回 false 阻止更新）</td>
</tr>
<tr>
<td align="left">更新</td>
<td align="left">getSnapshotBeforeUpdate</td>
<td align="left">DOM 更新前</td>
<td align="left">获取滚动位置等 DOM 信息</td>
</tr>
<tr>
<td align="left">更新</td>
<td align="left">componentDidUpdate</td>
<td align="left">DOM 更新完成</td>
<td align="left">基于新 DOM 操作</td>
</tr>
<tr>
<td align="left">卸载</td>
<td align="left">componentWillUnmount</td>
<td align="left">组件卸载前</td>
<td align="left">清理定时器、取消订阅</td>
</tr>
<tr>
<td align="left">错误</td>
<td align="left">componentDidCatch</td>
<td align="left">子组件抛出错误</td>
<td align="left">错误日志、显示降级 UI</td>
</tr>
</tbody></table>
<h3 id="函数组件-useEffect-替代方案"><a href="#函数组件-useEffect-替代方案" class="headerlink" title="函数组件 useEffect 替代方案"></a>函数组件 useEffect 替代方案</h3><p>生命周期映射关系：</p>
<pre class="mermaid">graph LR
  A[componentDidMount] --> B["useEffect(() => {}, [])"]
  C[componentDidUpdate] --> D["useEffect(() => {}, [deps])"]
  E[componentWillUnmount] --> F["useEffect(() => { return cleanup }, [])"]
  G[shouldComponentUpdate] --> H[React.memo 或 useMemo]</pre>

<h3 id="核心机制深度解析-1"><a href="#核心机制深度解析-1" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>useEffect 执行时机</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">执行阶段</th>
<th align="left">是否阻塞渲染</th>
<th align="left">访问 DOM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">componentDidMount</td>
<td align="left">浏览器绘制后</td>
<td align="left">是</td>
<td align="left">可访问</td>
</tr>
<tr>
<td align="left">componentDidUpdate</td>
<td align="left">浏览器绘制后</td>
<td align="left">是</td>
<td align="left">可访问</td>
</tr>
<tr>
<td align="left">useEffect</td>
<td align="left">浏览器绘制前</td>
<td align="left">否（异步）</td>
<td align="left">可访问（但需注意时机）</td>
</tr>
<tr>
<td align="left">useLayoutEffect</td>
<td align="left">DOM 变更后，绘制前</td>
<td align="left">是（同步）</td>
<td align="left">可访问</td>
</tr>
</tbody></table>
<p><strong>依赖数组精妙之处</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 安全：包含所有依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> total = price * quantity;<br>  <span class="hljs-title function_">setTotal</span>(total);<br>&#125;, [price, quantity]); <br><br><span class="hljs-comment">// ❌ 危险：缺少依赖（使用过期状态）</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> total = price * quantity;<br>  <span class="hljs-title function_">setTotal</span>(total);<br>&#125;, [price]); <span class="hljs-comment">// 缺少 quantity</span><br><br><span class="hljs-comment">// ✅ 解决方案：函数式更新</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setTotal</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> price * quantity);<br>&#125;, [price]); <span class="hljs-comment">// 不再依赖 quantity</span><br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-2"><a href="#高频面试题与破解方案-2" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么 useEffect 可能执行两次？</strong></p>
<p>React 18+ 严格模式行为：</p>
<ul>
<li>开发环境下故意双调用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">StrictMode</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span> &#123;<span class="hljs-comment">/* useEffect 挂载/卸载各执行两次 */</span>&#125;<br>&lt;/<span class="hljs-title class_">React</span>.<span class="hljs-property">StrictMode</span>&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>目的：检测不纯渲染（例如未正确实现清理）</li>
<li>解决方案：确保清理函数完全复原初始状态</li>
</ul>
<p><strong>Q：如何替代 shouldComponentUpdate？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：React.memo 浅比较</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123; ... &#125;);<br><br><span class="hljs-comment">// 方案2：自定义比较</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<br>  <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123; ... &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> prevProps.<span class="hljs-property">id</span> === nextProps.<span class="hljs-property">id</span>; <span class="hljs-comment">// 自定义比较逻辑</span><br>  &#125;<br>);<br><br><span class="hljs-comment">// 方案3：useMemo 控制子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> memoizedChild = <span class="hljs-title function_">useMemo</span>(<br>    <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;complexData&#125;</span> /&gt;</span></span>,<br>    [complexData] <span class="hljs-comment">// 仅 complexData 变化时重建</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;memoizedChild&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Q：getSnapshotBeforeUpdate 如何替代？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span>;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span> - snapshot;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数组件：useLayoutEffect + useRef</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ScrollList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> listRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> lastScrollHeight = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// DOM 更新后，绘制前执行（类似 getSnapshotBeforeUpdate）</span><br>    lastScrollHeight.<span class="hljs-property">current</span> = listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 清理阶段相当于 getSnapshotBeforeUpdate</span><br>      <span class="hljs-keyword">const</span> snapshot = listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span>;<br>      listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollTop</span> += listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span> - lastScrollHeight.<span class="hljs-property">current</span>;<br>    &#125;;<br>  &#125;, [items]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="错误边界（Error-Boundaries）特殊说明"><a href="#错误边界（Error-Boundaries）特殊说明" class="headerlink" title="错误边界（Error Boundaries）特殊说明"></a>错误边界（Error Boundaries）特殊说明</h3><p><strong>类组件专属能力</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) &#123;<br>    <span class="hljs-title function_">logErrorToService</span>(error, info.<span class="hljs-property">componentStack</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span><br>      ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FallbackComponent</span> /&gt;</span></span><br>      : <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>函数组件解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用第三方库 react-error-boundary</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ErrorBoundary</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-error-boundary&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">FallbackComponent</span>=<span class="hljs-string">&#123;ErrorFallback&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UnstableComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-3-受控组件-vs-非受控组件（表单处理）"><a href="#2-3-受控组件-vs-非受控组件（表单处理）" class="headerlink" title="2.3 受控组件 vs. 非受控组件（表单处理）"></a>2.3 受控组件 vs. 非受控组件（表单处理）</h2><h3 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>受控组件</th>
<th>非受控组件</th>
</tr>
</thead>
<tbody><tr>
<td>数据管理</td>
<td>React state 完全控制</td>
<td>DOM 节点自身管理</td>
</tr>
<tr>
<td>值获取</td>
<td>value 属性</td>
<td>ref 访问 DOM 节点</td>
</tr>
<tr>
<td>值更新</td>
<td>onChange 事件 + setState</td>
<td>用户直接输入</td>
</tr>
<tr>
<td>初始化</td>
<td>value 属性</td>
<td>defaultValue&#x2F;defaultChecked</td>
</tr>
<tr>
<td>表单提交</td>
<td>从 state 获取</td>
<td>从 ref 获取</td>
</tr>
<tr>
<td>实时验证</td>
<td>容易实现</td>
<td>需要手动监听事件</td>
</tr>
<tr>
<td>适用场景</td>
<td>复杂表单、即时验证</td>
<td>简单表单、文件上传</td>
</tr>
</tbody></table>
<h3 id="受控组件深度解析"><a href="#受控组件深度解析" class="headerlink" title="受控组件深度解析"></a>受控组件深度解析</h3><p><strong>实现原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ControlledForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 完全控制输入值</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span>       // <span class="hljs-attr">值绑定</span> <span class="hljs-attr">state</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> // <span class="hljs-attr">更新</span> <span class="hljs-attr">state</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>多字段优化模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MultiFieldForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 通用变更处理器</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; name, value &#125; = e.<span class="hljs-property">target</span>;<br>    <span class="hljs-title function_">setFormData</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, [name]: value &#125;));<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;formData.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;formData.email&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>即时验证示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">EmailInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [email, setEmail] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [isValid, setIsValid] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    <span class="hljs-title function_">setEmail</span>(value);<br>    <span class="hljs-title function_">setIsValid</span>(<span class="hljs-regexp">/^[^\s@]+@[^\s@]+\.[^\s@]+$/</span>.<span class="hljs-title function_">test</span>(value)); <span class="hljs-comment">// 实时验证</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;email&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      &#123;!isValid &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>邮箱格式错误<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="非受控组件深度解析"><a href="#非受控组件深度解析" class="headerlink" title="非受控组件深度解析"></a>非受控组件深度解析</h3><p><strong>实现原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UncontrolledForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 提交时获取值</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span>          // <span class="hljs-attr">绑定</span> <span class="hljs-attr">ref</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;初始值&quot;</span>   // <span class="hljs-attr">仅初始值</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>文件上传场景（必须使用非受控）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FileUpload</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fileRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> file = fileRef.<span class="hljs-property">current</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 处理文件...</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;fileRef&#125;</span> /&gt;</span> &#123;/* 无法受控 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第三方库集成</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">RichTextEditor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> editorRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化第三方编辑器</span><br>    <span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyEditor</span>(editorRef.<span class="hljs-property">current</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> editor.<span class="hljs-title function_">destroy</span>();<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;editorRef&#125;</span> /&gt;</span></span>; <span class="hljs-comment">// 非受控管理</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-3"><a href="#高频面试题与破解方案-3" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么文件输入必须用非受控组件？</strong></p>
<ul>
<li>安全限制：浏览器禁止 JavaScript 设置文件输入值（<code>&lt;input type=&quot;file&quot;&gt;</code>）</li>
<li>只读属性：文件路径由用户选择，程序无法控制</li>
<li>数据获取：只能通过 ref.current.files 获取文件对象</li>
</ul>
<p><strong>Q：受控组件相比非受控有何优势？</strong></p>
<ul>
<li>即时验证：每次输入都可触发验证逻辑</li>
<li>条件渲染：基于输入值动态控制其他 UI</li>
<li>状态追溯：完整的状态历史记录</li>
<li>表单重置：轻松实现 reset 功能（setState(‘’)）</li>
</ul>
<p><strong>Q：如何实现表单重置功能？</strong></p>
<p>受控组件方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResettableForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [form, setForm] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setForm</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;); <span class="hljs-comment">// 重置 state</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;form.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;/*...*/&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleReset&#125;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>非受控组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResettableForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> formRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    formRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 调用原生 DOM reset</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;formRef&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleReset&#125;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-组件通信（父子通信、Context-API、事件总线）"><a href="#2-4-组件通信（父子通信、Context-API、事件总线）" class="headerlink" title="2.4 组件通信（父子通信、Context API、事件总线）"></a>2.4 组件通信（父子通信、Context API、事件总线）</h2><h3 id="组件通信方式全景图"><a href="#组件通信方式全景图" class="headerlink" title="组件通信方式全景图"></a>组件通信方式全景图</h3><pre class="mermaid">graph TD
  A[组件通信] --> B[父子组件]
  A --> C[兄弟组件]
  A --> D[祖孙组件]
  A --> E[任意组件]
  
  B --> B1[Props/回调函数]
  C --> C1[状态提升]
  C --> C2[通过共同父组件]
  D --> D1[Context API]
  D --> D2[逐层传递Props]
  E --> E1[事件总线]
  E --> E2[状态管理库]</pre>

<h3 id="父子组件通信（Props-回调）"><a href="#父子组件通信（Props-回调）" class="headerlink" title="父子组件通信（Props + 回调）"></a>父子组件通信（Props + 回调）</h3><p><strong>基础模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildData</span> = (<span class="hljs-params">childData</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setData</span>(childData);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onDataSend</span>=<span class="hljs-string">&#123;handleChildData&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; onDataSend &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onDataSend(&#x27;Hello&#x27;)&#125;&gt;发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>多层透传问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 祖孙组件通信（不推荐）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Grandparent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">&#123; data &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>; <span class="hljs-comment">// 中间层被迫传递</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; data &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>痛点：Props drilling（属性钻探）导致代码冗余</p>
<h3 id="Context-API-深度解析"><a href="#Context-API-深度解析" class="headerlink" title="Context API 深度解析"></a>Context API 深度解析</h3><p><strong>核心三要素</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 创建Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>); <span class="hljs-comment">// 默认值</span><br><br><span class="hljs-comment">// 2. Provider 提供数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;dark&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. Consumer 消费数据（两种方式）</span><br><span class="hljs-comment">// 方式1：useContext Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 方式2：Context.Consumer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;(&#123; theme &#125;) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>性能优化策略</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误写法：直接传递对象</span><br>&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span> value=&#123;&#123; theme, setTheme &#125;&#125;&gt;<br>  ...<br>&lt;/<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// ✅ 正确方案：useMemo 缓存值</span><br><span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; theme, setTheme &#125;), [theme]);<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;contextValue&#125;</span>&gt;</span></span><br><span class="language-xml">    ...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>

<p><strong>多层Context嵌套</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span> value=&#123;user&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">LayoutContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;layout&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">LayoutContext.Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// 消费时自动匹配最近Provider</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>);       <span class="hljs-comment">// 获取user</span><br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);     <span class="hljs-comment">// 获取theme</span><br>  <span class="hljs-keyword">const</span> layout = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">LayoutContext</span>);   <span class="hljs-comment">// 获取layout</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件总线（Event-Bus）模式"><a href="#事件总线（Event-Bus）模式" class="headerlink" title="事件总线（Event Bus）模式"></a>事件总线（Event Bus）模式</h3><p><strong>实现原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// eventBus.js</span><br><span class="hljs-keyword">const</span> events = &#123;&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  $on(eventName, fn) &#123;<br>    events[eventName] = events[eventName] || [];<br>    events[eventName].<span class="hljs-title function_">push</span>(fn);<br>  &#125;,<br>  <br>  $off(eventName, fn) &#123;<br>    <span class="hljs-keyword">if</span> (events[eventName]) &#123;<br>      events[eventName] = events[eventName].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f !== fn);<br>    &#125;<br>  &#125;,<br>  <br>  $emit(eventName, data) &#123;<br>    <span class="hljs-keyword">if</span> (events[eventName]) &#123;<br>      events[eventName].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(data));<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>React 组件中使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组件A（发布事件）</span><br><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    eventBus.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;数据内容&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 组件B（订阅事件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [msg, setMsg] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">data</span>) =&gt; <span class="hljs-title function_">setMsg</span>(data);<br>    eventBus.$on(<span class="hljs-string">&#x27;message&#x27;</span>, handler);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> eventBus.$off(<span class="hljs-string">&#x27;message&#x27;</span>, handler); <span class="hljs-comment">// 清理</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景与风险</strong></p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">跨任意组件通信</td>
<td align="left">破坏组件独立性</td>
<td align="left">微前端架构通信</td>
</tr>
<tr>
<td align="left">解耦性强</td>
<td align="left">难以追踪数据流</td>
<td align="left">非父子组件简单交互</td>
</tr>
<tr>
<td align="left">实现简单</td>
<td align="left">可能内存泄漏（未及时取消订阅）</td>
<td align="left">第三方库事件通知</td>
</tr>
</tbody></table>
<h3 id="高级通信模式"><a href="#高级通信模式" class="headerlink" title="高级通信模式"></a>高级通信模式</h3><p><strong>状态提升 + Context 组合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建共享状态上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SharedStateContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SharedStateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">state</span>, <span class="hljs-attr">setState</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">SharedStateContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 任意子组件消费</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; state, setState &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">SharedStateContext</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Render Props 模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 数据提供者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> &#125;;<br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; data &#125;));<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">children</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>); <span class="hljs-comment">// 关键</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Consumer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DataProvider</span>&gt;</span></span><br><span class="language-xml">      &#123;data =&gt; data ? <span class="hljs-tag">&lt;<span class="hljs-name">ShowData</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DataProvider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>观察者模式（Pub&#x2F;Sub）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用第三方库 (rxjs)</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Subject</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br><span class="hljs-keyword">const</span> message$ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br><br><span class="hljs-comment">// 发布</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">publishMessage</span>(<span class="hljs-params">text</span>) &#123;<br>  message$.<span class="hljs-title function_">next</span>(text);<br>&#125;<br><br><span class="hljs-comment">// 订阅</span><br>message$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息:&#x27;</span>, text);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-4"><a href="#高频面试题与破解方案-4" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q:：Context 与 Redux 如何选择？</strong></p>
<pre class="mermaid">graph TD
A[需要全局状态?] -->|是| B[状态更新频率高?]
A -->|否| C[用Props/状态提升]
B -->|是| D[用Redux/Zustand]
B -->|否| E[用Context API]</pre>

<p>关键区别：</p>
<ul>
<li>Context：轻量级，适合低频更新（主题&#x2F;用户信息）</li>
<li>Redux：重量级，适合高频更新+时间旅行调试</li>
</ul>
<p><strong>Q：如何避免 Context 性能问题？</strong></p>
<ul>
<li>拆分 Context：按业务分离（用户Context&#x2F;主题Context）</li>
<li>使用 React.memo：防止无关组件重渲染</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; nonContextProp &#125;</span>) =&gt;</span> &#123; ... &#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>选择订阅：使用 use-context-selector 库</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useContextSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;use-context-selector&#x27;</span>;<br><span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContextSelector</span>(<span class="hljs-title class_">ThemeContext</span>, <span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> ctx.<span class="hljs-property">theme</span>);<br></code></pre></td></tr></table></figure>

<p><strong>Q：事件总线会导致什么问题？</strong></p>
<ul>
<li>内存泄漏：组件卸载时取消订阅</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;;<br>  bus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, handler);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> bus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;event&#x27;</span>, handler); <span class="hljs-comment">// ✅</span><br>&#125;, []);<br></code></pre></td></tr></table></figure>

<ul>
<li>事件冲突：使用命名空间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">bus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;moduleA:event&#x27;</span>, data);<br></code></pre></td></tr></table></figure>

<ul>
<li>调试困难：添加事件日志</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Event] <span class="hljs-subst">$&#123;event&#125;</span>`</span>, data);<br>  <span class="hljs-comment">// ...原逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-Refs-使用场景（DOM-操作、forwardRef）"><a href="#2-5-Refs-使用场景（DOM-操作、forwardRef）" class="headerlink" title="2.5 Refs 使用场景（DOM 操作、forwardRef）"></a>2.5 Refs 使用场景（DOM 操作、forwardRef）</h2><h3 id="Refs-核心概念全景图"><a href="#Refs-核心概念全景图" class="headerlink" title="Refs 核心概念全景图"></a>Refs 核心概念全景图</h3><pre class="mermaid">graph TD
  A[Refs 类型] --> B[对象 Ref]
  A --> C[回调 Ref]
  A --> D[函数组件 useRef]
  
  E[使用场景] --> F[访问 DOM 节点]
  E --> G[访问类组件实例]
  E --> H[存储可变值]
  E --> I[集成第三方库]
  
  J[高级特性] --> K[forwardRef 转发]
  J --> L[useImperativeHandle 暴露方法]</pre>

<h3 id="三大-Refs-创建方式"><a href="#三大-Refs-创建方式" class="headerlink" title="三大 Refs 创建方式"></a>三大 Refs 创建方式</h3><p><strong>对象 Ref（类组件）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFocusInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  inputRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();  <span class="hljs-comment">// 创建 Ref 对象</span><br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 访问 DOM 节点</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.inputRef&#125;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>回调 Ref（动态场景）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  setRef = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (element) &#123;<br>      element.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 元素挂载时执行</span><br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.setRef&#125;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>useRef Hook（函数组件）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FocusInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 创建 Ref</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 挂载后聚焦</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="核心使用场景深度解析"><a href="#核心使用场景深度解析" class="headerlink" title="核心使用场景深度解析"></a>核心使用场景深度解析</h3><p><strong>DOM 操作（核心场景）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> videoRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">play</span> = (<span class="hljs-params"></span>) =&gt; videoRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">pause</span> = (<span class="hljs-params"></span>) =&gt; videoRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;videoRef&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;play&#125;</span>&gt;</span>播放<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;pause&#125;</span>&gt;</span>暂停<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>存储可变值（不触发重渲染）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> intervalRef = <span class="hljs-title function_">useRef</span>();  <span class="hljs-comment">// 存储计时器 ID</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    intervalRef.<span class="hljs-property">current</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>);<br>  &#125;, []);<br>  <br>  <span class="hljs-comment">// 停止计时器（不依赖 state）</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stop</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;count&#125; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>停止<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>类组件方法调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 子组件（类组件）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  play = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">audio</span>.<span class="hljs-title function_">play</span>();<br>  pause = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">audio</span>.<span class="hljs-title function_">pause</span>();<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;el</span> =&gt;</span> this.audio = el&#125; /&gt;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> playerRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AudioPlayer</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;playerRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> playerRef.current.play()&#125;&gt;播放<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第三方库集成</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChartContainer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> chartRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> chartInstance = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化图表</span><br>    chartInstance.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyChart</span>(chartRef.<span class="hljs-property">current</span>, data);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> chartInstance.<span class="hljs-property">current</span>.<span class="hljs-title function_">destroy</span>();  <span class="hljs-comment">// 清理</span><br>  &#125;, [data]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;chartRef&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">400px</span>&#x27; &#125;&#125; /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="forwardRef-转发机制"><a href="#forwardRef-转发机制" class="headerlink" title="forwardRef 转发机制"></a>forwardRef 转发机制</h3><p><strong>问题背景：函数组件不能直接使用 ref</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误用法：函数组件无实例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyInput</span> = (<span class="hljs-params">&#123; value &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-comment">// 无效！inputRef.current 将为 null</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>forwardRef 解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// ✅ 现在可以操作 DOM</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>转发多个 ref</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MultiInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> input1Ref = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> input2Ref = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-comment">// 合并 ref 到父组件</span><br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focusFirst</span>: <span class="hljs-function">() =&gt;</span> input1Ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>(),<br>    <span class="hljs-attr">focusSecond</span>: <span class="hljs-function">() =&gt;</span> input2Ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;));<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;input1Ref&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;input2Ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-comment">// 父组件使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputsRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MultiInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputsRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> inputsRef.current.focusFirst()&#125;&gt;聚焦输入1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useImperativeHandle-高级用法"><a href="#useImperativeHandle-高级用法" class="headerlink" title="useImperativeHandle 高级用法"></a>useImperativeHandle 高级用法</h3><p><strong>暴露自定义方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-comment">// 暴露特定方法</span><br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;,<br>    <span class="hljs-attr">scrollIntoView</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;,<br>    <span class="hljs-comment">// 限制访问 DOM 节点</span><br>    <span class="hljs-attr">getValue</span>: <span class="hljs-function">() =&gt;</span> inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span><br>  &#125;));<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FancyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> inputRef.current.focus()&#125;&gt;聚焦<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> console.log(inputRef.current.getValue())&#125;&gt;获取值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>依赖项控制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-comment">// 当 value 变化时更新方法</span><br>  <span class="hljs-attr">getValue</span>: <span class="hljs-function">() =&gt;</span> inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span><br>&#125;), [props.<span class="hljs-property">value</span>]);  <span class="hljs-comment">// 依赖项数组</span><br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-5"><a href="#高频面试题与破解方案-5" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么函数组件默认不能使用 ref？</strong></p>
<ul>
<li>函数组件无实例，ref 无法指向组件对象</li>
<li>React 设计哲学：避免直接操作子组件</li>
<li>解决方案：forwardRef + useImperativeHandle</li>
</ul>
<p><strong>Q：useRef 和 useState 有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useRef</th>
<th align="left">useState</th>
</tr>
</thead>
<tbody><tr>
<td align="left">触发重渲染</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">存储值类型</td>
<td align="left">可变对象（.current）</td>
<td align="left">不可变状态</td>
</tr>
<tr>
<td align="left">数据持久化</td>
<td align="left">组件生命周期</td>
<td align="left">状态更新保留</td>
</tr>
<tr>
<td align="left">典型用途</td>
<td align="left">DOM 引用&#x2F;计时器 ID</td>
<td align="left">渲染相关状态</td>
</tr>
</tbody></table>
<p><strong>Q：回调 Ref 有何特殊用途？</strong></p>
<p>(1) 动态绑定：可在运行时切换 ref 目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;input ref=&#123;condition ? ref1 : ref2&#125; /&gt;<br></code></pre></td></tr></table></figure>

<p>(2) 精细控制：元素挂载&#x2F;卸载时执行逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">measureRef</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (el) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;尺寸:&#x27;</span>, el.<span class="hljs-title function_">getBoundingClientRect</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结：Refs-使用决策"><a href="#总结：Refs-使用决策" class="headerlink" title="总结：Refs 使用决策"></a>总结：Refs 使用决策</h3><pre class="mermaid">graph TD
  A[是否需要操作 DOM?] -->|是| B[使用 Ref]
  A -->|否| C[考虑 State]
  B --> D{组件类型?}
  D -->|函数组件| E[useRef + forwardRef]
  D -->|类组件| F[createRef]
  B --> G{需要暴露方法?}
  G -->|是| H[useImperativeHandle]
  G -->|否| I[直接访问 DOM]</pre>

<h1 id="第三章：Hooks-深度解析"><a href="#第三章：Hooks-深度解析" class="headerlink" title="第三章：Hooks 深度解析"></a>第三章：Hooks 深度解析</h1><h2 id="3-1-useState-与状态管理"><a href="#3-1-useState-与状态管理" class="headerlink" title="3.1 useState 与状态管理"></a>3.1 useState 与状态管理</h2><h3 id="基础概念概述-4"><a href="#基础概念概述-4" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p><strong>useState 作用</strong>：函数组件中添加状态能力的 Hook，替代类组件的 this.state</p>
<p>基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialValue);<br></code></pre></td></tr></table></figure>

<ul>
<li>state：当前状态值</li>
<li>setState：状态更新函数</li>
<li>initialValue：初始状态（支持惰性初始化）</li>
</ul>
<h3 id="核心机制深度解析-2"><a href="#核心机制深度解析-2" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>闭包状态快照原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 闭包捕获当前 count 值</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);    <span class="hljs-comment">// 输出旧值（状态更新是异步的）</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键特性：</p>
<ul>
<li>每次渲染都有独立的函数作用域</li>
<li>状态更新函数调用时使用当次渲染的快照值</li>
<li>状态更新触发重新渲染（生成新的闭包）</li>
</ul>
<p><strong>函数式更新解决闭包陷阱</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 闭包陷阱（连续点击只增加1）</span><br><span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// ✅ 函数式更新（连续点击增加2）</span><br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>原理：更新函数接收 previous state 参数，React 保证这是最新状态</p>
<p><strong>状态批处理机制（React 18+）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f);<br>  <span class="hljs-comment">// React 18：自动批处理为单次渲染</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>事件循环中的表现：</p>
<pre class="mermaid">sequenceDiagram
  participant UI as 用户界面
  participant React as React 运行时
  UI->>React: 触发事件
  React->>React: 执行所有 setState
  React->>React: 合并状态更新
  React->>UI: 单次重渲染</pre>

<p><strong>惰性初始化（Lazy Initialization）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 避免重复计算初始值</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">computeExpensiveValue</span>(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>初始化函数仅在挂载时执行一次</li>
<li>避免重新渲染时重复计算</li>
</ul>
<h3 id="状态管理进阶模式"><a href="#状态管理进阶模式" class="headerlink" title="状态管理进阶模式"></a>状态管理进阶模式</h3><p><strong>状态依赖更新</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 当 count 变化时重置 page</span><br>  <span class="hljs-title function_">setPage</span>(<span class="hljs-number">1</span>);<br>&#125;, [count]); <span class="hljs-comment">// 依赖项触发状态重置</span><br></code></pre></td></tr></table></figure>

<p><strong>状态提升与下沉策略</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 状态提升：共享状态到共同祖先</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [sharedState, setSharedState] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;sharedState&#125;</span> <span class="hljs-attr">setState</span>=<span class="hljs-string">&#123;setSharedState&#125;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;sharedState&#125;</span> <span class="hljs-attr">setState</span>=<span class="hljs-string">&#123;setSharedState&#125;</span> /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 状态下沉：缩小状态影响范围</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 只有按钮依赖 count</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c =&gt; c + 1)&#125; /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>状态合并模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：使用对象</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span> &#125;);<br><span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br><br><span class="hljs-comment">// 方案2：多个 useState</span><br><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> [flag, setFlag] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 方案3：useReducer（复杂状态）</span><br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-6"><a href="#高频面试题与破解方案-6" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么连续调用 setState 不更新？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 本次渲染 count=0</span><br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 本次渲染 count=0</span><br>  <span class="hljs-comment">// 结果：count 只增加1</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>闭包捕获的 count 是当次渲染的固定值，解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 函数式更新</span><br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p><strong>Q：useState 和 useRef 存储数据有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useState</th>
<th align="left">useRef</th>
</tr>
</thead>
<tbody><tr>
<td align="left">触发重渲染</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">数据持久化</td>
<td align="left">跨渲染保留</td>
<td align="left">跨渲染保留</td>
</tr>
<tr>
<td align="left">数据访问</td>
<td align="left">直接使用 state</td>
<td align="left">通过 .current 访问</td>
</tr>
<tr>
<td align="left">更新方式</td>
<td align="left">setState 函数</td>
<td align="left">直接修改 .current</td>
</tr>
<tr>
<td align="left">典型用途</td>
<td align="left">驱动 UI 变化的状态</td>
<td align="left">DOM 引用&#x2F;不触发渲染的值</td>
</tr>
</tbody></table>
<p><strong>Q：如何实现状态重置？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> initialUser = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(initialUser);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// ✅ 正确：重置为初始值</span><br>    <span class="hljs-title function_">setUser</span>(initialUser);<br>    <br>    <span class="hljs-comment">// ❌ 危险：可能导致引用问题</span><br>    <span class="hljs-comment">// setUser(&#123; name: &#x27;John&#x27;, age: 30 &#125;);</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="性能优化技巧-1"><a href="#性能优化技巧-1" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><p><strong>避免不必要状态</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 冗余状态（可从 props 派生）</span><br><span class="hljs-keyword">const</span> [fullName, setFullName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>);<br><br><span class="hljs-comment">// ✅ 直接用计算值</span><br><span class="hljs-keyword">const</span> fullName = <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>;<br></code></pre></td></tr></table></figure>

<p><strong>状态隔离减少重渲染</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始结构：状态变化导致整个组件重渲染</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;);<br><br><span class="hljs-comment">// 优化方案：拆分为独立状态</span><br><span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p><strong>状态记忆化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 避免子组件不必要重渲染</span><br>  <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">useMemo</span>(<br>    <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveChild</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> /&gt;</span></span>,<br>    [count] <span class="hljs-comment">// 仅 count 变化时更新</span><br>  );<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;child&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="与类组件状态对比"><a href="#与类组件状态对比" class="headerlink" title="与类组件状态对比"></a>与类组件状态对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useState</th>
<th align="left">this.state</th>
</tr>
</thead>
<tbody><tr>
<td align="left">更新方式</td>
<td align="left">独立 set 函数</td>
<td align="left">this.setState({})</td>
</tr>
<tr>
<td align="left">状态合并</td>
<td align="left">不自动合并</td>
<td align="left">自动浅合并</td>
</tr>
<tr>
<td align="left">异步行为</td>
<td align="left">批处理更新</td>
<td align="left">批处理更新</td>
</tr>
<tr>
<td align="left">函数式更新</td>
<td align="left">setCount(prev &#x3D;&gt; prev+1)</td>
<td align="left">this.setState(prev &#x3D;&gt; {})</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="left">支持惰性初始化函数</td>
<td align="left">构造函数中初始化</td>
</tr>
</tbody></table>
<h3 id="React-18-新特性：自动批处理"><a href="#React-18-新特性：自动批处理" class="headerlink" title="React 18 新特性：自动批处理"></a>React 18 新特性：自动批处理</h3><p><strong>批处理范围扩展</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 17：只在事件处理函数中批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 立即渲染</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 再次渲染</span><br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// React 18：自动批处理所有更新</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 合并更新</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 单次渲染</span><br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p><strong>紧急更新与非紧急更新</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; startTransition &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 紧急更新（用户输入）</span><br><span class="hljs-title function_">setInputValue</span>(input);<br><br><span class="hljs-comment">// 标记非紧急更新（搜索结果）</span><br><span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setSearchQuery</span>(input);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="3-2-useEffect-与副作用（依赖数组、清理函数）"><a href="#3-2-useEffect-与副作用（依赖数组、清理函数）" class="headerlink" title="3.2 useEffect 与副作用（依赖数组、清理函数）"></a>3.2 useEffect 与副作用（依赖数组、清理函数）</h2><h3 id="基础概念概述-5"><a href="#基础概念概述-5" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useEffect 作用：处理副作用操作：数据获取、订阅管理、手动 DOM 操作等</p>
<p>核心参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 副作用逻辑</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 清理函数 */</span> &#125;;<br>&#125;, [dependencies]); <span class="hljs-comment">// 依赖数组</span><br></code></pre></td></tr></table></figure>

<p>执行时机:</p>
<ul>
<li>组件挂载后（componentDidMount）</li>
<li>依赖项变化时（componentDidUpdate）</li>
<li>组件卸载前执行清理（componentWillUnmount）</li>
</ul>
<h3 id="依赖数组深度解析"><a href="#依赖数组深度解析" class="headerlink" title="依赖数组深度解析"></a>依赖数组深度解析</h3><p><strong>三种依赖模式对比</strong></p>
<table>
<thead>
<tr>
<th align="left">依赖数组</th>
<th align="left">执行时机</th>
<th align="left">常见用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[]</td>
<td align="left">仅挂载时执行一次</td>
<td align="left">初始化请求、事件订阅</td>
</tr>
<tr>
<td align="left">[dep1, dep2]</td>
<td align="left">依赖变化时执行</td>
<td align="left">数据请求、状态联动</td>
</tr>
<tr>
<td align="left">无依赖</td>
<td align="left">每次渲染后都执行</td>
<td align="left">极少使用（性能危险）</td>
</tr>
</tbody></table>
<p><strong>依赖项优化技巧</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误：缺少必要依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchData</span>(user.<span class="hljs-property">id</span>); <br>&#125;, []); <span class="hljs-comment">// 当 user.id 变化时不会重新请求</span><br><br><span class="hljs-comment">// ✅ 正确：包含所有依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchData</span>(user.<span class="hljs-property">id</span>);<br>&#125;, [user.<span class="hljs-property">id</span>]); <br><br><span class="hljs-comment">// ✅ 高级：函数式更新避免依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 不依赖 count</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []); <span class="hljs-comment">// 空依赖安全</span><br></code></pre></td></tr></table></figure>

<p><strong>依赖引用陷阱</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 问题：对象引用变化导致无限循环</span><br><span class="hljs-keyword">const</span> config = &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> &#125;;<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">startTimer</span>(config);<br>&#125;, [config]); <span class="hljs-comment">// 每次渲染 config 都是新对象</span><br><br><span class="hljs-comment">// ✅ 解决方案：useMemo 稳定引用</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> &#125;), []);<br></code></pre></td></tr></table></figure>

<h3 id="清理函数高级用法"><a href="#清理函数高级用法" class="headerlink" title="清理函数高级用法"></a>清理函数高级用法</h3><p><strong>执行机制</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Mount as 组件挂载
  participant Update as 依赖更新
  participant Unmount as 组件卸载
  Mount->>+Effect: 执行副作用
  Update->>+Cleanup: 执行旧清理函数
  Update->>+Effect: 执行新副作用
  Unmount->>+Cleanup: 执行清理函数</pre>

<p><strong>常见清理场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 清除定时器</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-comment">/*...*/</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br><br><span class="hljs-comment">// 2. 取消网络请求</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  <span class="hljs-title function_">fetch</span>(url, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 取消未完成请求</span><br>&#125;, [url]);<br><br><span class="hljs-comment">// 3. 移除事件监听</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>&#125;, []);<br></code></pre></td></tr></table></figure>

<p><strong>清理函数闭包特性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 总是初始值（闭包陷阱）</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br><br><span class="hljs-comment">// ✅ 解决方案：使用 ref 保存最新值</span><br><span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);<br>countRef.<span class="hljs-property">current</span> = count;<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// 最新值</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-7"><a href="#高频面试题与破解方案-7" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：如何避免 useEffect 无限循环？</strong></p>
<p>常见原因：</p>
<ul>
<li>副作用内更新依赖项状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 危险：更新状态触发重渲染</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <br>&#125;, [count]); <span class="hljs-comment">// 每次count变化又触发</span><br></code></pre></td></tr></table></figure>

<ul>
<li>依赖引用类型未优化</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 对象字面量导致无限循环</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;, [&#123; data &#125;]); <span class="hljs-comment">// 每次新对象</span><br></code></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 方案1：检查依赖链，移除不必要的状态更新</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (needsUpdate) <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 条件执行</span><br>&#125;, [data]);<br><br><span class="hljs-comment">// ✅ 方案2：使用 useMemo 稳定依赖</span><br><span class="hljs-keyword">const</span> stableData = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> data, [data.<span class="hljs-property">id</span>]);<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;, [stableData]);<br></code></pre></td></tr></table></figure>

<p><strong>Q：为什么严格模式下 useEffect 执行两次？</strong></p>
<p>React 18 严格模式行为：</p>
<ul>
<li>开发环境故意双调用组件（挂载 → 卸载 → 挂载）</li>
<li>目的：暴露未正确清理的副作用</li>
<li>生产环境无此行为</li>
</ul>
<p>正确应对：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> connection = <span class="hljs-title function_">createConnection</span>();<br>  connection.<span class="hljs-title function_">connect</span>();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> connection.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// ✅ 确保完全清理</span><br>&#125;, []);<br></code></pre></td></tr></table></figure>

<p><strong>Q：useEffect 和 useLayoutEffect 有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useEffect</th>
<th align="left">useLayoutEffect</th>
</tr>
</thead>
<tbody><tr>
<td align="left">执行时机</td>
<td align="left">浏览器绘制后异步执行</td>
<td align="left">DOM 更新后，绘制前同步执行</td>
</tr>
<tr>
<td align="left">阻塞渲染</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">使用场景</td>
<td align="left">数据获取、订阅等</td>
<td align="left">DOM 测量、同步样式变更</td>
</tr>
<tr>
<td align="left">服务端渲染</td>
<td align="left">正常执行</td>
<td align="left">警告（需用 useEffect 替代）</td>
</tr>
</tbody></table>
<h3 id="自定义-Hook-封装"><a href="#自定义-Hook-封装" class="headerlink" title="自定义 Hook 封装"></a>自定义 Hook 封装</h3><p><strong>通用数据请求 Hook</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url, initialData</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(initialData);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> isActive = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setData</span>(<span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>());<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-title function_">fetchData</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; isActive = <span class="hljs-literal">false</span> &#125;;<br>  &#125;, [url]);<br>  <br>  <span class="hljs-keyword">return</span> &#123; data, loading &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> &#123; data, loading &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>事件监听 Hook</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEventListener</span>(<span class="hljs-params">eventName, handler, element = <span class="hljs-variable language_">window</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> savedHandler = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    savedHandler.<span class="hljs-property">current</span> = handler;<br>  &#125;, [handler]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventListener</span> = e =&gt; savedHandler.<span class="hljs-title function_">current</span>(e);<br>    element.<span class="hljs-title function_">addEventListener</span>(eventName, eventListener);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> element.<span class="hljs-title function_">removeEventListener</span>(eventName, eventListener);<br>  &#125;, [eventName, element]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-useContext-与全局状态共享"><a href="#3-3-useContext-与全局状态共享" class="headerlink" title="3.3 useContext 与全局状态共享"></a>3.3 useContext 与全局状态共享</h2><h3 id="基础概念概述-6"><a href="#基础概念概述-6" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useContext 作用：解决组件跨层级通信问题，避免 Props drilling（属性钻探）</p>
<p>核心三要素</p>
<ul>
<li>React.createContext()：创建上下文对象</li>
<li><code>&lt;Context.Provider&gt;</code>：提供数据</li>
<li>useContext()：消费数据</li>
</ul>
<p>典型场景:主题切换、用户认证、多语言、全局配置等跨组件共享数据</p>
<h3 id="上下文工作流程详解"><a href="#上下文工作流程详解" class="headerlink" title="上下文工作流程详解"></a>上下文工作流程详解</h3><pre class="mermaid">graph TD
  A[创建Context] --> B[Provider 提供数据]
  B --> C[子组件消费数据]
  C --> D{消费方式}
  D --> E[useContext Hook]
  D --> F[Context.Consumer]
  D --> G[Class.contextType]</pre>

<p>完整使用示例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 创建上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>); <span class="hljs-comment">// 默认值</span><br><br><span class="hljs-comment">// 2. Provider 提供数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;dark&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. 函数组件消费</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 4. 类组件消费</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">ThemeContext</span>; <span class="hljs-comment">// 类组件绑定</span><br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高级应用模式"><a href="#高级应用模式" class="headerlink" title="高级应用模式"></a>高级应用模式</h3><p><strong>自定义 Hook 封装</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建自定义上下文 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">if</span> (!context) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;useTheme 必须在 ThemeProvider 内使用&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-comment">// 在组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme, toggleTheme &#125; = <span class="hljs-title function_">useTheme</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleTheme&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">      切换主题</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-8"><a href="#高频面试题与破解方案-8" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：Context 与 Redux 如何选择？</strong></p>
<p>决策矩阵：</p>
<table>
<thead>
<tr>
<th align="left">考量因素</th>
<th align="left">Context</th>
<th align="left">Redux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用复杂度</td>
<td align="left">简单</td>
<td align="left">复杂（action&#x2F;reducer）</td>
</tr>
<tr>
<td align="left">性能优化</td>
<td align="left">需手动优化</td>
<td align="left">内置精细更新</td>
</tr>
<tr>
<td align="left">中间件支持</td>
<td align="left">不支持</td>
<td align="left">支持（thunk&#x2F;saga）</td>
</tr>
<tr>
<td align="left">调试工具</td>
<td align="left">无</td>
<td align="left">Redux DevTools</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">低频更新数据（主题&#x2F;用户）</td>
<td align="left">高频更新&#x2F;复杂状态逻辑</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>中小应用：Context + useReducer</li>
<li>大型应用：Redux&#x2F;Zustand</li>
</ul>
<p><strong>Q：为什么 Context 会导致不必要的重渲染？</strong></p>
<p>根本原因：</p>
<p>Context 使用 值比较（value comparison），当 Provider 的 value 变化时，所有消费该 Context 的组件都会重渲染，无论是否使用变化的部分。</p>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 拆分 Context（如前文示例）</span><br><span class="hljs-comment">// 2. 使用 React.memo 优化子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ExpensiveComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123; ... &#125;);<br><br><span class="hljs-comment">// 3. 使用选择器库（use-context-selector）</span><br></code></pre></td></tr></table></figure>

<p><strong>Q：如何检测 Context 未提供？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建时设置默认值（生产环境有用）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-comment">// 自定义 Hook 添加检测</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <br>  <span class="hljs-keyword">if</span> (context === <span class="hljs-literal">undefined</span>) &#123; <span class="hljs-comment">// 未提供时使用默认值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;light&#x27;</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-useReducer-与复杂状态逻辑"><a href="#3-4-useReducer-与复杂状态逻辑" class="headerlink" title="3.4 useReducer 与复杂状态逻辑"></a>3.4 useReducer 与复杂状态逻辑</h2><h3 id="基础概念概述-7"><a href="#基础概念概述-7" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useReducer 作用：管理复杂状态逻辑的 Hook，是 useState 的替代方案，借鉴 Redux 的核心思想</p>
<p>核心参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState, initFunc);<br></code></pre></td></tr></table></figure>

<ul>
<li>reducer：状态更新函数 (state, action) &#x3D;&gt; newState</li>
<li>initialState：初始状态</li>
<li>initFunc：惰性初始化函数（可选）</li>
</ul>
<p>三大要素:</p>
<ul>
<li>State：应用的状态数据</li>
<li>Action：描述状态变化的普通对象</li>
<li>Dispatch：触发状态更新的函数 dispatch(action)</li>
</ul>
<h3 id="核心机制深度解析-3"><a href="#核心机制深度解析-3" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>Reducer 函数工作原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 典型 reducer 结构</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;set_user&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">user</span>: action.<span class="hljs-property">payload</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 必须返回默认状态</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>状态更新流程</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Component as 组件
  participant Reducer as Reducer函数
  participant React as React运行时
  
  Component->>Reducer: dispatch({ type: 'increment' })
  Reducer->>Reducer: 计算新状态 (state + 1)
  Reducer->>React: 返回新状态
  React->>Component: 触发重渲染</pre>

<p><strong>与 useState 对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useReducer</th>
<th align="left">useState</th>
</tr>
</thead>
<tbody><tr>
<td align="left">适用场景</td>
<td align="left">复杂状态逻辑</td>
<td align="left">简单状态</td>
</tr>
<tr>
<td align="left">状态结构</td>
<td align="left">对象&#x2F;复杂结构</td>
<td align="left">任意类型</td>
</tr>
<tr>
<td align="left">更新逻辑</td>
<td align="left">集中管理（reducer）</td>
<td align="left">分散在组件中</td>
</tr>
<tr>
<td align="left">性能优化</td>
<td align="left">容易避免不必要更新</td>
<td align="left">需手动优化</td>
</tr>
<tr>
<td align="left">测试</td>
<td align="left">纯函数易于测试</td>
<td align="left">需渲染组件测试</td>
</tr>
</tbody></table>
<h3 id="高级应用模式-1"><a href="#高级应用模式-1" class="headerlink" title="高级应用模式"></a>高级应用模式</h3><p><strong>中间件模式（类似 Redux）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 增强 dispatch 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useReducerWithMiddleware</span>(<span class="hljs-params">reducer, initialState</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <br>  <span class="hljs-comment">// 支持中间件链</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatchWithMiddleware</span> = action =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Action:&#x27;</span>, action); <span class="hljs-comment">// 日志中间件</span><br>    <span class="hljs-title function_">dispatch</span>(action); <span class="hljs-comment">// 继续传递</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> [state, dispatchWithMiddleware];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复杂状态管理实战"><a href="#复杂状态管理实战" class="headerlink" title="复杂状态管理实战"></a>复杂状态管理实战</h3><p><strong>表单状态管理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;change_field&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        [action.<span class="hljs-property">field</span>]: action.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">touched</span>: &#123; ...state.<span class="hljs-property">touched</span>, [action.<span class="hljs-property">field</span>]: <span class="hljs-literal">true</span> &#125;<br>      &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;validate&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">errors</span>: <span class="hljs-title function_">validateForm</span>(state) &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;submit&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">isSubmitting</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;submit_success&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...initialState, <span class="hljs-attr">submitSuccess</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(formReducer, initialState);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;change_field&#x27;</span>,<br>      <span class="hljs-attr">field</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">name</span>,<br>      <span class="hljs-attr">value</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>异步操作管理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_START&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; userId &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(asyncReducer, &#123;<br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span><br>  &#125;);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_START&#x27;</span> &#125;);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(userId);<br>        <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data &#125;);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span>, error &#125;);<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-title function_">fetchUser</span>();<br>  &#125;, [userId]);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>状态机模式（XState 思想）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stateMachineReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (state.<span class="hljs-property">status</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;idle&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;FETCH&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;loading&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;loading&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;SUCCESS&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span> &#125;;<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;FAILURE&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;success&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;RESET&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;error&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;RETRY&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;loading&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-9"><a href="#高频面试题与破解方案-9" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：何时该用 useReducer 而不是 useState？</strong></p>
<p>决策树：</p>
<pre class="mermaid">graph TD
  A[状态结构复杂?] -->|是| B[useReducer]
  A -->|否| C{状态更新逻辑复杂?}
  C -->|是| B
  C -->|否| D[useState]
  E[需要跨组件更新?] -->|是| B
  F[需要可预测状态?] -->|是| B</pre>

<p><strong>Q：如何避免 reducer 函数过大？</strong></p>
<p>优化策略：</p>
<ul>
<li>拆分 reducer：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rootReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-title function_">userReducer</span>(state.<span class="hljs-property">user</span>, action),<br>    <span class="hljs-attr">posts</span>: <span class="hljs-title function_">postsReducer</span>(state.<span class="hljs-property">posts</span>, action)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>组合 action 创建函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increment&#x27;</span> &#125;),<br>  <span class="hljs-attr">addTodo</span>: <span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add_todo&#x27;</span>, <span class="hljs-attr">payload</span>: text &#125;)<br>&#125;;<br><span class="hljs-comment">// 使用：dispatch(actions.increment())</span><br></code></pre></td></tr></table></figure>

<p><strong>Q：useReducer 如何实现时间旅行调试？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 添加历史记录</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducerWithHistory</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">const</span> nextState = <span class="hljs-title function_">reducer</span>(state.<span class="hljs-property">current</span>, action);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">current</span>: nextState,<br>    <span class="hljs-attr">history</span>: [...state.<span class="hljs-property">history</span>, &#123; action, <span class="hljs-attr">state</span>: nextState &#125;]<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现撤销/重做</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">undoableReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;UNDO&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">current</span>: state.<span class="hljs-property">history</span>[state.<span class="hljs-property">history</span>.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>] &#125;;<br>  &#125;<br>  <span class="hljs-comment">// ...其他action处理</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(undoableReducer, &#123;<br>  <span class="hljs-attr">current</span>: initialState,<br>  <span class="hljs-attr">history</span>: [initialState]<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="与-Context-集成"><a href="#与-Context-集成" class="headerlink" title="与 Context 集成"></a>与 Context 集成</h3><p><strong>全局状态管理方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建 Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StateContext</span> = <span class="hljs-title function_">createContext</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">DispatchContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-comment">// 全局 Provider</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(rootReducer, initialState);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;state&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DispatchContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;dispatch&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DispatchContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">StateContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 自定义 Hook 访问</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAppState</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">StateContext</span>);<br>  <span class="hljs-keyword">if</span> (!state) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;必须在 AppProvider 内使用&#x27;</span>);<br>  <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAppDispatch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DispatchContext</span>);<br>  <span class="hljs-keyword">if</span> (!dispatch) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;必须在 AppProvider 内使用&#x27;</span>);<br>  <span class="hljs-keyword">return</span> dispatch;<br>&#125;<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useAppState</span>();<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useAppDispatch</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;</span><br><span class="language-xml">      &#123;state.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol>
<li>纯函数原则：Reducer 必须是纯函数，不产生副作用</li>
<li>不可变更新：始终返回新状态对象，不修改原状态</li>
<li>类型安全：使用 TypeScript 强化 action 类型</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Action</span> = <br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increment&#x27;</span> &#125;<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;decrement&#x27;</span> &#125;<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;set_count&#x27;</span>; <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span> &#125;;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>逻辑复用：提取 reducer 到独立文件便于测试</li>
<li>合理拆分：大型应用按功能域拆分多个 reducer</li>
<li>避免过度：简单状态仍使用 useState</li>
</ol>
<h3 id="使用场景决策逻辑"><a href="#使用场景决策逻辑" class="headerlink" title="使用场景决策逻辑"></a>使用场景决策逻辑</h3><pre class="mermaid">graph TD
  A[状态管理需求] --> B{状态结构}
  B -->|简单值| C[useState]
  B -->|复杂对象| D{更新逻辑}
  D -->|简单| C
  D -->|复杂| E[useReducer]
  A --> F{状态共享范围}
  F -->|组件内| G[useState/useReducer]
  F -->|跨组件| H[Context + useReducer]
  A --> I{需要时间旅行/撤销}
  I -->|是| E</pre>

<h2 id="3-5-自定义-Hooks（封装可复用逻辑）"><a href="#3-5-自定义-Hooks（封装可复用逻辑）" class="headerlink" title="3.5 自定义 Hooks（封装可复用逻辑）"></a>3.5 自定义 Hooks（封装可复用逻辑）</h2><h3 id="基础概念概述-8"><a href="#基础概念概述-8" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>自定义 Hook 是什么：将组件逻辑提取到可重用的 JavaScript 函数中的技术，是 React 逻辑复用的终极解决方案</p>
<p>核心特征：</p>
<ul>
<li>名称以 use 开头（如 useFetch）</li>
<li>可以调用其他 Hook（如 useState, useEffect）</li>
<li>不包含 UI 渲染，只包含状态逻辑</li>
</ul>
<p>与普通函数的区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">自定义 Hook</th>
<th align="left">工具函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可调用其他 Hook</td>
<td align="left">✅</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left">状态隔离</td>
<td align="left">每次调用独立状态</td>
<td align="left">无状态&#x2F;静态</td>
</tr>
<tr>
<td align="left">使用场景</td>
<td align="left">组件逻辑复用</td>
<td align="left">数据处理&#x2F;工具类</td>
</tr>
</tbody></table>
<h3 id="核心机制深度解析-4"><a href="#核心机制深度解析-4" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>状态隔离原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params">initialValue = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialValue);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [count, increment];<br>&#125;<br><br><span class="hljs-comment">// 组件A使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [countA, incA] = <span class="hljs-title function_">useCounter</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>&#125;<br><br><span class="hljs-comment">// 组件B使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [countB, incB] = <span class="hljs-title function_">useCounter</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 独立状态</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键原理：每次调用自定义 Hook 都会创建独立的状态副本（闭包机制）</p>
<p><strong>Hook 调用规则</strong></p>
<pre class="mermaid">graph LR
  A[函数组件] --> B[调用自定义Hook]
  B --> C[内部调用React Hook]
  C --> D[返回状态和逻辑]
  D --> A</pre>

<p>强制规则：</p>
<ul>
<li>只在 React 函数组件或自定义 Hook 中调用</li>
<li>只在顶层调用（不能在条件&#x2F;循环中使用）</li>
<li>命名必须以 use 开头</li>
</ul>
<h3 id="设计模式与最佳实践"><a href="#设计模式与最佳实践" class="headerlink" title="设计模式与最佳实践"></a>设计模式与最佳实践</h3><p><strong>参数传递与返回值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 灵活的参数设计</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useToggle</span>(<span class="hljs-params">initial = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initial);<br>  <br>  <span class="hljs-comment">// 支持直接设置或切换</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>      <span class="hljs-title function_">setState</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> !prev);<br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-comment">// 返回状态和控制方法</span><br>  <span class="hljs-keyword">return</span> [state, toggle];<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [isOpen, toggleOpen] = <span class="hljs-title function_">useToggle</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<p><strong>组合 Hook 模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组合多个 Hook 创建复杂逻辑</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useUserProfile</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, loading, error] = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>);<br>  <span class="hljs-keyword">const</span> [preferences, setPrefs] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">`prefs_<span class="hljs-subst">$&#123;userId&#125;</span>`</span>, &#123;&#125;);<br>  <span class="hljs-keyword">const</span> [notifications, addNotification] = <span class="hljs-title function_">useNotifications</span>();<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    user,<br>    preferences,<br>    <span class="hljs-attr">setPreferences</span>: setPrefs,<br>    notifications,<br>    addNotification,<br>    loading,<br>    error<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>依赖注入模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建可配置的自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAPI</span>(<span class="hljs-params">endpoint, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-keyword">const</span> fetchData = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, options);<br>      <span class="hljs-title function_">setData</span>(<span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;, [endpoint, options]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetchData</span>();<br>  &#125;, [fetchData]);<br>  <br>  <span class="hljs-keyword">return</span> &#123; data, loading, <span class="hljs-attr">refetch</span>: fetchData &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> userAPI = <span class="hljs-title function_">useAPI</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-10"><a href="#高频面试题与破解方案-10" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：自定义 Hook 和 HOC（高阶组件）&#x2F;Render Props 有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">自定义 Hook</th>
<th align="left">HOC</th>
<th align="left">Render Props</th>
</tr>
</thead>
<tbody><tr>
<td align="left">逻辑复用方式</td>
<td align="left">直接调用 Hook</td>
<td align="left">包装组件</td>
<td align="left">通过 props 渲染</td>
</tr>
<tr>
<td align="left">组件层级</td>
<td align="left">无额外层级</td>
<td align="left">增加包装层级</td>
<td align="left">增加回调层级</td>
</tr>
<tr>
<td align="left">命名冲突</td>
<td align="left">无</td>
<td align="left">可能发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left">调试难度</td>
<td align="left">简单</td>
<td align="left">组件树变深</td>
<td align="left">回调嵌套复杂</td>
</tr>
<tr>
<td align="left">TypeScript 支持</td>
<td align="left">优秀</td>
<td align="left">类型推导复杂</td>
<td align="left">类型推导中等</td>
</tr>
</tbody></table>
<p>结论：<br>自定义 Hook 是 React 官方推荐的逻辑复用方案，解决了 HOC 和 Render Props 的嵌套问题</p>
<p><strong>Q：如何测试自定义 Hook？</strong></p>
<p>测试策略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 @testing-library/react-hooks</span><br><span class="hljs-keyword">import</span> &#123; renderHook, act &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react-hooks&#x27;</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should use counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; result &#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">useCounter</span>());<br>  <br>  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始值</span><br>  <br>  <span class="hljs-title function_">act</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    result.<span class="hljs-property">current</span>[<span class="hljs-number">1</span>](); <span class="hljs-comment">// 执行 increment</span><br>  &#125;);<br>  <br>  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 更新后值</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>Q：自定义 Hook 会导致内存泄漏吗？</strong></p>
<p>风险与防范：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEventListener</span>(<span class="hljs-params">eventName, handler, element = <span class="hljs-variable language_">window</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> savedHandler = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-comment">// 保存最新处理函数</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    savedHandler.<span class="hljs-property">current</span> = handler;<br>  &#125;, [handler]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventListener</span> = event =&gt; savedHandler.<span class="hljs-title function_">current</span>(event);<br>    element.<span class="hljs-title function_">addEventListener</span>(eventName, eventListener);<br>    <br>    <span class="hljs-comment">// ✅ 必须返回清理函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> element.<span class="hljs-title function_">removeEventListener</span>(eventName, eventListener);<br>  &#125;, [eventName, element]); <span class="hljs-comment">// 依赖变化时重新绑定</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h3><p><strong>权限控制 Hook</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">usePermission</span>(<span class="hljs-params">requiredPermission</span>) &#123;<br>  <span class="hljs-keyword">const</span> [user] = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">const</span> [hasPermission, setHasPermission] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 异步检查权限（如调用API）</span><br>    <span class="hljs-title function_">checkPermission</span>(user.<span class="hljs-property">id</span>, requiredPermission).<span class="hljs-title function_">then</span>(setHasPermission);<br>  &#125;, [user, requiredPermission]);<br>  <br>  <span class="hljs-keyword">return</span> hasPermission;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AdminPanel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canEdit = <span class="hljs-title function_">usePermission</span>(<span class="hljs-string">&#x27;admin_edit&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> canEdit ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Editor</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PermissionDenied</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>状态机 Hook</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useStateMachine</span>(<span class="hljs-params">states, initialState</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br>  <br>  <span class="hljs-keyword">const</span> transition = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> currentState = state;<br>    <span class="hljs-keyword">const</span> nextState = states[currentState]?.[event];<br>    <br>    <span class="hljs-keyword">if</span> (!nextState) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无效转换: <span class="hljs-subst">$&#123;currentState&#125;</span> -&gt; <span class="hljs-subst">$&#123;event&#125;</span>`</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-title function_">setState</span>(nextState);<br>  &#125;, [state, states]);<br>  <br>  <span class="hljs-keyword">return</span> [state, transition];<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [state, transition] = <span class="hljs-title function_">useStateMachine</span>(&#123;<br>  <span class="hljs-attr">idle</span>: &#123; <span class="hljs-attr">START</span>: <span class="hljs-string">&#x27;running&#x27;</span> &#125;,<br>  <span class="hljs-attr">running</span>: &#123; <span class="hljs-attr">PAUSE</span>: <span class="hljs-string">&#x27;paused&#x27;</span>, <span class="hljs-attr">COMPLETE</span>: <span class="hljs-string">&#x27;done&#x27;</span> &#125;,<br>  <span class="hljs-attr">paused</span>: &#123; <span class="hljs-attr">RESUME</span>: <span class="hljs-string">&#x27;running&#x27;</span>, <span class="hljs-attr">CANCEL</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;,<br>  <span class="hljs-attr">done</span>: &#123; <span class="hljs-attr">RESET</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;<br>&#125;, <span class="hljs-string">&#x27;idle&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="自定义-Hook-设计原则"><a href="#自定义-Hook-设计原则" class="headerlink" title="自定义 Hook 设计原则"></a>自定义 Hook 设计原则</h3><ol>
<li>单一职责：一个 Hook 只解决一个问题</li>
<li>命名清晰：use + 功能名（useWindowSize）</li>
<li>参数合理：提供默认值和必要配置</li>
<li>返回简洁：返回数组或对象结构</li>
<li>文档完善：使用 JSDoc 说明用法</li>
<li>类型安全：TypeScript 类型定义</li>
</ol>
<h3 id="总结：自定义-Hook-价值"><a href="#总结：自定义-Hook-价值" class="headerlink" title="总结：自定义 Hook 价值"></a>总结：自定义 Hook 价值</h3><pre class="mermaid">graph TD
  A[逻辑复用] --> B[减少代码重复]
  A --> C[统一业务逻辑]
  D[关注点分离] --> E[提升可维护性]
  D --> F[便于单元测试]
  G[组件简化] --> H[提升可读性]
  G --> I[降低复杂度]</pre>

<h2 id="3-6-其他常用-Hooks（useMemo、useCallback、useRef）"><a href="#3-6-其他常用-Hooks（useMemo、useCallback、useRef）" class="headerlink" title="3.6 其他常用 Hooks（useMemo、useCallback、useRef）"></a>3.6 其他常用 Hooks（useMemo、useCallback、useRef）</h2><h3 id="三大-Hook-快速对比"><a href="#三大-Hook-快速对比" class="headerlink" title="三大 Hook 快速对比"></a>三大 Hook 快速对比</h3><table>
<thead>
<tr>
<th align="left">Hook</th>
<th align="left">主要作用</th>
<th align="left">返回值</th>
<th align="left">性能优化原理</th>
</tr>
</thead>
<tbody><tr>
<td align="left">useMemo</td>
<td align="left">缓存计算结果</td>
<td align="left">记忆化值</td>
<td align="left">避免重复计算</td>
</tr>
<tr>
<td align="left">useCallback</td>
<td align="left">缓存函数引用</td>
<td align="left">记忆化函数</td>
<td align="left">避免子组件不必要重渲染</td>
</tr>
<tr>
<td align="left">useRef</td>
<td align="left">保存可变值&#x2F;DOM 引用</td>
<td align="left">{ current: value }</td>
<td align="left">不触发重渲染</td>
</tr>
</tbody></table>
<h3 id="useMemo-深度解析"><a href="#useMemo-深度解析" class="headerlink" title="useMemo 深度解析"></a>useMemo 深度解析</h3><p><strong>核心语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure>

<ul>
<li>计算函数：返回需要缓存的值</li>
<li>依赖数组：当依赖变化时重新计算</li>
</ul>
<p><strong>工作原理</strong></p>
<pre class="mermaid">graph LR
  A[组件渲染] --> B{依赖是否变化?}
  B -->|否| C[返回缓存值]
  B -->|是| D[执行计算函数]
  D --> E[缓存新值]
  E --> F[返回新值]</pre>

<p><strong>使用场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 场景1：高开销计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">&#123; items &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> sortedItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">value</span> - b.<span class="hljs-property">value</span>); <span class="hljs-comment">// 排序开销大</span><br>  &#125;, [items]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;sortedItems&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 场景2：避免不必要重渲染</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> userContext = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; <br>    user, <br>    <span class="hljs-attr">isAdmin</span>: user.<span class="hljs-property">role</span> === <span class="hljs-string">&#x27;admin&#x27;</span> <br>  &#125;), [user]); <span class="hljs-comment">// 依赖变化时重建</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">context</span>=<span class="hljs-string">&#123;userContext&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>错误用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误1：没有依赖数组（每次渲染都计算）</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compute</span>());<br><br><span class="hljs-comment">// ❌ 错误2：依赖数组不全</span><br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>, [name]);<br></code></pre></td></tr></table></figure>

<h3 id="useCallback-深度解析"><a href="#useCallback-深度解析" class="headerlink" title="useCallback 深度解析"></a>useCallback 深度解析</h3><p><strong>核心语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">doSomething</span>(a, b);<br>&#125;, [a, b]);<br></code></pre></td></tr></table></figure>

<p><strong>与 useMemo 关系</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// useCallback 等价于：</span><br><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">doSomething</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 场景1：避免子组件不必要重渲染</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 稳定函数引用</span><br>  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>), []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; onClick &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 依赖稳定函数引用不会重渲染</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-comment">// 场景2：依赖数组中的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;提交:&#x27;</span>, text);<br>  &#125;, [text]); <span class="hljs-comment">// 正确捕获最新text</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">keyHandler</span> = e =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Enter&#x27;</span>) <span class="hljs-title function_">handleSubmit</span>();<br>    &#125;;<br>    <br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, keyHandler);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, keyHandler);<br>  &#125;, [handleSubmit]); <span class="hljs-comment">// 依赖稳定函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>性能陷阱</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误：过度使用 useCallback</span><br><span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击&#x27;</span>);<br>&#125;, []); <span class="hljs-comment">// 简单函数不需要缓存</span><br><br><span class="hljs-comment">// ✅ 正确：直接定义函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="useRef-高级用法（补充-2-5-章节）"><a href="#useRef-高级用法（补充-2-5-章节）" class="headerlink" title="useRef 高级用法（补充 2.5 章节）"></a>useRef 高级用法（补充 2.5 章节）</h3><p><strong>保存可变值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// &#123; current: 0 &#125;</span><br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    countRef.<span class="hljs-property">current</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计数:&#x27;</span>, countRef.<span class="hljs-property">current</span>);<br>  &#125;;<br>  <br>  <span class="hljs-comment">// 不触发重渲染！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>访问上一状态</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> prevCountRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    prevCountRef.<span class="hljs-property">current</span> = count; <span class="hljs-comment">// 渲染后保存当前值</span><br>  &#125;);<br>  <br>  <span class="hljs-keyword">const</span> prevCount = prevCountRef.<span class="hljs-property">current</span>;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      当前: &#123;count&#125;, 之前: &#123;prevCount&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>跨渲染周期存储</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChatRoom</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [messages, setMessages] = <span class="hljs-title function_">useState</span>([]);<br>  <span class="hljs-keyword">const</span> socketRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    socketRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://...&#x27;</span>);<br>    socketRef.<span class="hljs-property">current</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setMessages</span>(<span class="hljs-function"><span class="hljs-params">msgs</span> =&gt;</span> [...msgs, event.<span class="hljs-property">data</span>]);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> socketRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">close</span>();<br>  &#125;, []);<br>  <br>  <span class="hljs-comment">// 在其他函数中使用</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params">text</span>) =&gt; &#123;<br>    socketRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">send</span>(text);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-11"><a href="#高频面试题与破解方案-11" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：useMemo 和 useCallback 有何区别？</strong></p>
<p>核心区别：</p>
<ul>
<li>useMemo 缓存计算结果，用于避免重复计算</li>
<li>useCallback 缓存函数引用，用于保持引用稳定</li>
</ul>
<p>等效关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useCallback</span>(fn, deps) === <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> fn, deps)<br></code></pre></td></tr></table></figure>

<p><strong>Q：何时该用 useMemo&#x2F;useCallback？</strong></p>
<pre class="mermaid">graph TD
  A[需要优化？] -->|否| B[直接计算/定义函数]
  A -->|是| C{优化类型?}
  C -->|避免计算开销| D[用useMemo]
  C -->|避免子组件重渲染| E[useCallback+React.memo]
  C -->|稳定依赖项| F[两者皆可]</pre>

<p><strong>Q：useRef 和 useState 有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">useRef</th>
<th align="left">useState</th>
</tr>
</thead>
<tbody><tr>
<td align="left">触发重渲染</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">存储值类型</td>
<td align="left">可变对象（.current）</td>
<td align="left">不可变状态</td>
</tr>
<tr>
<td align="left">数据持久化</td>
<td align="left">组件生命周期</td>
<td align="left">状态更新保留</td>
</tr>
<tr>
<td align="left">典型用途</td>
<td align="left">DOM 引用&#x2F;计时器 ID</td>
<td align="left">渲染相关状态</td>
</tr>
<tr>
<td align="left">初始化</td>
<td align="left">useRef(initial)</td>
<td align="left">useState(initial)</td>
</tr>
</tbody></table>
<h3 id="高级优化模式"><a href="#高级优化模式" class="headerlink" title="高级优化模式"></a>高级优化模式</h3><p><strong>虚拟滚动优化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VirtualList</span>(<span class="hljs-params">&#123; items, itemHeight &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> containerRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> [visibleRange, setVisibleRange] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]);<br>  <br>  <span class="hljs-comment">// 缓存可见项</span><br>  <span class="hljs-keyword">const</span> visibleItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">slice</span>(visibleRange[<span class="hljs-number">0</span>], visibleRange[<span class="hljs-number">1</span>]);<br>  &#125;, [items, visibleRange]);<br>  <br>  <span class="hljs-comment">// 计算总高度（虚拟滚动）</span><br>  <span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-property">length</span> * itemHeight;<br>  &#125;, [items.<span class="hljs-property">length</span>, itemHeight]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;containerRef&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">500px</span>&#x27;, <span class="hljs-attr">overflow:</span> &#x27;<span class="hljs-attr">auto</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> `$&#123;<span class="hljs-attr">totalHeight</span>&#125;<span class="hljs-attr">px</span>`, <span class="hljs-attr">position:</span> &#x27;<span class="hljs-attr">relative</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">        &#123;visibleItems.map(item =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">item</span>=<span class="hljs-string">&#123;item&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">position:</span> &#x27;<span class="hljs-attr">absolute</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">top:</span> `$&#123;<span class="hljs-attr">item.index</span> * <span class="hljs-attr">itemHeight</span>&#125;<span class="hljs-attr">px</span>` </span></span><br><span class="hljs-tag"><span class="language-xml">            &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>防抖&#x2F;节流优化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounce</span>(<span class="hljs-params">value, delay</span>) &#123;<br>  <span class="hljs-keyword">const</span> [debouncedValue, setDebouncedValue] = <span class="hljs-title function_">useState</span>(value);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setDebouncedValue</span>(value), delay);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);<br>  &#125;, [value, delay]);<br>  <br>  <span class="hljs-keyword">return</span> debouncedValue;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Search</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> debouncedQuery = <span class="hljs-title function_">useDebounce</span>(query, <span class="hljs-number">300</span>);<br>  <br>  <span class="hljs-comment">// 使用useMemo避免重复请求</span><br>  <span class="hljs-keyword">const</span> results = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchResults</span>(debouncedQuery);<br>  &#125;, [debouncedQuery]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;query&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setQuery(e.target.value)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Results</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;results&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结：性能优化决策"><a href="#总结：性能优化决策" class="headerlink" title="总结：性能优化决策"></a>总结：性能优化决策</h3><pre class="mermaid">graph TD
  A[性能问题?] -->|是| B{问题类型}
  A -->|否| C[无需优化]
  B -->|组件重渲染过多| D[React.memo+useCallback]
  B -->|计算开销大| E[useMemo]
  B -->|DOM操作频繁| F[useRef+useLayoutEffect]
  D --> G[验证优化效果]
  E --> G
  F --> G
  G -->|解决| H[停止]
  G -->|未解决| I[性能分析工具]</pre>

<h1 id="第四章：React-高级特性"><a href="#第四章：React-高级特性" class="headerlink" title="第四章：React 高级特性"></a>第四章：React 高级特性</h1><h2 id="4-1-性能优化（React-memo、useMemo、useCallback）"><a href="#4-1-性能优化（React-memo、useMemo、useCallback）" class="headerlink" title="4.1 性能优化（React.memo、useMemo、useCallback）"></a>4.1 性能优化（React.memo、useMemo、useCallback）</h2><h2 id="4-2-错误边界（ErrorBoundary）"><a href="#4-2-错误边界（ErrorBoundary）" class="headerlink" title="4.2 错误边界（ErrorBoundary）"></a>4.2 错误边界（ErrorBoundary）</h2><h2 id="4-3-代码分割与懒加载（React-lazy-Suspense）"><a href="#4-3-代码分割与懒加载（React-lazy-Suspense）" class="headerlink" title="4.3 代码分割与懒加载（React.lazy + Suspense）"></a>4.3 代码分割与懒加载（React.lazy + Suspense）</h2><h2 id="4-4-Portals（渲染到-DOM-外部节点）"><a href="#4-4-Portals（渲染到-DOM-外部节点）" class="headerlink" title="4.4 Portals（渲染到 DOM 外部节点）"></a>4.4 Portals（渲染到 DOM 外部节点）</h2><h2 id="4-5-高阶组件（HOC）与-Render-Props"><a href="#4-5-高阶组件（HOC）与-Render-Props" class="headerlink" title="4.5 高阶组件（HOC）与 Render Props"></a>4.5 高阶组件（HOC）与 Render Props</h2><h1 id="第五章：React-状态管理"><a href="#第五章：React-状态管理" class="headerlink" title="第五章：React 状态管理"></a>第五章：React 状态管理</h1><h2 id="5-1-状态提升与单向数据流"><a href="#5-1-状态提升与单向数据流" class="headerlink" title="5.1 状态提升与单向数据流"></a>5.1 状态提升与单向数据流</h2><h3 id="核心概念全景图"><a href="#核心概念全景图" class="headerlink" title="核心概念全景图"></a>核心概念全景图</h3><pre class="mermaid">graph TD
  A[状态管理方案] --> B[组件内部状态]
  A --> C[状态提升]
  A --> D[全局状态管理]
  C --> E[父子组件通信]
  C --> F[兄弟组件通信]</pre>

<h3 id="状态提升（Lifting-State-Up）深度解析"><a href="#状态提升（Lifting-State-Up）深度解析" class="headerlink" title="状态提升（Lifting State Up）深度解析"></a>状态提升（Lifting State Up）深度解析</h3><p><strong>基本定义</strong><br>将多个组件需要共享的状态提升到它们最近的公共父组件中管理，通过 props 向下传递数据，通过回调函数向上传递状态变更</p>
<p><strong>解决什么问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 问题场景：两个独立组件需要同步状态</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInputA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [temp, setTemp] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInputB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [temp, setTemp] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 无法保持两个输入框温度值同步</span><br></code></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. 状态提升到公共父组件</span><br>  <span class="hljs-keyword">const</span> [temperature, setTemperature] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 2. 通过props传递状态</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setTemperature&#125;</span> // <span class="hljs-attr">3.</span> <span class="hljs-attr">传递回调函数</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureDisplay</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 子组件成为受控组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInput</span>(<span class="hljs-params">&#123; value, onChange &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onChange(Number(e.target.value))&#125;</span><br><span class="language-xml">    /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单向数据流（Unidirectional-Data-Flow）"><a href="#单向数据流（Unidirectional-Data-Flow）" class="headerlink" title="单向数据流（Unidirectional Data Flow）"></a>单向数据流（Unidirectional Data Flow）</h3><p><strong>核心原则</strong></p>
<pre class="mermaid">graph LR
  A[State] --> B[UI]
  B --> C[Actions]
  C --> D[State Changes]
  D --> A</pre>

<p><strong>React 中的实现</strong></p>
<pre class="mermaid">graph TD
  P[父组件State] -->|Props| C1[子组件A]
  P -->|Props| C2[子组件B]
  C1 -->|回调函数| P
  C2 -->|回调函数| P</pre>

<p><strong>与双向绑定的对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">单向数据流</th>
<th align="left">双向绑定</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据方向</td>
<td align="left">父→子</td>
<td align="left">父⇄子</td>
</tr>
<tr>
<td align="left">状态管理</td>
<td align="left">集中管理</td>
<td align="left">分散管理</td>
</tr>
<tr>
<td align="left">数据可预测性</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">调试难度</td>
<td align="left">相对容易</td>
<td align="left">相对复杂</td>
</tr>
<tr>
<td align="left">典型框架</td>
<td align="left">React</td>
<td align="left">Vue&#x2F;Angular</td>
</tr>
</tbody></table>
<h3 id="状态提升的局限性"><a href="#状态提升的局限性" class="headerlink" title="状态提升的局限性"></a>状态提升的局限性</h3><ul>
<li>组件树层级过深时（超过3层）</li>
<li>非直系组件需要通信（如堂兄弟组件）</li>
<li>跨路由组件状态共享</li>
</ul>
<h3 id="现代状态管理方案基础"><a href="#现代状态管理方案基础" class="headerlink" title="现代状态管理方案基础"></a>现代状态管理方案基础</h3><p><strong>Flux 架构思想</strong></p>
<pre class="mermaid">graph LR
  A[Action] --> B[Dispatcher]
  B --> C[Store]
  C --> D[View]
  D --> A</pre>

<p><strong>状态提升 vs Redux</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">状态提升</th>
<th align="left">Redux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">状态存储</td>
<td align="left">组件 state</td>
<td align="left">独立 store</td>
</tr>
<tr>
<td align="left">状态更新</td>
<td align="left">setState</td>
<td align="left">dispatch(action)</td>
</tr>
<tr>
<td align="left">更新逻辑</td>
<td align="left">在组件内</td>
<td align="left">reducer 纯函数</td>
</tr>
<tr>
<td align="left">状态共享范围</td>
<td align="left">父组件及子组件</td>
<td align="left">全局可访问</td>
</tr>
<tr>
<td align="left">中间件支持</td>
<td align="left">无</td>
<td align="left">支持异步操作</td>
</tr>
</tbody></table>
<h3 id="最佳实践总结-1"><a href="#最佳实践总结-1" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol>
<li>最小状态原则：只提升必要共享的状态</li>
<li>保持状态局部：非共享状态保持在组件内部</li>
<li>避免过度提升：超过3层传递考虑 Context</li>
<li>数据不可变：状态更新时创建新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误</span><br>formData.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(newItem);<br><span class="hljs-title function_">setFormData</span>(formData);<br><br><span class="hljs-comment">// ✅ 正确</span><br><span class="hljs-title function_">setFormData</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123;<br>  ...prev,<br>  <span class="hljs-attr">items</span>: [...prev.<span class="hljs-property">items</span>, newItem]<br>&#125;));<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>回调函数命名：统一使用 on{Event} 格式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">Button</span> onSave=&#123;handleSave&#125; /&gt;<br></code></pre></td></tr></table></figure>

<h2 id="5-2-Redux-核心概念（Store、Action、Reducer）"><a href="#5-2-Redux-核心概念（Store、Action、Reducer）" class="headerlink" title="5.2 Redux 核心概念（Store、Action、Reducer）"></a>5.2 Redux 核心概念（Store、Action、Reducer）</h2><h3 id="Redux-三大核心概念全景图"><a href="#Redux-三大核心概念全景图" class="headerlink" title="Redux 三大核心概念全景图"></a>Redux 三大核心概念全景图</h3><pre class="mermaid">graph LR
  A[Action] -->|描述事件| B[Reducer]
  B -->|处理事件| C[Store]
  C -->|提供状态| D[View]
  D -->|触发| A</pre>

<h3 id="Action：状态变化的描述"><a href="#Action：状态变化的描述" class="headerlink" title="Action：状态变化的描述"></a>Action：状态变化的描述</h3><p><strong>本质与结构</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基本结构</span><br><span class="hljs-keyword">const</span> action = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,      <span class="hljs-comment">// 必需：动作类型</span><br>  <span class="hljs-attr">payload</span>: <span class="hljs-string">&#x27;Learn Redux&#x27;</span> <span class="hljs-comment">// 可选：携带数据</span><br>&#125;<br><br><span class="hljs-comment">// Flux Standard Action (FSA) 规范</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>,<br>  <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;, <span class="hljs-comment">// 成功数据</span><br>  <span class="hljs-attr">error</span>: <span class="hljs-literal">false</span>,                     <span class="hljs-comment">// 是否错误</span><br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &#125;    <span class="hljs-comment">// 元信息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Action 创建函数（Action Creators）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步 Action</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTodo</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,<br>    <span class="hljs-attr">payload</span>: text<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 异步 Action (需中间件支持)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> dispatch =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_REQUEST&#x27;</span> &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(id);<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_FAILURE&#x27;</span>, error &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Reducer：状态转换的纯函数"><a href="#Reducer：状态转换的纯函数" class="headerlink" title="Reducer：状态转换的纯函数"></a>Reducer：状态转换的纯函数</h3><p><strong>核心特征</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">todosReducer</span>(<span class="hljs-params">state = [], action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>      <span class="hljs-comment">// ✅ 正确：返回新对象</span><br>      <span class="hljs-keyword">return</span> [...state, &#123; <span class="hljs-attr">text</span>: action.<span class="hljs-property">payload</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;];<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TOGGLE_TODO&#x27;</span>:<br>      <span class="hljs-comment">// ✅ 正确：使用map创建新数组</span><br>      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> <br>        index === action.<span class="hljs-property">index</span> <br>          ? &#123; ...todo, <span class="hljs-attr">completed</span>: !todo.<span class="hljs-property">completed</span> &#125;<br>          : todo<br>      );<br>      <br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// ⚠️ 必须：返回当前state</span><br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>不可变更新模式</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">错误方式</th>
<th align="left">正确方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加项</td>
<td align="left">state.push(item)</td>
<td align="left">[…state, item]</td>
</tr>
<tr>
<td align="left">删除项</td>
<td align="left">state.splice(index, 1)</td>
<td align="left">state.filter((_, i) &#x3D;&gt; i !&#x3D;&#x3D; index)</td>
</tr>
<tr>
<td align="left">更新对象属性</td>
<td align="left">state[prop] &#x3D; value</td>
<td align="left">{ …state, [prop]: value }</td>
</tr>
<tr>
<td align="left">嵌套对象更新</td>
<td align="left">state.a.b &#x3D; value</td>
<td align="left">{ …state, a: { …state.a, b: value } }</td>
</tr>
</tbody></table>
<p><strong>Reducer 拆分与组合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 根Reducer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rootReducer</span>(<span class="hljs-params">state = &#123;&#125;, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">todos</span>: <span class="hljs-title function_">todosReducer</span>(state.<span class="hljs-property">todos</span>, action),<br>    <span class="hljs-attr">visibilityFilter</span>: <span class="hljs-title function_">filterReducer</span>(state.<span class="hljs-property">visibilityFilter</span>, action)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 combineReducers 简化</span><br><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<br>  <span class="hljs-attr">todos</span>: todosReducer,<br>  <span class="hljs-attr">visibilityFilter</span>: filterReducer<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="Store：应用状态的容器"><a href="#Store：应用状态的容器" class="headerlink" title="Store：应用状态的容器"></a>Store：应用状态的容器</h3><p><strong>核心职责</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><br><span class="hljs-comment">// 创建Store</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, initialState);<br><br><span class="hljs-comment">// 主要API</span><br>store.<span class="hljs-title function_">dispatch</span>(action);  <span class="hljs-comment">// 触发状态更新</span><br>store.<span class="hljs-title function_">getState</span>();        <span class="hljs-comment">// 获取当前状态</span><br>store.<span class="hljs-title function_">subscribe</span>(listener); <span class="hljs-comment">// 监听状态变化</span><br><br><span class="hljs-comment">// 使用示例</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;新状态:&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>&#125;);<br><br>store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;Learn Redux&#x27;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>Store 工作流程</strong></p>
<pre class="mermaid">sequenceDiagram
  participant View as 视图
  participant Store as Store
  participant Reducer as Reducer
  
  View->>Store: dispatch(action)
  Store->>Reducer: 当前state + action
  Reducer->>Reducer: 计算新state
  Reducer->>Store: 返回新state
  Store->>View: 通知订阅者更新</pre>

<h3 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h3><p>(1) 单一数据源 (Single Source of Truth)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 整个应用只有一个Store</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>());<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  todos: [],</span><br><span class="hljs-comment">  visibilityFilter: &#x27;SHOW_ALL&#x27;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>(2) 状态只读 (State is Read-Only)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 禁止直接修改</span><br>store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Illegal mutation!&#x27;</span>);<br><br><span class="hljs-comment">// ✅ 唯一修改方式：dispatch(action)</span><br>store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Legal update&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>(3) 纯函数修改 (Changes with Pure Functions)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Reducer必须是纯函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">impureReducer</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) &#123;<br>  <span class="hljs-comment">// ❌ 错误：包含副作用</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;state&#x27;</span>, state); <br>  <br>  <span class="hljs-comment">// ❌ 错误：不纯（依赖外部变量）</span><br>  <span class="hljs-keyword">return</span> state + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Redux-数据流完整周期"><a href="#Redux-数据流完整周期" class="headerlink" title="Redux 数据流完整周期"></a>Redux 数据流完整周期</h3><pre class="mermaid">sequenceDiagram
  participant View as 视图
  participant Action as Action
  participant Middleware as 中间件
  participant Store as Store
  participant Reducer as Reducer
  
  View->>Action: 用户交互触发
  Action->>Middleware: 处理异步/副作用
  Middleware->>Store: dispatch(action)
  Store->>Reducer: (currentState, action)
  Reducer->>Store: 返回newState
  Store->>View: 通知订阅者
  View->>View: 使用新状态重渲染</pre>

<h3 id="高频面试题与破解方案-12"><a href="#高频面试题与破解方案-12" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么Redux要求Reducer是纯函数？</strong></p>
<ol>
<li>可预测性：相同输入必定得到相同输出</li>
<li>时间旅行：支持状态快照和回滚</li>
<li>易于测试：无需模拟环境，直接测试输入输出</li>
<li>性能优化：可安全进行浅比较</li>
</ol>
<p><strong>Q：Redux如何实现时间旅行调试？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 核心原理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer</span>) &#123;<br>  <span class="hljs-keyword">let</span> state = initialState;<br>  <span class="hljs-keyword">const</span> listeners = [];<br>  <span class="hljs-keyword">const</span> history = []; <span class="hljs-comment">// ⭐ 历史状态记录</span><br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<br>      history.<span class="hljs-title function_">push</span>(state); <span class="hljs-comment">// 保存当前状态</span><br>      state = <span class="hljs-title function_">reducer</span>(state, action); <span class="hljs-comment">// 计算新状态</span><br>      listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());<br>    &#125;,<br>    <span class="hljs-attr">getState</span>: <span class="hljs-function">() =&gt;</span> state,<br>    <span class="hljs-attr">undo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (history.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        state = history.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 恢复历史状态</span><br>        listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际使用redux-undo库</span><br><span class="hljs-keyword">import</span> undoable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-undo&#x27;</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(<span class="hljs-title function_">undoable</span>(rootReducer));<br></code></pre></td></tr></table></figure>

<p><strong>Q：Redux与Flux架构有何区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Redux</th>
<th align="left">Flux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Store数量</td>
<td align="left">单一Store</td>
<td align="left">多个Store</td>
</tr>
<tr>
<td align="left">Dispatcher</td>
<td align="left">无独立Dispatcher</td>
<td align="left">有中央Dispatcher</td>
</tr>
<tr>
<td align="left">状态更新</td>
<td align="left">纯函数Reducer</td>
<td align="left">Store内方法更新</td>
</tr>
<tr>
<td align="left">样板代码</td>
<td align="left">相对较少</td>
<td align="left">相对较多</td>
</tr>
<tr>
<td align="left">时间旅行</td>
<td align="left">原生支持</td>
<td align="left">需要额外实现</td>
</tr>
</tbody></table>
<h3 id="Redux-在函数组件中的使用"><a href="#Redux-在函数组件中的使用" class="headerlink" title="Redux 在函数组件中的使用"></a>Redux 在函数组件中的使用</h3><p><strong>基础连接方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-comment">// 根组件包裹Provider</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br><span class="hljs-comment">// 子组件连接</span><br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">&#123; todos, dispatch &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123; <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span> &#125;), <span class="hljs-comment">// mapStateToProps</span><br>  <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)         <span class="hljs-comment">// mapDispatchToProps</span><br>)(<span class="hljs-title class_">TodoList</span>);<br></code></pre></td></tr></table></figure>

<p><strong>Hooks API（推荐）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取状态</span><br>  <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">todos</span>);<br>  <br>  <span class="hljs-comment">// 获取dispatch函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = text =&gt; <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, text &#125;);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;todos.map(todo =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Redux-中间件机制"><a href="#Redux-中间件机制" class="headerlink" title="Redux 中间件机制"></a>Redux 中间件机制</h3><p><strong>中间件原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 中间件签名</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">middleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理前逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action);<br>  <br>  <span class="hljs-comment">// 调用下一个中间件</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">next</span>(action);<br>  <br>  <span class="hljs-comment">// 处理后逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// 创建支持中间件的store</span><br><span class="hljs-keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(<br>  rootReducer,<br>  <span class="hljs-title function_">applyMiddleware</span>(middleware1, middleware2)<br>);<br></code></pre></td></tr></table></figure>

<p><strong>常用中间件</strong></p>
<table>
<thead>
<tr>
<th align="left">中间件</th>
<th align="left">解决的核心问题</th>
<th align="left">典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">redux-thunk</td>
<td align="left">异步Action处理</td>
<td align="left">简单API请求</td>
</tr>
<tr>
<td align="left">redux-saga</td>
<td align="left">复杂异步流程管理</td>
<td align="left">多步骤异步、竞态处理</td>
</tr>
<tr>
<td align="left">redux-observable</td>
<td align="left">响应式编程</td>
<td align="left">复杂事件流处理</td>
</tr>
<tr>
<td align="left">redux-logger</td>
<td align="left">状态变更日志</td>
<td align="left">开发环境调试</td>
</tr>
</tbody></table>
<h3 id="Redux-最佳实践"><a href="#Redux-最佳实践" class="headerlink" title="Redux 最佳实践"></a>Redux 最佳实践</h3><p><strong>项目结构组织</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>  ├── store/           <span class="hljs-comment"># Redux相关</span><br>  │   ├── actions/     <span class="hljs-comment"># Action创建函数</span><br>  │   ├── reducers/    <span class="hljs-comment"># Reducer函数</span><br>  │   ├── sagas/       <span class="hljs-comment"># Saga中间件</span><br>  │   └── store.js     <span class="hljs-comment"># Store配置</span><br>  │<br>  ├── components/      <span class="hljs-comment"># 展示组件</span><br>  └── containers/      <span class="hljs-comment"># 容器组件</span><br></code></pre></td></tr></table></figure>

<p><strong>命名规范</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Action类型：&lt;名词&gt;_&lt;动词&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USER_FETCH_REQUESTED</span> = <span class="hljs-string">&#x27;USER_FETCH_REQUESTED&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TODOS_ADD</span> = <span class="hljs-string">&#x27;TODOS_ADD&#x27;</span>;<br><br><span class="hljs-comment">// Action创建函数：动词+名词</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>) &#123; ... &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addTodo</span>(<span class="hljs-params">text</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<p><strong>状态设计原则</strong></p>
<ol>
<li>扁平化结构：避免嵌套过深</li>
<li>按业务域拆分：不同功能独立状态分支</li>
<li>ID驱动：通过ID关联数据</li>
</ol>
<h3 id="总结：Redux-核心概念关系图"><a href="#总结：Redux-核心概念关系图" class="headerlink" title="总结：Redux 核心概念关系图"></a>总结：Redux 核心概念关系图</h3><pre class="mermaid">graph TD
  A[Action] -->|描述| B[Reducer]
  B -->|生成| C[Store]
  C -->|提供| D[View]
  D -->|触发| A
  E[Middleware] -->|拦截| A
  F[Selector] -->|获取| C
  G[React-Redux] -->|连接| D</pre>

<h2 id="5-3-Redux-中间件（redux-thunk、redux-saga）"><a href="#5-3-Redux-中间件（redux-thunk、redux-saga）" class="headerlink" title="5.3 Redux 中间件（redux-thunk、redux-saga）"></a>5.3 Redux 中间件（redux-thunk、redux-saga）</h2><h3 id="Redux-中间件核心原理"><a href="#Redux-中间件核心原理" class="headerlink" title="Redux 中间件核心原理"></a>Redux 中间件核心原理</h3><p><strong>中间件在数据流中的位置</strong></p>
<pre class="mermaid">graph LR
  A[View] -->|dispatch| B[Middleware]
  B -->|"next(action)"| C[Reducer]
  C --> D[Store]
  D -->|newState| A</pre>

<p><strong>中间件签名与执行链</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 中间件结构（柯里化函数）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">middleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 前置处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dispatching:&#x27;</span>, action);<br>  <br>  <span class="hljs-comment">// 传递 action 给下一个中间件或 reducer</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">next</span>(action);<br>  <br>  <span class="hljs-comment">// 后置处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state:&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// 中间件执行顺序</span><br><span class="hljs-title function_">applyMiddleware</span>(mid1, mid2, mid3)<br><span class="hljs-comment">// 实际调用顺序：</span><br><span class="hljs-comment">// mid1(store) -&gt; mid2(store) -&gt; mid3(store) -&gt; reducer</span><br></code></pre></td></tr></table></figure>

<h3 id="redux-thunk：处理简单异步"><a href="#redux-thunk：处理简单异步" class="headerlink" title="redux-thunk：处理简单异步"></a>redux-thunk：处理简单异步</h3><p><strong>核心概念</strong></p>
<p>允许 action 创建函数返回函数（而不仅是对象），该函数接收 dispatch 和 getState 作为参数</p>
<p><strong>使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步 action</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 异步 action (thunk)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params">userId</span>) =&gt; <span class="hljs-title function_">async</span> (dispatch, getState) =&gt; &#123;<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_REQUEST&#x27;</span> &#125;);<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(userId);<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>    <br>    <span class="hljs-comment">// 可访问当前状态</span><br>    <span class="hljs-keyword">const</span> &#123; settings &#125; = <span class="hljs-title function_">getState</span>();<br>    <span class="hljs-keyword">if</span> (settings.<span class="hljs-property">notify</span>) <span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;用户加载成功&#x27;</span>);<br>    <br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FAILURE&#x27;</span>, error &#125;);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 组件中触发</span><br><span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchUser</span>(<span class="hljs-number">123</span>));<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>API 请求</li>
<li>简单异步操作</li>
<li>需要访问当前状态的异步逻辑</li>
</ul>
<p><strong>优点与局限</strong></p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">局限</th>
</tr>
</thead>
<tbody><tr>
<td align="left">学习成本低</td>
<td align="left">复杂异步流程难管理</td>
</tr>
<tr>
<td align="left">代码简洁</td>
<td align="left">测试相对复杂</td>
</tr>
<tr>
<td align="left">无需额外库</td>
<td align="left">不支持高级异步模式</td>
</tr>
</tbody></table>
<h3 id="redux-saga：处理复杂异步"><a href="#redux-saga：处理复杂异步" class="headerlink" title="redux-saga：处理复杂异步"></a>redux-saga：处理复杂异步</h3><p><strong>核心概念</strong></p>
<pre class="mermaid">graph TD
  A[View] -->|dispatch| B[Action]
  B --> C[Watcher Saga]
  C --> D[Worker Saga]
  D --> E[API Call]
  E --> F[Action to Store]</pre>

<p><strong>关键特性</strong></p>
<ul>
<li>基于 ES6 Generator 函数</li>
<li>集中管理副作用（side effects）</li>
<li>提供丰富异步控制原语（takeEvery, takeLatest 等）</li>
<li>支持竞态条件处理、并行任务等复杂场景</li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; call, put, takeEvery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span>;<br><br><span class="hljs-comment">// Worker Saga</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">action</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(api.<span class="hljs-property">getUser</span>, action.<span class="hljs-property">payload</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FAILURE&#x27;</span>, error &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Watcher Saga</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">watchUserRequests</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&#x27;USER_REQUEST&#x27;</span>, fetchUser);<br>&#125;<br><br><span class="hljs-comment">// 根Saga</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">rootSaga</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">all</span>([<br>    <span class="hljs-title function_">watchUserRequests</span>(),<br>    <span class="hljs-comment">// 其他 watcher</span><br>  ]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>常用 Effect 原语</strong></p>
<table>
<thead>
<tr>
<th align="left">Effect</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">call</td>
<td align="left">调用异步函数</td>
<td align="left">yield call(api.fetch, url)</td>
</tr>
<tr>
<td align="left">put</td>
<td align="left">发起 action</td>
<td align="left">yield put({ type: ‘SUCCESS’ })</td>
</tr>
<tr>
<td align="left">take</td>
<td align="left">等待指定 action</td>
<td align="left">yield take(‘ACTION’)</td>
</tr>
<tr>
<td align="left">takeEvery</td>
<td align="left">监听每个 action</td>
<td align="left">yield takeEvery(‘ACTION’, saga)</td>
</tr>
<tr>
<td align="left">takeLatest</td>
<td align="left">只响应最新的 action</td>
<td align="left">yield takeLatest(‘ACTION’, saga)</td>
</tr>
<tr>
<td align="left">fork</td>
<td align="left">非阻塞调用 saga</td>
<td align="left">yield fork(otherSaga)</td>
</tr>
<tr>
<td align="left">all</td>
<td align="left">并行运行多个 Effect</td>
<td align="left">yield all([call(a), call(b)])</td>
</tr>
<tr>
<td align="left">race</td>
<td align="left">竞态执行</td>
<td align="left">yield race({ task: call(fn), cancel: take(‘CANCEL’) })</td>
</tr>
</tbody></table>
<h3 id="高频面试题与破解方案-13"><a href="#高频面试题与破解方案-13" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么需要中间件处理异步？</strong></p>
<ol>
<li>Redux 自身限制：reducer 必须是纯函数，不能包含副作用</li>
<li>可预测性：集中管理副作用，避免分散在组件中</li>
<li>可维护性：统一处理错误、日志、重试等通用逻辑</li>
<li>高级功能：实现请求取消、竞态处理等复杂场景</li>
</ol>
<p><strong>Q：如何选择 thunk 还是 saga？</strong></p>
<pre class="mermaid">graph TD
  A[项目需求] --> B{异步复杂度}
  B -->|简单API请求| C[redux-thunk]
  B -->|复杂流程/竞态| D[redux-saga]
  A --> E{团队熟悉度}
  E -->|熟悉Generator| D
  E -->|新手团队| C
  A --> F{包大小敏感}
  F -->|是| C
  F -->|否| D</pre>

<h2 id="5-4-React-Redux（Provider、useSelector、useDispatch）"><a href="#5-4-React-Redux（Provider、useSelector、useDispatch）" class="headerlink" title="5.4 React-Redux（Provider、useSelector、useDispatch）"></a>5.4 React-Redux（Provider、useSelector、useDispatch）</h2><h3 id="React-Redux-核心架构图"><a href="#React-Redux-核心架构图" class="headerlink" title="React-Redux 核心架构图"></a>React-Redux 核心架构图</h3><pre class="mermaid">graph TD
  A[Redux Store] --> B[Provider]
  B -->|Context| C[React Components]
  C -->|useSelector| A
  C -->|useDispatch| A</pre>

<h3 id="Provider：状态注入的基石"><a href="#Provider：状态注入的基石" class="headerlink" title="Provider：状态注入的基石"></a>Provider：状态注入的基石</h3><p><strong>核心作用与原理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainApp</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>作用：通过 React Context 将 Redux store 注入整个组件树</li>
<li>原理：使用 React.createContext() 创建 Store 上下文</li>
<li>位置：必须在组件树最顶层</li>
</ul>
<p><strong>实现原理揭秘</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 简化版 Provider 实现</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Provider</span>(<span class="hljs-params">&#123; store, children &#125;</span>) &#123;<br>  <span class="hljs-comment">// 使用 useMemo 避免重复渲染</span><br>  <span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; store &#125;), [store]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StoreContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;contextValue&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">StoreContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useSelector：精准状态选择"><a href="#useSelector：精准状态选择" class="headerlink" title="useSelector：精准状态选择"></a>useSelector：精准状态选择</h3><p><strong>基础用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 从 Redux store 选择所需状态</span><br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>性能优化机制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 默认使用 === 严格相等比较</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>);<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>,<br>  <span class="hljs-function">(<span class="hljs-params">prevUser, nextUser</span>) =&gt;</span> prevUser.<span class="hljs-property">id</span> === nextUser.<span class="hljs-property">id</span><br>);<br></code></pre></td></tr></table></figure>

<p><strong>高级选择器模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 reselect 库创建记忆化选择器</span><br><span class="hljs-keyword">import</span> &#123; createSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;reselect&#x27;</span>;<br><br><span class="hljs-keyword">const</span> selectActiveUsers = <span class="hljs-title function_">createSelector</span>(<br>  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">users</span>],<br>  <span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">isActive</span>)<br>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ActiveUsersList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> activeUsers = <span class="hljs-title function_">useSelector</span>(selectActiveUsers);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useDispatch：触发状态更新"><a href="#useDispatch：触发状态更新" class="headerlink" title="useDispatch：触发状态更新"></a>useDispatch：触发状态更新</h3><p><strong>基础用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddTodoButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;New todo&#x27;</span> &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>封装动作创建函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动作创建函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = (<span class="hljs-params">text</span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, text &#125;);<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddTodoButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;New todo&#x27;</span>)); <span class="hljs-comment">// 直接 dispatch action</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>异步操作集成</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 redux-thunk</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params">id</span>) =&gt; <span class="hljs-keyword">async</span> dispatch =&gt; &#123;<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_REQUEST&#x27;</span> &#125;);<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(id);<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserLoader</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchUser</span>(<span class="hljs-number">123</span>));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三大-Hook-协作模式"><a href="#三大-Hook-协作模式" class="headerlink" title="三大 Hook 协作模式"></a>三大 Hook 协作模式</h3><p>完整数据流示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. 获取状态</span><br>  <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">todos</span>);<br>  <br>  <span class="hljs-comment">// 2. 获取 dispatch 函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-comment">// 3. 事件处理</span><br>  <span class="hljs-keyword">const</span> handleAdd = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;新任务&#x27;</span>));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-keyword">const</span> handleToggle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">toggleTodo</span>(id));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleAdd&#125;</span>&gt;</span>添加任务<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;todos.map(todo =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onToggle</span>=<span class="hljs-string">&#123;handleToggle&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="connect-高阶组件（传统写法）"><a href="#connect-高阶组件（传统写法）" class="headerlink" title="connect 高阶组件（传统写法）"></a>connect 高阶组件（传统写法）</h3><p><strong>mapStateToProps</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state, ownProps</span>) =&gt; (&#123;<br>  <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span>,<br>  <span class="hljs-attr">currentUser</span>: state.<span class="hljs-property">users</span>[ownProps.<span class="hljs-property">userId</span>]<br>&#125;);<br><br><span class="hljs-comment">// 组件中通过 props 访问</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">&#123; todos, currentUser &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>mapDispatchToProps</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 对象简写（自动绑定 dispatch）</span><br><span class="hljs-keyword">const</span> mapDispatchToProps = &#123;<br>  addTodo,<br>  deleteTodo<br>&#125;;<br><br><span class="hljs-comment">// 函数形式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;<br>  <span class="hljs-attr">addTodo</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(text)),<br>  <span class="hljs-attr">deleteTodo</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">deleteTodo</span>(id))<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>connect 使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ConnectedTodoList</span> = <span class="hljs-title function_">connect</span>(<br>  mapStateToProps,<br>  mapDispatchToProps<br>)(<span class="hljs-title class_">TodoList</span>);<br></code></pre></td></tr></table></figure>

<h3 id="高频面试题与破解方案-14"><a href="#高频面试题与破解方案-14" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么需要 React-Redux？</strong></p>
<ol>
<li>解耦组件：避免组件直接依赖 Redux store</li>
<li>性能优化：自动实现 shouldComponentUpdate 优化</li>
<li>上下文管理：通过 Provider 优雅注入 store</li>
<li>简化开发：提供 useSelector&#x2F;useDispatch 便捷 API</li>
<li>未来兼容：官方维护，保证与 React 新特性兼容</li>
</ol>
<p><strong>Q：useSelector 如何避免不必要重渲染？</strong></p>
<p>优化策略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 策略1：返回原始值（非引用类型）</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counter</span>); <span class="hljs-comment">// number</span><br><br><span class="hljs-comment">// 策略2：使用浅比较</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>, shallowEqual);<br><br><span class="hljs-comment">// 策略3：记忆化选择器</span><br><span class="hljs-keyword">const</span> selectUser = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123; <span class="hljs-attr">name</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>, <span class="hljs-attr">id</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">id</span> &#125;), <br>  []<br>);<br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">useSelector</span>(selectUser);<br></code></pre></td></tr></table></figure>

<p><strong>Q：如何在类组件中使用 Hooks？</strong></p>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建连接组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withReduxHooks</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">data</span>);<br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> <span class="hljs-attr">dispatch</span>=<span class="hljs-string">&#123;dispatch&#125;</span> /&gt;</span></span>;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LegacyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// 通过 props 访问 data 和 dispatch</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withReduxHooks</span>(<span class="hljs-title class_">LegacyComponent</span>);<br></code></pre></td></tr></table></figure>

<h3 id="总结：React-Redux-核心知识点"><a href="#总结：React-Redux-核心知识点" class="headerlink" title="总结：React-Redux 核心知识点"></a>总结：React-Redux 核心知识点</h3><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">作用</th>
<th align="left">最佳实践</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Provider</td>
<td align="left">注入 Redux store 到组件树</td>
<td align="left">包裹整个应用根组件</td>
</tr>
<tr>
<td align="left">useSelector</td>
<td align="left">从 store 选择状态</td>
<td align="left">返回原始值 + 精细选择</td>
</tr>
<tr>
<td align="left">useDispatch</td>
<td align="left">获取 dispatch 方法</td>
<td align="left">封装动作创建函数</td>
</tr>
<tr>
<td align="left">connect</td>
<td align="left">类组件连接方案（传统）</td>
<td align="left">使用 mapState&#x2F;mapDispatch</td>
</tr>
<tr>
<td align="left">记忆化选择器</td>
<td align="left">优化性能</td>
<td align="left">使用 reselect 或 useMemo</td>
</tr>
<tr>
<td align="left">Redux Toolkit</td>
<td align="left">现代 Redux 开发标准</td>
<td align="left">使用 createSlice + configureStore</td>
</tr>
</tbody></table>
<h2 id="5-5-现代状态管理方案（Recoil、Zustand、Jotai）"><a href="#5-5-现代状态管理方案（Recoil、Zustand、Jotai）" class="headerlink" title="5.5 现代状态管理方案（Recoil、Zustand、Jotai）"></a>5.5 现代状态管理方案（Recoil、Zustand、Jotai）</h2><h1 id="第六章：React-Router-与数据请求"><a href="#第六章：React-Router-与数据请求" class="headerlink" title="第六章：React Router 与数据请求"></a>第六章：React Router 与数据请求</h1><h2 id="6-1-React-Router-基础（BrowserRouter、Route、Link）"><a href="#6-1-React-Router-基础（BrowserRouter、Route、Link）" class="headerlink" title="6.1 React Router 基础（BrowserRouter、Route、Link）"></a>6.1 React Router 基础（BrowserRouter、Route、Link）</h2><h2 id="6-2-动态路由与嵌套路由"><a href="#6-2-动态路由与嵌套路由" class="headerlink" title="6.2 动态路由与嵌套路由"></a>6.2 动态路由与嵌套路由</h2><h2 id="6-3-路由守卫与权限控制"><a href="#6-3-路由守卫与权限控制" class="headerlink" title="6.3 路由守卫与权限控制"></a>6.3 路由守卫与权限控制</h2><h2 id="6-4-数据请求方案（fetch、axios、React-Query、SWR）"><a href="#6-4-数据请求方案（fetch、axios、React-Query、SWR）" class="headerlink" title="6.4 数据请求方案（fetch、axios、React Query、SWR）"></a>6.4 数据请求方案（fetch、axios、React Query、SWR）</h2><h2 id="6-5-SSR-与-Next-js-基础"><a href="#6-5-SSR-与-Next-js-基础" class="headerlink" title="6.5 SSR 与 Next.js 基础"></a>6.5 SSR 与 Next.js 基础</h2><h1 id="第七章：React-工程化与优化"><a href="#第七章：React-工程化与优化" class="headerlink" title="第七章：React 工程化与优化"></a>第七章：React 工程化与优化</h1><h2 id="7-1-组件设计模式（复合组件、受控组件模式）"><a href="#7-1-组件设计模式（复合组件、受控组件模式）" class="headerlink" title="7.1 组件设计模式（复合组件、受控组件模式）"></a>7.1 组件设计模式（复合组件、受控组件模式）</h2><h2 id="7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）"><a href="#7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）" class="headerlink" title="7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）"></a>7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）</h2><h2 id="7-3-测试（Jest-React-Testing-Library）"><a href="#7-3-测试（Jest-React-Testing-Library）" class="headerlink" title="7.3 测试（Jest + React Testing Library）"></a>7.3 测试（Jest + React Testing Library）</h2><h2 id="7-4-性能优化（React-Profiler、减少重渲染）"><a href="#7-4-性能优化（React-Profiler、减少重渲染）" class="headerlink" title="7.4 性能优化（React Profiler、减少重渲染）"></a>7.4 性能优化（React Profiler、减少重渲染）</h2><h2 id="7-5-构建工具（Webpack-配置、Vite-优化）"><a href="#7-5-构建工具（Webpack-配置、Vite-优化）" class="headerlink" title="7.5 构建工具（Webpack 配置、Vite 优化）"></a>7.5 构建工具（Webpack 配置、Vite 优化）</h2><h1 id="第八章：React-18-新特性与未来趋势"><a href="#第八章：React-18-新特性与未来趋势" class="headerlink" title="第八章：React 18 新特性与未来趋势"></a>第八章：React 18 新特性与未来趋势</h1><h2 id="8-1-Concurrent-Mode（并发渲染）"><a href="#8-1-Concurrent-Mode（并发渲染）" class="headerlink" title="8.1 Concurrent Mode（并发渲染）"></a>8.1 Concurrent Mode（并发渲染）</h2><h2 id="8-2-自动批处理（Automatic-Batching）"><a href="#8-2-自动批处理（Automatic-Batching）" class="headerlink" title="8.2 自动批处理（Automatic Batching）"></a>8.2 自动批处理（Automatic Batching）</h2><h2 id="8-3-Transition-API（startTransition）"><a href="#8-3-Transition-API（startTransition）" class="headerlink" title="8.3 Transition API（startTransition）"></a>8.3 Transition API（startTransition）</h2><h2 id="8-4-Server-Components（服务端组件）"><a href="#8-4-Server-Components（服务端组件）" class="headerlink" title="8.4 Server Components（服务端组件）"></a>8.4 Server Components（服务端组件）</h2><h2 id="8-5-React-生态趋势（RSC、React-Native）"><a href="#8-5-React-生态趋势（RSC、React-Native）" class="headerlink" title="8.5 React 生态趋势（RSC、React Native）"></a>8.5 React 生态趋势（RSC、React Native）</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/React/" class="category-chain-item">React</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/React/" class="print-no-link">#React</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>React 知识体系专题学习</div>
      <div>https://tianfei92.github.io/2025/06/23/React Study Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ariel</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/29/Performance%20Optimization/" title="前端性能优化知识专题学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端性能优化知识专题学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/22/CSS%20Study%20Notes/" title="CSS 专题知识学习">
                        <span class="hidden-mobile">CSS 专题知识学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
