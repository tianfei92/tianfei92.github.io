

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ariel">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、性能指标体系与监控1.1 核心性能指标 (Web Vitals)LCP (最大内容渲染时间)LCP 核心定义  官方标准： 测量 视口内最大文本&#x2F;图片元素 从页面开始加载到其渲染完成的时间 反映用户感知的主要内容可见性速度   性能阈值（Chrome官方）: Good（优）：≤ 2.5 秒 Needs Improvement（需优化）：2.6 - 4.0 秒 Poor（差）：&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="前端性能优化知识专题学习">
<meta property="og:url" content="https://tianfei92.github.io/2025/06/29/Performance%20Optimization/index.html">
<meta property="og:site_name" content="Ariel&#39;s Blog">
<meta property="og:description" content="一、性能指标体系与监控1.1 核心性能指标 (Web Vitals)LCP (最大内容渲染时间)LCP 核心定义  官方标准： 测量 视口内最大文本&#x2F;图片元素 从页面开始加载到其渲染完成的时间 反映用户感知的主要内容可见性速度   性能阈值（Chrome官方）: Good（优）：≤ 2.5 秒 Needs Improvement（需优化）：2.6 - 4.0 秒 Poor（差）：&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-29T08:56:27.000Z">
<meta property="article:modified_time" content="2025-06-30T12:44:51.599Z">
<meta property="article:author" content="Ariel">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>前端性能优化知识专题学习 - Ariel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tianfei92.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ariel</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端性能优化知识专题学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-29 16:56" pubdate>
          2025年6月29日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          198 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">前端性能优化知识专题学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、性能指标体系与监控"><a href="#一、性能指标体系与监控" class="headerlink" title="一、性能指标体系与监控"></a>一、性能指标体系与监控</h1><h2 id="1-1-核心性能指标-Web-Vitals"><a href="#1-1-核心性能指标-Web-Vitals" class="headerlink" title="1.1 核心性能指标 (Web Vitals)"></a>1.1 核心性能指标 (Web Vitals)</h2><h3 id="LCP-最大内容渲染时间"><a href="#LCP-最大内容渲染时间" class="headerlink" title="LCP (最大内容渲染时间)"></a>LCP (最大内容渲染时间)</h3><p><strong>LCP 核心定义</strong></p>
<ul>
<li>官方标准：<ul>
<li>测量 视口内最大文本&#x2F;图片元素 从页面开始加载到其渲染完成的时间</li>
<li>反映用户感知的主要内容可见性速度</li>
</ul>
</li>
<li>性能阈值（Chrome官方）:<ul>
<li>Good（优）：≤ 2.5 秒</li>
<li>Needs Improvement（需优化）：2.6 - 4.0 秒</li>
<li>Poor（差）：&gt; 4.0 秒</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p><strong>LCP 计算规则</strong></p>
<ul>
<li>候选元素类型（按优先级）:<ul>
<li><code>&lt;img&gt;</code> 标签（含src或srcset）</li>
<li><code>&lt;image&gt;</code> 在 SVG 中的元素</li>
<li><code>&lt;video&gt;</code> 的封面图（poster属性）</li>
<li>通过 url() 加载背景图的块级元素</li>
<li>包含文本节点的块级元素（如<code>&lt;p&gt;、&lt;h1&gt;</code>）</li>
</ul>
</li>
<li>判定逻辑:<ul>
<li>取 视口内可见区域 面积最大的元素</li>
<li>若元素在渲染后被移除&#x2F;尺寸变化，取最终稳定状态</li>
</ul>
</li>
</ul>
<p><strong>影响 LCP 的关键因素</strong></p>
<table>
<thead>
<tr>
<th align="left">因素</th>
<th align="left">具体原因</th>
<th align="left">典型场景示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">资源加载延迟</td>
<td align="left">关键图片&#x2F;字体未优先加载</td>
<td align="left">未对首屏图片添加 preload</td>
</tr>
<tr>
<td align="left">服务端响应慢</td>
<td align="left">TTFB（首字节时间）过高</td>
<td align="left">未启用 CDN&#x2F;数据库查询慢</td>
</tr>
<tr>
<td align="left">渲染阻塞</td>
<td align="left">CSS&#x2F;JS 文件阻塞主线程</td>
<td align="left">未拆分关键 CSS&#x2F;未异步加载 JS</td>
</tr>
<tr>
<td align="left">布局偏移干扰</td>
<td align="left">动态插入内容导致最大元素变化</td>
<td align="left">广告位异步加载</td>
</tr>
</tbody></table>
<p><strong>LCP 优化手段</strong></p>
<p>(1) 资源优先级提升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 预加载 LCP 图片 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;hero-image.webp&quot; as=&quot;image&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>(2) 服务端加速</p>
<ul>
<li>采用 HTTP&#x2F;2 + TLS1.3</li>
<li>边缘缓存（CDN 静态资源）</li>
</ul>
<p>(3) 渲染关键路径优化</p>
<ul>
<li>内联关键 CSS（Critical CSS）</li>
<li>延迟非关键 JS（async&#x2F;defer）</li>
</ul>
<p>(4) 媒体资源针对性处理</p>
<ul>
<li>使用 <code>&lt;img loading=&quot;eager&quot;&gt;</code> 覆盖默认懒加载</li>
<li>响应式图片适配：srcset + sizes</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;img srcset=&quot;small.jpg 480w, medium.jpg 768w, large.jpg 1200w&quot;<br>     sizes=&quot;(max-width: 600px) 480px, 100vw&quot;<br>     src=&quot;fallback.jpg&quot; alt=&quot;Hero Image&quot;&gt;<br></code></pre></td></tr></table></figure>

<p><strong>LCP 测量工具</strong></p>
<ul>
<li>Chrome DevTools → Performance 面板（查看 Timings 中的 LCP 标记）</li>
</ul>
<p><strong>常见误区</strong></p>
<ul>
<li>错误认知<ul>
<li>❌ LCP 只关注图片 → ✅ 包含文本&#x2F;视频封面等任何最大元素</li>
<li>❌ 背景图一定计入 → ✅ 仅当元素为块级且尺寸明确时有效</li>
</ul>
</li>
<li>实践陷阱<ul>
<li>使用骨架屏（Skeleton Screen）可能延长 LCP（骨架屏本身可能被计为最大元素）</li>
<li>动态插入的广告&#x2F;Banner 若成为最大元素，其加载时间将主导 LCP</li>
</ul>
</li>
</ul>
<h3 id="FID-首次输入延迟-→-INP-Interaction-to-Next-Paint"><a href="#FID-首次输入延迟-→-INP-Interaction-to-Next-Paint" class="headerlink" title="FID (首次输入延迟) → INP (Interaction to Next Paint)"></a>FID (首次输入延迟) → INP (Interaction to Next Paint)</h3><p><strong>FID（首次输入延迟）核心概念</strong></p>
<p>定义：</p>
<ul>
<li>测量用户首次交互（点击&#x2F;触摸&#x2F;按键）到浏览器实际响应的时间差</li>
<li>量化页面可交互性的核心指标（反映主线程阻塞程度）</li>
</ul>
<p>性能阈值：</p>
<ul>
<li>Good（优）：≤ 100ms</li>
<li>Needs Improvement（需优化）：101 - 300ms</li>
<li>Poor（差）：&gt; 300ms</li>
</ul>
<p>关键局限：</p>
<ul>
<li>仅测量首次交互延迟</li>
<li>无法捕获页面生命周期中的持续交互体验</li>
</ul>
<p><strong>INP（下次绘制交互）取代 FID 的原因</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">FID (旧标准)</th>
<th align="left">INP (新标准)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">测量范围</td>
<td align="left">仅首次交互</td>
<td align="left">所有关键交互（滚动&#x2F;点击&#x2F;输入）</td>
</tr>
<tr>
<td align="left">时间覆盖</td>
<td align="left">页面加载初期</td>
<td align="left">整个页面生命周期</td>
</tr>
<tr>
<td align="left">代表性</td>
<td align="left">部分场景失真</td>
<td align="left">更全面反映真实用户体验</td>
</tr>
<tr>
<td align="left">官方状态</td>
<td align="left">2023年起逐步淘汰</td>
<td align="left">Chrome官方推荐指标（2024年成为Core Web Vital）</td>
</tr>
</tbody></table>
<p><strong>INP 核心机制</strong></p>
<p>(1) 测量原理</p>
<pre class="mermaid">graph LR
A[用户交互] --> B{事件触发}
B --> C[输入延迟]
C --> D[处理时间]
D --> E[呈现延迟]
E --> F[下次画面更新]</pre>

<ul>
<li>总耗时 &#x3D; 输入延迟 + 事件处理时间 + 呈现延迟</li>
</ul>
<p>(2) 性能阈值</p>
<ul>
<li>Good（优）：≤ 200ms</li>
<li>Needs Improvement（需优化）：201 - 500ms</li>
<li>Poor（差）：&gt; 500ms</li>
</ul>
<p>(3) 关键交互定义</p>
<ul>
<li>取所有交互事件中最慢的第98百分位值（排除长尾异常值）</li>
</ul>
<p><strong>影响 INP 的关键因素</strong></p>
<ul>
<li>长任务（Long Tasks）<ul>
<li>主线程阻塞 &gt; 50ms 的 JS 任务</li>
<li>典型场景：未优化的第三方脚本</li>
</ul>
</li>
<li>渲染效率低下<ul>
<li>复杂样式计算 &#x2F; 布局抖动（Layout Thrashing）</li>
<li>过度重绘（Repaint）</li>
</ul>
</li>
<li>内存压力<ul>
<li>频繁 GC（垃圾回收）导致暂停</li>
<li>内存泄漏积累</li>
</ul>
</li>
</ul>
<p><strong>INP 优化策略</strong></p>
<p>(1) 任务拆分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 将长任务拆分为 &lt;50ms 的片段</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">while</span> (tasks.<span class="hljs-property">length</span> &amp;&amp; performance.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">50</span>) &#123;<br>      <span class="hljs-title function_">executeTask</span>(tasks.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(processChunk, <span class="hljs-number">0</span>); <span class="hljs-comment">// 让出主线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 交互优先级调度</p>
<p>关键交互使用 scheduler.postTask() 高优先级:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskController</span>(&#123; <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;user-blocking&#x27;</span> &#125;);<br>scheduler.<span class="hljs-title function_">postTask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">handleInput</span>(), &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>(3) 减少呈现延迟</p>
<ul>
<li>避免强制同步布局（Forced Synchronous Layout）</li>
<li>使用 CSS content-visibility: auto 跳过离屏渲染</li>
</ul>
<p><strong>INP 测量方法</strong></p>
<ul>
<li>Chrome DevTools → Performance 面板（查看 Interaction to Next Paint 时间线）<ul>
<li>红色三角：交互开始</li>
<li>蓝色三角：下次绘制完成</li>
</ul>
</li>
</ul>
<h3 id="CLS-累积布局偏移"><a href="#CLS-累积布局偏移" class="headerlink" title="CLS (累积布局偏移)"></a>CLS (累积布局偏移)</h3><p><strong>CLS 核心定义</strong></p>
<ul>
<li>官方标准<ul>
<li>测量页面生命周期中意外布局偏移的累积分数</li>
<li>量化视觉稳定性（避免元素跳动导致误操作）</li>
</ul>
</li>
<li>计算规则<ul>
<li>CLS 分数 &#x3D; 影响比例 (impact fraction) × 距离比例 (distance fraction)</li>
<li>影响比例：偏移元素在视口内占据的面积百分比</li>
<li>距离比例：元素偏移距离 &#x2F; 视口最大尺寸（取宽或高中较大值）</li>
</ul>
</li>
<li>性能阈值<ul>
<li>Good（优）：≤ 0.1</li>
<li>Needs Improvement（需优化）：0.1 - 0.25</li>
<li>Poor（差）：&gt; 0.25</li>
</ul>
</li>
</ul>
<p><strong>布局偏移的触发条件</strong></p>
<ul>
<li>必要条件<ul>
<li>元素在两个连续帧间发生位置变化</li>
<li>变化原因非用户主动触发（如点击、滚动）</li>
</ul>
</li>
<li>常见场景：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">典型案例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未定义尺寸元素</td>
<td align="left"><code>&lt;img&gt;/&lt;video&gt;</code> 未设 width&#x2F;height</td>
</tr>
<tr>
<td align="left">动态插入内容</td>
<td align="left">广告位&#x2F;通知横幅异步加载</td>
</tr>
<tr>
<td align="left">字体加载抖动</td>
<td align="left">FOIT&#x2F;FOUT（字体替换导致文本重排）</td>
</tr>
<tr>
<td align="left">异步更新 DOM</td>
<td align="left">无限滚动列表加载新项</td>
</tr>
</tbody></table>
<p><strong>CLS 优化实践</strong></p>
<p>(1) 媒体元素预留空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 指定宽高比容器防止图片加载后抖动 --&gt;<br>&lt;div style=&quot;position: relative; padding-top: 56.25%&quot;&gt; &lt;!-- 16:9 --&gt;<br>  &lt;img src=&quot;banner.jpg&quot; alt=&quot;Banner&quot; <br>       style=&quot;position: absolute; top: 0; left: 0; width: 100%; height: 100%&quot;&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>(2) 动态内容隔离策略</p>
<ul>
<li>为动态插入元素预留占位容器</li>
<li>使用 CSS transform 替代影响布局的属性（避免触发重排）</li>
</ul>
<p>(3) 字体加载控制</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 强制使用备用字体直至自定义字体加载 */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;CustomFont&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;font.woff2&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  <span class="hljs-attribute">font-display</span>: swap; <span class="hljs-comment">/* 关键选项 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>(4) 布局稳定性 API</p>
<ul>
<li>使用 CSS aspect-ratio 定义宽高比</li>
<li>优先采用 Flexbox&#x2F;Grid 布局（减少浮动偏移</li>
</ul>
<p><strong>CLS 测量方法</strong></p>
<ul>
<li>Chrome DevTools → Performance 面板（查看 Layout Shift 轨迹）</li>
</ul>
<p><strong>常见误区</strong></p>
<ul>
<li>错误认知<ul>
<li>❌ 所有元素偏移都计入 → ✅ 仅意外偏移（用户触发偏移不计）</li>
<li>❌ CLS 只关注首屏 → ✅ 覆盖页面完整生命周期</li>
</ul>
</li>
<li>实践陷阱<ul>
<li>使用 position: fixed 的头部导航栏若动态改变高度（如登录条出现）将导致下方内容集体偏移</li>
<li>懒加载图片未设置 width&#x2F;height 时，滚动加载会触发连锁布局重排</li>
</ul>
</li>
</ul>
<h2 id="1-2-性能监控工具"><a href="#1-2-性能监控工具" class="headerlink" title="1.2 性能监控工具"></a>1.2 性能监控工具</h2><h3 id="Lighthouse-PageSpeed-Insights"><a href="#Lighthouse-PageSpeed-Insights" class="headerlink" title="Lighthouse &#x2F; PageSpeed Insights"></a>Lighthouse &#x2F; PageSpeed Insights</h3><p><strong>核心定位与差异</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Lighthouse</th>
<th align="left">PageSpeed Insights (PSI)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行环境</td>
<td align="left">本地（Node.js&#x2F;DevTools）</td>
<td align="left">Google服务器（云端测试）</td>
</tr>
<tr>
<td align="left">测试设备模拟</td>
<td align="left">可自定义设备&#x2F;网络参数</td>
<td align="left">固定移动端+桌面端（不可调参数）</td>
</tr>
<tr>
<td align="left">数据源</td>
<td align="left">实验室数据（Lab Data）</td>
<td align="left">实验室数据 + 部分真实用户数据（CrUX）</td>
</tr>
<tr>
<td align="left">报告深度</td>
<td align="left">原始跟踪数据可深度分析</td>
<td align="left">聚合结果（无Performance面板级细粒度数据）</td>
</tr>
</tbody></table>
<p><strong>核心功能解析</strong></p>
<ul>
<li>性能指标测量<ul>
<li>直接输出 Web Vitals 三项指标（LCP, FID&#x2F;INP, CLS）</li>
<li>提供性能评分（0-100分）及改进建议</li>
</ul>
</li>
<li>优化建议系统<ul>
<li>按优先级列出可优化项（高&#x2F;中&#x2F;低影响）</li>
<li>附带可操作代码示例（如未压缩图片列表）</li>
</ul>
</li>
<li>技术栈分析<ul>
<li>自动检测框架（React&#x2F;Vue等）</li>
<li>识别第三方脚本影响（广告&#x2F;分析工具）</li>
</ul>
</li>
</ul>
<p><strong>Lighthouse 高阶用法</strong></p>
<p>(1) Node CLI 自定义测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lighthouse https://example.com --output=json --emulated-form-factor=mobile --throttling.cpuSlowdownMultiplier=4<br></code></pre></td></tr></table></figure>

<ul>
<li>–preset（性能预设：perf|desktop）</li>
<li>–throttling（自定义网络&#x2F;CPU限流）</li>
<li>–only-categories（指定测试类目：performance|accessibility）</li>
</ul>
<p>(2) DevTools 深度分析</p>
<ul>
<li>查看 Performance 面板原始跟踪（Main主线程火焰图）</li>
<li>Coverage 标签页定位未使用JS&#x2F;CSS（红条标记可删代码）</li>
</ul>
<p><strong>报告解读技巧</strong></p>
<p>(1) 关键指标优先级</p>
<pre class="mermaid">graph TD
A[性能评分] --> B[Web Vitals]
B --> B1(LCP)
B --> B2(FID/INP)
B --> B3(CLS)
A --> C[优化建议]
C --> C1(Opportunities)
C --> C2(Diagnostics)</pre>

<p>(2) 核心优化建议分类</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">典型案例</th>
<th align="left">修复收益</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Opportunities</td>
<td align="left">移除未用CSS&#x2F;图片压缩</td>
<td align="left">★★★</td>
</tr>
<tr>
<td align="left">Diagnostics</td>
<td align="left">最小化主线程工作&#x2F;避免DOM过大</td>
<td align="left">★★</td>
</tr>
<tr>
<td align="left">Passed Audits</td>
<td align="left">已优化的最佳实践</td>
<td align="left">-</td>
</tr>
</tbody></table>
<h3 id="Chrome-DevTools-Performance面板深度使用"><a href="#Chrome-DevTools-Performance面板深度使用" class="headerlink" title="Chrome DevTools Performance面板深度使用"></a>Chrome DevTools Performance面板深度使用</h3><p><strong>核心功能定位</strong></p>
<ul>
<li>核心价值<ul>
<li>可视化分析页面运行时性能瓶颈（非加载阶段）</li>
<li>提供毫秒级主线程活动追踪（JS执行&#x2F;渲染&#x2F;网络）</li>
</ul>
</li>
<li>与Lighthouse差异：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Performance 面板</th>
<th align="left">Lighthouse</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分析类型</td>
<td align="left">运行时动态追踪</td>
<td align="left">静态规则审计</td>
</tr>
<tr>
<td align="left">数据粒度</td>
<td align="left">毫秒级函数调用栈</td>
<td align="left">聚合指标评分</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">诊断卡顿&#x2F;内存泄漏</td>
<td align="left">整体优化建议</td>
</tr>
</tbody></table>
<p><strong>操作全流程解析</strong></p>
<ul>
<li>录制准备<ul>
<li>开启 Screenshots（帧截图）捕捉视觉变化</li>
<li>启用 Advanced settings → Web Vitals 标记关键指标</li>
</ul>
</li>
</ul>
<pre class="mermaid">graph LR
A[点击Record开始录制] --> B[执行用户操作]
B --> C[停止录制]
C --> D[分析火焰图]</pre>

<ul>
<li>关键控制项<ul>
<li>CPU Throttling：模拟移动端CPU（推荐4x降速）</li>
<li>Network Throttling：模拟慢网络（推荐Fast 3G）</li>
<li>Enable advanced paint instrumentation：分析图层绘制</li>
</ul>
</li>
</ul>
<p><strong>报告结构深度解读</strong></p>
<p>(1) 时间线概览（Overview）</p>
<table>
<thead>
<tr>
<th align="left">区域</th>
<th align="left">分析维度</th>
<th align="left">关键信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FPS</td>
<td align="left">帧率波动</td>
<td align="left">红色块&#x3D;掉帧（&lt;50fps）</td>
</tr>
<tr>
<td align="left">CPU</td>
<td align="left">处理器负载分配</td>
<td align="left">颜色&#x3D;JS&#x2F;渲染&#x2F;其他</td>
</tr>
<tr>
<td align="left">NET</td>
<td align="left">网络请求瀑布流</td>
<td align="left">条形长度&#x3D;请求耗时</td>
</tr>
</tbody></table>
<p>(2) 主程火焰图</p>
<ul>
<li>横向：时间轴（毫秒级）</li>
<li>纵向：调用栈深度（函数嵌套关系）</li>
<li>关键标识：<ul>
<li>红色三角：长任务（&gt;50ms）</li>
<li>黄色块：JavaScript执行</li>
<li>紫色块：布局计算（Layout）</li>
</ul>
</li>
</ul>
<p><strong>性能瓶颈诊断技巧</strong></p>
<ul>
<li>长任务溯源<ul>
<li>展开火焰图中超过50ms的任务块</li>
<li>定位耗时最长的函数调用（底部最深色块）</li>
</ul>
</li>
<li>布局抖动分析<ul>
<li>查找连续出现的 Layout 紫色块</li>
<li>检查触发源（通常由JS强制同步布局导致）：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 反例：触发强制布局</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 读取</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 写入</span><br><span class="hljs-keyword">const</span> newWidth = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 再次读取 → 布局抖动！</span><br></code></pre></td></tr></table></figure>

<ul>
<li>渲染层优化：切换 Layers 标签页：<ul>
<li>检查图层数量（过多&#x3D;内存占用高）</li>
<li>定位 Repaint 高频区域（红色高亮）</li>
</ul>
</li>
</ul>
<p><strong>高级功能应用</strong></p>
<ul>
<li>性能监控点（Performance Monitor）<ul>
<li>实时跟踪关键指标：<ul>
<li>JS堆内存大小</li>
<li>DOM节点数量</li>
<li>事件监听器数量</li>
</ul>
</li>
<li>诊断内存泄漏：内存曲线持续上升</li>
</ul>
</li>
<li>渲染分析（Rendering）<ul>
<li>启用 Paint flashing：绿色闪烁&#x3D;重绘区域</li>
<li>开启 Layout Shift Regions：蓝色覆盖&#x3D;布局偏移区域</li>
</ul>
</li>
<li>代码级优化定位<ul>
<li>右击火焰图块 → Reveal in Source panel</li>
<li>查看函数源码及执行耗时（精确到行）</li>
</ul>
</li>
</ul>
<p><strong>实战调试案例</strong></p>
<p>场景：按钮点击卡顿</p>
<ul>
<li>录制点击操作</li>
<li>分析火焰图：<ul>
<li>发现 Event: click 下200ms长任务</li>
<li>展开定位到 processData() 函数耗时180ms</li>
</ul>
</li>
<li>优化方案：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优化前（同步阻塞）</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">processData</span>(); <span class="hljs-comment">// 200ms任务</span><br>&#125;);<br><br><span class="hljs-comment">// 优化后（任务拆分）</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(processData, <span class="hljs-number">0</span>); <span class="hljs-comment">// 拆解任务</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="RUM-Real-User-Monitoring-方案：Sentry-Google-Analytics"><a href="#RUM-Real-User-Monitoring-方案：Sentry-Google-Analytics" class="headerlink" title="RUM (Real User Monitoring) 方案：Sentry &#x2F; Google Analytics"></a>RUM (Real User Monitoring) 方案：Sentry &#x2F; Google Analytics</h3><p><strong>RUM 核心定义与价值</strong></p>
<ul>
<li>基本概念<ul>
<li>RUM 通过嵌入前端代码（如 JavaScript SDK）收集真实用户访问时的性能数据、交互行为及错误信息。</li>
<li>与合成监控（Synthetic Monitoring）的区别：真实用户数据（非模拟环境）覆盖多设备、多网络条件场景。</li>
</ul>
</li>
<li>核心价值<ul>
<li>性能优化：定位真实环境中的性能瓶颈（如慢加载、高延迟）。</li>
<li>错误诊断：捕获生产环境中的 JavaScript 错误及资源加载失败。</li>
<li>行为分析：追踪用户点击路径、页面停留时长，关联业务转化率</li>
</ul>
</li>
</ul>
<p><strong>Sentry：深度错误诊断方案</strong></p>
<p>核心功能：</p>
<table>
<thead>
<tr>
<th align="left">功能类别</th>
<th align="left">具体能力</th>
</tr>
</thead>
<tbody><tr>
<td align="left">错误追踪</td>
<td align="left">- 自动捕获未处理的 JavaScript 异常、Promise 拒绝、资源加载失败 <br> - 支持源码映射（Sourcemap）定位压缩代码的错误行</td>
</tr>
<tr>
<td align="left">会话重放</td>
<td align="left">录制用户操作序列，重现错误发生前的行为路径（需付费版）</td>
</tr>
<tr>
<td align="left">性能监控</td>
<td align="left">- 测量页面加载时间、API 请求延迟<br> - 关联错误与性能慢请求（如高延迟触发的超时错误）</td>
</tr>
<tr>
<td align="left">自定义上下文</td>
<td align="left">添加用户信息、环境变量等辅助诊断的标签（如 user.id、release.version）</td>
</tr>
</tbody></table>
<p>实施示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Sentry 初始化（Web SDK）</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Sentry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sentry/browser&quot;</span>;<br><span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">init</span>(&#123;<br>  <span class="hljs-attr">dsn</span>: <span class="hljs-string">&quot;https://example@sentry.io/123&quot;</span>,<br>  <span class="hljs-attr">release</span>: <span class="hljs-string">&quot;my-app@1.0.0&quot;</span>,<br>  <span class="hljs-attr">integrations</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sentry</span>.<span class="hljs-title class_">BrowserTracing</span>()],<br>  <span class="hljs-attr">tracesSampleRate</span>: <span class="hljs-number">0.2</span>, <span class="hljs-comment">// 性能数据采样率</span><br>&#125;);<br><br><span class="hljs-comment">// 手动捕获错误</span><br><span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">captureException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Custom error&quot;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>Google Analytics：行为与性能分析方案</strong></p>
<p>核心功能：</p>
<table>
<thead>
<tr>
<th align="left">功能类别</th>
<th align="left">具体能力</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户行为分析</td>
<td align="left">- 页面浏览量（PV）、会话时长、跳出率统计 <br> - 事件跟踪（点击、表单提交等自定义事件）</td>
</tr>
<tr>
<td align="left">性能指标</td>
<td align="left">通过 web-vitals 库集成 LCP&#x2F;FID&#x2F;CLS 等 Core Web Vitals 指标</td>
</tr>
<tr>
<td align="left">用户分群</td>
<td align="left">按设备、地域、流量来源细分性能数据（如“移动端用户 LCP &gt; 4s 占比”）</td>
</tr>
<tr>
<td align="left">转化漏斗</td>
<td align="left">定义多步骤业务流程（如注册流程），分析各环节流失率</td>
</tr>
</tbody></table>
<p>实施示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 通过 gtag.js 上报 Web Vitals</span><br><span class="hljs-keyword">import</span> &#123;getLCP, getFID, getCLS&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;web-vitals&#x27;</span>;<br><span class="hljs-title function_">getLCP</span>(<span class="hljs-function"><span class="hljs-params">metric</span> =&gt;</span> <span class="hljs-title function_">gtag</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-string">&#x27;LCP&#x27;</span>, &#123;<span class="hljs-attr">value</span>: metric.<span class="hljs-property">value</span>&#125;));<br></code></pre></td></tr></table></figure>

<p><strong>Sentry vs Google Analytics 关键对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Sentry</th>
<th align="left">Google Analytics</th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心定位</td>
<td align="left">错误诊断与根因分析</td>
<td align="left">用户行为分析与流量转化</td>
</tr>
<tr>
<td align="left">性能监控深度</td>
<td align="left">支持代码级错误定位 + 性能链路追踪</td>
<td align="left">仅提供聚合指标（无堆栈跟踪）</td>
</tr>
<tr>
<td align="left">自定义扩展</td>
<td align="left">支持自定义标签、事件、采样策略</td>
<td align="left">依赖 gtag 事件API，灵活性较低</td>
</tr>
<tr>
<td align="left">数据实时性</td>
<td align="left">错误报警分钟级推送</td>
<td align="left">数据延迟 24-48 小时</td>
</tr>
<tr>
<td align="left">成本模型</td>
<td align="left">按事件量收费（免费版有限额）</td>
<td align="left">完全免费（GA4 标准版）</td>
</tr>
<tr>
<td align="left">集成生态</td>
<td align="left">支持 Jira&#x2F;Slack 等 DevOps 工具链</td>
<td align="left">主要与 Google 生态（Ads&#x2F; BigQuery）集成</td>
</tr>
</tbody></table>
<h3 id="Synthetic-Monitoring-合成监控-：WebPageTest-Puppeteer"><a href="#Synthetic-Monitoring-合成监控-：WebPageTest-Puppeteer" class="headerlink" title="Synthetic Monitoring (合成监控)：WebPageTest &#x2F; Puppeteer"></a>Synthetic Monitoring (合成监控)：WebPageTest &#x2F; Puppeteer</h3><p><strong>合成监控核心概念</strong></p>
<ul>
<li>定义与价值<ul>
<li>在预设环境中通过脚本模拟用户操作路径（如页面导航、点击）</li>
<li>与 RUM 互补：提供稳定可复现的基准测试，排除用户设备&#x2F;网络差异</li>
</ul>
</li>
<li>核心应用场景<ul>
<li>版本发布前性能回归测试</li>
<li>竞品性能对标分析</li>
<li>CDN 节点选择优化（全球多地点测试）</li>
</ul>
</li>
</ul>
<p><strong>WebPageTest：云端自动化测试平台</strong></p>
<p>核心功能解析：</p>
<table>
<thead>
<tr>
<th align="left">功能维度</th>
<th align="left">技术实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">多地点测试</td>
<td align="left">支持全球 40+ 测试节点（AWS EC2 实例）</td>
</tr>
<tr>
<td align="left">网络模拟</td>
<td align="left">自定义带宽&#x2F;延迟（DSL&#x2F;Cable&#x2F;4G）或精确丢包率设置</td>
</tr>
<tr>
<td align="left">高级捕获</td>
<td align="left">视频录制、Traceroute 诊断、HTTP&#x2F;2 优先级可视化</td>
</tr>
<tr>
<td align="left">脚本扩展</td>
<td align="left">通过 navigate&#x2F;clickAndWait 等命令模拟用户流（支持登录等复杂操作）</td>
</tr>
</tbody></table>
<p>关键测试指标：</p>
<pre class="mermaid">graph LR
A[WebPageTest报告] --> B[核心性能指标]
A --> C[资源瀑布流]
A --> D[优化建议]
B --> B1(LCP)
B --> B2(TTFB)
B --> B3(Speed Index)
C --> C1(资源加载时序)
C --> C2(CDN命中状态)
D --> D1(压缩建议)
D --> D2(缓存策略)</pre>

<p><strong>实战工作流</strong></p>
<p>(1) 测试配置</p>
<ul>
<li>选择测试地点（如 ec2-us-east-1）</li>
<li>设置网络节流（如 4G: 20ms RTT, 20Mbps）</li>
<li>添加自定义脚本：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">navigate https://example.com<br>execAndWait document.querySelector(&#x27;#login&#x27;).click()<br>setValue input[name=user] test@email.com<br>setValue input[name=pass] 123456<br>submitForm id=login-form<br></code></pre></td></tr></table></figure>

<p>(2) 报告解读技巧</p>
<ul>
<li>Speed Index &lt; 3.5s 为良好（反映视觉完成速度）</li>
<li>Waterfall 红色竖线标记 DOMContentLoaded 时间点</li>
<li>Connection View 诊断 HTTP&#x2F;2 多路复用效果</li>
</ul>
<p><strong>Puppeteer：代码级精准控制方案</strong></p>
<p>核心功能解析：</p>
<table>
<thead>
<tr>
<th align="left">能力类别</th>
<th align="left">API 示例</th>
<th align="left">监控用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">浏览器控制</td>
<td align="left">puppeteer.launch()</td>
<td align="left">多环境测试（Headless&#x2F;Headful）</td>
</tr>
<tr>
<td align="left">用户行为模拟</td>
<td align="left">page.click(‘#button’)</td>
<td align="left">交互性能分析</td>
</tr>
<tr>
<td align="left">性能数据捕获</td>
<td align="left">page.metrics()</td>
<td align="left">获取 JS 堆大小&#x2F;节点数等运行时指标</td>
</tr>
<tr>
<td align="left">网络拦截</td>
<td align="left">page.setRequestInterception(true)</td>
<td align="left">模拟 API 失败&#x2F;延迟</td>
</tr>
</tbody></table>
<p>合成监控实现方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<br><br>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>();<br>  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>();<br>  <br>  <span class="hljs-comment">// 启动性能跟踪</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-property">tracing</span>.<span class="hljs-title function_">start</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;trace.json&#x27;</span> &#125;);<br>  <br>  <span class="hljs-comment">// 模拟用户流</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, &#123; <span class="hljs-attr">waitUntil</span>: <span class="hljs-string">&#x27;networkidle2&#x27;</span> &#125;);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;#search&#x27;</span>, <span class="hljs-string">&#x27;performance&#x27;</span>);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">click</span>(<span class="hljs-string">&#x27;#submit&#x27;</span>);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">waitForSelector</span>(<span class="hljs-string">&#x27;.results&#x27;</span>);<br>  <br>  <span class="hljs-comment">// 停止跟踪并输出指标</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-property">tracing</span>.<span class="hljs-title function_">stop</span>();<br>  <span class="hljs-keyword">const</span> perfMetrics = <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">metrics</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSHeapUsedSize:&#x27;</span>, perfMetrics.<span class="hljs-property">JSHeapUsedSize</span>);<br>  <br>  <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">close</span>();<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p><strong>WebPageTest vs Puppeteer 对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">WebPageTest</th>
<th align="left">Puppeteer</th>
</tr>
</thead>
<tbody><tr>
<td align="left">部署模式</td>
<td align="left">云端 SaaS</td>
<td align="left">本地 Node.js 环境</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">受限（仅支持内置命令）</td>
<td align="left">无限（可编程控制）</td>
</tr>
<tr>
<td align="left">报告深度</td>
<td align="left">开箱即用（含视频&#x2F;瀑布流）</td>
<td align="left">需自行实现数据可视化</td>
</tr>
<tr>
<td align="left">成本</td>
<td align="left">免费版有限额，企业版付费</td>
<td align="left">开源免费，需自建基础设施</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">快速获取多地点测试报告</td>
<td align="left">CI&#x2F;CD 流水线集成、复杂场景精准测试</td>
</tr>
</tbody></table>
<h1 id="二、网络层优化"><a href="#二、网络层优化" class="headerlink" title="二、网络层优化"></a>二、网络层优化</h1><h2 id="2-1-资源加载策略"><a href="#2-1-资源加载策略" class="headerlink" title="2.1 资源加载策略"></a>2.1 资源加载策略</h2><h3 id="关键渲染路径优化（Critical-Rendering-Path）"><a href="#关键渲染路径优化（Critical-Rendering-Path）" class="headerlink" title="关键渲染路径优化（Critical Rendering Path）"></a>关键渲染路径优化（Critical Rendering Path）</h3><p><strong>关键渲染路径（CRP）核心概念</strong></p>
<ul>
<li>定义<ul>
<li>浏览器将 HTML&#x2F;CSS&#x2F;JS 转换为可视像素的完整处理链条</li>
<li>从接收字节流到渲染首屏内容的关键步骤序列</li>
</ul>
</li>
<li>优化目标<ul>
<li>最小化 首次内容绘制时间（FCP）</li>
<li>缩短 首次有效渲染时间（First Meaningful Paint）</li>
</ul>
</li>
</ul>
<p><strong>CRP 核心处理阶段</strong></p>
<pre class="mermaid">graph TD
A[下载HTML] --> B[构建DOM树]
A --> C[下载CSS构建CSSOM树]
B & C --> D[合并生成渲染树]
D --> E[布局计算]
E --> F[像素绘制]</pre>

<p><strong>阶段详解</strong></p>
<ul>
<li>DOM 构建（Parse HTML）<ul>
<li>边下载边解析，遇 <code>&lt;script&gt;</code> 会阻塞解析（除非 async&#x2F;defer）</li>
<li>遇 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 不阻塞 DOM 解析但阻塞渲染</li>
</ul>
</li>
<li>CSSOM 构建<ul>
<li>完全渲染阻塞：浏览器需完整 CSSOM 才能渲染页面</li>
<li>特性：层叠规则导致 CSS 解析不可增量（底部样式可覆盖顶部）</li>
</ul>
</li>
<li>渲染树（Render Tree）:合并 DOM + CSSOM，排除不可见元素（如 display:none）</li>
<li>布局（Layout&#x2F;Reflow）:计算所有元素的几何位置（视口尺寸影响结果）<br>*绘制（Paint）:将布局结果转为屏幕像素（可能分多层绘制）</li>
</ul>
<p><strong>阻塞行为深度解析</strong></p>
<table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">DOM 构建</th>
<th align="left">渲染阻塞</th>
<th align="left">优化策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步 <code>&lt;script&gt;</code></td>
<td align="left">阻塞</td>
<td align="left">阻塞</td>
<td align="left">async&#x2F;defer</td>
</tr>
<tr>
<td align="left">外部 CSS</td>
<td align="left">不阻塞</td>
<td align="left">阻塞</td>
<td align="left">内联关键CSS</td>
</tr>
<tr>
<td align="left">媒体查询 CSS</td>
<td align="left">不阻塞</td>
<td align="left">条件阻塞</td>
<td align="left">拆分非关键CSS</td>
</tr>
<tr>
<td align="left"><code>&lt;img&gt;</code></td>
<td align="left">不阻塞</td>
<td align="left">不阻塞</td>
<td align="left">懒加载</td>
</tr>
<tr>
<td align="left">异步 <code>&lt;script&gt;</code></td>
<td align="left">不阻塞</td>
<td align="left">不阻塞</td>
<td align="left">预加载</td>
</tr>
</tbody></table>
<p><strong>CRP 优化五大策略</strong></p>
<p>(1) 最小化关键资源数量</p>
<ul>
<li>移除非首屏必需 JS&#x2F;CSS（如分析脚本延迟加载）</li>
</ul>
<p>(2) 压缩关键资源体积</p>
<ul>
<li>极限压缩 CSS&#x2F;JS（Terser + CSSNano）</li>
<li>内联核心 CSS（控制在 14KB 以内以利用 TCP 慢启动）</li>
</ul>
<p>(3) 缩短关键路径长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 非关键CSS异步加载 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;non-critical.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;<br>&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;non-critical.css&quot;&gt;&lt;/noscript&gt;<br></code></pre></td></tr></table></figure>

<p>(4) 优化 JavaScript 加载优先级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 首屏必需脚本：添加 preload --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.js&quot; as=&quot;script&quot;&gt;<br><br>&lt;!-- 非必需脚本：延迟执行 --&gt;<br>&lt;script src=&quot;analytics.js&quot; defer&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>(5) 并行化资源加载</p>
<ul>
<li>使用 HTTP&#x2F;2 多路复用避免队头阻塞</li>
<li>预建立连接：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot;&gt;<br></code></pre></td></tr></table></figure>

<p><strong>CRP 优化检查清单</strong></p>
<ol>
<li>首屏内容所需 CSS 内联到 <code>&lt;style&gt;</code> 标签</li>
<li>非关键 CSS 异步加载（preload + onload）</li>
<li>所有 <code>&lt;script&gt;</code> 添加 async 或 defer</li>
<li>图片&#x2F;字体使用 preload 提前获取</li>
<li>配置 HTTP&#x2F;2 服务端推送关键资源</li>
<li>使用骨架屏占位避免布局偏移（CLS）</li>
</ol>
<h3 id="资源优先级：preload-prefetch-preconnect"><a href="#资源优先级：preload-prefetch-preconnect" class="headerlink" title="资源优先级：preload, prefetch, preconnect"></a>资源优先级：preload, prefetch, preconnect</h3><p><strong>核心机制对比</strong></p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">加载优先级</th>
<th align="left">适用场景</th>
<th align="left">浏览器支持</th>
<th align="left">典型生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="left">preload</td>
<td align="left">最高（立即加载）</td>
<td align="left">当前路由关键资源（字体&#x2F;首图）</td>
<td align="left">93% (2023)</td>
<td align="left">当前页面</td>
</tr>
<tr>
<td align="left">prefetch</td>
<td align="left">最低（空闲加载）</td>
<td align="left">下个路由可能用到的资源</td>
<td align="left">92%</td>
<td align="left">跨页面缓存</td>
</tr>
<tr>
<td align="left">preconnect</td>
<td align="left">连接优先</td>
<td align="left">高频第三方源（CDN&#x2F;API）</td>
<td align="left">96%</td>
<td align="left">连接保持10s</td>
</tr>
</tbody></table>
<p><strong>preload 深度解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;font.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;<br><br>&lt;!-- 媒体查询扩展 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;desktop.css&quot; as=&quot;style&quot; media=&quot;(min-width: 1024px)&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>核心功能：</p>
<ul>
<li>强制浏览器提前请求：无视默认资源发现顺序</li>
<li>as 属性必填：声明资源类型（font&#x2F;image&#x2F;script&#x2F;style）<ul>
<li>错误类型将导致重复下载（如 as&#x3D;”style” 实际是JS）</li>
</ul>
</li>
<li>跨域要求：字体文件需加 crossorigin 属性</li>
</ul>
<p>最佳实践场景：</p>
<ul>
<li>首屏关键字体：防止FOIT（字体未加载时不可见文本）</li>
<li>首屏大图：配合 as&#x3D;”image” 提升LCP元素加载优先级</li>
<li>关键脚本：优先加载影响FCP的JS（如框架运行时）</li>
</ul>
<p>使用陷阱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 反例：未设置as属性 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.js&quot;&gt; ❌ 触发二次下载<br><br>&lt;!-- 反例：预加载非关键资源 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;background.jpg&quot;&gt; ❌ 浪费带宽<br></code></pre></td></tr></table></figure>

<p><strong>prefetch 应用策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- HTML 声明式 --&gt;<br>&lt;link rel=&quot;prefetch&quot; href=&quot;product-list.js&quot; as=&quot;script&quot;&gt;<br><br>&lt;!-- JS 编程式 --&gt;<br>&lt;link rel=&quot;prefetch&quot; href=&quot;product-list.js&quot; as=&quot;script&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>实现方式：</p>
<ul>
<li>低优先级加载：仅在浏览器空闲时请求</li>
<li>HTTP 缓存：资源存储在 disk-cache，有效期由 Cache-Control 控制</li>
</ul>
<p>典型场景：</p>
<p>(1) 路由级代码分割：预取下个页面的JS模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 路由预取示例</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./ProductPage&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>(2) 数据预取：提前获取用户可能访问的API数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;prefetch&quot; href=&quot;/api/recommendations&quot; as=&quot;fetch&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>性能权衡：</p>
<ul>
<li>✅ 带宽充足时减少后续页面加载时间（提升导航速度30-50%）</li>
<li>❌ 弱网环境可能抢占关键资源带宽</li>
</ul>
<p><strong>preconnect 技术细节</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;<br><br>&lt;!-- 扩展资源提示 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot; crossorigin&gt;<br></code></pre></td></tr></table></figure>

<p>链接建立过程：</p>
<pre class="mermaid">graph LR
A[preconnect] --> B[DNS解析]
A --> C[TCP握手]
A --> D[TLS协商] 
D --> E[保持连接池]</pre>

<ul>
<li>节省时间：提前完成100-500ms的网络握手</li>
<li>适用场景：已知需请求的第三方域（Google Fonts&#x2F;Analytics）</li>
</ul>
<p>实施规范：</p>
<ul>
<li>跨域要求：CORS资源需加 crossorigin</li>
<li>连接保持：默认10秒无请求则关闭（Chrome行为）</li>
</ul>
<p>智能决策：</p>
<ul>
<li>高频域：主CDN&#x2F;静态资源域（如 static.example.com）</li>
<li>关键第三方：支付SDK&#x2F;认证服务（如 auth0.com）</li>
<li>避免过度：&gt;4个preconnect可能被浏览器忽略</li>
</ul>
<p><strong>组合优化策略</strong></p>
<p>(1) 分阶段资源提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;head&gt;<br>  &lt;!-- 阶段1：关键资源 --&gt;<br>  &lt;link rel=&quot;preload&quot; href=&quot;main.css&quot; as=&quot;style&quot;&gt;<br>  <br>  &lt;!-- 阶段2：第三方连接 --&gt;<br>  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;<br>  <br>  &lt;!-- 阶段3：预测性资源 --&gt;<br>  &lt;link rel=&quot;prefetch&quot; href=&quot;checkout.js&quot; as=&quot;script&quot;&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure>

<p>(2) 优先级冲突规避</p>
<table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">preload</th>
<th align="left">prefetch</th>
<th align="left">风险</th>
</tr>
</thead>
<tbody><tr>
<td align="left">首屏图片</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">重复加载浪费带宽</td>
</tr>
<tr>
<td align="left">非首屏组件JS</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">弱网环境延迟关键请求</td>
</tr>
<tr>
<td align="left">字体文件</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">不加crossorigin失效</td>
</tr>
</tbody></table>
<h3 id="HTTP-2-Server-Push-策略设计"><a href="#HTTP-2-Server-Push-策略设计" class="headerlink" title="HTTP&#x2F;2 Server Push 策略设计"></a>HTTP&#x2F;2 Server Push 策略设计</h3><p><strong>工作原理</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Client as 浏览器
    participant Server as 服务器
    Client->>Server: 请求 index.html
    Server->>Client: 响应 HTML + PUSH_PROMISE 帧（声明推送资源）
    Server->>Client: 同时推送 style.css 和 script.js
    Client->>Server: 无需再请求 style.css/script.js</pre>

<ul>
<li>主动推送：服务器在响应主请求时主动发送关联资源</li>
<li>协议层实现：通过 PUSH_PROMISE 帧声明即将推送的资源</li>
<li>客户端缓存：浏览器将推送资源存入缓存，遇到对应标签时直接使用</li>
</ul>
<p><strong>与传统优化的对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">HTTP&#x2F;1.1 资源合并</th>
<th align="left">HTTP&#x2F;2 Server Push</th>
</tr>
</thead>
<tbody><tr>
<td align="left">请求数量</td>
<td align="left">减少（合并文件）</td>
<td align="left">不减少但并行传输</td>
</tr>
<tr>
<td align="left">缓存效率</td>
<td align="left">低（整包缓存）</td>
<td align="left">高（资源独立缓存）</td>
</tr>
<tr>
<td align="left">更新粒度</td>
<td align="left">整文件更新</td>
<td align="left">单文件更新</td>
</tr>
<tr>
<td align="left">关键路径优化</td>
<td align="left">有限</td>
<td align="left">显著（预置关键资源）</td>
</tr>
</tbody></table>
<p><strong>推送策略设计原则</strong></p>
<p>推送决策矩阵：</p>
<table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">是否推送</th>
<th align="left">理由</th>
</tr>
</thead>
<tbody><tr>
<td align="left">首屏关键CSS</td>
<td align="left">✅</td>
<td align="left">消除渲染阻塞</td>
</tr>
<tr>
<td align="left">首屏关键JS</td>
<td align="left">✅</td>
<td align="left">提前编译执行</td>
</tr>
<tr>
<td align="left">首屏大图</td>
<td align="left">✅</td>
<td align="left">提升LCP</td>
</tr>
<tr>
<td align="left">非首屏JS&#x2F;CSS</td>
<td align="left">❌</td>
<td align="left">浪费带宽，可能抢占关键资源</td>
</tr>
<tr>
<td align="left">低频使用资源</td>
<td align="left">❌</td>
<td align="left">缓存利用率低</td>
</tr>
<tr>
<td align="left">用户特定内容</td>
<td align="left">❌</td>
<td align="left">无法预判用户需求</td>
</tr>
</tbody></table>
<p>智能推送触发条件:</p>
<ul>
<li>基于HTML依赖分析: 解析HTML中的 <code>&lt;link&gt;, &lt;script&gt;</code> 标签自动推送</li>
<li>配置白名单：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx 配置示例</span><br><span class="hljs-attribute">http2_push</span> /static/css/core.css; <br><span class="hljs-attribute">http2_push</span> /static/js/main.js;<br></code></pre></td></tr></table></figure>

<ul>
<li>动态决策（需编程实现）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Node.js 动态推送</span><br>res.<span class="hljs-property">stream</span>.<span class="hljs-title function_">pushStream</span>(&#123; <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/critical.css&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err, pushStream</span>) =&gt;</span> &#123;<br>  pushStream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;/path/to/critical.css&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>风险规避策略</strong></p>
<table>
<thead>
<tr>
<th align="left">风险</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">推送冗余资源</td>
<td align="left">配置ETag验证，客户端缓存存在时跳过推送</td>
</tr>
<tr>
<td align="left">带宽竞争</td>
<td align="left">限制推送资源数量（≤3个）</td>
</tr>
<tr>
<td align="left">队头阻塞</td>
<td align="left">设置优先级权重（Weight）</td>
</tr>
<tr>
<td align="left">缓存污染</td>
<td align="left">为推送资源设置短缓存（max-age&#x3D;300）</td>
</tr>
</tbody></table>
<p><strong>使用前检查清单</strong></p>
<ol>
<li>确认服务器支持 HTTP&#x2F;2（Nginx ≥ 1.13.9）</li>
<li>仅推送 ≤3个关键渲染路径资源</li>
<li>为推送资源设置版本化路径</li>
<li>实现缓存状态验证（Cache-Digest）</li>
<li>监控推送资源命中率（CDN日志）</li>
<li>配置降级策略（不支持HTTP&#x2F;2时回退preload）</li>
</ol>
<h2 id="2-2-缓存机制"><a href="#2-2-缓存机制" class="headerlink" title="2.2 缓存机制"></a>2.2 缓存机制</h2><h3 id="强缓存：Cache-Control-Expires"><a href="#强缓存：Cache-Control-Expires" class="headerlink" title="强缓存：Cache-Control &#x2F; Expires"></a>强缓存：Cache-Control &#x2F; Expires</h3><p><strong>工作原理</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Browser as 浏览器
    participant Cache as 本地缓存
    participant Server as 服务器
    
    Browser->>Cache: 请求资源
    alt 缓存有效
        Cache-->>Browser: 直接返回缓存(状态码200 from cache)
    else 缓存失效
        Browser->>Server: 发送请求
        Server-->>Browser: 返回资源 + 新缓存头
    end</pre>

<ul>
<li>无网络请求：命中缓存时不产生任何网络流量</li>
<li>HTTP状态码：<ul>
<li>Chrome：200 (from disk cache) 或 200 (from memory cache)</li>
<li>Firefox：200 OK (cached)</li>
</ul>
</li>
</ul>
<p><strong>Expires：绝对时间控制</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2025 07:28:00 GMT<br></code></pre></td></tr></table></figure>

<ul>
<li>基于服务端时间：指定资源的具体过期时间点</li>
<li>时区要求：必须使用 GMT 格式</li>
<li>致命缺陷：<ul>
<li>依赖客户端与服务端时钟严格同步（时差导致缓存失效）</li>
<li>无法应对时区切换（如夏令时调整）</li>
</ul>
</li>
<li>使用场景：<ul>
<li>仅需兼容IE8及以下浏览器的系统</li>
<li>静态资源版本变更频率极低（如年更）</li>
</ul>
</li>
</ul>
<p><strong>Cache-Control：现代缓存控制</strong></p>
<p>指令全集（常用20+指令）：</p>
<table>
<thead>
<tr>
<th align="left">指令类型</th>
<th align="left">关键指令</th>
<th align="left">值格式</th>
<th align="left">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">过期控制</td>
<td align="left">max-age</td>
<td align="left">秒数（如 3600）</td>
<td align="left">资源有效期（相对时间）</td>
</tr>
<tr>
<td align="left">可缓存性</td>
<td align="left">public<br>private<br>no-store</td>
<td align="left">无值<br>无值<br>无值</td>
<td align="left">允许代理&#x2F;CDN缓存<br>仅限用户浏览器缓存<br>禁止任何缓存</td>
</tr>
<tr>
<td align="left">重新验证</td>
<td align="left">must-revalidate</td>
<td align="left">无值</td>
<td align="left">过期后必须回源验证</td>
</tr>
<tr>
<td align="left">特殊行为</td>
<td align="left">no-cache<br>immutable</td>
<td align="left">无值<br>无值</td>
<td align="left">每次使用前需验证（非字面意思）<br> 永不变更资源（版本化路径适用）</td>
</tr>
<tr>
<td align="left">缓存继承</td>
<td align="left">s-maxage</td>
<td align="left">秒数</td>
<td align="left">代理服务器专用max-age</td>
</tr>
</tbody></table>
<p>优先级规则：</p>
<pre class="mermaid">graph TB
    A[Cache-Control] --> B[no-store] -->|最高| C[禁止缓存]
    A --> D[no-cache] -->|次高| E[每次验证]
    A --> F[max-age] -->|基础| G[相对时间缓存]
    A --> H[Expires] -->|兜底| I[绝对时间缓存]</pre>

<p><strong>浏览器缓存存储机制</strong></p>
<table>
<thead>
<tr>
<th align="left">缓存类型</th>
<th align="left">存储位置</th>
<th align="left">生命周期</th>
<th align="left">容量限制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Memory Cache</td>
<td align="left">系统内存</td>
<td align="left">进程关闭即清除</td>
<td align="left">小（约10MB）</td>
</tr>
<tr>
<td align="left">Disk Cache</td>
<td align="left">硬盘分区</td>
<td align="left">持久化存储</td>
<td align="left">大（数百MB）</td>
</tr>
</tbody></table>
<p><strong>资源分配规则</strong></p>
<ul>
<li>大文件(&gt;1MB) –&gt; Disk Cache	长期保留</li>
<li>小文件 –&gt; Memory Cache	短期快速读取</li>
<li>预加载资源 –&gt; Memory Cache	页面关闭即清除</li>
</ul>
<p><strong>强缓存失效策略</strong></p>
<p>(1) 主动更新机制</p>
<ul>
<li>URL版本化（最高效）：<code>/main.v2.3.1.js</code></li>
<li>查询参数变更（部分CDN不兼容）：<code>/data.json?v=20231021</code></li>
<li>文件名指纹（构建工具自动生成）：<code>/app.8e9d2a.js</code></li>
</ul>
<p>(2) 被动更新机制</p>
<ul>
<li>max-age 过期后自动失效</li>
<li>用户强制刷新（Ctrl+F5）跳过缓存</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>所有静态资源设置 public</li>
<li>版本化资源添加 immutable</li>
<li>动态内容设置 private + 适当 max-age</li>
<li>敏感数据明确 no-store</li>
<li>配置 s-maxage 控制CDN缓存</li>
<li>弃用 Expires（优先使用 Cache-Control）</li>
</ol>
<h3 id="协商缓存：ETag-Last-Modified"><a href="#协商缓存：ETag-Last-Modified" class="headerlink" title="协商缓存：ETag &#x2F; Last-Modified"></a>协商缓存：ETag &#x2F; Last-Modified</h3><p><strong>工作原理</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Browser as 浏览器
    participant Server as 服务器
    
    Browser->>Server: 请求资源（携带 If-None-Match/If-Modified-Since）
    alt 资源未变更
        Server-->>Browser: 304 Not Modified（空响应体）
        Browser->>Browser: 使用本地缓存
    else 资源已变更
        Server-->>Browser: 200 OK + 新资源 + 新验证头
    end</pre>

<ul>
<li>条件请求：浏览器携带验证器询问资源是否变更</li>
<li>网络交互：无论是否变更都产生网络请求</li>
<li>状态码：<ul>
<li>304 Not Modified：资源未变更</li>
<li>200 OK：资源已更新</li>
</ul>
</li>
</ul>
<p><strong>Last-Modified：基于时间戳</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">### 首次响应<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2023 07:28:00 GMT<br><br><span class="language-apache"><span class="hljs-comment">### 后续请求</span></span><br><span class="language-apache"><span class="hljs-attribute">GET</span> /resource</span><br><span class="language-apache"><span class="hljs-attribute">If</span>-Modified-Since: Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2023</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT</span><br></code></pre></td></tr></table></figure>

<ul>
<li>时间精度：最小单位为秒（1秒内多次修改无法识别）</li>
<li>验证逻辑：服务器对比当前资源修改时间与请求头时间</li>
</ul>
<p>致命缺陷：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">问题</th>
<th align="left">后果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">文件内容不变但时间更新</td>
<td align="left">时间戳变化触发无效更新</td>
<td align="left">带宽浪费</td>
</tr>
<tr>
<td align="left">分布式服务器时间不同步</td>
<td align="left">修改时间偏差导致缓存失效</td>
<td align="left">频繁请求</td>
</tr>
<tr>
<td align="left">1秒内多次修改</td>
<td align="left">时间未变但内容已改</td>
<td align="left">返回过期内容</td>
</tr>
</tbody></table>
<p><strong>ETag：基于内容指纹</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">### 首次响应<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;13a-17d5ecc5d10&quot;<br><br><span class="language-routeros"><span class="hljs-comment">### 后续请求</span></span><br><span class="language-routeros"><span class="hljs-built_in">GET</span> <span class="hljs-built_in">/resource</span></span><br><span class="hljs-built_in"><span class="language-routeros"></span>If-None-Match: <span class="hljs-string">&quot;13a-17d5ecc5d10&quot;</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>指纹生成算法：<ul>
<li>强验证器：内容哈希值（如 SHA-1）</li>
<li>弱验证器（W&#x2F;前缀）：仅检查语义变化（如 W&#x2F;“13a”）</li>
</ul>
</li>
<li>优先级规则：ETag 优先级高于 Last-Modified</li>
</ul>
<p>优势对比：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">ETag</th>
<th align="left">Last-Modified</th>
</tr>
</thead>
<tbody><tr>
<td align="left">修改检测精度</td>
<td align="left">字节级（内容哈希）</td>
<td align="left">秒级（文件系统时间）</td>
</tr>
<tr>
<td align="left">分布式一致性</td>
<td align="left">稳定（内容决定指纹）</td>
<td align="left">依赖时间同步</td>
</tr>
<tr>
<td align="left">资源变更识别</td>
<td align="left">内容不变指纹一定不变</td>
<td align="left">时间可能误变</td>
</tr>
</tbody></table>
<p><strong>服务端验证逻辑</strong></p>
<p>配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-comment"># 启用ETag（默认开启）</span><br>    <span class="hljs-attribute">etag</span> <span class="hljs-literal">on</span>;<br>    <br>    <span class="hljs-comment"># 弱ETag配置（节省CPU）</span><br>    <span class="hljs-attribute">etag_format</span> <span class="hljs-string">&#x27;W/&quot;%x-%t&quot;&#x27;</span>;  <span class="hljs-comment"># 文件大小+修改时间</span><br>    <br>    <span class="hljs-comment"># 禁用Last-Modified</span><br>    <span class="hljs-attribute">add_header</span> Last-Modified <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>决策过程：</p>
<pre class="mermaid">graph TD
    A[收到请求] --> B{携带 If-None-Match?}
    B -->|是| C[比较ETag]
    B -->|否| D{携带 If-Modified-Since?}
    D -->|是| E[比较时间戳]
    D -->|否| F[返回200]
    C -->|匹配| G[返回304]
    C -->|不匹配| F
    E -->|未修改| G
    E -->|已修改| F</pre>

<p><strong>ETag 生成策略</strong></p>
<p>最佳实践：</p>
<table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">推荐算法</th>
<th align="left">示例</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">静态文件</td>
<td align="left">强ETag（内容哈希）</td>
<td align="left">ETag: “5d83c-17a9”</td>
<td align="left">精确但消耗CPU</td>
</tr>
<tr>
<td align="left">动态API</td>
<td align="left">弱ETag（版本号&#x2F;时间戳）</td>
<td align="left">ETag: W&#x2F;“v1.2”</td>
<td align="left">高效但粒度粗</td>
</tr>
<tr>
<td align="left">大文件</td>
<td align="left">分段哈希</td>
<td align="left">ETag: “5d83c-17a9:10”</td>
<td align="left">支持Range请求验证</td>
</tr>
</tbody></table>
<p>Node.js 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 强ETag生成</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStrongEtag</span>(<span class="hljs-params">filePath</span>) &#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filePath);<br>  <span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>).<span class="hljs-title function_">update</span>(content).<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;hash&#125;</span>&quot;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 弱ETag生成</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateWeakEtag</span>(<span class="hljs-params">version</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`W/&quot;<span class="hljs-subst">$&#123;version&#125;</span>&quot;`</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>所有可缓存资源设置ETag或Last-Modified</li>
<li>静态资源优先使用强ETag</li>
<li>动态API使用弱ETag（版本号）</li>
<li>禁用不必要资源的Last-Modified</li>
<li>配合Cache-Control定义缓存周期</li>
<li>分布式环境确保验证器一致性</li>
</ol>
<h3 id="Service-Worker-离线缓存策略（Cache-API）"><a href="#Service-Worker-离线缓存策略（Cache-API）" class="headerlink" title="Service Worker 离线缓存策略（Cache API）"></a>Service Worker 离线缓存策略（Cache API）</h3><p><strong>核心机制</strong></p>
<p>技术架构：</p>
<pre class="mermaid">graph LR
    A[浏览器主线程] --> B[Service Worker]
    B --> C[Cache API]
    B --> D[Fetch API]
    C --> E[缓存存储]
    D --> F[网络请求]</pre>

<ul>
<li>独立线程：在浏览器后台运行，不阻塞主线程</li>
<li>生命周期：注册 → 安装 → 激活 → 拦截请求 → 终止</li>
<li>作用域限制：仅能控制同源下的 scope 路径</li>
</ul>
<p><strong>Cache API 核心操作</strong></p>
<p>缓存操作指令集：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">caches.open(name)</td>
<td align="left">创建&#x2F;访问命名缓存空间</td>
<td align="left">const cache &#x3D; await caches.open(‘v1’)</td>
</tr>
<tr>
<td align="left">cache.add(url)</td>
<td align="left">缓存单个请求</td>
<td align="left">cache.add(‘&#x2F;styles.css’)</td>
</tr>
<tr>
<td align="left">cache.addAll(urls)</td>
<td align="left">批量缓存请求</td>
<td align="left">cache.addAll(assets)</td>
</tr>
<tr>
<td align="left">cache.put(req, res)</td>
<td align="left">手动存储响应</td>
<td align="left">cache.put(event.request, response)</td>
</tr>
<tr>
<td align="left">cache.match(req)</td>
<td align="left">查找缓存匹配</td>
<td align="left">cache.match(event.request)</td>
</tr>
<tr>
<td align="left">cache.delete(req)</td>
<td align="left">删除特定缓存</td>
<td align="left">cache.delete(‘&#x2F;old.js’)</td>
</tr>
<tr>
<td align="left">caches.delete(name)</td>
<td align="left">删除整个缓存库</td>
<td align="left">caches.delete(‘v1’)</td>
</tr>
<tr>
<td align="left">caches.keys()</td>
<td align="left">列出所有缓存库名称</td>
<td align="left">const keys &#x3D; await caches.keys()</td>
</tr>
</tbody></table>
<p><strong>离线缓存策略</strong></p>
<p>(1) 缓存优先（Cache First）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> cached || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>))<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>适用场景：静态资源（CSS&#x2F;JS&#x2F;图片）</li>
<li>优势：离线可用，极速响应</li>
<li>风险：可能返回过期内容</li>
</ul>
<p>(2) 网络优先（Network First）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>))<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>适用场景：实时数据（股票&#x2F;新闻）</li>
<li>优势：内容最新</li>
<li>风险：弱网环境延迟高</li>
</ul>
<p>(3) 增量缓存（Stale-While-Revalidate）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">netRes</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 更新缓存</span><br>      caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, netRes));<br>      <span class="hljs-keyword">return</span> netRes.<span class="hljs-title function_">clone</span>();<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cached || fetchPromise;<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>适用场景：频繁更新资源（用户头像&#x2F;评论）</li>
<li>优势：平衡速度与新鲜度</li>
<li>开销：额外网络请求</li>
</ul>
<p>(4) 仅缓存（Cache Only）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>));<br></code></pre></td></tr></table></figure>

<ul>
<li>适用场景：核心离线资源（App Shell）</li>
<li>风险：未缓存资源直接失败</li>
</ul>
<p><strong>预缓存策略（安装阶段）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Service Worker 安装阶段</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>      cache.<span class="hljs-title function_">addAll</span>([<br>        <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>        <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,<br>        <span class="hljs-string">&#x27;/scripts/app.js&#x27;</span>,<br>        <span class="hljs-string">&#x27;/images/logo.webp&#x27;</span><br>      ])<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>event.waitUntil：延迟安装直到缓存完成</li>
<li>版本控制：每次更新使用新缓存名（v2, v3）</li>
<li>缓存清理：激活阶段删除旧缓存：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key !== <span class="hljs-string">&#x27;v2&#x27;</span> &amp;&amp; caches.<span class="hljs-title function_">delete</span>(key)))<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>动态缓存策略（运行时）</strong></p>
<p>按需缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 仅缓存GET请求和同源资源</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;GET&#x27;</span> &amp;&amp; <br>      event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>.<span class="hljs-title function_">startsWith</span>(self.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>)) &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>      <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">netRes</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 克隆响应（流只能使用一次）</span><br>        <span class="hljs-keyword">const</span> resClone = netRes.<span class="hljs-title function_">clone</span>();<br>        caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, resClone)<br>        );<br>        <span class="hljs-keyword">return</span> netRes;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>))<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>缓存更新策略</strong></p>
<p>(1) 版本化资源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 监听消息（主线程发送更新命令）</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;update&#x27;</span>) &#123;<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v2&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>      cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;/new-style.css&#x27;</span>, <span class="hljs-string">&#x27;/new-app.js&#x27;</span>])<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>(2) 内容 Hash 校验</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 检查资源更新</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkUpdate</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">url</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> cacheRes = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(url);<br>  <span class="hljs-keyword">const</span> netRes = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>  <br>  <span class="hljs-comment">// 比较ETag</span><br>  <span class="hljs-keyword">if</span> (cacheRes.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;ETag&#x27;</span>) !== netRes.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;ETag&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(url, netRes.<span class="hljs-title function_">clone</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>性能优化技巧</strong></p>
<p>(1) 缓存分段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_TYPES</span> = &#123;<br>  <span class="hljs-attr">CORE</span>: <span class="hljs-string">&#x27;core-v1&#x27;</span>,    <span class="hljs-comment">// 核心App Shell</span><br>  <span class="hljs-attr">STATIC</span>: <span class="hljs-string">&#x27;static-v1&#x27;</span>, <span class="hljs-comment">// 不常变资源</span><br>  <span class="hljs-attr">DYNAMIC</span>: <span class="hljs-string">&#x27;dynamic&#x27;</span>   <span class="hljs-comment">// 经常变资源</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>(2) 缓存容量控制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 限制动态缓存数量</span><br>caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> &#123;<br>  cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">100</span>) cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>(3) 缓存过期</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 定时清理旧缓存</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>    cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(key.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;date&#x27;</span>)) &gt; <span class="hljs-number">86400000</span>) &#123;<br>        cache.<span class="hljs-title function_">delete</span>(key);<br>      &#125;<br>    &#125;))<br>  );<br>&#125;, <span class="hljs-number">3600000</span>);<br></code></pre></td></tr></table></figure>

<p><strong>安全注意事项</strong></p>
<ul>
<li>HTTPS 强制要求：Service Worker 仅限安全上下文</li>
<li>缓存敏感数据：避免缓存私密内容（如 Cache-Control: private）</li>
<li>跨域资源限制：<ul>
<li>缓存跨域资源需设置 CORS 响应头</li>
<li>fetch 模式需为 cors</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">cache.<span class="hljs-title function_">put</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span> &#125;))<br></code></pre></td></tr></table></figure>

<p><strong>浏览器兼容性</strong></p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">支持版本</th>
<th align="left">关键限制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Chrome</td>
<td align="left">40+</td>
<td align="left">完整支持</td>
</tr>
<tr>
<td align="left">Firefox</td>
<td align="left">44+</td>
<td align="left">隐私模式受限</td>
</tr>
<tr>
<td align="left">Safari</td>
<td align="left">11.1+</td>
<td align="left">生命周期管理差异</td>
</tr>
<tr>
<td align="left">Edge</td>
<td align="left">17+</td>
<td align="left">完整支持</td>
</tr>
<tr>
<td align="left">移动端兼容</td>
<td align="left">Android 5+ &#x2F; iOS 11.3+</td>
<td align="left">部分API限制</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ol>
<li>所有静态资源预缓存</li>
<li>实现缓存清理机制（activate阶段）</li>
<li>动态资源设置容量上限</li>
<li>区分核心&#x2F;静态&#x2F;动态缓存策略</li>
<li>添加缓存更新提示逻辑</li>
<li>配置HTTP缓存头协同（max-age&#x3D;0 绕过SW缓存）</li>
</ol>
<h2 id="2-3-资源压缩与交付"><a href="#2-3-资源压缩与交付" class="headerlink" title="2.3 资源压缩与交付"></a>2.3 资源压缩与交付</h2><h3 id="Brotli-vs-Gzip-压缩算法"><a href="#Brotli-vs-Gzip-压缩算法" class="headerlink" title="Brotli vs Gzip 压缩算法"></a>Brotli vs Gzip 压缩算法</h3><p><strong>核心机制对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Gzip (DEFLATE)</th>
<th align="left">Brotli</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算法基础</td>
<td align="left">LZ77 + 霍夫曼编码</td>
<td align="left">LZ77 + 二阶上下文建模</td>
</tr>
<tr>
<td align="left">诞生时间</td>
<td align="left">1992年（RFC 1951）</td>
<td align="left">2013年（Google开发）</td>
</tr>
<tr>
<td align="left">压缩级别</td>
<td align="left">1-9（默认6）</td>
<td align="left">0-11（默认11）</td>
</tr>
<tr>
<td align="left">核心优势</td>
<td align="left">广泛兼容，CPU消耗低</td>
<td align="left">高压缩率（尤其文本资源）</td>
</tr>
<tr>
<td align="left">字典支持</td>
<td align="left">无预定义字典</td>
<td align="left">内置120KB静态字典（含HTML&#x2F;CSS&#x2F;JS常见标记）</td>
</tr>
</tbody></table>
<p><strong>浏览器兼容性</strong></p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">Gzip支持</th>
<th align="left">Brotli支持</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Chrome</td>
<td align="left">✅ 全版本</td>
<td align="left">✅ 49+</td>
<td align="left">Android 5.0+</td>
</tr>
<tr>
<td align="left">Firefox</td>
<td align="left">✅ 全版本</td>
<td align="left">✅ 44+</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Safari</td>
<td align="left">✅ 全版本</td>
<td align="left">✅ 11+ (macOS&#x2F;iOS)</td>
<td align="left">macOS High Sierra+</td>
</tr>
<tr>
<td align="left">Edge</td>
<td align="left">✅ 全版本</td>
<td align="left">✅ 15+</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">IE 11</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">不支持</td>
</tr>
</tbody></table>
<p><strong>服务器配置策略</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 启用Gzip</span><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">6</span>;  <span class="hljs-comment"># 推荐6（平衡模式）</span><br><br><span class="hljs-comment"># 启用Brotli（需安装brotli模块）</span><br><span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">brotli_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">brotli_comp_level</span> <span class="hljs-number">6</span>; <span class="hljs-comment"># 生产环境推荐6（非11）</span><br></code></pre></td></tr></table></figure>

<p>压缩级别选择建议：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">Gzip级别</th>
<th align="left">Brotli级别</th>
<th align="left">理由</th>
</tr>
</thead>
<tbody><tr>
<td align="left">实时压缩（动态）</td>
<td align="left">1-3</td>
<td align="left">0-4</td>
<td align="left">速度优先，降低CPU负载</td>
</tr>
<tr>
<td align="left">预压缩（静态）</td>
<td align="left">9</td>
<td align="left">11</td>
<td align="left">体积优先，构建时完成压缩</td>
</tr>
</tbody></table>
<p><strong>预压缩实践</strong></p>
<p>(1) webpack 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同时生成gzip和br预压缩文件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;  <span class="hljs-comment">// gzip</span><br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>,<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;  <span class="hljs-comment">// brotli</span><br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[path][base].br&#x27;</span>,<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;brotliCompress&#x27;</span>,<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span>,<br>      <span class="hljs-attr">compressionOptions</span>: &#123; <span class="hljs-attr">level</span>: <span class="hljs-number">11</span> &#125;<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) nginx 配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-comment"># 优先返回预压缩的br文件</span><br>  <span class="hljs-attribute">brotli_static</span> <span class="hljs-literal">on</span>;<br>  <br>  <span class="hljs-comment"># 若无br则返回gzip</span><br>  <span class="hljs-attribute">gzip_static</span> <span class="hljs-literal">on</span>;<br>  <br>  <span class="hljs-comment"># 动态压缩回退</span><br>  <span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>请求头协商机制</strong></p>
<p>(1) 客户端声明支持</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">GET</span> <span class="hljs-string">/main.js</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br  # 声明支持br<br></code></pre></td></tr></table></figure>

<p>(2) 服务端响应</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"># 返回Brotli压缩<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>br<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><br><span class="language-apache"><span class="hljs-comment"># 返回Gzip压缩</span></span><br><span class="language-apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK</span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Encoding: gzip</span><br><span class="language-apache"><span class="hljs-attribute">Vary</span>: Accept-Encoding</span><br></code></pre></td></tr></table></figure>

<p><strong>特殊注意事项</strong></p>
<ul>
<li>动态内容压缩：避免对已压缩格式（JPEG&#x2F;PNG&#x2F;WOFF2）二次压缩</li>
<li>CPU开销控制：动态Brotli级别≥7可能触发CPU过载（监控服务器负载）</li>
<li>缓存穿透风险：不同压缩算法需单独缓存：Vary: Accept-Encoding 必须设置</li>
</ul>
<h3 id="图片优化：WebP-AVIF格式、响应式图片（srcset）、渐进加载"><a href="#图片优化：WebP-AVIF格式、响应式图片（srcset）、渐进加载" class="headerlink" title="图片优化：WebP&#x2F;AVIF格式、响应式图片（srcset）、渐进加载"></a>图片优化：WebP&#x2F;AVIF格式、响应式图片（srcset）、渐进加载</h3><p><strong>现代图片格式对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">JPEG</th>
<th align="left">PNG</th>
<th align="left">WebP</th>
<th align="left">AVIF</th>
</tr>
</thead>
<tbody><tr>
<td align="left">压缩算法</td>
<td align="left">离散余弦变换</td>
<td align="left">无损DEFLATE</td>
<td align="left">VP8&#x2F;VP9帧内编码</td>
<td align="left">AV1帧内编码</td>
</tr>
<tr>
<td align="left">透明度</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">动画</td>
<td align="left">不支持</td>
<td align="left">支持（APNG）</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">HDR&#x2F;宽色域</td>
<td align="left">有限支持</td>
<td align="left">有限支持</td>
<td align="left">支持</td>
<td align="left">完整支持（10bit）</td>
</tr>
</tbody></table>
<p><strong>WebP 实施策略</strong></p>
<p>(1) 兼容性处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;picture&gt;<br>  &lt;!-- 优先AVIF --&gt;<br>  &lt;source srcset=&quot;image.avif&quot; type=&quot;image/avif&quot;&gt;<br>  <br>  &lt;!-- 次选WebP --&gt;<br>  &lt;source srcset=&quot;image.webp&quot; type=&quot;image/webp&quot;&gt;<br>  <br>  &lt;!-- 兜底方案 --&gt;<br>  &lt;img src=&quot;image.jpg&quot; alt=&quot;示例图片&quot;&gt;<br>&lt;/picture&gt;<br></code></pre></td></tr></table></figure>

<p>(2) 转换工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># WebP转换（质量80）</span><br>cwebp -q 80 input.jpg -o output.webp<br><br><span class="hljs-comment"># 批量转换（imagemagick）</span><br>magick mogrify -format webp -quality 85 *.jpg<br></code></pre></td></tr></table></figure>

<p><strong>AVIF 进阶特性</strong></p>
<p>核心优势：</p>
<ul>
<li>极致压缩率：比WebP再节省20-30%</li>
<li>12bit色深：完美还原HDR内容</li>
<li>无损压缩：压缩率比PNG高50%</li>
</ul>
<p>部署配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx添加MIME类型</span><br><span class="hljs-section">types</span> &#123;<br>    image/<span class="hljs-attribute">avif</span>  avif;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># AVIF编码（CPU密集型）</span><br>avifenc --speed 0 --quality 50 input.jpg output.avif<br></code></pre></td></tr></table></figure>

<p><strong>响应式图片（srcset）</strong></p>
<p>设备适配方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;img srcset=&quot;<br>  small.jpg  480w,<br>  medium.jpg 768w,<br>  large.jpg  1200w&quot;<br> sizes=&quot;(max-width: 600px) 480px,<br>        (max-width: 1024px) 768px,<br>        1200px&quot;<br> src=&quot;fallback.jpg&quot;<br> alt=&quot;响应式图片示例&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>sizes 计算规则：</p>
<pre class="mermaid">graph TD
    A[视口宽度] --> B{匹配media条件}
    B -->|600px↓| C[使用480px]
    B -->|601-1024px| D[使用768px]
    B -->|1025px↑| E[使用1200px]</pre>

<p>像素密度适配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 2x高清屏适配 --&gt;<br>&lt;img srcset=&quot;<br>  image@1x.jpg 1x,<br>  image@2x.jpg 2x,<br>  image@3x.jpg 3x&quot;<br> src=&quot;image@1x.jpg&quot; <br> alt=&quot;高DPI适配&quot;&gt;<br></code></pre></td></tr></table></figure>

<p><strong>渐进加载（Progressive Loading）</strong></p>
<p>实现方案对比：</p>
<table>
<thead>
<tr>
<th align="left">技术</th>
<th align="left">实现方式</th>
<th align="left">用户体验</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基线JPEG</td>
<td align="left">顺序加载</td>
<td align="left">从上到下扫描</td>
</tr>
<tr>
<td align="left">渐进式JPEG</td>
<td align="left">多次扫描渲染</td>
<td align="left">模糊→清晰</td>
</tr>
<tr>
<td align="left">WebP渐进</td>
<td align="left">内置渐进加载</td>
<td align="left">同JPEG但更快</td>
</tr>
<tr>
<td align="left">LQIP占位</td>
<td align="left">加载超小预览图（20px宽）</td>
<td align="left">先显示模糊预览</td>
</tr>
</tbody></table>
<p>生成渐进JPEG：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ImageMagick转换</span><br>convert input.jpg -interlace Plane progressive.jpg<br><br><span class="hljs-comment"># MozJPEG工具</span><br>cjpeg -progressive -quality 85 input.png &gt; output.jpg<br></code></pre></td></tr></table></figure>

<p>现代实现框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">// 使用loading=&quot;lazy&quot; + 模糊占位<br>&lt;img <br>  src=&quot;tiny-preview.jpg&quot; <br>  data-src=&quot;full.jpg&quot; <br>  loading=&quot;lazy&quot;<br>  style=&quot;filter: blur(5px)&quot;<br>  onload=&quot;this.style.filter=&#x27;none&#x27;&quot;<br>&gt;<br></code></pre></td></tr></table></figure>

<p><strong>图片格式选择决策策略</strong></p>
<pre class="mermaid">graph TD
    A[图片类型] --> B{需要动画?}
    B -->|是| C[WebP/AVIF]
    B -->|否| D{需要透明度?}
    D -->|是| E{需要无损?}
    E -->|是| F[PNG/AVIF]
    E -->|否| G[WebP/AVIF]
    D -->|否| H{高画质要求?}
    H -->|是| I[AVIF]
    H -->|否| J[WebP]</pre>

<p><strong>浏览器兼容性</strong></p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">WebP支持</th>
<th align="left">AVIF支持</th>
<th align="left">响应式图片</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Chrome</td>
<td align="left">✅ 32+</td>
<td align="left">✅ 85+</td>
<td align="left">✅ 完全</td>
</tr>
<tr>
<td align="left">Firefox</td>
<td align="left">✅ 65+</td>
<td align="left">✅ 86+</td>
<td align="left">✅ 完全</td>
</tr>
<tr>
<td align="left">Safari</td>
<td align="left">✅ 14+</td>
<td align="left">✅ 16.1+</td>
<td align="left">✅ 完全</td>
</tr>
<tr>
<td align="left">Edge</td>
<td align="left">✅ 18+</td>
<td align="left">✅ 85+</td>
<td align="left">✅ 完全</td>
</tr>
<tr>
<td align="left">IE 11</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
</tr>
</tbody></table>
<h3 id="代码拆分：动态import-、Webpack-SplitChunks"><a href="#代码拆分：动态import-、Webpack-SplitChunks" class="headerlink" title="代码拆分：动态import()、Webpack SplitChunks"></a>代码拆分：动态import()、Webpack SplitChunks</h3><p><strong>代码拆分核心目标</strong></p>
<ul>
<li>减少初始负载：仅加载当前路由必需代码</li>
<li>提升交互响应：延迟加载非关键功能</li>
<li>缓存优化：分离频繁变更与稳定代码</li>
</ul>
<p><strong>动态 import() 实现机制</strong></p>
<p>基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 静态导入（传统方式）</span><br><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span>; <br><br><span class="hljs-comment">// 动态导入（返回Promise）</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./utils&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">doSomething</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>React 组件级拆分：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductList&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Vue 异步组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AdminPanel</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br>  <span class="hljs-attr">component</span>: <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AdminPanel.vue&#x27;</span>),<br>  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>,<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span> <span class="hljs-comment">// 延迟显示loading</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>Webpack SplitChunks 高级配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>      <span class="hljs-attr">cacheGroups</span>: &#123;<br>        <span class="hljs-attr">vendors</span>: &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span><br>        &#125;,<br>        <span class="hljs-attr">default</span>: &#123;<br>          <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>          <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>关键配置参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">功能</th>
<th align="left">推荐值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">minSize</td>
<td align="left">number</td>
<td align="left">生成块的最小尺寸</td>
<td align="left">20000 (20KB)</td>
</tr>
<tr>
<td align="left">maxSize</td>
<td align="left">number</td>
<td align="left">尝试拆分的最大尺寸</td>
<td align="left">0 (无限制)</td>
</tr>
<tr>
<td align="left">minChunks</td>
<td align="left">number</td>
<td align="left">被引用次数阈值</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">chunks</td>
<td align="left">string</td>
<td align="left">选择块类型（all&#x2F;async&#x2F;initial）</td>
<td align="left">‘all’</td>
</tr>
<tr>
<td align="left">automaticNameDelimiter</td>
<td align="left">string	自动命名分隔符</td>
<td align="left">‘~’</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>拆分配置策略</strong></p>
<p>(1) 第三方库分离</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">reactVendor</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](react|react-dom)[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;react-vendor&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">utilityVendor</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](lodash|moment)[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;utility-vendor&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 业务模块分离</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">userModule</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]src[\\/]modules[\\/]user[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user-module&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;async&#x27;</span> <span class="hljs-comment">// 仅异步加载</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3) 公共模块提取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">common</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span>,<br>    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 被2个以上入口引用</span><br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>    <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>路由级代码拆分</strong></p>
<p>(1) React Router实现</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; lazy, <span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/Home&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/About&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">FullPageSpinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) Vue Router 实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>)<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;product&quot; */</span> <span class="hljs-string">&#x27;./views/Product.vue&#x27;</span>)<br>  &#125;<br>];<br></code></pre></td></tr></table></figure>

<p><strong>预加载 - webpack 魔法注释</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 常规加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;chart&quot; */</span> <span class="hljs-string">&#x27;./Chart&#x27;</span>);<br><br><span class="hljs-comment">// 空闲时预加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;chart&quot;, webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./Chart&#x27;</span>);<br><br><span class="hljs-comment">// 高优先级预加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;auth&quot;, webpackPreload: true */</span> <span class="hljs-string">&#x27;./Auth&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="Tree-Shaking-ES-Module-静态分析"><a href="#Tree-Shaking-ES-Module-静态分析" class="headerlink" title="Tree Shaking (ES Module 静态分析)"></a>Tree Shaking (ES Module 静态分析)</h3><p><strong>Tree Shaking 核心机制</strong></p>
<p>工作原理：</p>
<pre class="mermaid">graph LR
    A[源代码] --> B{ES Module 静态分析}
    B --> C[识别导出/导入关系]
    C --> D[构建依赖图]
    D --> E[标记未使用代码]
    E --> F[移除“死代码”]</pre>

<ul>
<li>静态分析基础：ES Module 的 import&#x2F;export 必须在顶层声明（非动态）</li>
<li>副作用检测：识别可能影响全局状态的代码（如 polyfill）</li>
<li>安全删除：仅移除确定未使用的纯函数代码</li>
</ul>
<p>与传统打包对比：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">普通打包</th>
<th align="left">Tree Shaking</th>
</tr>
</thead>
<tbody><tr>
<td align="left">代码包含</td>
<td align="left">全部模块</td>
<td align="left">仅实际使用的导出</td>
</tr>
<tr>
<td align="left">依赖分析</td>
<td align="left">文件级</td>
<td align="left">函数&#x2F;变量级</td>
</tr>
<tr>
<td align="left">适用模块</td>
<td align="left">CommonJS&#x2F;AMD</td>
<td align="left">ES Module</td>
</tr>
<tr>
<td align="left">输出大小</td>
<td align="left">较大</td>
<td align="left">显著减小</td>
</tr>
</tbody></table>
<p><strong>ES Module 静态特性</strong></p>
<p>(1) 可摇树优化的代码特征</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 可安全移除（未使用导出）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">util1</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;  <span class="hljs-comment">// ❌ 将被移除</span><br><br><span class="hljs-comment">// 被使用的导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">util2</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;  <span class="hljs-comment">// ✅ 保留</span><br><br><span class="hljs-comment">// 副作用代码（需特殊标记）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initSDK</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">_track</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 有全局副作用！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 不可摇树的情况</p>
<table>
<thead>
<tr>
<th align="left">代码模式</th>
<th align="left">原因</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">动态导入import()</td>
<td align="left">运行时依赖分析</td>
<td align="left">配置sideEffects: false</td>
</tr>
<tr>
<td align="left">CommonJS 模块</td>
<td align="left">动态导出结构</td>
<td align="left">转换为ES Module</td>
</tr>
<tr>
<td align="left">原型方法扩展</td>
<td align="left">隐式副作用</td>
<td align="left">避免修改内置原型</td>
</tr>
</tbody></table>
<p><strong>Webpack 实现详解</strong></p>
<p>(1) 基础配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 必须生产模式</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用标记</span><br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 启用代码压缩</span><br>    <span class="hljs-attr">sideEffects</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 开启副作用分析</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) package.json 关键声明</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-library&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 声明无副作用</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>       <span class="hljs-comment">// 或声明有副作用的文件</span><br>    <span class="hljs-string">&quot;**/*.css&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;src/polyfill.js&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>优化实践</strong></p>
<p>(1) 库开发规范</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正确：独立导出函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b &#125;<br><br><span class="hljs-comment">// 错误：聚合导出对象（难优化）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; ... &#125;,<br>  <span class="hljs-title function_">subtract</span>(<span class="hljs-params">a, b</span>) &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) Babel 配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-comment">// .babelrc</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;modules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 保留ES Module</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>(3) 副作用显式标记</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/*#__PURE__*/</span> <br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">calculate</span>(); <span class="hljs-comment">// 提示可安全移除</span><br><br><span class="hljs-comment">// 或使用Webpack魔法注释</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">init</span> = (<span class="hljs-params"></span>) =&gt; &#123; ... &#125; <span class="hljs-comment">/* webpackExports: [&quot;init&quot;] */</span><br></code></pre></td></tr></table></figure>

<p><strong>Tree Shaking 三阶段流程</strong></p>
<pre class="mermaid">sequenceDiagram
    participant W as Webpack
    participant T as Terser
    W->>W: 1. 标记阶段<br>（usedExports: true）
    Note right of W: 生成未使用代码列表<br>但不实际删除
    W->>T: 2. 传递优化标记
    T->>T: 3. 压缩阶段实际移除<br>（dead_code elimination）
    T-->>W: 返回精简后的bundle</pre>

<h1 id="三、渲染性能优化"><a href="#三、渲染性能优化" class="headerlink" title="三、渲染性能优化"></a>三、渲染性能优化</h1><h2 id="3-1-DOM-操作优化"><a href="#3-1-DOM-操作优化" class="headerlink" title="3.1 DOM 操作优化"></a>3.1 DOM 操作优化</h2><h3 id="避免重排（Reflow）与重绘（Repaint）"><a href="#避免重排（Reflow）与重绘（Repaint）" class="headerlink" title="避免重排（Reflow）与重绘（Repaint）"></a>避免重排（Reflow）与重绘（Repaint）</h3><p><strong>浏览器渲染管线核心流程</strong></p>
<pre class="mermaid">sequenceDiagram
    JavaScript->>样式计算: 修改DOM/CSS
    样式计算->>布局: 计算样式
    布局->>重排: 计算几何属性
    重排->>重绘: 生成绘制指令
    重绘->>合成: 栅格化处理
    合成->>显示: 输出到屏幕</pre>

<ul>
<li>重排（Reflow）：重新计算元素几何属性（位置&#x2F;尺寸）</li>
<li>重绘（Repaint）：重新绘制元素外观（颜色&#x2F;背景等）</li>
<li>关键结论：重排必导致重绘，重绘不一定触发重排</li>
</ul>
<p><strong>触发重排的操作清单</strong></p>
<table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">具体示例</th>
<th align="left">影响范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">尺寸变化</td>
<td align="left">elem.style.width &#x3D; ‘500px’</td>
<td align="left">自身及子元素</td>
</tr>
<tr>
<td align="left">位置变化</td>
<td align="left">elem.style.marginTop &#x3D; ‘20px’</td>
<td align="left">后续兄弟元素</td>
</tr>
<tr>
<td align="left">内容变化</td>
<td align="left">elem.textContent &#x3D; ‘new’</td>
<td align="left">整个文档流</td>
</tr>
<tr>
<td align="left">添加&#x2F;删除DOM</td>
<td align="left">parent.appendChild(newElem)</td>
<td align="left">父元素及后续元素</td>
</tr>
<tr>
<td align="left">获取布局信息</td>
<td align="left">elem.offsetHeight</td>
<td align="left">强制同步重排</td>
</tr>
<tr>
<td align="left">窗口缩放</td>
<td align="left">window.resize</td>
<td align="left">整个文档</td>
</tr>
</tbody></table>
<p><strong>触发重绘的操作清单</strong></p>
<table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">具体示例</th>
<th align="left">性能开销</th>
</tr>
</thead>
<tbody><tr>
<td align="left">颜色变化</td>
<td align="left">elem.style.color &#x3D; ‘red’</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">背景变化</td>
<td align="left">elem.style.background &#x3D; ‘blue’</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">阴影变化</td>
<td align="left">elem.style.boxShadow &#x3D; …</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">轮廓变化</td>
<td align="left">elem.style.outline &#x3D; ‘1px solid’</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">透明度变化</td>
<td align="left">elem.style.opacity &#x3D; 0.5</td>
<td align="left">低（触发合成层）</td>
</tr>
</tbody></table>
<p><strong>优化策略：减少重排</strong></p>
<p>(1) 读写分离（批处理DOM操作）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：交替读写触发多次重排</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 读（强制重排）</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 写</span><br><span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// 读（再次强制重排）</span><br><br><span class="hljs-comment">// 正确：先读后写</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 集中读</span><br><span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 集中写</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = height + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>(2) 脱离文档流修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方法1：使用display:none</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br><span class="hljs-comment">// 批量修改DOM</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;block&#x27;</span>;<br><br><span class="hljs-comment">// 方法2：克隆修改后替换</span><br><span class="hljs-keyword">const</span> clone = element.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 修改克隆体</span><br>parent.<span class="hljs-title function_">replaceChild</span>(clone, element);<br><br><span class="hljs-comment">// 方法3：绝对定位脱离文档流</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&#x27;1000px&#x27;</span>; <span class="hljs-comment">// 移出视口</span><br><span class="hljs-comment">// 安全修改</span><br></code></pre></td></tr></table></figure>

<p>(3) 使用CSS transform替代位置变化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：触发重排</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;<br><br><span class="hljs-comment">// 正确：仅触发合成（跳过重排重绘）</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateX(100px)&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><strong>优化策略：减少重绘</strong></p>
<p>(1) 合并样式修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：多次重绘</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;<br><br><span class="hljs-comment">// 正确：单次重绘</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&#x27;color:red; background:blue;&#x27;</span>; <br><br><span class="hljs-comment">// 或使用class</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>(2) 使用 GPU 加速合成层</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 创建独立合成层 */</span><br><span class="hljs-selector-class">.optimized</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 提前通知浏览器 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* 强制提升到合成层 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3) 避免频繁修改盒阴影</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 高开销属性 */</span><br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br><br><span class="hljs-comment">/* 优化方案 */</span><br><span class="hljs-comment">/* 方案1：缩小阴影范围 */</span><br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>);<br><br><span class="hljs-comment">/* 方案2：使用伪元素独立层 */</span><br><span class="hljs-selector-class">.element</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>开发者诊断工具</strong></p>
<p>Chrome DevTools 性能分析：</p>
<ul>
<li>Performance 面板：<ul>
<li>紫色块：Layout（重排）</li>
<li>绿色块：Paint（重绘）</li>
</ul>
</li>
<li>渲染调试工具：<ul>
<li>Paint flashing：绿色闪烁区域 &#x3D; 重绘发生位置</li>
<li>Layout Shift Regions：蓝色区域 &#x3D; 布局偏移</li>
</ul>
</li>
</ul>
<p><strong>框架级优化</strong></p>
<p>(1) React 避免策略</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 错误：内联对象每次渲染都是新引用</span><br>&lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-number">10</span> &#125;&#125;&gt;...&lt;/div&gt;<br><br><span class="hljs-comment">// 正确：提取常量</span><br><span class="hljs-keyword">const</span> style = &#123; <span class="hljs-attr">margin</span>: <span class="hljs-number">10</span> &#125;;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="hljs-comment">// 使用React.memo避免不必要渲染</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComp</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;...&#125;);<br></code></pre></td></tr></table></figure>

<p>(2) Vue 优化方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;template&gt;<br>  &lt;!-- 错误：v-if频繁切换触发重排 --&gt;<br>  &lt;div v-if=&quot;show&quot;&gt;内容A&lt;/div&gt;<br>  &lt;div v-else&gt;内容B&lt;/div&gt;<br>  <br>  &lt;!-- 正确：v-show仅触发重绘 --&gt;<br>  &lt;div v-show=&quot;show&quot;&gt;内容A&lt;/div&gt;<br>  &lt;div v-show=&quot;!show&quot;&gt;内容B&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="批量DOM更新：DocumentFragment-Virtual-DOM"><a href="#批量DOM更新：DocumentFragment-Virtual-DOM" class="headerlink" title="批量DOM更新：DocumentFragment &#x2F; Virtual DOM"></a>批量DOM更新：DocumentFragment &#x2F; Virtual DOM</h3><p><strong>批量更新的核心价值</strong></p>
<ul>
<li>减少重排次数：将多次DOM操作合并为单次</li>
<li>性能提升：避免频繁布局计算和渲染</li>
<li>应用场景：动态列表渲染、大规模UI更新</li>
</ul>
<p><strong>DocumentFragment：原生批量更新</strong></p>
<p>核心机制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建文档片段（内存DOM容器）</span><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><br><span class="hljs-comment">// 批量添加元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>  item.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">$&#123;i&#125;</span>`</span>;<br>  fragment.<span class="hljs-title function_">appendChild</span>(item);<br>&#125;<br><br><span class="hljs-comment">// 单次插入真实DOM</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>).<span class="hljs-title function_">appendChild</span>(fragment);<br></code></pre></td></tr></table></figure>

<ul>
<li>内存操作：在文档片段中的操作不会触发重排&#x2F;重绘</li>
<li>原子提交：片段插入真实DOM时仅触发单次重排</li>
</ul>
<p><strong>Virtual DOM：框架级优化</strong></p>
<p>工作原理：</p>
<pre class="mermaid">graph LR
    A[状态变化] --> B[生成新Virtual DOM]
    B --> C{对比差异}
    C -->|有变化| D[计算最小更新]
    C -->|无变化| E[跳过更新]
    D --> F[批量更新真实DOM]</pre>

<p>关键优势：</p>
<ul>
<li>差异比对（Diffing）：仅更新变化部分</li>
<li>批处理：合并多个状态变更</li>
<li>跨平台：抽象渲染逻辑（Web&#x2F;iOS&#x2F;Android）</li>
</ul>
<p><strong>实现模式对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">DocumentFragment</th>
<th align="left">Virtual DOM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作层级</td>
<td align="left">真实DOM节点</td>
<td align="left">内存中的轻量对象</td>
</tr>
<tr>
<td align="left">更新粒度</td>
<td align="left">子树级</td>
<td align="left">组件级</td>
</tr>
<tr>
<td align="left">语法复杂度</td>
<td align="left">原生API（简单）</td>
<td align="left">需框架支持（复杂）</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">局部DOM更新</td>
<td align="left">整个应用状态管理</td>
</tr>
<tr>
<td align="left">内存开销</td>
<td align="left">低（临时容器）</td>
<td align="left">中（维护虚拟树）</td>
</tr>
</tbody></table>
<p><strong>React Virtual DOM 实现</strong></p>
<p>(1) JSX 编译结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始JSX</span><br>&lt;div className=<span class="hljs-string">&quot;title&quot;</span>&gt;<span class="hljs-title class_">Hello</span>&lt;/div&gt;<br><br><span class="hljs-comment">// 编译为虚拟DOM对象</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) Diffing 算法优化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 键值优化列表对比</span><br><span class="hljs-keyword">const</span> list = items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span> /&gt;</span></span> <span class="hljs-comment">// key避免全量重渲染</span><br>));<br><br><span class="hljs-comment">// 更新策略</span><br><span class="hljs-keyword">if</span> (prev.<span class="hljs-property">type</span> === next.<span class="hljs-property">type</span>) &#123;<br>  <span class="hljs-comment">// 同类型组件：更新属性</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不同类型：卸载重建</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="复合层优化：will-change-transform-opacity"><a href="#复合层优化：will-change-transform-opacity" class="headerlink" title="复合层优化：will-change, transform, opacity"></a>复合层优化：will-change, transform, opacity</h3><p><strong>浏览器渲染层叠模型</strong></p>
<pre class="mermaid">graph TB
    A[DOM树] --> B[布局树]
    B --> C[分层]
    C --> D[绘制列表]
    D --> E[栅格化]
    E --> F[合成显示]</pre>

<ol>
<li>复合层（Compositing Layer）：浏览器将页面划分为独立图层</li>
<li>合成（Composition）：GPU直接混合图层生成最终画面</li>
<li>关键优势：修改特定属性可跳过布局和绘制阶段</li>
</ol>
<p><strong>触发复合层的CSS属性</strong></p>
<p>核心三剑客：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">优化原理</th>
<th align="left">使用示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">transform</td>
<td align="left">创建独立位图，GPU直接处理位移&#x2F;缩放&#x2F;旋转</td>
<td align="left">transform: translateX(100px)</td>
</tr>
<tr>
<td align="left">opacity</td>
<td align="left">GPU混合透明度，无需重绘底层内容</td>
<td align="left">opacity: 0.5</td>
</tr>
<tr>
<td align="left">will-change</td>
<td align="left">提前声明变化属性，浏览器预分配资源</td>
<td align="left">will-change: transform</td>
</tr>
</tbody></table>
<p>其他触发属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 创建新层 */</span><br><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">backface-visibility</span>: hidden;<br><span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>;<br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>); <span class="hljs-comment">/* 部分浏览器 */</span><br><span class="hljs-attribute">mask</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>);<br></code></pre></td></tr></table></figure>

<p><strong>will-change 深度解析</strong></p>
<p>正确做法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.optimized</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 限定具体属性 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>&#125;<br><span class="hljs-selector-class">.optimized</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>错误做法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误1：声明过多属性 */</span><br><span class="hljs-attribute">will-change</span>: transform, opacity, top, left; <span class="hljs-comment">/* 过度消耗内存 */</span><br><br><span class="hljs-comment">/* 错误2：全局应用 */</span><br>* &#123; <span class="hljs-attribute">will-change</span>: transform; &#125; <span class="hljs-comment">/* 严重性能问题 */</span><br><br><span class="hljs-comment">/* 错误3：不配合实际变化 */</span><br><span class="hljs-comment">/* 浏览器预备资源但未使用 */</span><br></code></pre></td></tr></table></figure>

<p>声明周期管理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 交互前启用</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;transform&#x27;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 交互后释放</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;transitionend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;auto&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>Transform 与 Opacity 优化机制</strong></p>
<p>GPU 加速原理：</p>
<pre class="mermaid">sequenceDiagram
    Browser->>GPU: 提交图层位图
    Browser->>GPU: 发送变换指令(transform/opacity)
    GPU->>Display: 直接合成最终画面</pre>

<ul>
<li>跳过关键路径：避免重排（Layout）和重绘（Paint）</li>
<li>60fps保障：GPU合成耗时通常小于3ms&#x2F;帧</li>
</ul>
<p><strong>浏览器层创建规则</strong></p>
<p>Chrome 层类型：</p>
<table>
<thead>
<tr>
<th align="left">层类型</th>
<th align="left">触发条件</th>
<th align="left">内存开销</th>
</tr>
</thead>
<tbody><tr>
<td align="left">根层</td>
<td align="left">页面根元素</td>
<td align="left">必需</td>
</tr>
<tr>
<td align="left">显式层</td>
<td align="left">will-change&#x2F;transform等</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">重叠层</td>
<td align="left">层叠上下文（z-index）</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">滚动层</td>
<td align="left">overflow: scroll</td>
<td align="left">高</td>
</tr>
</tbody></table>
<p>内存成本计算：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text">内存占用 = 层宽度 × 高度 × 4字节（RGBA）<br>示例：1920x1080层 ≈ 1920×1080×4 ≈ 8MB<br></code></pre></td></tr></table></figure>

<p><strong>调试工具分析</strong></p>
<p>Chrome DevTools：</p>
<ul>
<li>Layers 面板：<ul>
<li>可视化所有复合层</li>
<li>查看层尺寸&#x2F;内存占用&#x2F;创建原因</li>
</ul>
</li>
<li>Rendering 面板：<ul>
<li>开启 Layer borders：橙色边框&#x3D;复合层</li>
<li>Scrolling performance：标记滚动层问题</li>
</ul>
</li>
</ul>
<h2 id="3-2-高效CSS实践"><a href="#3-2-高效CSS实践" class="headerlink" title="3.2 高效CSS实践"></a>3.2 高效CSS实践</h2><h3 id="选择器性能：BEM-约束深度"><a href="#选择器性能：BEM-约束深度" class="headerlink" title="选择器性能：BEM 约束深度"></a>选择器性能：BEM 约束深度</h3><p><strong>CSS选择器匹配机制</strong></p>
<p>浏览器解析顺序：</p>
<pre class="mermaid">graph RL
    A[.nav__item--active] --> B[--active修饰符]
    A --> C[__item元素]
    A --> D[.nav块]
    D --> E[样式规则]</pre>

<ul>
<li>从右向左解析：浏览器先匹配最右侧选择器（如.nav__item–active）</li>
<li>关键路径：查找所有 –active 类 → 筛选含 __item 的元素 → 验证父级有 .nav</li>
</ul>
<p>性能消耗公式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">选择器开销 = 匹配步骤数 × 文档元素数量<br></code></pre></td></tr></table></figure>

<p><strong>BEM命名规范核心</strong></p>
<p>结构定义：</p>
<table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">语法</th>
<th align="left">示例</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Block</td>
<td align="left">.block</td>
<td align="left">.nav</td>
<td align="left">独立功能模块</td>
</tr>
<tr>
<td align="left">Element</td>
<td align="left">__element</td>
<td align="left">.nav__item</td>
<td align="left">块的组成部分</td>
</tr>
<tr>
<td align="left">Modifier</td>
<td align="left">–modifier</td>
<td align="left">.nav__item–active</td>
<td align="left">状态&#x2F;变体</td>
</tr>
</tbody></table>
<p>深度约束原则:</p>
<p>(1) 禁止嵌套：元素选择器不依赖祖先结构</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误：依赖结构 */</span><br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.item</span> <span class="hljs-selector-class">.text</span> &#123; ... &#125;<br><br><span class="hljs-comment">/* 正确：BEM扁平化 */</span><br><span class="hljs-selector-class">.nav__text</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<p>(2) 最大深度：选择器不超过3个部分</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 有效BEM */</span><br><span class="hljs-selector-class">.block__element--modifier</span> <br><br><span class="hljs-comment">/* 无效（超过3部分） */</span><br><span class="hljs-selector-class">.block__element__subelement--modifier</span><br></code></pre></td></tr></table></figure>

<p><strong>BEM性能优势原理</strong></p>
<p>(1) 减少匹配步骤</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 传统嵌套（4步匹配） */</span><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123; ... &#125; <br><span class="hljs-comment">/* 匹配过程：1.所有a → 2.在li内 → 3.在ul内 → 4.在nav内 */</span><br><br><span class="hljs-comment">/* BEM等效（1步匹配） */</span><br><span class="hljs-selector-class">.nav__link</span> &#123; ... &#125;<br><span class="hljs-comment">/* 匹配过程：1.所有.nav__link元素 */</span><br></code></pre></td></tr></table></figure>

<p>(2) 降低样式冲突</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 传统方式：可能意外影响其他区域 */</span><br><span class="hljs-selector-class">.content</span> <span class="hljs-selector-class">.title</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;<br><br><span class="hljs-comment">/* BEM：作用域隔离 */</span><br><span class="hljs-selector-class">.content__title</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125; <span class="hljs-comment">/* 只影响content块内 */</span><br><span class="hljs-selector-class">.product__title</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;  <span class="hljs-comment">/* 独立作用域 */</span><br></code></pre></td></tr></table></figure>

<p>(3) 避免过度修饰</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 冗余选择器 */</span><br><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.btn</span><span class="hljs-selector-class">.primary</span> &#123; ... &#125; <span class="hljs-comment">/* 特异性过高 */</span><br><br><span class="hljs-comment">/* BEM简化 */</span><br><span class="hljs-selector-class">.btn--primary</span> &#123; ... &#125; <span class="hljs-comment">/* 特异性保持低位 */</span><br></code></pre></td></tr></table></figure>

<p><strong>BEM实施规范</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 正确：符合BEM层级 --&gt;<br>&lt;nav class=&quot;nav&quot;&gt;<br>  &lt;ul class=&quot;nav__list&quot;&gt;<br>    &lt;li class=&quot;nav__item&quot;&gt;<br>      &lt;a class=&quot;nav__link nav__link--active&quot;&gt;首页&lt;/a&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/nav&gt;<br><br>&lt;!-- 错误：元素嵌套过深 --&gt;<br>&lt;div class=&quot;nav&quot;&gt;<br>  &lt;ul&gt;<br>    &lt;li&gt;<br>      &lt;a class=&quot;nav-link-active&quot;&gt;首页&lt;/a&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CSS">// SASS实现<br>// BEM规范写法<br><span class="hljs-selector-class">.nav</span> &#123;<br>  &amp;__list &#123; ... &#125;<br>  <br>  &amp;__item &#123;<br>    &amp;<span class="hljs-attr">--active</span> &#123; ... &#125; // 修饰符<br>  &#125;<br>  <br>  &amp;__link &#123;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; ... &#125; // 伪状态<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 编译结果 */</span><br><span class="hljs-selector-class">.nav__list</span> &#123; ... &#125;<br><span class="hljs-selector-class">.nav__item--active</span> &#123; ... &#125;<br><span class="hljs-selector-class">.nav__link</span><span class="hljs-selector-pseudo">:hover</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<h3 id="布局性能：Flexbox-Grid-Float"><a href="#布局性能：Flexbox-Grid-Float" class="headerlink" title="布局性能：Flexbox &gt; Grid &gt; Float"></a>布局性能：Flexbox &gt; Grid &gt; Float</h3><p><strong>布局引擎性能对比</strong></p>
<p>渲染管线差异：</p>
<pre class="mermaid">graph LR
    A[布局计算] --> B{Float}
    A --> C{Flexbox}
    A --> D{Grid}
    B --> E[多次计算]
    C --> F[单次递归]
    D --> G[单次计算]</pre>

<p>性能排序依据：</p>
<ol>
<li>计算复杂度：Float &gt; Grid &gt; Flexbox</li>
<li>渲染速度：Flexbox ≈ Grid &gt; Float（2-3倍差距）</li>
<li>重排影响范围：Float（全局） &gt; Grid（容器内） ≈ Flexbox（容器内）</li>
</ol>
<p><strong>Float：传统布局的性能陷阱</strong></p>
<p>渲染机制：</p>
<pre class="mermaid">sequenceDiagram
    浏览器->>浮动元素: 脱离文档流
    浏览器->>后续内容: 重排（环绕布局）
    浏览器->>父容器: 高度塌陷
    浏览器->>清除浮动: 额外布局计算</pre>

<ol>
<li>全局重排：修改任意浮动元素影响整个文档流</li>
<li>高度计算：需要额外清除浮动（clearfix hack）</li>
<li>复合层创建：浮动元素常触发额外合成层（内存开销）</li>
</ol>
<p><strong>Flexbox：现代布局优化方案</strong></p>
<p>性能优势：</p>
<ol>
<li>单次递归计算：容器尺寸变化时仅重新计算直接子项</li>
<li>最小化重排范围：修改子项仅影响容器内部</li>
<li>GPU加速潜力：配合transform实现高性能动画</li>
</ol>
<p>渲染流程优化：</p>
<pre class="mermaid">graph TB
    A[设置display:flex] --> B[计算主轴尺寸]
    B --> C[计算交叉轴尺寸]
    C --> D[分配剩余空间]
    D --> E[单次绘制完成]</pre>

<p><strong>Grid：二维布局的高效实现</strong></p>
<p>性能特性:</p>
<ol>
<li>显式定位：行列模板预先定义，减少动态计算</li>
<li>区域隔离：修改单元格不影响外部布局</li>
<li>分层渲染：支持独立定位的复合层</li>
</ol>
<p>与Flexbox的关键差异:</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">Grid</th>
<th align="left">Flexbox</th>
</tr>
</thead>
<tbody><tr>
<td align="left">维度能力</td>
<td align="left">二维布局（行+列）</td>
<td align="left">一维布局（主轴+交叉轴）</td>
</tr>
<tr>
<td align="left">渲染计算方式</td>
<td align="left">矩阵计算</td>
<td align="left">线性递归</td>
</tr>
<tr>
<td align="left">重排影响范围</td>
<td align="left">网格容器内</td>
<td align="left">弹性容器内</td>
</tr>
<tr>
<td align="left">性能开销</td>
<td align="left">略高于Flexbox（约10-15%）</td>
<td align="left">最低</td>
</tr>
</tbody></table>
<p><strong>布局选择决策策略</strong></p>
<pre class="mermaid">graph TD
    A[布局需求] --> B{一维布局?}
    B -->|是| C[Flexbox]
    B -->|否| D{二维网格?}
    D -->|是| E[Grid]
    D -->|否| F[Float+Position]
    F --> G{考虑性能影响}
    G -->|关键路径| H[转换为Flexbox/Grid]
    G -->|非关键区域| I[保持Float]</pre>

<h3 id="减少布局抖动（Layout-Thrashing）"><a href="#减少布局抖动（Layout-Thrashing）" class="headerlink" title="减少布局抖动（Layout Thrashing）"></a>减少布局抖动（Layout Thrashing）</h3><p><strong>布局抖动核心机制</strong></p>
<p>问题定义：</p>
<pre class="mermaid">sequenceDiagram
    participant JavaScript
    participant Browser
    participant RenderEngine
    
    JavaScript->>Browser: 读取布局属性(offsetHeight等)
    Browser->>RenderEngine: 触发强制同步布局
    RenderEngine->>JavaScript: 返回布局值
    JavaScript->>Browser: 修改样式(width等)
    Browser->>RenderEngine: 再次触发布局计算
    loop 循环重复
        JavaScript->>Browser: 读取新布局属性
        Browser->>RenderEngine: 再次强制同步布局
    end</pre>

<ul>
<li>强制同步布局（Forced Synchronous Layout）：JS读取布局属性时，浏览器必须立即计算最新布局</li>
<li>抖动（Thrashing）：读写操作交替进行，导致多次不必要的布局计算</li>
<li>性能断崖式下降：N个元素操作可能触发2N次布局计算</li>
</ul>
<p><strong>典型错误模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 灾难性写法：每轮循环触发2次布局计算</span><br><span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.item&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 读：触发布局</span><br>  <span class="hljs-keyword">const</span> width = elements[i].<span class="hljs-property">offsetWidth</span>; <br>  <br>  <span class="hljs-comment">// 写：修改样式</span><br>  elements[i].<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (width + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>; <br>  <br>  <span class="hljs-comment">// 再读：再次触发布局！</span><br>  <span class="hljs-keyword">const</span> newWidth = elements[i].<span class="hljs-property">offsetWidth</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优化策略：批处理读写操作</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正确：先集中读取所有值</span><br><span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.item&#x27;</span>);<br><span class="hljs-keyword">const</span> widths = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  widths[i] = elements[i].<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 仅触发1次布局</span><br>&#125;<br><br><span class="hljs-comment">// 再集中写入修改</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  elements[i].<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (widths[i] + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 触发1次布局</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优化策略：使用FastDOM库</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> fastdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fastdom&#x27;</span>;<br><br><span class="hljs-comment">// 自动批处理读写</span><br>elements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>  fastdom.<span class="hljs-title function_">measure</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 读操作</span><br>    <span class="hljs-keyword">const</span> width = el.<span class="hljs-property">offsetWidth</span>;<br>    <br>    fastdom.<span class="hljs-title function_">mutate</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 写操作</span><br>      el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (width + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="3-3-JavaScript执行优化"><a href="#3-3-JavaScript执行优化" class="headerlink" title="3.3 JavaScript执行优化"></a>3.3 JavaScript执行优化</h2><h3 id="任务分片：requestIdleCallback-requestAnimationFrame"><a href="#任务分片：requestIdleCallback-requestAnimationFrame" class="headerlink" title="任务分片：requestIdleCallback &#x2F; requestAnimationFrame"></a>任务分片：requestIdleCallback &#x2F; requestAnimationFrame</h3><p><strong>任务分片核心机制</strong></p>
<p>浏览器事件循环模型：</p>
<pre class="mermaid">graph LR
    A[宏任务] --> B[微任务]
    B --> C[渲染管线]
    C -->|空闲时段| D[requestIdleCallback]
    C -->|下一帧前| E[requestAnimationFrame]</pre>

<p>关键问题定义：</p>
<pre class="mermaid">sequenceDiagram
    JS引擎->>主线程: 执行长任务(>50ms)
    主线程->>用户: 界面冻结/卡顿
    用户->>浏览器: 操作无响应
    浏览器->>开发者: 显示Long Task警告</pre>

<p><strong>requestAnimationFrame（rAF）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在下一帧渲染前执行</span><br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;pos&#125;</span>px)`</span>;<br>&#125;<br><br><span class="hljs-comment">// 注册下一帧执行</span><br><span class="hljs-title function_">requestAnimationFrame</span>(updateUI);<br></code></pre></td></tr></table></figure>

<p>核心特性：</p>
<ol>
<li>执行时机：浏览器下一帧绘制之前（约16.6ms&#x2F;帧）</li>
<li>最佳场景：视觉更新&#x2F;动画处理</li>
<li>自动暂停：后台标签页中自动停止调用</li>
</ol>
<p>任务分片模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> tasks = <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();<br>  <br>  <span class="hljs-comment">// 每帧执行5ms任务</span><br>  <span class="hljs-keyword">while</span> (index &lt; tasks.<span class="hljs-property">length</span> &amp;&amp; performance.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-title function_">processTask</span>(tasks[index++]);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (index &lt; tasks.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-title function_">requestAnimationFrame</span>(processChunk);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">requestAnimationFrame</span>(processChunk);<br></code></pre></td></tr></table></figure>

<p><strong>requestIdleCallback（rIC）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">backgroundWork</span>(<span class="hljs-params">deadline</span>) &#123;<br>  <span class="hljs-keyword">while</span> (<br>    tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <br>    deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 剩余空闲时间</span><br>  ) &#123;<br>    <span class="hljs-title function_">processTask</span>(tasks.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">requestIdleCallback</span>(backgroundWork);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 注册空闲任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(backgroundWork);<br></code></pre></td></tr></table></figure>

<p>核心特性：</p>
<ol>
<li>执行时机：渲染管线空闲时段（默认50ms超时）</li>
<li>最佳场景：非关键后台任务</li>
<li>超时机制：timeout选项强制执行</li>
</ol>
<p>优先级控制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 高优先级任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(urgentTask, &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">100</span> &#125;);<br><br><span class="hljs-comment">// 低优先级任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(lowPriorityTask);<br></code></pre></td></tr></table></figure>

<p><strong>性能对比矩阵</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">requestAnimationFrame</th>
<th align="left">requestIdleCallback</th>
</tr>
</thead>
<tbody><tr>
<td align="left">执行时机</td>
<td align="left">每帧开始前</td>
<td align="left">浏览器空闲期</td>
</tr>
<tr>
<td align="left">适用任务</td>
<td align="left">视觉更新&#x2F;动画</td>
<td align="left">数据分析&#x2F;日志上报</td>
</tr>
<tr>
<td align="left">执行保证</td>
<td align="left">每帧必执行</td>
<td align="left">可能永不执行（持续忙碌）</td>
</tr>
<tr>
<td align="left">超时控制</td>
<td align="left">无</td>
<td align="left">timeout参数强制触发</td>
</tr>
<tr>
<td align="left">后台行为</td>
<td align="left">标签页隐藏时暂停</td>
<td align="left">标签页隐藏时降频执行</td>
</tr>
<tr>
<td align="left">任务时长</td>
<td align="left">应&lt;5ms（保持60fps）</td>
<td align="left">应&lt;50ms（避免阻塞交互）</td>
</tr>
</tbody></table>
<p><strong>分片策略决策</strong></p>
<pre class="mermaid">graph TD
    A[任务类型] --> B{需要视觉同步?}
    B -->|是| C[使用requestAnimationFrame]
    B -->|否| D{是否关键任务?}
    D -->|是| E[setTimeout微任务]
    D -->|否| F[使用requestIdleCallback]
    F --> G{需要执行保证?}
    G -->|是| H[设置timeout参数]
    G -->|否| I[纯空闲处理]</pre>

<h3 id="Web-Workers-多线程计算"><a href="#Web-Workers-多线程计算" class="headerlink" title="Web Workers 多线程计算"></a>Web Workers 多线程计算</h3><p><strong>Web Workers 核心机制</strong></p>
<p>架构原理：</p>
<pre class="mermaid">graph LR
    Main[主线程] -->|消息传递| Worker[Worker线程]
    Worker -->|消息传递| Main
    Worker -->|独立运行| Sub[无DOM/BOM访问]</pre>

<ul>
<li>独立线程：在后台线程中运行JavaScript</li>
<li>通信机制：基于 postMessage 和 onmessage 事件</li>
<li>沙箱限制：<ul>
<li>❌ 无法访问 DOM&#x2F;BOM</li>
<li>❌ 不能使用 window&#x2F;document 对象</li>
<li>✅ 支持 fetch&#x2F;IndexedDB&#x2F;数学运算</li>
</ul>
</li>
</ul>
<p><strong>创建与通信流程</strong></p>
<p>(1) 基本用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br><br><span class="hljs-comment">// 发送数据</span><br>worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CALC&#x27;</span>, <span class="hljs-attr">data</span>: bigArray &#125;);<br><br><span class="hljs-comment">// 接收结果</span><br>worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结果:&#x27;</span>, e.<span class="hljs-property">data</span>.<span class="hljs-property">result</span>);<br>&#125;;<br><br><span class="hljs-comment">// worker.js</span><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;CALC&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">heavyCompute</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>);<br>    self.<span class="hljs-title function_">postMessage</span>(&#123; result &#125;); <span class="hljs-comment">// 返回结果</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>(2) 传输机制优化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 零拷贝传输（移动所有权）</span><br>worker.<span class="hljs-title function_">postMessage</span>(bigBuffer, [bigBuffer]); <br><br><span class="hljs-comment">// 共享内存（SharedArrayBuffer）</span><br><span class="hljs-keyword">const</span> sharedBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>);<br>worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">buffer</span>: sharedBuffer &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>性能优势场景</strong></p>
<p>(1) 计算密集型任务</p>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">主线程耗时</th>
<th align="left">Worker耗时</th>
<th align="left">加速比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">canvas图像处理（1000x1000）</td>
<td align="left">320ms</td>
<td align="left">45ms</td>
<td align="left">7.1×</td>
</tr>
<tr>
<td align="left">物理引擎计算</td>
<td align="left">85ms</td>
<td align="left">12ms</td>
<td align="left">7.0×</td>
</tr>
<tr>
<td align="left">大数据排序（1e6）</td>
<td align="left">780ms</td>
<td align="left">110ms</td>
<td align="left">7.0×</td>
</tr>
</tbody></table>
<p>(2) 避免阻塞关键路径</p>
<pre class="mermaid">sequenceDiagram
    Main->>Worker: 分派计算任务
    Main->>UI: 继续渲染/响应用户
    Worker->>Main: 返回结果（异步）</pre>

<p><strong>Worker 类型对比</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">创建方式</th>
<th align="left">作用域</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">专用Worker (Dedicated)</td>
<td align="left">new Worker()</td>
<td align="left">单个页面</td>
<td align="left">页面专属计算</td>
</tr>
<tr>
<td align="left">共享Worker (Shared)</td>
<td align="left">new SharedWorker()</td>
<td align="left">多页面&#x2F;标签页</td>
<td align="left">跨页面数据同步</td>
</tr>
<tr>
<td align="left">Service Worker</td>
<td align="left">navigator.serviceWorker.register()</td>
<td align="left">整个域名</td>
<td align="left">离线缓存&#x2F;后台同步</td>
</tr>
</tbody></table>
<p><strong>性能优化技巧</strong></p>
<p>(1) 线程池管理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建4个Worker的线程池</span><br><span class="hljs-keyword">const</span> workerPool = <span class="hljs-title class_">Array</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;compute.js&#x27;</span>));<br><br><span class="hljs-comment">// 任务分发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchTask</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">const</span> worker = workerPool.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.<span class="hljs-property">busy</span>);<br>  <span class="hljs-keyword">if</span> (!worker) <span class="hljs-keyword">return</span>;<br>  <br>  worker.<span class="hljs-property">busy</span> = <span class="hljs-literal">true</span>;<br>  worker.<span class="hljs-title function_">postMessage</span>(data);<br>  worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">handleResult</span>(e.<span class="hljs-property">data</span>);<br>    worker.<span class="hljs-property">busy</span> = <span class="hljs-literal">false</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 数据传输优化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 使用Transferable Objects</span><br>worker.<span class="hljs-title function_">postMessage</span>(largeArrayBuffer, [largeArrayBuffer]);<br><br><span class="hljs-comment">// 2. 序列化优化（protobuf/MessagePack）</span><br><span class="hljs-keyword">const</span> encoded = msgpack.<span class="hljs-title function_">encode</span>(data);<br>worker.<span class="hljs-title function_">postMessage</span>(encoded);<br><br><span class="hljs-comment">// 3. 减少通信频率（批量处理）</span><br></code></pre></td></tr></table></figure>

<p><strong>终止与释放</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程控制</span><br>worker.<span class="hljs-title function_">terminate</span>(); <span class="hljs-comment">// 立即终止</span><br><br><span class="hljs-comment">// Worker内部自毁</span><br>self.<span class="hljs-title function_">close</span>();<br></code></pre></td></tr></table></figure>

<p><strong>现代API集成</strong></p>
<p>(1) ES Module Worker</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span>  <span class="hljs-comment">// 支持ES6模块</span><br>&#125;);<br><br><span class="hljs-comment">// worker.js</span><br><span class="hljs-keyword">import</span> &#123; heavyTask &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span>;<br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-title function_">async</span> (e) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">heavyTask</span>(e.<span class="hljs-property">data</span>);<br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>(2) Web Assembly 协同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// worker.js</span><br><span class="hljs-keyword">const</span> wasmModule = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;compute.wasm&#x27;</span>));<br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = wasmModule.<span class="hljs-property">exports</span>.<span class="hljs-title function_">compute</span>(e.<span class="hljs-property">data</span>);<br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="内存泄漏排查（Chrome-Memory面板）"><a href="#内存泄漏排查（Chrome-Memory面板）" class="headerlink" title="内存泄漏排查（Chrome Memory面板）"></a>内存泄漏排查（Chrome Memory面板）</h3><p><strong>内存泄漏核心特征</strong></p>
<pre class="mermaid">graph LR
    A[内存分配] --> B[未释放]
    B --> C[堆内存持续增长]
    C --> D[页面卡顿崩溃]</pre>

<p>关键表现：</p>
<ul>
<li>页面操作后内存不回落</li>
<li>时间线显示锯齿状上升（GC后仍增长）</li>
<li>最终触发 Out of Memory 崩溃</li>
</ul>
<p><strong>Chrome Memory 面板三剑客</strong></p>
<p>(1) Heap Snapshot（堆快照）</p>
<p>(2) Allocation Instrumentation（分配分析）</p>
<pre class="mermaid">graph TB
    A[开始记录] --> B[执行用户操作]
    B --> C[停止记录]
    C --> D[定位未释放内存]</pre>

<p>(3) Allocation Timeline（分配时间线）</p>
<p><strong>排查流程五步法</strong></p>
<p>步骤1：复现泄漏</p>
<ul>
<li>打开 Chrome DevTools → Memory 面板</li>
<li>执行可疑操作（如打开&#x2F;关闭弹窗）</li>
<li>手动触发GC（点击垃圾桶图标）</li>
</ul>
<p>步骤2：创建基准快照</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text">// 操作前：初始状态<br>1. 点击 &quot;Take snapshot&quot; → 保存为 &quot;Snapshot 1&quot;<br></code></pre></td></tr></table></figure>

<p>步骤3：执行泄漏操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 模拟用户行为</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-title function_">openModal</span>();  <span class="hljs-comment">// 打开弹窗</span><br>  <span class="hljs-title function_">closeModal</span>(); <span class="hljs-comment">// 关闭弹窗</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>步骤4：创建对比快照</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">// 操作后：理想状态应回到初始内存<br>1. 手动触发GC<br>2. 点击 &quot;Take snapshot&quot; → 保存为 &quot;Snapshot 2&quot;<br></code></pre></td></tr></table></figure>

<p>步骤5：分析差异</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">1. 选择 &quot;Snapshot 2&quot;<br>2. 切换比较模式为 &quot;Snapshot 1&quot;<br>3. 筛选 &quot;All objects&quot; 查看 #Delta 正增长项<br></code></pre></td></tr></table></figure>

<p><strong>泄漏模式诊断表</strong></p>
<table>
<thead>
<tr>
<th align="left">泄漏类型</th>
<th align="left">关键特征</th>
<th align="left">排查技巧</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未解绑事件</td>
<td align="left">EventListener 数量持续增长</td>
<td align="left">搜索 EventListener 保留树</td>
</tr>
<tr>
<td align="left">DOM游离节点</td>
<td align="left">Detached HTMLDivElement 堆积</td>
<td align="left">筛选 Detached 节点</td>
</tr>
<tr>
<td align="left">闭包累积</td>
<td align="left">Closure 占用巨大</td>
<td align="left">检查函数上下文引用链</td>
</tr>
<tr>
<td align="left">定时器未清除</td>
<td align="left">setInterval 持有对象</td>
<td align="left">搜索 Timer 持有者</td>
</tr>
<tr>
<td align="left">全局缓存膨胀</td>
<td align="left">全局数组&#x2F;对象大小只增不减</td>
<td align="left">跟踪大对象分配路径</td>
</tr>
</tbody></table>
<p><strong>内存分配追踪</strong></p>
<p>(1) 时间线定位泄露点</p>
<pre class="mermaid">timeline
    title 内存分配时间线
    section 操作过程
    点击打开弹窗 ： 内存+15MB
    关闭弹窗 ： 内存-2MB
    循环10次 ： 内存+130MB // 泄漏！</pre>

<p>(2) 火焰图分析</p>
<ul>
<li>开启 “Allocation instrumentation”</li>
<li>执行操作 → 停止记录</li>
<li>分析堆栈火焰图：<ul>
<li>蓝色条：未回收内存</li>
<li>调用树定位泄漏函数</li>
</ul>
</li>
</ul>
<h3 id="防抖（Debounce）与节流（Throttle）"><a href="#防抖（Debounce）与节流（Throttle）" class="headerlink" title="防抖（Debounce）与节流（Throttle）"></a>防抖（Debounce）与节流（Throttle）</h3><p>这两个概念是解决高频事件（如滚动 scroll、窗口调整大小 resize、鼠标移动 mousemove、输入框输入 input、键盘按下 keyup&#x2F;keydown 等）导致性能问题的核心策略。它们的目标都是限制事件处理函数被执行的频率，从而减少不必要的、昂贵的计算、DOM 操作或网络请求（如搜索建议），提升页面响应性和流畅度。</p>
<p><strong>防抖（Debounce）</strong></p>
<p>核心思想：“等一等，等你消停了再说”</p>
<p>工作原理：</p>
<ul>
<li>当事件连续触发时，防抖函数不会立即执行。</li>
<li>它会设置一个等待计时器（timer）。</li>
<li>如果在等待时间（delay） 内，事件再次被触发，则清除之前的计时器，并重新开始计时。</li>
<li>只有在事件停止触发，并且等待时间 delay 毫秒过去之后，目标函数才会执行一次。</li>
</ul>
<p>实现（简化版）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeoutId; <span class="hljs-comment">// 用于存储计时器ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123; <span class="hljs-comment">// 返回包装后的函数</span><br>    <span class="hljs-built_in">clearTimeout</span>(timeoutId); <span class="hljs-comment">// 每次触发都清除之前的计时器</span><br>    timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 设置新的计时器</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 等待delay后执行原函数</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例：搜索框输入防抖</span><br><span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;search&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchSuggestions = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">query</span>) &#123;<br>  <span class="hljs-comment">// 发送请求获取搜索建议...</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Fetching suggestions for:&#x27;</span>, query);<br>&#125;, <span class="hljs-number">300</span>); <span class="hljs-comment">// 延迟300ms</span><br><br>searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchSuggestions</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 使用防抖后的函数</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>节流（Throttle）</strong></p>
<p>核心思想：“不管你怎么闹，我固定时间只做一次”。</p>
<p>工作原理：</p>
<ul>
<li>当事件连续触发时，节流函数会按照固定的时间间隔（delay） 执行目标函数。</li>
<li>它保证在 delay 毫秒内，目标函数最多只执行一次。</li>
<li>有两种常见实现方式：<ul>
<li>计时器方式： 第一次触发立即执行并开启计时器，在计时器结束前忽略后续触发。计时器结束后，再响应下一次触发。</li>
<li>时间戳方式： 记录上次执行的时间戳 lastExec。每次触发时，检查当前时间与 lastExec 的差值是否大于 delay。如果大于，则执行函数并更新 lastExec；否则忽略。</li>
</ul>
</li>
</ul>
<p>实现（时间戳方式 - 更精确控制首次和最后一次）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastExec = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>  <span class="hljs-keyword">let</span> timeoutId; <span class="hljs-comment">// 可选，用于处理尾随调用（如果需要）</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">const</span> timeSinceLastExec = now - lastExec;<br><br>    <span class="hljs-keyword">if</span> (timeSinceLastExec &gt;= delay) &#123;<br>      <span class="hljs-comment">// 距离上次执行已超过delay，立即执行</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastExec = now;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 可选：如果希望在停止触发后还能执行一次（尾随调用）</span><br>      <span class="hljs-comment">// 清除之前可能设置的尾随计时器</span><br>      <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>      <span class="hljs-comment">// 设置新的计时器，在剩余时间后执行</span><br>      timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        lastExec = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 更新执行时间</span><br>      &#125;, delay - timeSinceLastExec);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例：滚动事件节流</span><br><span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 检查是否滚动到底部、更新UI等...</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Handling scroll...&#x27;</span>);<br>&#125;, <span class="hljs-number">250</span>); <span class="hljs-comment">// 最多每250ms执行一次</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, handleScroll);<br></code></pre></td></tr></table></figure>

<p><strong>防抖 vs 节流：关键区别总结</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">防抖 (Debounce)</th>
<th align="left">节流 (Throttle)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心目标</td>
<td align="left">在事件停止触发后执行一次</td>
<td align="left">固定间隔执行一次，不管触发频率多高</td>
</tr>
<tr>
<td align="left">执行时机</td>
<td align="left">等待期 (delay) 结束后执行</td>
<td align="left">间隔期 (delay) 开始或结束时执行</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">关注最终状态 (停止输入、停止调整大小)</td>
<td align="left">关注过程状态 (滚动位置、鼠标位置)</td>
</tr>
<tr>
<td align="left">效果</td>
<td align="left">密集触发只执行一次 (最后那次)</td>
<td align="left">密集触发按固定频率执行多次</td>
</tr>
</tbody></table>
<h1 id="四、应用级优化策略"><a href="#四、应用级优化策略" class="headerlink" title="四、应用级优化策略"></a>四、应用级优化策略</h1><h2 id="4-1-框架专项优化"><a href="#4-1-框架专项优化" class="headerlink" title="4.1 框架专项优化"></a>4.1 框架专项优化</h2><h3 id="React：Memoization、懒加载组件、并发模式（Suspense）"><a href="#React：Memoization、懒加载组件、并发模式（Suspense）" class="headerlink" title="React：Memoization、懒加载组件、并发模式（Suspense）"></a>React：Memoization、懒加载组件、并发模式（Suspense）</h3><p><strong>Memoization（记忆化）</strong></p>
<p>核心目标：避免不必要的组件重渲染</p>
<p>实现机制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. React.memo (组件级记忆)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">/* 仅当props变更时重渲染 */</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 自定义比较逻辑（非必须）</span><br>    <span class="hljs-keyword">return</span> prevProps.<span class="hljs-property">id</span> === nextProps.<span class="hljs-property">id</span>;<br>  &#125;<br>);<br><br><span class="hljs-comment">// 2. useMemo (值记忆)</span><br><span class="hljs-keyword">const</span> expensiveValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b);<br>&#125;, [a, b]); <span class="hljs-comment">// 依赖项变化时重新计算</span><br><br><span class="hljs-comment">// 3. useCallback (函数记忆)</span><br><span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">doSomething</span>(a, b);<br>&#125;, [a, b]); <span class="hljs-comment">// 依赖不变时返回相同函数引用</span><br></code></pre></td></tr></table></figure>

<p>优化场景：</p>
<ul>
<li>父组件频繁渲染但子组件props未变化</li>
<li>计算成本高的数据推导</li>
<li>作为依赖项的函数&#x2F;对象（避免下游useEffect无效触发）</li>
</ul>
<p><strong>懒加载组件（Code Splitting）</strong></p>
<p>核心目标：减少首屏JS体积</p>
<p>实现方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. React.lazy + Suspense 基础用法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductList&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 2. 路由级懒加载 (React Router v6)</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/products&quot;</span>,<br>    <span class="hljs-attr">element</span>: (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">PageSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ProductsPage</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>    ),<br>    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./pages/Products&quot;</span>) <span class="hljs-comment">// 并行加载</span><br>  &#125;<br>]);<br></code></pre></td></tr></table></figure>

<p><strong>并发模式（Concurrent Mode）与 Suspense</strong></p>
<p>核心能力：可中断渲染与优先级调度</p>
<p>技术组合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. createRoot 启用并发模式</span><br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br><br><span class="hljs-comment">// 2. Suspense 数据获取</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfilePage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ProfileSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProfileDetails</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. startTransition 保持UI响应</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBox</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [keywords, setKeywords] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setKeywords</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 立即更新输入框</span><br>    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// 延迟计算搜索结果</span><br>      <span class="hljs-title function_">setResults</span>(<span class="hljs-title function_">computeResults</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>));<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>并发优势：</p>
<table>
<thead>
<tr>
<th align="left">传统模式</th>
<th align="left">并发模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">渲染阻塞用户输入</td>
<td align="left">高优先级操作（如输入）可中断渲染</td>
</tr>
<tr>
<td align="left">数据加载完成前显示空白</td>
<td align="left">Suspense提供加载态占位</td>
</tr>
<tr>
<td align="left">组件树全量更新</td>
<td align="left">部分子树独立更新</td>
</tr>
</tbody></table>
<p><strong>综合优化效果对比</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优化前组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ProductPage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [products] = <span class="hljs-title function_">fetchAllProducts</span>(); <span class="hljs-comment">// 同步阻塞</span><br>  <br>  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductCard</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;p&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;computeDetails&#125;</span> // <span class="hljs-attr">复杂计算</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  ))<br>&#125;<br><br><span class="hljs-comment">// 优化后实现</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">OptimizedProductPage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 1. 数据异步加载</span><br>  <span class="hljs-keyword">const</span> [products] = <span class="hljs-title function_">use</span>(fetchProductsResource); <span class="hljs-comment">// Suspense兼容</span><br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span> &#123;/* 包含startTransition的输入框 */&#125;</span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">GridSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;product-grid&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;products.map(p =&gt; (</span><br><span class="language-xml">            // 2. 组件记忆化</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">MemoizedProductCard</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;p.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;p&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              // <span class="hljs-attr">3.</span> <span class="hljs-attr">事件回调记忆化</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;useCallback(()</span> =&gt;</span> </span><br><span class="language-xml">                computeDetails(p.id), [p.id]</span><br><span class="language-xml">              )&#125;</span><br><span class="language-xml">            /&gt;</span><br><span class="language-xml">          ))&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 4. 异步加载推荐模块 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">RecommendPlaceholder</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">LazyRecommendSection</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vue：v-once、异步组件、KeepAlive"><a href="#Vue：v-once、异步组件、KeepAlive" class="headerlink" title="Vue：v-once、异步组件、KeepAlive"></a>Vue：v-once、异步组件、KeepAlive</h3><p><strong>v-once：静态内容优化</strong></p>
<p>核心作用：标记元素&#x2F;组件只渲染一次，跳过后续更新</p>
<p>实现原理：</p>
<ul>
<li>编译阶段识别静态节点树</li>
<li>创建DOM后解除响应式绑定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;template&gt;<br>  &lt;!-- 静态头部 --&gt;<br>  &lt;header v-once&gt;<br>    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;!-- 仅首次渲染 --&gt;<br>    &lt;nav&gt;...&lt;/nav&gt;<br>  &lt;/header&gt;<br>  <br>  &lt;!-- 动态内容 --&gt;<br>  &lt;main&gt;<br>    &#123;&#123; dynamicContent &#125;&#125; &lt;!-- 每次更新 --&gt;<br>  &lt;/main&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      title: &#x27;永久标题&#x27;, // 初始值锁定<br>      dynamicContent: &#x27;变化内容&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><strong>异步组件：按需加载</strong></p>
<p>核心方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 基础异步组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncPopup</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Popup.vue&#x27;</span>)<br>)<br><br><span class="hljs-comment">// 2. 高级配置（加载状态/超时/错误处理）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncCart</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ShoppingCart.vue&#x27;</span>),<br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingSpinner</span>,<br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorDisplay</span>,<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 延迟显示loading</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span> <span class="hljs-comment">// 超时时间</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>路由级分割：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vue Router配置</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;dashboard&quot; */</span> <span class="hljs-string">&#x27;./Dashboard.vue&#x27;</span>),<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;analytics&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Analytics.vue&#x27;</span>) <span class="hljs-comment">// 嵌套异步</span><br>      &#125;<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<p><strong>KeepAlive：组件缓存</strong></p>
<p>核心能力：缓存非活动组件实例，避免重复渲染</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>  &lt;component :is=&quot;currentTab&quot;&gt;<br>    &lt;!-- 动态切换组件 --&gt;<br>  &lt;/component&gt;<br>  <br>  &lt;KeepAlive <br>    :include=&quot;[&#x27;UserProfile&#x27;, &#x27;Settings&#x27;]&quot; <br>    :max=&quot;5&quot;<br>  &gt;<br>    &lt;component :is=&quot;activeComponent&quot; /&gt;<br>  &lt;/KeepAlive&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>生命周期控制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 组件被激活时调用（从缓存恢复）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>()<br>  &#125;,<br>  <span class="hljs-title function_">deactivated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 组件被停用时调用（进入缓存）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">clearTimers</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>综合优化示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>  &lt;!-- 静态框架 --&gt;<br>  &lt;div v-once class=&quot;app-frame&quot;&gt;<br>    &lt;AppHeader /&gt;<br>    &lt;AppNav /&gt;<br>  &lt;/div&gt;<br>  <br>  &lt;!-- 动态区域 --&gt;<br>  &lt;RouterView v-slot=&quot;&#123; Component &#125;&quot;&gt;<br>    &lt;KeepAlive include=&quot;ProductList,UserProfile&quot;&gt;<br>      &lt;Suspense&gt;<br>        &lt;!-- 异步组件容器 --&gt;<br>        &lt;component :is=&quot;Component&quot; /&gt;<br>        <br>        &lt;!-- 加载状态 --&gt;<br>        &lt;template #fallback&gt;<br>          &lt;LoadingIndicator /&gt;<br>        &lt;/template&gt;<br>      &lt;/Suspense&gt;<br>    &lt;/KeepAlive&gt;<br>  &lt;/RouterView&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// 异步组件注册<br>const ProductList = defineAsyncComponent(() =&gt; <br>  import(&#x27;./ProductList.vue&#x27;)<br>)<br>const UserProfile = defineAsyncComponent(&#123;<br>  loader: () =&gt; import(&#x27;./UserProfile.vue&#x27;),<br>  loadingComponent: ProfileSkeleton<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><strong>最佳实践组合</strong></p>
<ul>
<li>静态内容：v-once 用于页眉&#x2F;页脚等不变区域</li>
<li>动态模块：defineAsyncComponent + Suspense 实现按需加载</li>
<li>高频切换：KeepAlive 缓存标签页&#x2F;弹窗等组件</li>
<li>缓存管理：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主动清除缓存</span><br><span class="hljs-keyword">import</span> &#123; getCurrentInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>()<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resetCache</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-comment">// 清除UserProfile缓存</span><br>      instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$keepAliveStore</span><br>        .<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;UserProfile&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>与 React 优化对比</strong></p>
<table>
<thead>
<tr>
<th align="left">技术</th>
<th align="left">Vue</th>
<th align="left">React</th>
<th align="left">等效方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">静态优化</td>
<td align="left">v-once</td>
<td align="left">React.memo</td>
<td align="left">避免重渲染</td>
</tr>
<tr>
<td align="left">按需加载</td>
<td align="left">defineAsyncComponent</td>
<td align="left">React.lazy</td>
<td align="left">代码分割</td>
</tr>
<tr>
<td align="left">组件缓存</td>
<td align="left">KeepAlive</td>
<td align="left">无内置等效</td>
<td align="left">需手动实现</td>
</tr>
<tr>
<td align="left">加载状态</td>
<td align="left">Suspense</td>
<td align="left">Suspense</td>
<td align="left">占位符方案</td>
</tr>
</tbody></table>
<h3 id="Angular：Change-Detection策略、Pure-Pipes"><a href="#Angular：Change-Detection策略、Pure-Pipes" class="headerlink" title="Angular：Change Detection策略、Pure Pipes"></a>Angular：Change Detection策略、Pure Pipes</h3><h2 id="4-2-SSR-SSG优化"><a href="#4-2-SSR-SSG优化" class="headerlink" title="4.2 SSR&#x2F;SSG优化"></a>4.2 SSR&#x2F;SSG优化</h2><h3 id="水合（Hydration）性能瓶颈分析"><a href="#水合（Hydration）性能瓶颈分析" class="headerlink" title="水合（Hydration）性能瓶颈分析"></a>水合（Hydration）性能瓶颈分析</h3><p><strong>水合机制核心原理</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Client
  participant DOM
  participant JavaScript
  
  Note over Client, JavaScript: 1. 初始加载
  Client->>DOM: 接收静态HTML（SSR输出）
  DOM->>Client: 快速显示非交互界面
  
  Note over Client, JavaScript: 2. 水合启动
  JavaScript->>DOM: 扫描DOM节点
  DOM->>JavaScript: 返回节点信息
  
  Note over Client, JavaScript: 3. 重建关联
  JavaScript->>JavaScript: 重新创建组件实例
  JavaScript->>DOM: 绑定事件监听器
  JavaScript->>DOM: 关联内部状态
  
  Note over Client, JavaScript: 4. 完成转换
  JavaScript->>Client: 静态页面→可交互应用</pre>

<p>技术本质：</p>
<ul>
<li>将服务器渲染的静态HTML与客户端JavaScript逻辑关联</li>
<li>重建组件树状态&#x2F;事件绑定，使页面可交互</li>
<li>关键步骤：DOM节点遍历 → VDOM匹配 → 事件绑定 → 状态注入</li>
</ul>
<p><strong>水合优化路线图</strong></p>
<pre class="mermaid">flowchart LR
  A[识别瓶颈] --> B{问题类型}
  B --> C[DOM节点过多] --> C1[代码分割/懒加载]
  B --> D[事件绑定慢] --> D1[事件委托/延迟绑定]
  B --> E[数据不匹配] --> E1[统一渲染逻辑]
  B --> F[请求阻塞] --> F1[异步数据获取]
  B --> G[库不兼容] --> G1[动态导入]
  B --> H[内存泄漏] --> H1[资源清理]
  
  C1 & D1 & E1 & F1 & G1 & H1 --> I[水合完成时间<200ms]</pre>

<p><strong>关键结论</strong></p>
<p>水合瓶颈的本质是主线程过载，优化核心是减少不可中断的同步操作。通过节点精简、异步解耦和渐进加载，可提升交互就绪速度 50-300%。</p>
<h3 id="流式渲染（Streaming-SSR）"><a href="#流式渲染（Streaming-SSR）" class="headerlink" title="流式渲染（Streaming SSR）"></a>流式渲染（Streaming SSR）</h3><p><strong>传统SSR vs 流式SSR架构对比</strong></p>
<pre class="mermaid">graph LR
  A[传统SSR] --> B[请求]
  B --> C[服务器获取数据]
  C --> D[渲染完整HTML]
  D --> E[发送HTML]
  E --> F[客户端显示]
  
  G[流式SSR] --> H[请求]
  H --> I[立即发送HTML框架]
  I --> J[服务器并行获取数据]
  J --> K[流式传输内容块]
  K --> L[客户端渐进渲染]</pre>

<p>核心差异：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">传统SSR</th>
<th align="left">流式SSR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">响应方式</td>
<td align="left">全有或全无</td>
<td align="left">分块渐进传输</td>
</tr>
<tr>
<td align="left">TTFB</td>
<td align="left">高（等所有数据）</td>
<td align="left">极低（立即发送框架）</td>
</tr>
<tr>
<td align="left">LCP</td>
<td align="left">依赖完整HTML</td>
<td align="left">优先渲染关键内容</td>
</tr>
<tr>
<td align="left">资源加载</td>
<td align="left">最后阶段加载</td>
<td align="left">早期并行加载</td>
</tr>
</tbody></table>
<p><strong>技术实现原理</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Client
  participant Server
  participant DB
  
  Client->>Server: 请求页面
  Server->>Client: 立即发送HTML框架+占位符
  
  par 并行处理
    Server->>DB: 查询关键数据
    Server->>DB: 查询次要数据
  end
  
  Server->>Client: 发送关键内容块
  Client->>Client: 渲染关键内容
  
  Server->>Client: 发送次要内容块
  Client->>Client: 渲染次要内容
  
  Server->>Client: 发送结束标记
  Client->>Client: 完成渲染</pre>

<p>关键步骤：</p>
<p>(1) 响应头设置：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br></code></pre></td></tr></table></figure>

<p>(2) 内容分块传输</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 初始框架 --&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;...&lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;div id=&quot;header&quot;&gt;...&lt;/div&gt;<br>    &lt;!-- 内容占位符 --&gt;<br>    <br>&lt;!-- 数据块1 --&gt;<br>&lt;script&gt;appendToDOM(&quot;content&quot;, &quot;&lt;div&gt;首屏数据...&lt;/div&gt;&quot;)&lt;/script&gt;<br><br>&lt;!-- 数据块2 --&gt;<br>&lt;script&gt;appendToDOM(&quot;footer&quot;, &quot;&lt;div&gt;推荐内容...&lt;/div&gt;&quot;)&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><strong>React18+实现方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 服务端代码 (Node.js)</span><br><span class="hljs-keyword">import</span> &#123; renderToPipeableStream &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/server&#x27;</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; pipe &#125; = <span class="hljs-title function_">renderToPipeableStream</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>,<br>    &#123;<br>      <span class="hljs-attr">bootstrapScripts</span>: [<span class="hljs-string">&#x27;/main.js&#x27;</span>],<br>      <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"></span>) &#123;<br>        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br>        <span class="hljs-title function_">pipe</span>(res); <span class="hljs-comment">// 开始流式传输</span><br>      &#125;,<br>      <span class="hljs-title function_">onError</span>(<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;渲染错误:&#x27;</span>, error);<br>      &#125;<br>    &#125;<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">import</span> &#123; hydrateRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><br><span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>, <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure>

<p><strong>Vue3 实现方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 服务端代码 (Vite SSR)</span><br><span class="hljs-keyword">import</span> &#123; renderToWebStream &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/stream&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);<br>  <span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToWebStream</span>(app);<br>  <br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br>  stream.<span class="hljs-title function_">pipe</span>(res);<br>&#125;);<br><br><span class="hljs-comment">// 客户端激活</span><br><span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="部分静态生成（Incremental-Static-Regeneration）"><a href="#部分静态生成（Incremental-Static-Regeneration）" class="headerlink" title="部分静态生成（Incremental Static Regeneration）"></a>部分静态生成（Incremental Static Regeneration）</h3><p><strong>ISR 核心概念</strong></p>
<pre class="mermaid">graph LR
  A[传统SSG] --> B[构建时生成所有页面]
  B --> C[内容更新需全站重建]
  
  D[ISR] --> E[构建时生成关键页面]
  E --> F[按需生成其他页面]
  F --> G[定时/触发更新单个页面]</pre>

<p>技术定义：</p>
<ul>
<li>静态生成（SSG）：构建时预渲染完整HTML</li>
<li>部分静态生成（ISR）：<ul>
<li>首次访问时生成静态页面</li>
<li>按需更新过期页面</li>
<li>更新时不中断当前请求</li>
</ul>
</li>
</ul>
<p><strong>工作原理</strong></p>
<pre class="mermaid">sequenceDiagram
  participant User
  participant CDN
  participant Server
  
  User->>CDN: 请求 /product/123
  alt 页面已缓存且未过期
    CDN->>User: 立即返回静态HTML
  else 页面过期/不存在
    CDN->>Server: 请求重新生成
    Server->>Server: 增量构建页面
    Server->>CDN: 返回新HTML + 更新缓存
    CDN->>User: 返回新内容
    Server->>Background: 触发后台重建
  end</pre>

<p><strong>Next.js 实现方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// pages/products/[id].js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params">&#123; params &#125;</span>) &#123;<br>  <span class="hljs-comment">// 获取产品数据</span><br>  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProduct</span>(params.<span class="hljs-property">id</span>);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; product &#125;,<br>    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span>, <span class="hljs-comment">// 60秒后页面过期</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticPaths</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 预生成热门产品页</span><br>  <span class="hljs-keyword">const</span> hotProducts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getHotProducts</span>();<br>  <span class="hljs-keyword">const</span> paths = hotProducts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> (&#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: p.<span class="hljs-property">id</span> &#125; &#125;));<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    paths,<br>    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;blocking&#x27;</span>, <span class="hljs-comment">// 其他产品按需生成</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">&#123; product &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;product.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>关键配置参数</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">revalidate</td>
<td align="left">秒数</td>
<td align="left">false</td>
<td align="left">页面刷新间隔</td>
</tr>
<tr>
<td align="left">fallback</td>
<td align="left">boolean&#x2F;string</td>
<td align="left">false</td>
<td align="left">未生成页面的行为</td>
</tr>
<tr>
<td align="left">fallback: true</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">显示fallback UI → 后台生成</td>
</tr>
<tr>
<td align="left">fallback: ‘blocking’</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">用户等待直到页面生成完成</td>
</tr>
<tr>
<td align="left">unstable_revalidate</td>
<td align="left">函数</td>
<td align="left">-</td>
<td align="left">手动触发重新生成</td>
</tr>
</tbody></table>
<p><strong>更新触发机制</strong></p>
<p>(1) 时间驱动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">revalidate</span>: <span class="hljs-number">3600</span> <span class="hljs-comment">// 每小时检查更新</span><br></code></pre></td></tr></table></figure>

<p>(2) 事件驱动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// API路由：手动触发重新生成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">unstable_revalidate</span>(<span class="hljs-string">&#x27;/product/123&#x27;</span>)<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">true</span> &#125;)<br>&#125;<br><br><span class="hljs-comment">// CMS更新回调</span><br>cms.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;product-update&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/revalidate?id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>(3) 按访问刷新：</p>
<pre class="mermaid">graph LR
  A[用户访问] --> B{页面是否过期?}
  B -->|是| C[后台生成新版本]
  B -->|否| D[返回缓存]
  C --> E[下次访问生效]</pre>

<p><strong>缓存优化策略</strong></p>
<pre class="mermaid">graph TB
  A[用户请求] --> B[CDN边缘缓存]
  B -->|HIT| C[返回缓存]
  B -->|MISS| D[源站ISR服务]
  D --> E{页面存在?}
  E -->|是| F[验证过期]
  F -->|未过期| G[返回缓存]
  F -->|已过期| H[后台重建]
  E -->|否| I[同步生成]
  H & I --> J[更新CDN]
  J --> K[返回用户]</pre>

<h2 id="4-3-状态管理优化"><a href="#4-3-状态管理优化" class="headerlink" title="4.3 状态管理优化"></a>4.3 状态管理优化</h2><h3 id="局部状态-vs-全局状态粒度控制"><a href="#局部状态-vs-全局状态粒度控制" class="headerlink" title="局部状态 vs 全局状态粒度控制"></a>局部状态 vs 全局状态粒度控制</h3><p><strong>核心概念解析</strong></p>
<pre class="mermaid">graph TD
  A[状态管理] --> B[局部状态]
  A --> C[全局状态]
  
  B --> B1[组件内部useState]
  B --> B2[组件props传递]
  C --> C1[Context API]
  C --> C2[Redux/Zustand]
  
  D[优化目标] --> E[精准更新]
  D --> F[避免过度渲染]</pre>

<p>技术定义：</p>
<ul>
<li>局部状态：仅在单个组件内部使用的状态（影响范围：1个组件）</li>
<li>全局状态：被多个组件共享的状态（影响范围：N个组件）</li>
<li>粒度控制：根据状态使用范围选择最佳存储位置</li>
</ul>
<p><strong>状态选择决策</strong></p>
<pre class="mermaid">flowchart TD
  A[新状态] --> B{使用范围}
  B -->|单个组件| C[局部状态]
  B -->|2-3个紧密关联组件| D[提升状态到父组件]
  B -->|跨多层级/多个功能模块| E[全局状态]
  C --> F[useState/useReducer]
  D --> G[Props传递]
  E --> H[Context/Redux/Pinia]</pre>

<p><strong>React 实现方案</strong></p>
<p>(1) 局部状态优化</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 纯局部状态：仅影响本组件</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c =&gt; c + 1)&#125;&gt;</span><br><span class="language-xml">        Clicked &#123;count&#125; times</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 状态提升</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 状态提升：影响子组件</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeSwitcher</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setTheme&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3) 精准全局状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 创建细粒度Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserPrefsContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 分离关注点：避免单个大状态对象</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [fontSize, setFontSize] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">16</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPrefsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">fontSize</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPrefsContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 消费端精准订阅</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserPrefsContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Vue 实现方案</strong></p>
<p>(1) 局部状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 创建细粒度Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserPrefsContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 分离关注点：避免单个大状态对象</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [fontSize, setFontSize] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">16</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPrefsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">fontSize</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPrefsContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 消费端精准订阅</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserPrefsContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 状态提升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;!-- Parent.vue --&gt;<br>&lt;template&gt;<br>  &lt;ChildA :value=&quot;sharedState&quot; /&gt;<br>  &lt;ChildB @update=&quot;sharedState = $event&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>const sharedState = ref(&#x27;&#x27;); // 父子共享状态<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>(3) 精准全局状态（Pinia）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// stores/user.js (Pinia store)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&#x27;light&#x27;</span> &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">setTheme</span>(<span class="hljs-params">newTheme</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span> = newTheme;<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/user&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();<br>    <span class="hljs-comment">// 精准解构响应式状态</span><br>    <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">storeToRefs</span>(userStore);<br>    <span class="hljs-keyword">return</span> &#123; theme &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>性能陷阱</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 错误做法：大状态对象导致全量更新</span><br>&lt;<span class="hljs-title class_">AppContext</span>.<span class="hljs-property">Provider</span> value=&#123;&#123; user, theme, cart, ... &#125;&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span>  <span class="hljs-comment">// 任何状态变化都重渲染</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">AppContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// 正确方案：拆分Context</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;user&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">CartContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;cart&#125;</span>&gt;</span></span><br><span class="language-xml">      ...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CartContext.Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><strong>最佳实践原则</strong></p>
<p>(1) 最小范围原则：</p>
<pre class="mermaid">graph LR
  A[状态创建] --> B{影响范围}
  B -->|组件内| C[useState/ref]
  B -->|父子组件| D[Props/emit]
  B -->|跨组件| E[Context/Pinia]</pre>

<p>(2) 读写分离原则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 分离状态读取和更新Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeUpdateContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useThemeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeUpdateContext</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(3) 原子化设计：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 使用状态管理库（如Jotai）</span><br><span class="hljs-keyword">const</span> themeAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeSwitcher</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useAtom</span>(themeAtom);<br>  <span class="hljs-comment">// 仅订阅theme的组件更新</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>框架推荐方案</strong></p>
<table>
<thead>
<tr>
<th align="left">框架</th>
<th align="left">局部状态</th>
<th align="left">组件间共享</th>
<th align="left">全局状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">React</td>
<td align="left">useState</td>
<td align="left">Props + 状态提升</td>
<td align="left">Context&#x2F;Recoil&#x2F;Jotai</td>
</tr>
<tr>
<td align="left">Vue</td>
<td align="left">ref&#x2F;reactive</td>
<td align="left">Props&#x2F;emit</td>
<td align="left">Pinia&#x2F;Provide-Inject</td>
</tr>
<tr>
<td align="left">Angular</td>
<td align="left">Component State</td>
<td align="left">@Input&#x2F;@Output</td>
<td align="left">NgRx&#x2F;Service + RxJS</td>
</tr>
</tbody></table>
<blockquote>
<p>黄金法则：当状态更新导致超过3个无关组件重渲染时，应重新评估状态位置</p>
</blockquote>
<h3 id="Immutable-Data-减少重复渲染"><a href="#Immutable-Data-减少重复渲染" class="headerlink" title="Immutable Data 减少重复渲染"></a>Immutable Data 减少重复渲染</h3><p><strong>核心问题：可变数据导致的无效渲染</strong></p>
<pre class="mermaid">graph LR
  A[状态更新] --> B{使用可变数据}
  B -->|直接修改对象/数组| C[引用地址不变]
  C --> D[浅比较无法检测变化]
  D --> E[组件不更新或过度更新]</pre>

<p><strong>Immutable Data 解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 可变数据（问题）</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">31</span>; <span class="hljs-comment">// 修改后引用地址不变</span><br><br><span class="hljs-comment">// 不可变数据（解决方案）</span><br><span class="hljs-keyword">const</span> updatedUser = &#123; ...user, <span class="hljs-attr">age</span>: <span class="hljs-number">31</span> &#125;; <span class="hljs-comment">// 创建新引用</span><br></code></pre></td></tr></table></figure>

<p><strong>三大核心优势</strong></p>
<ul>
<li>精准变更检测：引用变化即表示数据变化</li>
<li>渲染优化：避免深度比较的性能损耗</li>
<li>状态可预测：消除隐式副作用</li>
</ul>
<p><strong>React 实现方案</strong></p>
<p>(1) 基础不可变操作</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 对象更新</span><br><span class="hljs-keyword">const</span> newState = &#123; ...oldState, <span class="hljs-attr">profile</span>: updatedProfile &#125;;<br><br><span class="hljs-comment">// 数组更新</span><br><span class="hljs-keyword">const</span> newList = [<br>  ...oldList.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index),<br>  updatedItem,<br>  ...oldList.<span class="hljs-title function_">slice</span>(index + <span class="hljs-number">1</span>)<br>];<br><br><span class="hljs-comment">// 嵌套结构更新</span><br><span class="hljs-keyword">const</span> newData = &#123;<br>  ...oldData,<br>  <span class="hljs-attr">user</span>: &#123;<br>    ...oldData.<span class="hljs-property">user</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>      ...oldData.<span class="hljs-property">user</span>.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;New York&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>(2) 使用 Immer 简化</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> nextState = <span class="hljs-title function_">produce</span>(currentState, <span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>  draft.<span class="hljs-property">user</span>.<span class="hljs-property">age</span> = <span class="hljs-number">31</span>;<br>  draft.<span class="hljs-property">posts</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New Post&#x27;</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>(3) Redux 最佳实践</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">todoReducer</span>(<span class="hljs-params">state = initialState, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TOGGLE_TODO&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span><br>          todo.<span class="hljs-property">id</span> === action.<span class="hljs-property">id</span> ? &#123; ...todo, <span class="hljs-attr">completed</span>: !todo.<span class="hljs-property">completed</span> &#125; : todo<br>        )<br>      &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Vue 实现方案</strong></p>
<p>(1) 组合式 API 优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive &#125; from &#x27;vue&#x27;;<br><br>// 使用不可变更新<br>const state = reactive(&#123; items: [] &#125;);<br><br>function addItem(newItem) &#123;<br>  state.items = [...state.items, newItem]; // 创建新数组<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>(2) Pinia 不可变模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCart = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;cart&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">items</span>: [] &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">addItem</span>(<span class="hljs-params">product</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>, product]; <span class="hljs-comment">// 不可变更新</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>性能优化原理</strong></p>
<pre class="mermaid">graph TD
  A[状态变更] --> B{是否使用不可变数据}
  B -->|是| C[创建新引用]
  C --> D[浅比较即可检测变化]
  D --> E[精准更新相关组件]
  
  B -->|否| F[修改原对象]
  F --> G[引用未变但内容变化]
  G --> H[需要深度比较检测变化]
  H --> I[性能损耗+可能漏更新]</pre>

<p><strong>与可变数据对比</strong></p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">可变数据 (Mutable)</th>
<th align="left">不可变数据 (Immutable)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">检测方式</td>
<td align="left">深度比较</td>
<td align="left">浅比较</td>
</tr>
<tr>
<td align="left">更新性能</td>
<td align="left">快(修改)慢(比较)</td>
<td align="left">慢(创建)快(比较)</td>
</tr>
<tr>
<td align="left">内存使用</td>
<td align="left">低</td>
<td align="left">高(需垃圾回收)</td>
</tr>
<tr>
<td align="left">代码复杂度</td>
<td align="left">简单(直接修改)</td>
<td align="left">复杂(需创建副本)</td>
</tr>
<tr>
<td align="left">调试难度</td>
<td align="left">难(状态历史丢失)</td>
<td align="left">易(完整状态快照)</td>
</tr>
<tr>
<td align="left">并发安全</td>
<td align="left">不安全</td>
<td align="left">安全</td>
</tr>
</tbody></table>
<h1 id="五、工程化基建优化"><a href="#五、工程化基建优化" class="headerlink" title="五、工程化基建优化"></a>五、工程化基建优化</h1><h2 id="5-1-构建工具优化"><a href="#5-1-构建工具优化" class="headerlink" title="5.1 构建工具优化"></a>5.1 构建工具优化</h2><h3 id="Webpack：持久化缓存、并行压缩（Terser多进程）"><a href="#Webpack：持久化缓存、并行压缩（Terser多进程）" class="headerlink" title="Webpack：持久化缓存、并行压缩（Terser多进程）"></a>Webpack：持久化缓存、并行压缩（Terser多进程）</h3><p><strong>持久化缓存 (Persistent Caching)</strong></p>
<p>解决的问题：</p>
<ul>
<li>Webpack 每次构建默认会重新处理所有模块（解析、加载、转换），导致重复构建开销，尤其影响大型项目的开发迭代和 CI&#x2F;CD 效率。</li>
</ul>
<p>核心机制（Webpack 5+）：</p>
<p>(1) 缓存存储：</p>
<ul>
<li>将模块构建结果（AST、转换后代码、依赖关系等）序列化存储到本地文件系统（默认路径：node_modules&#x2F;.cache&#x2F;webpack）</li>
<li>配置示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">cache</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;filesystem&#x27;</span>,  <span class="hljs-comment">// 启用文件系统缓存</span><br>    <span class="hljs-attr">cacheDirectory</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;.temp_cache&#x27;</span>), <span class="hljs-comment">// 自定义缓存目录</span><br>    <span class="hljs-attr">buildDependencies</span>: &#123;<br>      <span class="hljs-attr">config</span>: [__filename],  <span class="hljs-comment">// 配置文件变更时使缓存失效</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>(2) 增量构建：</p>
<ul>
<li>二次构建时仅处理变更文件及其依赖链</li>
<li>未变更模块直接从缓存读取，跳过解析&#x2F;转换流程</li>
</ul>
<p>(3) 智能失效：</p>
<ul>
<li>自动追踪配置、loader、依赖包版本等关键因素</li>
<li>相关变更时自动失效对应缓存</li>
</ul>
<p><strong>并行压缩 (Parallel Compression with Terser)</strong></p>
<p>解决的问题：</p>
<ul>
<li>JavaScript 压缩（混淆&#x2F;优化）是构建中最耗 CPU 的阶段</li>
<li>默认单线程压缩无法利用多核 CPU 优势</li>
</ul>
<p>实现原理：</p>
<ul>
<li>多进程并行：<ul>
<li>通过 TerserPlugin 的 parallel 选项启用</li>
<li>创建多个 Worker 进程（默认数量：CPU 核心数 -1）</li>
<li>将不同 chunk 分配给 Worker 并行压缩</li>
</ul>
</li>
<li>生产环境配置：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用多进程压缩</span><br>        <span class="hljs-attr">terserOptions</span>: &#123;<br>          <span class="hljs-attr">compress</span>: &#123; <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span> &#125;  <span class="hljs-comment">// 压缩配置</span><br>        &#125;<br>      &#125;)<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Vite：基于ESM的按需编译"><a href="#Vite：基于ESM的按需编译" class="headerlink" title="Vite：基于ESM的按需编译"></a>Vite：基于ESM的按需编译</h3><p><strong>核心原理：ESM 原生支持</strong></p>
<p>(1) 传统打包器问题（如 Webpack）：</p>
<ul>
<li>启动慢：需先打包整个应用才能启动服务</li>
<li>热更新慢：文件修改后需重新构建整个 bundle</li>
<li>按需加载局限：仅支持路由级代码分割</li>
</ul>
<p>(2) Vite 的突破：</p>
<ul>
<li>利用浏览器原生支持 ES 模块 (ESM)：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 浏览器直接解析 ESM --&gt;<br>&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>按需编译：<ul>
<li>启动时只编译轻量级依赖（预构建）</li>
<li>业务代码按需转换（访问时编译）</li>
</ul>
</li>
</ul>
<p><strong>工作流程</strong></p>
<pre class="mermaid">graph LR
    A[浏览器请求] --> B[Vite 服务器]
    B --> C{路由请求?}
    C -->|是| D[返回 HTML 模板]
    C -->|否| E{文件类型}
    E -->|JS/TS| F[按需编译为 ESM]
    E -->|CSS| G[编译为 CSS 变量注入]
    E -->|Vue/JSX| H[即时编译为 JS]
    F & G & H --> I[返回浏览器执行]</pre>

<p><strong>关键技术实现</strong></p>
<p>(1) 依赖预构建：</p>
<ul>
<li>目标：将 CommonJS 模块转换为 ESM，合并零散文件</li>
<li>工具：esbuild（Go 语言编写，比 JS 工具快 10-100 倍）</li>
<li>结果：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换前（node_modules）</span><br><span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><br><span class="hljs-comment">// 转换后（预构建）</span><br><span class="hljs-keyword">import</span> lodash <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/node_modules/.vite/lodash.js&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>(2) 按需编译</p>
<ul>
<li>请求拦截：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vite 中间件伪代码</span><br>server.<span class="hljs-property">middlewares</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.vue&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> code = <span class="hljs-title function_">compileVue</span>(req.<span class="hljs-property">url</span>); <span class="hljs-comment">// 即时编译</span><br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-title function_">transformToESM</span>(code));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>编译时机：浏览器发起请求时才编译对应文件</li>
</ul>
<p>(3) HMR 热更新：</p>
<ul>
<li>传统方案：重建整个 bundle</li>
<li>Vite 方案：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 建立 WebSocket 连接</span><br><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);<br><br><span class="hljs-comment">// 文件修改时</span><br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;update&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 只重新请求单个模块</span><br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">`/src/<span class="hljs-subst">$&#123;data.filePath&#125;</span>?t=<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>优势场景：<ul>
<li>现代浏览器项目（需支持 ESM）</li>
<li>大型 Monorepo 项目</li>
<li>频繁热更新的开发环境</li>
</ul>
</li>
<li>限制：<ul>
<li>不支持 IE11 等旧浏览器（需插件 @vitejs&#x2F;plugin-legacy）</li>
<li>深度定制构建需学习 Rollup API</li>
</ul>
</li>
</ul>
<h3 id="Bundle-分析工具：Webpack-bundle-analyzer"><a href="#Bundle-分析工具：Webpack-bundle-analyzer" class="headerlink" title="Bundle 分析工具：Webpack-bundle-analyzer"></a>Bundle 分析工具：Webpack-bundle-analyzer</h3><p><strong>核心功能</strong></p>
<p>(1) 可视化分析：</p>
<ul>
<li>生成交互式树状图（Treemap）展示所有输出文件</li>
<li>按模块&#x2F;包(package)展示物理体积（gzip前）和占比</li>
</ul>
<pre class="mermaid">graph TD
  A[入口文件] --> B[react-dom]
  A --> C[lodash-es]
  A --> D[业务组件]
  D --> D1[Header.jsx]
  D --> D2[ProductList.ts]</pre>

<p>(2) 关键洞察维度：</p>
<ul>
<li>模块体积排名（找出最大模块）</li>
<li>重复依赖检测（同一包被多次打包）</li>
<li>代码分割效果验证</li>
<li>第三方依赖（node_modules）占比</li>
</ul>
<p><strong>工作原理</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Webpack
  participant Plugin
  participant Browser
  
  Webpack->>Plugin: 构建完成后触发钩子
  Plugin->>Plugin: 收集stats.json数据
  Plugin->>Plugin: 生成分析报告HTML
  Plugin->>Browser: 自动打开127.0.0.1:8888
  Browser->>Plugin: 请求报告数据
  Plugin->>Browser: 返回交互式可视化页面</pre>

<p><strong>配置示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>)<br> .<span class="hljs-property">BundleAnalyzerPlugin</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(&#123;<br>      <span class="hljs-attr">analyzerMode</span>: <span class="hljs-string">&#x27;server&#x27;</span>, <span class="hljs-comment">// 启动本地服务查看</span><br>      <span class="hljs-attr">openAnalyzer</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 构建完成后自动打开</span><br>      <span class="hljs-attr">reportFilename</span>: <span class="hljs-string">&#x27;report.html&#x27;</span> <span class="hljs-comment">// 自定义报告文件名</span><br>    &#125;)<br>  ]<br>&#125;;<br><br><span class="hljs-comment">// 高级参数</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(&#123;<br>  <span class="hljs-attr">analyzerPort</span>: <span class="hljs-number">3000</span>,              <span class="hljs-comment">// 自定义端口</span><br>  <span class="hljs-attr">defaultSizes</span>: <span class="hljs-string">&#x27;parsed&#x27;</span>,          <span class="hljs-comment">// 显示解析后大小</span><br>  <span class="hljs-attr">excludeAssets</span>: <span class="hljs-regexp">/\.map$/</span>,         <span class="hljs-comment">// 排除sourcemap</span><br>  <span class="hljs-attr">statsOptions</span>: &#123;<br>    <span class="hljs-attr">excludeModules</span>: <span class="hljs-regexp">/node_modules\/core-js/</span> <span class="hljs-comment">// 排除特定模块</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>分析报告解读 - 关键区域说明</strong></p>
<table>
<thead>
<tr>
<th align="left">区域</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">矩形大小</td>
<td align="left">模块物理体积（非gzip）</td>
</tr>
<tr>
<td align="left">颜色深度</td>
<td align="left">文件数量（越深文件越多）</td>
</tr>
<tr>
<td align="left">悬停提示</td>
<td align="left">显示精确大小和路径</td>
</tr>
<tr>
<td align="left">左上角筛选器</td>
<td align="left">按入口&#x2F;文件类型过滤</td>
</tr>
</tbody></table>
<h2 id="5-2-CDN与边缘计算"><a href="#5-2-CDN与边缘计算" class="headerlink" title="5.2 CDN与边缘计算"></a>5.2 CDN与边缘计算</h2><h3 id="边缘缓存策略（CDN-Cache-Rules）"><a href="#边缘缓存策略（CDN-Cache-Rules）" class="headerlink" title="边缘缓存策略（CDN Cache Rules）"></a>边缘缓存策略（CDN Cache Rules）</h3><p><strong>核心概念与价值</strong></p>
<p>(1) CDN 边缘节点：</p>
<ul>
<li>全球分布的服务器节点（通常1000+）</li>
<li>物理位置靠近终端用户</li>
<li>示例拓扑：</li>
</ul>
<pre class="mermaid">graph LR
  User[北京用户] --> |10ms| BJ[北京CDN节点]
  User --> |150ms| NY[纽约源站]
  BJ --> |40ms| SH[上海源站]</pre>

<p>(2) 缓存策略目标：</p>
<ul>
<li>加速内容分发（降低延迟）</li>
<li>减少源站带宽成本</li>
<li>缓解源站压力（防DDoS）</li>
</ul>
<p><strong>缓存规则核心配置维度</strong></p>
<table>
<thead>
<tr>
<th align="left">配置维度</th>
<th align="left">关键参数</th>
<th align="left">典型值示例</th>
<th align="left">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缓存键</td>
<td align="left">Cache-Key</td>
<td align="left">$uri-$query-$cookie</td>
<td align="left">定义资源唯一标识</td>
</tr>
<tr>
<td align="left">缓存时间</td>
<td align="left">Cache-Control: max-age</td>
<td align="left">max-age&#x3D;31536000</td>
<td align="left">静态资源设置1年缓存</td>
</tr>
<tr>
<td align="left">缓存层级</td>
<td align="left">CDN-Cache-Level</td>
<td align="left">L1&#x2F;L2</td>
<td align="left">控制边缘&#x2F;中间层缓存</td>
</tr>
<tr>
<td align="left">缓存行为</td>
<td align="left">X-Cache</td>
<td align="left">HIT&#x2F;MISS&#x2F;BYPASS</td>
<td align="left">显示缓存命中状态</td>
</tr>
<tr>
<td align="left">缓存清除</td>
<td align="left">Purge-API</td>
<td align="left">POST &#x2F;purge&#x2F;{url}</td>
<td align="left">主动失效缓存</td>
</tr>
</tbody></table>
<p><strong>缓存生命周期管理</strong></p>
<pre class="mermaid">sequenceDiagram
  participant Client
  participant CDN
  participant Origin
  
  Client->>CDN: 请求 /main.js
  alt 首次请求
    CDN->>Origin: MISS (回源获取)
    Origin->>CDN: 200 OK + Cache-Control: max-age=3600
    CDN->>Client: 返回资源 (存储缓存)
  else 缓存有效
    CDN->>Client: HIT (直接返回)
  else 缓存过期
    CDN->>Origin: If-Modified-Since
    alt 内容未变
      Origin->>CDN: 304 Not Modified
      CDN->>Client: HIT (更新有效期)
    else 内容已变
      Origin->>CDN: 200 OK (新内容)
      CDN->>Client: 返回新资源
    end
  end</pre>

<h3 id="边缘函数：Cloudflare-Workers-Vercel-Edge-Functions"><a href="#边缘函数：Cloudflare-Workers-Vercel-Edge-Functions" class="headerlink" title="边缘函数：Cloudflare Workers &#x2F; Vercel Edge Functions"></a>边缘函数：Cloudflare Workers &#x2F; Vercel Edge Functions</h3><p><strong>核心概念与架构演进</strong></p>
<pre class="mermaid">graph TB
  A[传统架构] --> B[客户端请求]
  B --> C[云服务器]
  C --> D[数据库]
  D --> C
  C --> B
  
  E[边缘计算架构] --> F[客户端请求]
  F --> G[边缘节点]
  G --> H[边缘函数执行]
  H -->|直接响应| F
  H -->|必要数据| I[边缘缓存/数据库]</pre>

<p>技术定义：</p>
<ul>
<li>边缘函数：在全球分布式CDN节点上运行的JavaScript&#x2F;WASM函数</li>
<li>执行位置：距离用户最近的网络边缘节点（通常&lt;50ms）</li>
<li>核心价值：<ul>
<li>超低延迟响应（减少往返源站时间）</li>
<li>全球分布式执行</li>
<li>零服务器运维</li>
</ul>
</li>
</ul>
<p><strong>工作原理</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Cloudflare Workers</th>
<th align="left">Vercel Edge Functions</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行时</td>
<td align="left">V8 Isolates (Chrome引擎)</td>
<td align="left">V8 Isolates</td>
</tr>
<tr>
<td align="left">编程语言</td>
<td align="left">JavaScript&#x2F;WASM&#x2F;Rust</td>
<td align="left">JavaScript&#x2F;TypeScript</td>
</tr>
<tr>
<td align="left">部署单位</td>
<td align="left">单个脚本 (.js&#x2F;.ts)</td>
<td align="left">函数文件 (&#x2F;api&#x2F;*.ts)</td>
</tr>
<tr>
<td align="left">触发器</td>
<td align="left">所有HTTP请求</td>
<td align="left">按路由匹配的请求</td>
</tr>
<tr>
<td align="left">本地开发</td>
<td align="left">wrangler dev</td>
<td align="left">vercel dev</td>
</tr>
<tr>
<td align="left">持久存储</td>
<td align="left">Workers KV &#x2F; D1 &#x2F; R2</td>
<td align="left">Vercel KV &#x2F; Postgres Edge</td>
</tr>
</tbody></table>
<p><strong>核心应用场景</strong></p>
<p>(1) 动态内容优化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Cloudflare Worker示例：个性化内容注入</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>)<br>    <br>    <span class="hljs-comment">// 从边缘KV读取用户偏好</span><br>    <span class="hljs-keyword">const</span> pref = <span class="hljs-keyword">await</span> <span class="hljs-variable constant_">KV</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">`pref:<span class="hljs-subst">$&#123;user.ip&#125;</span>`</span>, <span class="hljs-string">&#x27;json&#x27;</span>)<br>    <br>    <span class="hljs-comment">// 修改HTML响应</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url)<br>    <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">text</span>()<br>    <span class="hljs-keyword">const</span> newHtml = html.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;/body&gt;&#x27;</span>, <span class="hljs-string">`&lt;script&gt;THEME=<span class="hljs-subst">$&#123;pref.theme&#125;</span>&lt;/script&gt;&lt;/body&gt;`</span>)<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(newHtml, res)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(2) 安全防护</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Cloudflare Worker：API攻击防护</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> request = event.<span class="hljs-property">request</span><br>  <span class="hljs-keyword">const</span> ip = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;CF-Connecting-IP&#x27;</span>)<br>  <br>  <span class="hljs-comment">// 检查IP信誉库</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMaliciousIP</span>(ip)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;Blocked&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">403</span> &#125;)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 验证JWT令牌</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateToken</span>(request)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;Unauthorized&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">401</span> &#125;)<br>  &#125;<br>  <br>  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(request))<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>开发部署流程</strong></p>
<pre class="mermaid">flowchart LR
  A[代码开发] --> B[本地测试]
  B --> C[wrangler publish]
  C --> D[全球部署]
  D --> E[自动流量切换]
  E --> F[实时监控]</pre>

<p>典型部署命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装CLI</span><br>npm install -g wrangler<br><br><span class="hljs-comment"># 登录认证</span><br>wrangler login<br><br><span class="hljs-comment"># 发布Worker</span><br>wrangler publish src/index.js<br></code></pre></td></tr></table></figure>

<p><strong>典型应用架构</strong></p>
<pre class="mermaid">graph LR
  A[客户端] --> B[边缘节点]
  B --> C{路由判断}
  C -->|静态资源| D[边缘缓存]
  C -->|API请求| E[边缘函数]
  E --> F[边缘KV数据库]
  E --> G[边缘SQLite]
  E -->|复杂查询| H[传统云数据库]
  D & E --> A</pre>

<h1 id="六、进阶场景优化"><a href="#六、进阶场景优化" class="headerlink" title="六、进阶场景优化"></a>六、进阶场景优化</h1><h2 id="6-1-移动端专项"><a href="#6-1-移动端专项" class="headerlink" title="6.1 移动端专项"></a>6.1 移动端专项</h2><h3 id="首屏秒开方案：离线包、预请求、VAP（视觉动画进度）"><a href="#首屏秒开方案：离线包、预请求、VAP（视觉动画进度）" class="headerlink" title="首屏秒开方案：离线包、预请求、VAP（视觉动画进度）"></a>首屏秒开方案：离线包、预请求、VAP（视觉动画进度）</h3><h3 id="手势性能优化（避免阻塞滚动）"><a href="#手势性能优化（避免阻塞滚动）" class="headerlink" title="手势性能优化（避免阻塞滚动）"></a>手势性能优化（避免阻塞滚动）</h3><h2 id="6-2-复杂动画性能"><a href="#6-2-复杂动画性能" class="headerlink" title="6.2 复杂动画性能"></a>6.2 复杂动画性能</h2><h3 id="CSS动画-vs-JS动画（RAF）"><a href="#CSS动画-vs-JS动画（RAF）" class="headerlink" title="CSS动画 vs JS动画（RAF）"></a>CSS动画 vs JS动画（RAF）</h3><h3 id="FLIP动画技术（First-Last-Invert-Play）"><a href="#FLIP动画技术（First-Last-Invert-Play）" class="headerlink" title="FLIP动画技术（First, Last, Invert, Play）"></a>FLIP动画技术（First, Last, Invert, Play）</h3><h2 id="6-3-低端设备适配"><a href="#6-3-低端设备适配" class="headerlink" title="6.3 低端设备适配"></a>6.3 低端设备适配</h2><h3 id="代码降级策略（Dynamic-Polyfill）"><a href="#代码降级策略（Dynamic-Polyfill）" class="headerlink" title="代码降级策略（Dynamic Polyfill）"></a>代码降级策略（Dynamic Polyfill）</h3><h3 id="内存占用量控制（-100MB）"><a href="#内存占用量控制（-100MB）" class="headerlink" title="内存占用量控制（&lt; 100MB）"></a>内存占用量控制（&lt; 100MB）</h3><h1 id="七、性能优化流程"><a href="#七、性能优化流程" class="headerlink" title="七、性能优化流程"></a>七、性能优化流程</h1><h2 id="7-1-性能审计方法论"><a href="#7-1-性能审计方法论" class="headerlink" title="7.1 性能审计方法论"></a>7.1 性能审计方法论</h2><h3 id="制定性能预算（Performance-Budget）"><a href="#制定性能预算（Performance-Budget）" class="headerlink" title="制定性能预算（Performance Budget）"></a>制定性能预算（Performance Budget）</h3><h3 id="RAIL模型（Response-Animation-Idle-Load）"><a href="#RAIL模型（Response-Animation-Idle-Load）" class="headerlink" title="RAIL模型（Response, Animation, Idle, Load）"></a>RAIL模型（Response, Animation, Idle, Load）</h3><h2 id="7-2-灰度与度量"><a href="#7-2-灰度与度量" class="headerlink" title="7.2 灰度与度量"></a>7.2 灰度与度量</h2><h3 id="A-B测试性能方案"><a href="#A-B测试性能方案" class="headerlink" title="A&#x2F;B测试性能方案"></a>A&#x2F;B测试性能方案</h3><h3 id="性能指标自动化报警"><a href="#性能指标自动化报警" class="headerlink" title="性能指标自动化报警"></a>性能指标自动化报警</h3><h1 id="八、新兴技术方向"><a href="#八、新兴技术方向" class="headerlink" title="八、新兴技术方向"></a>八、新兴技术方向</h1><h2 id="8-1-现代浏览器API"><a href="#8-1-现代浏览器API" class="headerlink" title="8.1 现代浏览器API"></a>8.1 现代浏览器API</h2><h3 id="IntersectionObserver-懒加载"><a href="#IntersectionObserver-懒加载" class="headerlink" title="IntersectionObserver 懒加载"></a>IntersectionObserver 懒加载</h3><h3 id="ResizeObserver-替代滚动监听"><a href="#ResizeObserver-替代滚动监听" class="headerlink" title="ResizeObserver 替代滚动监听"></a>ResizeObserver 替代滚动监听</h3><h3 id="Priority-Hints-实验性"><a href="#Priority-Hints-实验性" class="headerlink" title="Priority Hints (实验性)"></a>Priority Hints (实验性)</h3><h2 id="8-2-Web性能标准演进"><a href="#8-2-Web性能标准演进" class="headerlink" title="8.2 Web性能标准演进"></a>8.2 Web性能标准演进</h2><h3 id="WebAssembly-高性能模块"><a href="#WebAssembly-高性能模块" class="headerlink" title="WebAssembly 高性能模块"></a>WebAssembly 高性能模块</h3><h3 id="WebGPU-图形计算加速"><a href="#WebGPU-图形计算加速" class="headerlink" title="WebGPU 图形计算加速"></a>WebGPU 图形计算加速</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="category-chain-item">性能优化</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="print-no-link">#性能优化</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端性能优化知识专题学习</div>
      <div>https://tianfei92.github.io/2025/06/29/Performance Optimization/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ariel</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/03/Webpack%20Notes/" title="Webpack 专题知识学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Webpack 专题知识学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/23/React%20Study%20Notes/" title="React 知识体系专题学习">
                        <span class="hidden-mobile">React 知识体系专题学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
